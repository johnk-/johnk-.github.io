<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>How Much Determinism Should Be Pursued?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2057">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We can pick many examples... like whether a MAP! will always enumerate in the same order on different platforms, or with the same contents. Using a deterministically sorted implementation of map would seem to have a number of advantages.</p>
<p>Especially since there's a growing push in software for giving deterministic outputs by default.</p>
</blockquote>
</aside>
<p>I happened across an article discussing what someone felt was lacking in Go:</p>
<p><a href="https://kokada.capivaras.dev/blog/an-unordered-list-of-things-i-miss-in-go/" class="inline-onebox">An unordered list of things I miss in Go — kokada</a></p>
<p>The title is a joke about how the only option for enumerating maps was to use one with a randomized hash.  They felt there should be an option without a third party library where you can explicitly ask for an ordered map.</p>
<p>It also links through to mention that as of Python 3.7, the standard "Dict" dictionary preserves the insertion order:</p>
<p><a href="https://mail.python.org/pipermail/python-dev/2017-December/151283.html" class="inline-onebox">[Python-Dev] Guarantee ordered dict literals in v3.7?</a></p>
<p>My historical biases coming from C++ would likely to have been for Go's choice: to actually force randomization in order to prevent people from depending on something they don't care about.  This helps fuzz test and make sure the default doesn't overspecify to prevent optimizations of the structure.</p>
<p>But for a higher-level interpreted language in the space of something like Python (or Rebol), that tradeoff may not be the right one for modern concerns.</p> ]]></description>
        <link>https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057#post_3</link>
        <pubDate>Sun, 18 Aug 2024 04:16:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7317</guid>
      </item>
      <item>
        <title>Back to Bedlam: August 2024 Status and...Plan? :confused:</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p>So Ren-C had a pretty exciting first 3 months of 2024, and then started to drop off, until I wasn't working on it at all.</p>
<p>I'll try and sum up what's gone on, and where things might realistically go from here.</p>
</blockquote>
<hr>
<h1>
<a name="rapid-development-january-march-1" class="anchor" href="https://forum.rebol.info#rapid-development-january-march-1"></a>Rapid Development: January <img src="https://forum.rebol.info/images/emoji/twitter/arrow_right.png?v=12" title=":arrow_right:" class="emoji" alt=":arrow_right:" loading="lazy" width="20" height="20"> March</h1>
<h3>
<a name="binding-paradigm-shift-2" class="anchor" href="https://forum.rebol.info#binding-paradigm-shift-2"></a>Binding Paradigm Shift</h3>
<p>The <a href="https://forum.rebol.info/t/bradrn-brad/2088">arrival of @bradrn</a> who had been investigating "R" directed attention back to the central language issue of how binding works at all (if it can be made to work).  This prioritized revisiting "Pure Virtual Binding" with fresh eyes: <strong><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/9">Pure Virtual Binding II</a></strong></p>
<p>I feel the premises are sound.  But if you buy into the methodology, then there are many consequences that will seem more alien than usual to historical Rebol programmers.  BLOCK!s are not inert in the evaluator, but rather evaluate to a version of the BLOCK! with binding applied... so <strong><code>(blk: [a b c])</code></strong> is distinct from <strong><code>(blk: '[a b c])</code></strong> where the latter uses quoting to suppress the evaluation.  And since quoting suppresses any binding, <strong><code>(x: 10, y: get 'x)</code></strong> won't work because the <strong><code>'x</code></strong> term drops the quote and stays unbound, meaning you have to use the new VAR-WORD! type and write <strong><code>(x: 10, y: get $x)</code></strong>.</p>
<p><em>The epicycles of this new world touch every aspect of the design</em>--forcing "binding awareness" to the forefront of dialect authors and casual users.  I wish there were an easier answer, but "implicitly paste unique binding pointers on words in waves" is being proven to be non-composable sufficiently well by other Redbol implementations.  It doesn't work meaningfully, so they simply write anything non-trivial as C or Red/System.</p>
<p>I managed to get the system to run well enough to research the design.  It is very half-baked, and every few minutes I work with it triggers the need for a new meditation in the <a href="https://forum.rebol.info/c/development/binding/49">Binding category</a>.  But as a positive sign, the new model made it possible to add a LET combinator to UPARSE, and there are other longstanding problems that get solved.</p>
<h3>
<a name="isotopes-shape-up-more-clearly-3" class="anchor" href="https://forum.rebol.info#isotopes-shape-up-more-clearly-3"></a>Isotopes Shape Up More Clearly</h3>
<p>We now use a more consistent terminology where things like null are called <a href="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005/9">"antiforms" instead of "isotopes"</a> (e.g. the null antiform is one of the three isotopes of the WORD! <strong>null</strong>).</p>
<p>Some other shuffles were made, like saying that <a href="https://forum.rebol.info/t/why-shouldnt-void-be-done-with-a-void-word-antiform/2160">void is the antiform word of <strong>~void~</strong></a>, and flipping <a href="https://forum.rebol.info/t/why-trash-is-the-name-for-unset-state/2078">"trash" to the antiform of BLANK!</a>.  This was based on the realization that there wasn't really all that much value in trying to make voids some special magic type that wasn't an antiform and couldn't be put in blocks, just so its quoted form could be a lone apostrophe.</p>
<h3>
<a name="breaking-through-the-64-fundamental-types-barrier-4" class="anchor" href="https://forum.rebol.info#breaking-through-the-64-fundamental-types-barrier-4"></a>Breaking Through the 64 Fundamental Types Barrier</h3>
<p>Since the dawn of Rebol, the use of a 64-bit bitflag for type checking has meant there can be only 64 types.  We need more, and fully generalized typechecking wants to be able to test not just for fundamental types but also for predicates (like if something is EVEN? vs. just if it's an INTEGER!).</p>
<p>To keep the system from slowing down to a glacial pace by type checking through function calls, <a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">I hacked together an implementation of what I called "intrinsics"</a>.  These functions are faster to call than ordinary natives, helping make type checking faster, but also other simple function calls.</p>
<h3>
<a name="the-new-sigil-type-5" class="anchor" href="https://forum.rebol.info#the-new-sigil-type-5"></a>The New SIGIL! Type</h3>
<p>For a while there was a concept of tolerating "Weird Words" (e.g. with spaces in them) by putting them in vertical bars, <strong><code>|like this|</code></strong>.  That allowed a few new interesting "plain WORD!s" like <strong><code>::</code></strong> to exist because you could accomplish their "weird" forms with vertical bars like a SET-WORD! form as <strong><code>|::|:</code></strong>.</p>
<p>This turned out to be a bad idea.  So I simplified with <a href="https://github.com/metaeducation/ren-c/blob/master/tests/datatypes/sigil.test.reb">a new type called the SIGIL!</a>... with one for each decoration you could put on WORD!s and arrays.  These SIGIL!s only have a plain form, and have baked in evaluator behavior.  This also solves a problem elegantly, where you can write code like <strong><code>(x: '$abc, if '$ = sigil of x [...])</code></strong></p>
<h3>
<a name="api-antiform-splicing-solved-6" class="anchor" href="https://forum.rebol.info#api-antiform-splicing-solved-6"></a>API Antiform Splicing Solved</h3>
<p>Having the <code>@</code> symbol be a SIGIL! with built-in evaluator behavior finessed another longstanding problem that having it be a WORD! bound to a reassignable function couldn't do, which was to reconstruct antiforms in API splices, e.g.:</p>
<pre><code>Value* val = rebValue("~true~");  // quasiform evaluates to antiform (logic)

// rebElide("if", val, "[print {Error: no antiforms in source code blocks}]");

rebElide("if @", val, "[print {Special loophole for @ makes this work}]");
</code></pre>
<p>The @ sigil can be given a special baked-in behavior--specific to the API--allowing it to preserve and reconstitute the antiform state.  This helps bridge the fact that <code>val</code> above isn't a Rebol WORD!, but a C variable, but still give the indirection that a word would have.  <em>(Note that splicing antiforms as quasiforms would be too permissive, because you can't be certain that your splices are in code that is evaluative... it would be like saying <strong><code>compose [1 (null) 2]</code></strong> gives you <strong><code>[1 ~null~ 2]</code></strong> instead of raising the intended error.)</em></p>
<p>Resolving this major sticking point in the API was a big relief.</p>
<h3>
<a name="string-interpolation-solved-7" class="anchor" href="https://forum.rebol.info#string-interpolation-solved-7"></a>String Interpolation Solved?</h3>
<p>Whenever you are passing around a BLOCK! you may be passing along its environment, to which it holds a permanent reference (preventing that environment from GC'ing).  But even more costly would be if every string had to carry around an environment...which also meant anyone you passed a string to gets access to environments that may have incidentally been put on that string.</p>
<p>The solution seems a bit obvious in retrospect: if you want to do interpolation on a string, <a href="https://forum.rebol.info/t/could-strings-have-context/587/27">put it in something like a BLOCK!</a>.  Like I say, <em>"a lot better than starting to worry about having to quote your strings to suppress binding!"</em></p>
<hr>
<h1>
<a name="april-things-start-to-stall-8" class="anchor" href="https://forum.rebol.info#april-things-start-to-stall-8"></a>April : Things Start to Stall</h1>
<h3>
<a name="coming-to-terms-with-fence-and-brace-incompatibility-9" class="anchor" href="https://forum.rebol.info#coming-to-terms-with-fence-and-brace-incompatibility-9"></a>Coming to Terms with FENCE! and Brace Incompatibility</h3>
<p>For the past few years I'd been second-guessing the idea that plain braces should be used for strings, and that they should instead be another array type called FENCE!.  Comparing Rebol to the JSON it inspired made it seem like a thing that <a href="https://forum.rebol.info/t/json-envy-serialization-dialect-in-rebol/2140/2">once seen could not be unseen</a>.</p>
<p>Thinking through the natural alternatives for string representation made me think there could be an asymmetric pair of delimiters made by <strong><code>-{</code></strong> and <strong><code>}-</code></strong>.  Not only that, the pattern could be extended with more dashes.</p>
<pre><code> obj: {x: 10, y: "obj would be an object now"}

 print -{Hello new string "World"}-

 print -{Hello single } brace-containing string}-
 
 print --{Hello compound }- brace-containing double dash string}--
</code></pre>
<p>It might seem this would be a relatively simple-to-implement change compared to something like binding.  But it threw a wrench into things for many reasons:</p>
<ul>
<li>
<p>Historical binding was always complete garbage, whereas single-braced strings were actually touted as a pleasing aspect of the language (including by me).</p>
</li>
<li>
<p>This would be the first truly non-backwards-compatible LOAD change to Ren-C, meaning that either some special way to signal which interpretation would be needed, or the work in the Rebol2 compatibility module would go to waste.</p>
<ul>
<li>
<p>The idea of a single simple-switch covering this narrow issue always raises the question of whether you want a more generalized hook that you can give before loading.  Red offers such a thing as <code>system/lexer/pre-load</code> which is just a function that transform source UTF-8 before you load it, <a href="https://www.red-lang.org/2019/11/editorial-brief-essay-on-lexical.html">though claims it should not be abused</a></p>
</li>
<li>
<p>While I thought I could hack through a prototype with a kind of pre-load functionality using the existing bootstrap executable, trying to pre-empt the LOAD process exposed so many bugs in the R3-Alpha module implementation that it was basically impossible.</p>
</li>
</ul>
</li>
<li>
<p>Adding to the heaviness of the change, the concept that single-brace FENCE! creates an OBJECT! under evaluation just brings to attention the question of how binding works in such cases... e.g. does it make sense that <strong><code>{x: 10, y: y + 20}</code></strong> would try to make an object in which Y is adding 20 to the as-yet-to-be-defined Y field of the object being produced, necessitating you to write <strong><code>eval compose ${x: 10, y: (y) + 20}</code></strong> to capture an external Y?  Does that EVAL treat fences different than other array types, and if so should it treat groups different from blocks?</p>
</li>
</ul>
<h3>
<a name="i-went-down-the-rabbit-hole-of-updating-the-bootstrap-executable-10" class="anchor" href="https://forum.rebol.info#i-went-down-the-rabbit-hole-of-updating-the-bootstrap-executable-10"></a>I Went Down The Rabbit Hole Of Updating The Bootstrap Executable</h3>
<p>The makefile generation and other "prep" code has been building using a version of Ren-C from December 2018.  It's been somewhat impressive that techniques in a <code>bootstrap-shim</code> file have been able to largely twist the language to modern conventions from within the language itself.  (This continues the tradition from <code>r2-forward</code> which made Rebol2 act more like R3-Alpha without having to change the EXE itself, though the adaptations were much less radical and done without Ren-C's high-leverage function composition tools.)</p>
<p>But hitting the bugs in pre-empting the LOAD process made me realize that it was time to make new bootstrap executables that fixed those bugs, and supported a mechanism for the new string format (and perhaps even add the FENCE! type).</p>
<p>So long as I was doing that, I could fold <em>most</em> of the bootstrap-shim features into the executable itself, for better and cleaner performance.  While doing so I could take that time to assess whether all the improvements had actually turned out to be improvements or not...reverting anything that had turned out to be bad.  I could also make the bootstrap EXE's PARSE compatible with modern UPARSE, meaning the only Rebol2-style parsing we'd have would be in the Redbol emulation.</p>
<p>I also undertook modernizing the C code itself, where old names like <code>RELVAL</code> or <code>REBSER</code> could be replaced with newer stylization like <code>Cell</code> and <code>Series</code>.  This made it easier to read and compare older and newer code, and paste between them.</p>
<h3>
<a name="new-sigil-but-no-silver-bullet-for-types-11" class="anchor" href="https://forum.rebol.info#new-sigil-but-no-silver-bullet-for-types-11"></a>New <code>&amp;</code> Sigil, but No Silver Bullet For Types</h3>
<p>Opening up the number of fundamental types allowed bringing in a new sigil (<strong><code>&amp;[bl o ck]</code></strong>, <strong><code>&amp;word</code></strong>, <strong><code>&amp;(gr o up)</code></strong> etc.) which could be used for types.  While <a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">some ideas were thrown around</a>, no truly great coherent ideas for what Rebol's type system should be came up.</p>
<hr>
<h1>
<a name="may-july-not-really-thinking-about-rebol-12" class="anchor" href="https://forum.rebol.info#may-july-not-really-thinking-about-rebol-12"></a>May <img src="https://forum.rebol.info/images/emoji/twitter/arrow_right.png?v=12" title=":arrow_right:" class="emoji" alt=":arrow_right:" loading="lazy" width="20" height="20"> July : Not Really Thinking About Rebol</h1>
<p>I had a lot going on personally, and confronting Rebol's hard problems head-on was very wearying and not something I felt like doing (or even <em>able</em> to do).</p>
<p>Also wearying is that the world doesn't stand still.  The tools you use become deprecated and new versions have new flags and frustrations to deal with.  Every month (week?) you step away means you'll be coming back to something that broke, especially when you try to keep things running on as many platforms as Ren-C does.</p>
<p>So I found it easier to mess around with NixOS and discover more about what state it's in these days, watch YouTube math videos and <a href="https://github.com/ManimCommunity/manim">learn about Manim</a>, ask AI to turn my old <a href="http://metaeducation.com/media/music/harpsy.mp3">unfinished clips</a> into <a href="http://metaeducation.com/media/music/paper-planes.mp3">complete songs</a>, go to improv... basically anything but worry about the design of an esoteric language.</p>
<p><em>(I also have a "part-time job" as a product reviewer, that I was picked for on the basis of having written good reviews on Amazon for some years.  It doesn't pay directly, but I get free stuff to write reviews for: listening on <a href="https://www.pcmag.com/reviews/jabra-elite-10-gen-2">these $279-list-price earbuds right now</a>.)</em></p>
<hr>
<h1>
<a name="august-now-what-13" class="anchor" href="https://forum.rebol.info#august-now-what-13"></a>August : Now What?</h1>
<p>I'm back in Florida now, and settling into hermit mode...possibly for a couple of months, or maybe all winter.  More in the mood for doing some development.</p>
<p>I've synchronized Ren-C with all the updates of the compilers and tools, and made a new Linux development VM based on Ubuntu 24.04 LTS (since the last Long-Term-Support release I'd been using expired, long-term doesn't actually feel all that long).</p>
<p>And I'm now taking the important step of sitting down to write a status update.  It's good to remember the nifty stuff that happened earlier in the year, and consciously reflect on what has been blocking the desire to work on it since then.</p>
<p><strong>I sure wish I could make some conservative choices and create a mimimum viable product, without needing to single-handedly try and solve everything up front with the Ren-C artifact.</strong></p>
<p>Yet the sad fact is that when it comes to just "getting the idea out there", that ship sailed long ago with Rebol2.  From a design level, it found just enough that would stick to the wall.  But it was enough to inspire JSON, and then spawn a bunch of bus-factor-one derivative projects.</p>
<p>While Ren-C took R3-Alpha's <a href="https://en.wikipedia.org/wiki/Second-system_effect">Second-System Effect</a> to new heights of pathology, it has the merit of being full of ideas I find interesting.  Meanwhile in over a decade, Red's "getting the idea out there, part 2" mission hasn't even accomplished an artifact that achieves Rebol2 parity for our modern faster-evolving ecology... <em>despite being relatively unambitious about changing the language</em>.  And I don't personally find much interesting about it <sub>(except for some of the stuff Boris does)</sub></p>
<p>Grafting one or two of the cool ideas onto R3-Alpha or Red, while leaving binding and the other big picture issues unsolved, isn't something the world needs (or can be made to want, nor should it).  So I've dug my own hole: too many nifty concepts, but not a complete enough picture to deploy as a system.</p>
<p><strong>Could I do small bite-size YouTube shorts (or similar) that demonstrate interesting ideas, without actually trying to sell people on an artifact that implements those ideas?</strong>  I'm not sure... but there are people who will watch <a href="https://www.youtube.com/watch?v=UCgoxQCf5Jg">entire documentaries on things like TempleOS</a> without feeling they've wasted their time, even though they don't intend to ever run it.</p>
<hr>
<h1>
<a name="step-one-is-write-update-post-step-two-is-14" class="anchor" href="https://forum.rebol.info#step-one-is-write-update-post-step-two-is-14"></a>Step One Is Write Update Post.  Step Two Is...</h1>
<p>I've actually had some topics I've wanted to write on in the last few weeks.</p>
<p>But I felt that since I hadn't said anything for a while, I needed to write a status post and speak some about what's been on my mind.</p>
<p>Ok...</p>
<p><strong>I'm going to do some low-pressure tinkering just to get back to making commits and posts and see what grabs me.</strong></p>
<p>I'll update here with any more thoughts.  Certainly I think that making the canon "Rebol: The Movie" documentary is something I'm uniquely qualified to do.  Maybe if I combined history, stories of the cast of characters and personalities, along with summarized design arguments and critiques it would be enough that the software-writing-AI of the future (<a href="https://www.youtube.com/shorts/MSuw5AoN7I8">or...Thursday?</a>) could sort it out.  If not, at least entertain.</p> ]]></description>
        <link>https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188#post_1</link>
        <pubDate>Sun, 18 Aug 2024 00:43:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7315</guid>
      </item>
      <item>
        <title>O noes, Unicode Normalization</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="13" data-topic="1322">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Haskell is great in terms of the overall "wow isn't this great" of Haskell, but, if you're building an oddity out of modeling clay then the rules change.</p>
</blockquote>
</aside>
<p>Oh, sure; I was just explaining how it does things, and why it does them that way.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="13" data-topic="1322">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I kind of wish that a random standard for representing human written language hadn't gotten this far in concerns for deployed systems, just not sure what the best way to mitigate that is.</p>
</blockquote>
</aside>
<p>Unicode is far from being a ‘random standard’. It’s complicated because human written language is complicated. It may <em>seem</em> simple if you restrict yourself to English, but once you start to look at Hebrew or Arabic or Tamil or Khmer or Pollard — or even some less well-known Latin-based writing systems  — it gets a lot less so. Unicode may have its flaws, but most of its complexity is simply humans being humans.</p> ]]></description>
        <link>https://forum.rebol.info/t/o-noes-unicode-normalization/1322#post_14</link>
        <pubDate>Sat, 15 Jun 2024 10:06:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7314</guid>
      </item>
      <item>
        <title>O noes, Unicode Normalization</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="12" data-topic="1322">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>(This is what Haskell does. You can append <code>Text</code> to <code>Text</code>, and <code>ByteString</code> to <code>ByteString</code>, but to append a <code>ByteString</code> to <code>Text</code> you need to first convert it specifying an encoding.)</p>
</blockquote>
</aside>
<p>Haskell is great in terms of the overall "wow isn't this great" of Haskell, but, if you're building an oddity out of modeling clay then the rules change.</p>
<p>There's no semantic value out of forcing people to convert something to a string prior to appending bytes if it's runtime.  The type system isn't checking you so disallowing legal sequences is just stopping people from doing what they want.</p>
<p>I feel this is one of the moments to remind you that <em>I did not like Rebol</em> when I saw it, it breaks rules.</p>
<p>But art also breaks rules.  Weeping woman, by Picasso, may not be my <em>favorite</em> piece of art but I like the rule breaking:</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/f833139e4270534bd0c93ef3492779d46c71bfe1.jpeg" alt="Picasso_The_Weeping_Woman_Tate_identifier_T05010_10" data-base62-sha1="zpFQjM4AEElvkGj7phfn0fgvqjT" width="286" height="348"></p>
<p>I have said before, that if Haskell didn't already have a following, I'd be all over it.</p>
<p>But it does already.  It's like walking into a room full of people explaining why M.C. Escher is the greatest artist.  And, maybe?  But also maybe that's boring.</p>
<p>Anyway, yes.  Haskell, or Idris, or whatever succeeds that.  But I'm from C++ and still really respect C++, and, when I slip into the edges of madness of <em>"why can't we paint code like this"</em>, I mess around with this stuff.</p>
<p>I kind of wish that a random standard for representing human written language hadn't gotten this far in concerns for deployed systems, just not sure what the best way to mitigate that is.</p> ]]></description>
        <link>https://forum.rebol.info/t/o-noes-unicode-normalization/1322#post_13</link>
        <pubDate>Sat, 15 Jun 2024 04:38:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7313</guid>
      </item>
      <item>
        <title>O noes, Unicode Normalization</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="11" data-topic="1322">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I hope you agree that allowing <strong><code>append string #{CC}</code></strong> would be bad, and that today's behavior is good</p>
</blockquote>
</aside>
<p>Yes, I agree with this. In fact, I’ll go even further: appending arbitrary bytes to a string shouldn’t <em>ever</em> be allowed. You should be required to use an encoding to convert it to a string before appending.</p>
<p>(This is what Haskell does. You can append <code>Text</code> to <code>Text</code>, and <code>ByteString</code> to <code>ByteString</code>, but to append a <code>ByteString</code> to <code>Text</code> you need to first convert it specifying an encoding.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="11" data-topic="1322">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Per my writing <a href="https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187">criticizing the robustness principle</a>, the system would be mandating that input already be normalized and keeping things normalized at all times. This gives a saner foundation to the process.</p>
</blockquote>
</aside>
<p>‘Keeping things normalised at all times’ is a good general guideline. But it’s <em>only</em> a guideline — not the right thing to do in all cases!</p>
<p>I think the key question which needs to be asked here is, ‘why does one normalise’? That link I sent you in the other thread explains the key points, but it boils down to ‘making illegal states unrepresentable’. That is, normalisation is useful in situations where un-normalised data can become nonsensical or inconsistent.</p>
<p>But is non-normalised Unicode <em>really</em> an ‘illegal state’? I would strongly argue that it isn’t, in general. Perhaps it’s useful in specific circumstances, but precisely what needs to be normalised away differs between different cases.</p>
<p>In fact, even Unicode itself doesn’t prescribe a single normalised form for all text — it has four, and what is normalised in one is completely un-normalised in another! So, if you really want to go down the road of ‘mandating normalisation’, you’d need four separate string types, plus a fifth for the inevitable situations where you need to process user input without further normalisation (e.g. as I do for Brassica). I don’t think it’s even close to being worth the extra complication.</p> ]]></description>
        <link>https://forum.rebol.info/t/o-noes-unicode-normalization/1322#post_12</link>
        <pubDate>Fri, 14 Jun 2024 23:56:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7312</guid>
      </item>
      <item>
        <title>The Robustness Principle Is Not Robust</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2187">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I think you’d very much enjoy this article, if you haven’t seen it already: <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">Parse, don’t validate </a>.</p>
</blockquote>
</aside>
<p>Hadn't seen this...</p>
<p>It starts from the premise of <em>"you can't write <strong><code>[a] -&gt; a</code></strong>"</em>, which is where I had wanted to start my own Intro-to-Haskell essay.  Grasping how nothing is taken for granted (no default constructor, etc) and how the type signature practically tells you what the function does.</p>
<p>Now I don't have to write my own less-informed version of that.   <img src="https://forum.rebol.info/images/emoji/twitter/relieved.png?v=12" title=":relieved:" class="emoji" alt=":relieved:" loading="lazy" width="20" height="20"></p>
<p><em>(Although it does expect you to know what <strong><code>head :: [a] -&gt; a</code></strong> means, and I'd thought of really starting from no knowledge besides familiarity with some imperative language for contrast.)</em></p>
<hr>
<p>I don't see anything to disagree with:</p>
<ul>
<li>
<p><strong>"Use a data structure that makes illegal states unrepresentable."</strong></p>
</li>
<li>
<p><strong>"Get your data into the most precise representation you need as quickly as you can. Ideally, this should happen at the boundary of your system, before <em>any</em> of the data is acted upon."</strong></p>
</li>
<li>
<p><strong>"Avoid denormalized representations of data, <em>especially</em> if it’s mutable."</strong></p>
</li>
<li>
<p><strong>"Keep denormalized representations of data behind abstraction boundaries."</strong></p>
</li>
</ul>
<p>This kind of thinking is what made me want TEXT! to work how it does enforcing UTF-8, and is guiding thinking on <a href="https://forum.rebol.info/t/o-noes-unicode-normalization/1322/11">pushing that further to NFC</a>.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187#post_3</link>
        <pubDate>Thu, 13 Jun 2024 22:04:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7311</guid>
      </item>
      <item>
        <title>O noes, Unicode Normalization</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="10" data-topic="1322">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Making <code>append string #{CC81}</code> error would be a massive nightmare for any kind of string processing.</p>
</blockquote>
</aside>
<p>I hope you agree that allowing <strong><code>append string #{CC}</code></strong> would be bad, and that today's behavior is good:</p>
<pre><code>&gt;&gt; string: "e"
== "e"

&gt;&gt; append string #{CC}
** Script Error: String aliased as BINARY! can't become invalid UTF-8
</code></pre>
<p>If you want arbitrary bytes, you have to keep everything as BINARY!:</p>
<pre><code>&gt;&gt; bytes: to binary! "e"
== #{65}

&gt;&gt; append bytes #{CC}
== #{65CC}
</code></pre>
<p>But TEXT! must be valid UTF-8 on every operation:</p>
<pre><code>&gt;&gt; to text! bytes
** Script Error: invalid UTF-8 byte sequence found during decoding
</code></pre>
<p>I'm pleased with all of that.</p>
<aside class="quote no-group" data-username="bradrn" data-post="10" data-topic="1322">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>And the consequences of over-normalising can be severe: normalisation can change strings in ways which aren’t necessarily obvious. (The URL problem you gave is just one example of this.)</p>
</blockquote>
</aside>
<p>Per my writing <a href="https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187">criticizing the robustness principle</a>, the system would be mandating that input already be normalized and keeping things normalized at all times.  This gives a saner foundation to the process.</p>
<aside class="quote no-group" data-username="bradrn" data-post="10" data-topic="1322">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Forcing one normalisation method would make it difficult if one ever needs to use any of the others.</p>
</blockquote>
</aside>
<p>I did suggest that perhaps there be a middle tier... where TEXT! enforces NFC as an additional constraint on top of UTF-8!, and UTF-8! does its enforcement on top of BINARY!.</p>
<p>Because forcing you to use BINARY! for all non-NFC would lose the advantages of the already-existing codepoint coherence.  Seems like a waste.</p>
<p>But most of the system would use TEXT! as currency in canon form.</p>
<aside class="quote no-group" data-username="bradrn" data-post="10" data-topic="1322">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Parsing and generation would become drastically more complicated as programs would now need to guard against an ‘invalid’ character ever being in the wrong place.</p>
</blockquote>
</aside>
<p>Because I see this as a direct analogy to the constraint of maintaining valid UTF-8, I don't see this as being oppressive.  It keeps you sane.</p>
<p>The current state of things is what I find oppressive:</p>
<pre><code>&gt;&gt; single: to text! #{C3A9}
== "é"

&gt;&gt; double: to text! #{65CC81}
== "é"

&gt;&gt; length of single
== 1

&gt;&gt; length of double
== 2
</code></pre>
<p>So paralleling the "UTF-8 Everywhere Manifesto", I'd say the "NFC Everywhere Manifesto" has the potential to make people's lives better and not worse.</p>
<p>Giving an oft-better answer for LENGTH OF makes yet another argument for why to pick NFC.</p>
<p>If you were assured that all the TEXT! in the system was in NFC, you would not have any troubles when you went searching for substrings, because the substrings would also be NFC.</p> ]]></description>
        <link>https://forum.rebol.info/t/o-noes-unicode-normalization/1322#post_11</link>
        <pubDate>Thu, 13 Jun 2024 21:10:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7310</guid>
      </item>
      <item>
        <title>O noes, Unicode Normalization</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1322">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Is "NFC Everywhere" Possible?</p>
</blockquote>
</aside>
<p>I can answer this question quite straightforwardly: <strong>please God, no!</strong></p>
<p>Let’s start with the difficulties it creates for programmers. Making <code>append string #{CC81}</code> error would be a massive nightmare for any kind of string processing. Parsing and generation would become drastically more complicated as programs would now need to guard against an ‘invalid’ character ever being in the wrong place. My own <a href="https://bradrn.com/brassica/">Brassica</a> (which I still hope to reimplement in Ren-C one of these days) would become near-impossible to write without crashing unexpectedly.</p>
<p>Then there’s the fact that normalising strings everywhere is conceptually the wrong thing to be doing: generally you want to keep strings in their original representation. ‘Normalisation’ may sound like a desirable thing, but in general it isn’t. It’s useful if you happen to have a need to test string equality, but pretty much nowhere else. And the consequences of over-normalising can be severe: normalisation can change strings in ways which aren’t necessarily obvious. (The URL problem you gave is just one example of this.)</p>
<p>Another point to consider is that there are four separate normalised forms. This should give you a clue that none of them is entirely sufficient on their own. Instead, which to pick depends on precisely what you want ‘string equality’ to mean in each specific case. Forcing one normalisation method would make it difficult if one ever needs to use any of the others.</p>
<p>So, in sum: this is an extraordinarily bad idea, with almost no advantages. Don’t do it.</p>
<p>(Although, if you want, a ‘normalised string equality’ operator might not be a bad idea.)</p> ]]></description>
        <link>https://forum.rebol.info/t/o-noes-unicode-normalization/1322#post_10</link>
        <pubDate>Thu, 13 Jun 2024 10:38:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7309</guid>
      </item>
      <item>
        <title>The Robustness Principle Is Not Robust</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2187">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Authentic programs should demand a standard form. And when they aren't getting the standard form they should speak up, march you out the door, and force you to fix your input.</p>
</blockquote>
</aside>
<p>I think you’d very much enjoy this article, if you haven’t seen it already: <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/" class="inline-onebox">Parse, don’t validate</a>.</p>
<p>(That being said, I think there’s still a place for a weak version of the Robustness Principle. ‘Be conservative in what you send’ is always a good guideline, of course. And it seems reasonable to accept some amount of small variation in input, when it’s unambiguous.)</p> ]]></description>
        <link>https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187#post_2</link>
        <pubDate>Thu, 13 Jun 2024 10:16:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7308</guid>
      </item>
      <item>
        <title>The Robustness Principle Is Not Robust</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Something floating around that I've pretty much always hated--but experience has made me hate more--is the "Robustness Principle":</p>
<aside class="onebox wikipedia" data-onebox-src="https://en.wikipedia.org/wiki/Robustness_principle">
  <header class="source">

      <a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">en.wikipedia.org</a>
  </header>

  <article class="onebox-body">
    

<h3><a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">Robustness principle</a></h3>

<p>In computing, the robustness principle is a design guideline for software that states: "be conservative in what you do, be liberal in what you accept from others". It is often reworded as: "be conservative in what you send, be liberal in what you accept". The principle is also known as Postel's law, after Jon Postel, who used the wording in an early specification of TCP.
 In other words, programs that send messages to other machines (or to other programs on the same machine) should conform comple...</p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>I understand the motivation.  If you have something that imports to a vector graphics program and not all the Bezier curves have endpoints... then, sure.  Someone is going to appreciate that you were forgiving and they got some kind of maybe-a-bit-broken picture instead of an "Invalid File" error.</p>
<p>Pushing this further to those of us who remember the DOS days: we had those experiences where we accidentally deleted files, but the filesystem didn't delete everything--it just wrote a zero byte on the filename (or somesuch).  Norton Utilities let us catch our mistake and get our file back.  In some ways, a lax and forgiving attitude is a beautiful thing...</p>
<p>This so-called "robustness" cannot (and should not) be subconscious.  It needs to be mitigated with an in-your-face consciousness shift!  <em>(And I think Norton Utilities is an apt example, because if you were firing up that program <a href="https://www.youtube.com/watch?v=RRU3I_o1vLc">you knew you were in the Danger Zone</a>)</em>.</p>
<p>There must be a really jarring speedbump.  When a data file is not fitting the standards, you have to go through a procedure that transforms the broken file to the standard.  You have to be aware that you are dealing with a dirty file.  And the experience of that transformation informs you that the person who gave you the dirty file isn't playing with all their marbles, and you correct them for the next transmission.</p>
<p>Authentic programs should demand a standard form.  And when they aren't getting the standard form they should speak up, march you out the door, and force you to fix your input. "Real programs" should never pretend the byte sequence of bad input is okay--there should only be "Cleanup/Recovery programs" that fix the sequence to write a correct one.  And that recovery program should be terminated before the "Real program" runs.</p>
<hr>
<p>I don't need to rewrite the critiques of the "robustness principle" cited in Wikipedia.  But it is nonsense, and the opposite of robust.  It's a garbage idea, that anyone with a whit of sense regarding security can see right through immediately.</p>
<p>There is a better way: the better way is <em>consciousness</em> about what you are working with, and rejection of any sort of malignant "middleman" acting on your data without you knowing.</p>
<ul>
<li>
<p>"Normalization" you did not ask for is an attack on your information.</p>
</li>
<li>
<p>"Glossing over or fixing invalid sequences" you did not ask for is an attack on your information</p>
</li>
<li>
<p>Anything which makes a simple load of a file and save back of the same file not idempotent is an attack on your information</p>
</li>
</ul>
<p>Perhaps I've become even more religious than Carl in some of these ways.  But I certainly see things won't get better without pushing back.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187#post_1</link>
        <pubDate>Thu, 13 Jun 2024 05:45:28 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7307</guid>
      </item>
      <item>
        <title>Is there anything like parse in other languages?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="jjsullivan5196" data-post="4" data-topic="2032">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/jjsullivan5196/40/379_2.png" class="avatar"> jjsullivan5196:</div>
<blockquote>
<p>You can get pretty fancy with it if you know what you're doing, but it probably could use some more inspiration from <code>PARSE</code>.</p>
</blockquote>
</aside>
<p>I like Clojure on paper (and am incredibly tempted at times to add <a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">persistent vector</a>, though I keep trying to think of it as "if you lived in a world where FP was what has always been, mutable state without having to name each alteration would be a Eureka moment").</p>
<p>But whenever I read Clojure, I always get to "that's some illegible stuff right there".</p>
<p>I know we develop our lenses that see past the illegibility and forgive it <em>(I have that blindness with C++, I muck around with it and get to that point of "I can understand it so it must be coherent"... with that awareness <a href="https://github.com/metaeducation/ren-c/blob/master/src/include/sys-debug-casts.hpp">I engineered Ren-C's debug build cast operators</a>....whose only redeeming quality for most people is that you can build without that).</em></p>
<p>Anyway... what PARSE lacks in performance it makes up for in legibility.  And maybe there is indeed something we could be giving back to such projects, if I made the time to offer feedback and contribute ideas.</p>
<p>Or given that I'm a burnout, perhaps that could be your job.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p> ]]></description>
        <link>https://forum.rebol.info/t/is-there-anything-like-parse-in-other-languages/2032#post_5</link>
        <pubDate>Thu, 13 Jun 2024 05:34:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7306</guid>
      </item>
      <item>
        <title>Om: concatenative homoiconic language</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><sub>Sorry, long delay to look at this.  Personal distractions, then technical issues with the DNS, etc. but we're back...</sub></p>
<hr>
<blockquote>
<p>This was a one hit wonder on hackernews a couple years ago.</p>
</blockquote>
<p>Finally sat down to read over this.  And having not even heard the term "concatenative language" before... I also read the essay <strong><a href="http://evincarofautumn.blogspot.com/2012/02/why-concatenative-programming-matters.html">Why Concatenative Programming Matters</a></strong>.</p>
<p>Forth is claimed to be in this concatenative family, and oft cited as a Rebol influence.  I think <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> is the only person around here who still (maybe?) messes with Forth.  He follows the <a href="https://www.reddit.com/r/Forth/comments/573lmq/8th_is_it_forth/">pariah variant "8th"</a>, or at least used to.  I look at Forth programs and can't reasonably consider them "source code" in any kind of human sense...an illegible <a href="http://weblog.raganwald.com/2004/10/beware-of-turing-tar-pit.html">Turing Tarpit</a> <em>" …in which everything is possible but nothing of interest is easy."</em>  At best it's compiler output, you can never find a place in the program that corresponds to intent...just implementation.  Someone's off-the-cuff crafting of a bytecode.</p>
<p>My reading is that Om sought to be a "prefix-based lambda calculus of concatenative programming" (or something?) where expressions that lack enough operands to evaluate become... uh, pointfree, I think?</p>
<p><em>"If the computation cannot be completed (due to insufficient operands), the operator that names the operation is pushed onto the output program, followed by all remaining input terms."</em></p>
<p>The pitch seems like a purist prefix Forth that I'm less likely to be able to use than the Forth I already refuse to use.</p>
<aside class="quote no-group" data-username="jjsullivan5196" data-post="1" data-topic="2184">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/jjsullivan5196/40/379_2.png" class="avatar"> jjsullivan5196:</div>
<blockquote>
<pre><code class="lang-plaintext">quote {A}
-&gt; {{A}}
</code></pre>
<pre><code class="lang-plaintext">dequote {A}
-&gt; A
</code></pre>
</blockquote>
</aside>
<p>I'll mention the odd terminology thing we got into, where the question of removing one level of quoting was distinguished from removing all levels of quoting.</p>
<p><a class="mention" href="https://forum.rebol.info/u/iarnold">@iArnold</a> had his moment to shine <a href="https://forum.rebol.info/t/unquote-and-dequote-too-similar/1626/2">in suggesting NOQUOTE</a>, because DEQUOTE was too ambiguous.</p>
<pre><code>&gt;&gt; unquote first ['''abc]
== ''abc

&gt;&gt; noquote first ['''abc]
== abc
</code></pre>
<p>So we simply avoid the term DEQUOTE.</p>
<p>Of course, the craziest thing to absorb in Ren-C is the existence of "antiforms" (quoting level of -1) and quasiforms, which just show we're not in Kansas anymore.</p>
<p><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918" class="inline-onebox">A Justification of Generalized Isotopes</a></p>
<p>Rightly or wrongly, I'm now anchored to the semantics of an isotopic system.</p>
<blockquote>
<p><em>"unicode-correct: any UTF-8 text (without byte-order marker) defines a valid Om program."</em><br>
...<br>
<em>"Strings are automatically normalized to NFD, but can be explicitly normalized to NFKD using the <strong>normalize</strong> operation"</em></p>
</blockquote>
<p>There is curious attention to Unicode-isms for a project that is so... otherwise minimal.  I note that the implementation uses the obscenely complex dependency of <a href="https://en.wikipedia.org/wiki/International_Components_for_Unicode">ICU4C</a>--which is not something that would be considered for the purposes of our project.</p>
<p>Ren-C also <a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">standardizes on UTF-8... but uses "UTF-8 Everywhere"</a>.  This means it doesn't just enforce UTF-8 source code, but the runtime representation of strings.  <em>(As far as I can tell, Om uses fixed-sized codepoints at runtime for strings, despite linking to the UTF-8 Everywhere manifesto.)</em></p>
<p>Normalization is something that so far we have not addressed, though I've written about the topic:</p>
<p><strong><a href="https://forum.rebol.info/t/o-noes-unicode-normalization/1322">O Noes, Unicode Normalization</a></strong></p>
<p>Om only mentions the decomposed formats NFD/NFKD.  This is to say that if you had a single codepoint in your file on disk like an e with an accent (<strong>é</strong>) then it would be loaded into memory as the two codepoint sequence, of an e and then an accent.</p>
<p>This got me to dig deeper and I seriously don't know at this point where we should plant our Amish stake when it comes to Unicode.  I got in arguments with ChatGPT and Claude about why combining characters would ever be <em>after</em> the characters they modify, as it breaks anyone's chances of writing a stream sink.  Despite the fact that Unicode was being designed in a relatively modern time where you would assume people had learned their lessons and ran their ideas through some kind of filter of intelligent people.  But apparently no.</p> ]]></description>
        <link>https://forum.rebol.info/t/om-concatenative-homoiconic-language/2184#post_2</link>
        <pubDate>Thu, 13 Jun 2024 04:11:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7305</guid>
      </item>
      <item>
        <title>O noes, Unicode Normalization</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>While reading on some details Unicode normalization, I found a writeup of how URLs could be significantly changed by the process:</p>
<p><a href="https://github.com/whatwg/url/issues/626" class="inline-onebox">Unicode normalization could change the structure of a URL · Issue #626 · whatwg/url · GitHub</a></p>
<p>That's nuts.</p>
<p>To quickly refresh everyone's memory on our URL! datatype: we now think of it as being the decoded form...like what people would copy and paste out of a browser's URL bar.  That could contain forms not legal to GET or POST to a web server.  So the percent-encoding is something one has to choose to do with a string conversion to or from a URL! if applicable:</p>
<p><a href="https://github.com/metaeducation/ren-c/pull/655" class="inline-onebox">Treat URL! as normal strings with no encoding behavior by hostilefork · Pull Request #655 · metaeducation/ren-c · GitHub</a></p>
<p>However the GitHub issue I link up top points out that normalization is another nuance that is a place for bugs / hacking / etc.  This jumped out to me as a very simple--yet insidious--thing:</p>
<blockquote>
<p>NFD and NFKD will normalize the following three characters to generate potentially forbidden code points:</p>
<ul>
<li>
<code>\u2260</code> (<code>≠</code> as one code point) to <code>=\u0338</code> (<code>≠</code> as two code points)</li>
<li>
<code>\u226E</code> (<code>≮</code> as one code point) to <code>&lt;\u0338</code> (<code>&lt;̸</code> as two code points)</li>
<li>
<code>\u226F</code> (<code>≯</code> as one code point) to <code>&gt;\u0338</code> (<code>&gt;̸</code> as two code points)</li>
</ul>
</blockquote>
<p>So you aren't supposed to have <strong>&lt;</strong> or <strong>&gt;</strong> or <strong>=</strong> in the URL, but they can pop up as part of the unicode normalization process if you decompose things.</p>
<p><strong><a href="https://forum.rebol.info/t/newlina-non-grata/1207">I've been pushing against automatic transformations as a broken concept--even when it was just carriage returns and line feeds.</a></strong></p>
<p>Here I have the same instincts creeping in.  So what do we know?</p>
<ul>
<li>
<p><strong>We should not be building a system that normalizes or denormalize anything without being asked.</strong></p>
<ul>
<li>
<p>We either accept only one format as input, or accept more formats and act neutrally.</p>
</li>
<li>
<p>I am a fan of strong stances over neutral ones, in order to guide the ecosystem to a better place, even if it makes interoperability with things outside the ecosystem require more effort</p>
<ul>
<li>
<p>The "automatic" things that permit "interoperability" are a false economy</p>
</li>
<li>
<p>You pay with confusion, bugs, and security holes</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>The bias of stored formats on disks and filesystems is NFC</strong></p>
<ul>
<li>
<p>As canonized forms go it is not just the most compact, but it is also the most typical way to find codepoints encoded in practice.</p>
</li>
<li>
<p>It's what the W3C suggests be used for transfer over the Internet, regardless of the internal forms a program might use</p>
</li>
<li>
<p>Chrome is the leading browser by miles, and for <strong>é</strong> it canonizes both the one-codepoint (NFC) and separate e-and-accent form (NFD) to a network request for e.g. <code>http://example.com/%C3%A9.txt</code>.  While other browsers like Firefox don't canonize, hence the two-codepoint form shows as <code>http://example.com/e%CC%81.txt</code> with the naked <strong>e</strong> and the accent codepoint two-byte UTF-8 percent encoded afterward.</p>
<ul>
<li>Chrome's outsized influence suggests where the wind is blowing.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>When you think about streaming, e.g. bytes flowing one by one from your program to something like the Windows or Linux terminal to display, decomposed forms give rise to chaos</strong></p>
<ul>
<li>
<p>Let's say you are the terminal program, and over the pipe you get something like the bytes for a prompt, like <strong><code>&gt;</code></strong> followed by <strong><code>&gt;</code></strong>.</p>
<ul>
<li>
<p>Should you display those characters on the screen?  What if a composable character comes afterward, to transform it into <strong><code>≯</code></strong></p>
</li>
<li>
<p>You might not have the power to cursor back and erase what you already printed, depending.  But even if you can, that's a lot of complexity that has to be borne by every consumer of UTF-8 bytes</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This is making Latin1 seem like a saner choice, and that engaging Unicode has actually been a mistake.</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/7d1580ef3d9d786d8a847bdaaf9bb606c8251134.png" alt="the_history_of_unicode" data-base62-sha1="hQxKOQWhaUo21MsIwFuh5jGsWpu" width="624" height="239"></p>
<h2>
<a name="is-nfc-everywhere-possible-1" class="anchor" href="https://forum.rebol.info#is-nfc-everywhere-possible-1"></a>Is "NFC Everywhere" Possible?</h2>
<p>We already enforce atomic manipulations to strings at the byte level so that you can only insert/remove byte sequences that leave the string as valid UTF-8.</p>
<p>The canonization process is standardized, and ostensibly we know what the <a href="https://en.wikipedia.org/wiki/Combining_character">combining characters</a> are.  Wouldn't be trivial to implement, but we could say all modifications must generate NFC.</p>
<pre><code>&gt;&gt; string: "e"
== "e"

&gt;&gt; append string #{CC81}  ; the accent combining character in BINARY!
** Error: Modification to string would create non-canon form
</code></pre>
<p>That's different from today's answer, which lets you do it:</p>
<pre><code>&gt;&gt; append string #{CC81}
== "é"
</code></pre>
<p>I'm not particularly afraid to go in this direction, but there are some glitches.</p>
<p>I gather not all combining character sequences people might use canonize to a single codepoint.  Some meaningful sequences to readers are only available as their decomposed forms, and normalization just ensures that the combining marks are in the same byte order.</p>
<p>This means that if you're in the position of the terminal implementer, then so long as you are dealing with a character that could be composed with something in non-canonized form you'd have to wait for a non-composable character (?) before you print anything... or be able to go back.  It seems to me nonsensical that the combining characters come <em>after</em> the character you combine with.  Maybe we should buck the trend with our own format that puts them first, at least in streaming cases.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>Anyway, just wanted to write down some more thoughts about this heinous thing.</p> ]]></description>
        <link>https://forum.rebol.info/t/o-noes-unicode-normalization/1322#post_9</link>
        <pubDate>Wed, 12 Jun 2024 23:26:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7304</guid>
      </item>
      <item>
        <title>PicoLisp machine</title>
        <dc:creator><![CDATA[@jjsullivan5196 John Sullivan]]></dc:creator>
        <description><![CDATA[ <p>Pretty comprehensive reference on how picolisp's cons machine works <a href="https://software-lab.de/doc/ref.html#vm" class="inline-onebox" rel="noopener nofollow ugc">PicoLisp Reference</a></p> ]]></description>
        <link>https://forum.rebol.info/t/picolisp-machine/2185#post_1</link>
        <pubDate>Thu, 23 May 2024 06:34:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7302</guid>
      </item>
      <item>
        <title>Om: concatenative homoiconic language</title>
        <dc:creator><![CDATA[@jjsullivan5196 John Sullivan]]></dc:creator>
        <description><![CDATA[ <p><a href="https://www.om-language.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.om-language.org/</a></p>
<p>This was a one hit wonder on hackernews a couple years ago. Probably the thing of greatest relevance is its "panmorphic" data representation: 3 terminal types of</p>
<ul>
<li>Separators, which compose any utf8 whitespace characters</li>
<li>Operator, essentially symbols of <code>any-other-utf8-text</code>.</li>
<li>Operand, a quoted program in <code>{curlie braces}</code> containing operators or <code>{{other} {operands} and operators}</code> with separators between.</li>
</ul>
<p>The evaluator can define a vocabulary of base "operations" tied to an operator symbol. Every operation takes the rest of the program as input and appends its output. For instance, <code>quote</code> and <code>dequote</code> wrap or unwrap the next term of the program in an enclosing operand. (using <code>-&gt;</code> to indicate output)</p>
<pre><code class="lang-plaintext">quote {A}
-&gt; {{A}}
</code></pre>
<pre><code class="lang-plaintext">dequote {A}
-&gt; A
</code></pre>
<p>More examples on the website</p> ]]></description>
        <link>https://forum.rebol.info/t/om-concatenative-homoiconic-language/2184#post_1</link>
        <pubDate>Thu, 23 May 2024 02:44:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7301</guid>
      </item>
      <item>
        <title>Is there anything like parse in other languages?</title>
        <dc:creator><![CDATA[@jjsullivan5196 John Sullivan]]></dc:creator>
        <description><![CDATA[ <p>Should probably mention <a href="https://clojure.org/guides/spec#_sequences" rel="noopener nofollow ugc">clojure spec</a> has combinators for validation rules and <code>conform</code> as a not-so-well documented protocol for making productions based on those rules. There's some very simple productions for doing things like parsing argument lists and other sequential messages. You can get pretty fancy with it if you know what you're doing, but it probably could use some more inspiration from <code>PARSE</code>.</p> ]]></description>
        <link>https://forum.rebol.info/t/is-there-anything-like-parse-in-other-languages/2032#post_4</link>
        <pubDate>Wed, 22 May 2024 19:36:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7300</guid>
      </item>
      <item>
        <title>John Sullivan</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Welcome John!</p>
<aside class="quote no-group" data-username="jjsullivan5196" data-post="1" data-topic="2182">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/jjsullivan5196/40/379_2.png" class="avatar"> jjsullivan5196:</div>
<blockquote>
<p>I learned more about Carl's vision for the design and principles of the language, and Ren-C seems to be carrying on that tradition of simplicity and sustainability.</p>
</blockquote>
</aside>
<p>Dependency control is still a big motivator...though Ren-C aims to solve fundamental problems of fitness-for-purpose of the language.</p>
<p>This has led to some pretty crazy-seeming inventions, like <strong><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">Generalized Isotopes</a></strong> (including <a href="https://forum.rebol.info/t/taking-action-on-function-vs-action/596/6">antiform FRAME!</a>, which you've already met <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">), <a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">whole new ways of looking at binding</a>, and experimental designs for solving problems in really new ways.</p>
<p>So it's kind of an <em>"as simple as possible, but no simpler"</em> situation.  There are those who say Ren-C's inventions aren't necessary...but that's merely because they're willing to blind themselves to just how poor the language is without them.</p>
<aside class="quote no-group" data-username="jjsullivan5196" data-post="1" data-topic="2182">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/jjsullivan5196/40/379_2.png" class="avatar"> jjsullivan5196:</div>
<blockquote>
<p>I'm particularly inspired by <a class="mention" href="https://forum.rebol.info/u/hostilefork">@hostilefork</a>'s talk from a few years ago where you could build a new interpreter using <a href="https://youtu.be/PT3GOe1pj9I?si=NJlWjA6r_9i9J5Rh">just the tools that come with it </a>.</p>
</blockquote>
</aside>
<p>Glad you liked it!  That demo hasn't been patched up lately due to other priorities.  There is a GitHub Workflow for running the process, though:</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/master/.github/workflows/linux-tcc-build.yml" class="inline-onebox">ren-c/.github/workflows/linux-tcc-build.yml at master · metaeducation/ren-c · GitHub</a></p>
<p>I'll see if I can get it up to date and working again.</p>
<aside class="quote no-group quote-modified" data-username="jjsullivan5196" data-post="1" data-topic="2182">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/jjsullivan5196/40/379_2.png" class="avatar"> jjsullivan5196:</div>
<blockquote>
<p>I've been experimenting recently with the cosmopolitan libc toolchain, and I think it could supercharge that capability:</p>
<p><a href="https://github.com/jart/cosmopolitan" class="inline-onebox">GitHub - jart/cosmopolitan: build-once run-anywhere c library</a></p>
</blockquote>
</aside>
<p>I'd heard of the APE format a while ago.  Sounded like a neat trick.  But at the time there wasn't much of a library, and no X86 on ARM emulator.  Seems to have gotten further along.</p>
<p>Another avenue of attack here are WebAssembly runtimes.  We do have a WASI build:</p>
<p><a href="https://forum.rebol.info/t/ren-c-is-now-on-the-clouds-with-wasi/1854" class="inline-onebox">Ren-C is Now on the Clouds ☁️ with WASI</a></p>
<aside class="quote no-group" data-username="jjsullivan5196" data-post="1" data-topic="2182">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/jjsullivan5196/40/379_2.png" class="avatar"> jjsullivan5196:</div>
<blockquote>
<p>I decided to join the forum because I've been craving a language that's easier to carry with me wherever I might be, and REBOL fits the bill.</p>
</blockquote>
</aside>
<p>There's a lot of <em>interestingness</em> to the medium.  It leads you to look at problem solving in a very different way... to kind of "paint with code".  So things other languages would attack with libraries (or mixing the languages you use) you just attack by bending Rebol itself.</p>
<p>I'm not really an evangelist for using Ren-C (or any Redbol) to solve "important" problems, at least not in the current state.  But I do think it's a language family worth knowing, and tackling a little task or two in it is worthwhile.</p>
<p>If that generates enough interest to want to shape the future of it, then I welcome participation in the discussions here!</p> ]]></description>
        <link>https://forum.rebol.info/t/john-sullivan/2182#post_3</link>
        <pubDate>Mon, 20 May 2024 15:13:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7299</guid>
      </item>
      <item>
        <title>John Sullivan</title>
        <dc:creator><![CDATA[@jjsullivan5196 John Sullivan]]></dc:creator>
        <description><![CDATA[ <p>Hi!</p>
<p>Love what you all are doing here. I came to know about REBOL from a talk Doug Crockford did on syntax and data formats. I learned more about Carl's vision for the design and principles of the language, and Ren-C seems to be carrying on that tradition of simplicity and sustainability.</p>
<p>I decided to join the forum because I've been craving a language that's easier to carry with me wherever I might be, and REBOL fits the bill. Excited to learn more from you all.</p>
<p>I'm particularly inspired by <a class="mention" href="https://forum.rebol.info/u/hostilefork">@hostilefork</a>'s talk from a few years ago where you could build a new interpreter using <a href="https://youtu.be/PT3GOe1pj9I?si=NJlWjA6r_9i9J5Rh" rel="noopener nofollow ugc">just the tools that come with it</a>.  I've been experimenting recently with the cosmopolitan libc toolchain, and I think it could supercharge that capability:</p>
<p><strong><a href="https://github.com/jart/cosmopolitan" rel="noopener nofollow ugc">https://github.com/jart/cosmopolitan</a></strong></p>
<p>Admittedly I'm still a novice getting used to everything, but you can try what I have so far here if you'd like:</p>
<p><a href="https://github.com/jjsullivan5196/r3/blob/renc-cosmo-testing/README-COSMO.md" class="inline-onebox" rel="noopener nofollow ugc">r3/README-COSMO.md at renc-cosmo-testing · jjsullivan5196/r3 · GitHub</a></p>
<p>Building with cosmo allows the executable image to run on just about any computer you can paste it on, no rebuilding required!</p> ]]></description>
        <link>https://forum.rebol.info/t/john-sullivan/2182#post_1</link>
        <pubDate>Sun, 19 May 2024 03:09:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7296</guid>
      </item>
      <item>
        <title>RE: The Ordering and Priorities of the Ren-C Project</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It's outdated, and COMBINATOR <a href="https://github.com/metaeducation/ren-c/blob/70d066816ad705ca489c79b3aa9609e777b7b9cf/src/mezz/uparse.r#L103">is running as usermode, not commented out</a>.</p>
</blockquote>
</aside>
<p>Ah, good to know! In that case I think the comment should be removed.</p> ]]></description>
        <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179#post_9</link>
        <pubDate>Thu, 09 May 2024 09:20:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7294</guid>
      </item>
      <item>
        <title>RE: The Ordering and Priorities of the Ren-C Project</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>but I think my point stands.</p>
</blockquote>
</aside>
<p>It would if the comment weren't outdated...!</p>
<p>It's outdated, and COMBINATOR <a href="https://github.com/metaeducation/ren-c/blob/70d066816ad705ca489c79b3aa9609e777b7b9cf/src/mezz/uparse.r#L103">is running as usermode, not commented out</a>.</p>
<p>But like I say: the eventual goal is to leverage native code as what the comment says.  But keep the architecture be based around things that reflect and interchange with what could be entirely accomplished with usermode code, only slower.</p>
<p>That is a fundamental distinction from other approaches, that would not uncover issues like the use of CONTINUE in a GROUP! in PARSE when that could bind to code internal to the parse implementation.  There are many examples like this you hit while trying to fully implement a system in usermode.</p> ]]></description>
        <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179#post_8</link>
        <pubDate>Thu, 09 May 2024 02:22:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7293</guid>
      </item>
      <item>
        <title>RE: The Ordering and Priorities of the Ren-C Project</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><a href="https://github.com/metaeducation/ren-c/blob/70d066816ad705ca489c79b3aa9609e777b7b9cf/src/mezz/uparse.r#L2608">COMBINATORIZE is in no way "the key function"</a>!</p>
</blockquote>
</aside>
<p>I wasn’t thinking of COMBINATORIZE, but rather COMBINATOR itself, which has the following comment next to it:</p>
<blockquote>
<pre><code class="lang-plaintext">; !!! COMBINATOR is used so heavily that having it be usermode makes UPARSE
; prohibitively slow.  So it was made native.  However the usermode version is
; kept as a proof of concept that a user *could* have made such a thing.  It
; should be swapped in occasionally in the tests to overwrite the native
; version just to keep tabs on it.
</code></pre>
</blockquote>
<p>One could quibble about how ‘key’ this really is, but I think my point stands.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But large communities of patient people who work for free on weird things are rare.</p>
</blockquote>
</aside>
<p>I don’t know so much… there’s a lot of people interested in programming languages! At least some of them have found Rebol intriguing when I’ve mentioned it.</p>
<p>(The ‘constant disruption’ is certainly a barrier, but I think it’s something that early adopters are aware of.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Well, if I learn enough to understand Brassica in forming a Rebol version, maybe I can figure out how to contribute to the Haskell implementation as well, and it won't be a net loss of time.</p>
</blockquote>
</aside>
<p>Thanks for the offer! Although personally, I think that most of the remaining challenges are on the design side of things — implementation is usually straightforward, once I’ve worked out the details.</p> ]]></description>
        <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179#post_7</link>
        <pubDate>Thu, 09 May 2024 01:25:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7292</guid>
      </item>
      <item>
        <title>RE: The Ordering and Priorities of the Ren-C Project</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="5" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Serious question: is Ren-C any better in this regard? For instance, we do <em>have</em> a UPARSE implementation in Ren-C, but in practise the key function is commented out in favour of a C implementation</p>
</blockquote>
</aside>
<p><a href="https://github.com/metaeducation/ren-c/blob/70d066816ad705ca489c79b3aa9609e777b7b9cf/src/mezz/uparse.r#L2608">COMBINATORIZE is in no way "the key function"</a>!  And it wasn't nativized in order to avoid something usermode could not accomplish.  It was nativized with a few other things as an experiment... but the other things were all reverted because the design changed.  COMBINATORIZE didn't change much (yet), so it was left using the native version for now.  If the usermode code atrophied, that atrophy is hopefully minor.</p>
<p>Ultimately the goal is to nativize everything, <em>but</em> keep the scaffolding which wires everything together communicating in the abstractions of the language... and live-swappable with usermode implementations that do the same thing, just slower.  (I've mentioned that I want to put the Rebol and C code for a given combinator in the same file, and have the Rebol code extracted and aggregated from comments in the C at build time.  The same would apply to implementation guts like COMBINATORIZE.)</p>
<p>I've already demonstrated <a href="https://forum.rebol.info/t/replpad-visual-parse-debugger/2063">a primordial debugger</a> for UPARSE.  It depends on being able to programmatically dissect the stack frames of combinators, and that relies on those frames being bona fide FRAME! objects within the language.  That's instead of some customized "parse stack" that only applies to parsing (e.g. <a href="https://github.com/red/red/blob/27b2a730b6178928c0f205718d903e0edb546ee0/runtime/parse.reds#L1112">Red's PARSE</a>) and which would require a whole slew of specialized hooks to expose, and whose optimizations wouldn't speed anything else up.</p>
<p>What is nice is that by doing it my way, cross-cutting enhancements will help everything improve...not just UPARSE.  The glue between combinators will still be in terms of usermode-exposable abstractions, so that you can mix and match native combinators and usermode ones.  Using such methods does have cost over customized byte-level structures.  But it's worth it for the reflection abilities--and of course allowing proof of the ability to express it within the confines of the language if you need to.</p>
<p>So yes: Ren-C is better.  <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="5" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Perhaps if Ren-C had a larger and more active community, language development would be easy.</p>
</blockquote>
</aside>
<p>A large community of extremely patient people... maybe.  But large communities of patient people who work for free on weird things are rare.</p>
<p>Large usually correlates with people being invested, and those who invest in things will resist changes that break their systems.  To me, Red's thesis--that Rebol2 somehow is an end in and of itself--was disproven long ago.  But I'm happy enough to let them continue chasing <a href="https://www.theonion.com/boston-globe-tailors-print-edition-for-three-remaining-1819594940">the three people in that audience</a>.</p>
<p>I don't know what all the remaining massive breaking changes are, but there will be some.  I do think <em>"cut down stray bindings so you can assume bindings you encounter are intentional and need not be overridden"</em> was a good example of one that will be rippling for a while.</p>
<p>Right now, I've decided that the third array type of FENCE! opens up a lot of design space that is interesting. That interestingness is scaled up as the viability of binding and dialecting ramps up.  It's a tricky change affecting strings, and raising questions with how to have alternative loaders (e.g. if I want to continue pursuing Rebol2 compatibility layers).</p>
<p>So I'm still glad there aren't that many users to deal with disrupting...</p>
<aside class="quote no-group" data-username="bradrn" data-post="5" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Of course… like I said, I <em>am</em> busy. And even within the realm of SCAs, my primary focus is on improving my existing mature application.</p>
</blockquote>
</aside>
<p>Well, if I learn enough to understand Brassica in forming a Rebol version, maybe I can figure out how to contribute to the Haskell implementation as well, and it won't be a net loss of time.</p> ]]></description>
        <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179#post_6</link>
        <pubDate>Thu, 09 May 2024 00:18:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7291</guid>
      </item>
      <item>
        <title>RE: The Ordering and Priorities of the Ren-C Project</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The other Rebol derivatives quickly retreat to implementing dialects in C (or Red/System). They excuse it with "well, it would be too slow otherwise". But they literally don't know how to write and maintain non-trivial systems in the medium being discussed, without so many workarounds that it becomes more an exercise in constrained writing.</p>
</blockquote>
</aside>
<p>Serious question: is Ren-C any better in this regard? For instance, we do <em>have</em> a UPARSE implementation in Ren-C, but in practise the key function is commented out in favour of a C implementation — precisely because it’s too slow.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="4" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>[…] I assumed <em>"this all needs VERY serious rethinking"</em> was the prevailing belief. But most who were questioning the design had been involved for a decade already, and were burnt out...so they wandered off. The few of us here are all that's left of Rebol3</p>
</blockquote>
</aside>
<p>This is interesting context, thanks!</p>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm a fan of consensus... when people are willing to work toward it... and you've been helpful so far!</p>
</blockquote>
</aside>
<p>This actually gives me another thought about the difference between Ren-C and the other language communities I mentioned: <em>the others all have much larger communities</em>.</p>
<p>For instance, in a Haskell language discussion, you can easily have ten or so people arguing about the merits of a proposal, and often more than that. That lets maintainers make an informed decision given the thoughts of <em>many</em> people. Even in Lisp, the discussions I’ve seen can easily get 3–5 people weighing in — and I’m not in any Lisp-specific fora online.</p>
<p>By contrast, most discussions I’ve had with you… well, they’ve mostly just been me and you. Two people. It’s possible to get a consensus with two people, but it’s not as easy, because there’s no good way to choose when they have differing views. Perhaps if Ren-C had a larger and more active community, language development would become easier.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It would be good if you had some small project to add to the continuous integration roundup</p>
</blockquote>
</aside>
<p>You’re absolutely right here. I’ve been discussing a language I don’t use, and that’s not great.</p>
<p>Now that you mention it, I actually do have one project which would be well-suited to Rebol: a <em>sound change applier</em>. The concept comes from historical linguistics, but at it heart it boils down to something like a glorified regex-substitution program. I’ve developed a habit of writing one of these in every language I use seriously, with my <a href="https://github.com/bradrn/brassica">latest and most successful</a> being in Haskell.</p>
<p>[EDIT: apparently my webserver is down. Changed the link to GitHub instead.]<br>
[EDIT 2: back up again! See <a href="https://bradrn.com/brassica">https://bradrn.com/brassica</a>.]</p>
<p>What’s particularly interesting about this is that it’s a perfect fit for dialecting. One of the biggest motivators for having a dedicated sound change applier is that it gives you a convenient syntax to use, so making it a dialect is an obvious choice. A sound-change applier <em>embedded within a programming language</em> could let you do a lot of very interesting stuff. Ren-C probably isn’t mature enough to make a really usable application — for that I’d want some form of interactivity, at least — but a simple implementation should certainly be doable.</p>
<p>Of course… like I said, I <em>am</em> busy. And even within the realm of SCAs, my primary focus is on improving my existing mature application. But it’s something for me to keep in the back of my head for when I get the chance.</p> ]]></description>
        <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179#post_5</link>
        <pubDate>Wed, 08 May 2024 21:45:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7290</guid>
      </item>
      <item>
        <title>RE: The Ordering and Priorities of the Ren-C Project</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I do think that Ren-C is an objective step forward compared to other Rebols, when it comes to ‘big picture’ stuff like isotopes and definitional returns.</p>
</blockquote>
</aside>
<p><em>(... and <a href="https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066">definitional BREAK + CONTINUE</a> ...)</em></p>
<p>The other Rebol derivatives quickly retreat to implementing dialects in C (or Red/System).  They excuse it with "well, it would be too slow otherwise".  But they literally don't know how to write and maintain non-trivial systems in the medium being discussed, without so many workarounds that it becomes more an exercise in constrained writing.  Projects execute in spite of the language, not because of it... and that's what I'd call a <a href="http://weblog.raganwald.com/2004/10/beware-of-turing-tar-pit.html">Turing tar-pit</a>.</p>
<p>I want to show cases where the language solves problems in an impressive and novel way... that doesn't fall apart like a house of cards the moment the problem statement changes by one word.</p>
<p>So calling Ren-C an "objective step forward" is accurate.  <img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=12" title=":+1:" class="emoji" alt=":+1:" loading="lazy" width="20" height="20"></p>
<aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>what drives its language design? As far as I can tell, the answer seems to be: ‘whatever hostilefork feels is suitable’. Not that it’s unique to Ren-C by any means: Red feels largely driven by ‘whatever Nenad likes’, and similarly for Carl and historic Rebol. And then we have <a href="https://github.com/Oldes/Rebol3">Oldes’s fork</a>, which is yet another set of personal preferences.</p>
</blockquote>
</aside>
<p>The Rebol3 initiative put nearly every decision in Rebol2 under scrutiny, allowing for arbitrary incompatible changes...if they fixed fundamental issues.  I found the language in the middle of that discussion.  So I assumed <em>"this all needs VERY serious rethinking"</em> was the prevailing belief.  But most who were questioning the design had been involved for a decade already, and were burnt out...so they wandered off.  The few of us here are all that's left of Rebol3 <em>(and Oldes, who is prolific in wiring up libraries, but <a href="https://github.com/metaeducation/rebol-issues/issues/2293#issuecomment-369894095">not too concerned with language design</a> <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20">)</em></p>
<p>The Red crowd had a completely different mission, of an open-source Rebol2 written in a C-like systems dialect.  They considered Rebol2 to have been "good enough" to be copied more or less verbatim, and that deviating from it would cause delays and a requirement to write new documentation.  If you show them a broken scenario they'll occasionally acknowledge it as bad.  But the overwhelming tactic is to say "no language is perfect" (and Gregg can fill pages with saying this in about 100 different ways) vs. attempting to fix the problem.</p>
<p>Despite that, today's Red is incompatible with Rebol2 for seemingly trivial reasons, and is still missing many of its features (and <a href="https://forum.rebol.info/t/ren-c-license-changed-to-lgpl-3-0/1342">backpedaling on open source</a>).  "Whatever Nenad likes" seems to be the edge cases of the GUI design.  Because regardless of what they say publicly about the language or their goals, they envision RED.EXE winning the battle against the ever-bloating web browser.  (They don't say it often, because their quirky insecure 32-bit design sounds like a poor bet against the sunk cost of the globally-vetted browser everyone has installed already.)</p>
<aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>It just means that I’ll inevitably be of limited help with the design, insofar as my personal preferences diverge somewhat from yours.</p>
</blockquote>
</aside>
<p>I'm a fan of consensus... when people are willing to work toward it... and you've been helpful so far!</p>
<p>I feel that the examples I look at provide a lot of food for thought.  The <a href="https://github.com/hostilefork/rebol-whitespacers">Whitespace Dialect</a> alone provides years of deep questions to work on.  <a href="https://github.com/metaeducation/redbol/blob/main/redbol.reb">Emulating Rebol2</a> is a challenge. When I mix it all up with code that hasn't been written by me (e.g. <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a>'s Query and <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>'s Midcentral) it gives me a good gauge of what is still left to do before I can be happy.</p>
<p>It would be good if you had some small project to add to the continuous integration roundup--something that I'd take responsibility for having an answer to keeping working as the system evolves.  It would be code you were invested in, but not <em>too</em> invested in.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">  Small scale, so no sequencing of genomes.  This may help empathize with both what the joys of the medium are that I seek to distill and enhance, as well as the practicalities of what a slog this can be...</p>
<aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I just moved countries (for research) and have been rather busy of late.</p>
</blockquote>
</aside>
<p>A new country to give a Rebol talk in!  I've moved to the other side of the US (vertically) and have been busy as well...</p> ]]></description>
        <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179#post_4</link>
        <pubDate>Wed, 08 May 2024 20:12:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7289</guid>
      </item>
      <item>
        <title>RE: The Ordering and Priorities of the Ren-C Project</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>My apologies for taking so long to reply to this; I just moved countries (for research) and have been rather busy of late.</p>
<p>(Also, this is an important point, and I wanted to make sure I fully understood what’s been bothering me before writing anything.)</p>
<p>I think the key point here is this:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2179">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>While Carl and I may disagree about what exactly the artistic vision is, we do agree that it is an art... the medium is unique... and driven by a certain <em>je ne sais quoi</em> of what makes a good or bad decision.</p>
</blockquote>
</aside>
<p>To state the obvious, <em>je ne sais quoi</em> literally means ‘I don’t know what’. (You learn these things, living in France.) And I feel this is really the underlying fact which makes me so uneasy when discussing Rebol design: it’s not necessarily obvious what justification to give for specific design decisions, beyond vaguely saying that ‘I feel it makes code generally simpler’.</p>
<p>The languages I’m used to are not at all like this. Haskell and family, for instance, are strongly informed by the mathematics of type theory. The core language is rigorously worked out in these terms, and everything follows from that. If someone has a bad suggestion, it’s generally obvious as such, with strong arguments along the lines of ‘it would make the language unprincipled in such-and-such a well-defined way’. This sort of thing helps to keep everyone on the same page, and gives the language development an overall direction to aim for.</p>
<p>A fairer comparison to Rebol might be Lisps, which don’t care nearly so much for mathematical rigour. But on the other hand, Lisps tend to have a very strong tendency towards minimalism, which helps to direct language development in a similar way. You can argue for ages about what ideas to base your Lisp on, but it’s generally possible to ground those arguments in the goals of minimalism and expressivity. And, once you’ve written out the (often quite short) specification, everything else just follows from that.</p>
<p>Now, returning to Rebol: what drives its language design? As far as I can tell, the answer seems to be: ‘whatever hostilefork feels is suitable’. Not that it’s unique to Ren-C by any means: Red feels largely driven by ‘whatever Nenad likes’, and similarly for Carl and historic Rebol. And then we have <a href="https://github.com/Oldes/Rebol3">Oldes’s fork</a>, which is yet another set of personal preferences.</p>
<p>To be quite clear, I don’t consider this to be a <em>bad</em> thing by any means. Making a language optimised for onesself, personally, is a lovely thing to do. (Probably I’ll try it myself at some point.) And as an artistic vision, it’s perfectly respectable. It just means that I’ll inevitably be of limited help with the design, insofar as my personal preferences diverge somewhat from yours. But as long as it’s clear that that’s the case, I’m OK with it.</p>
<p>(It’s not <em>completely</em> subjective, of course. I do think that Ren-C is an objective step forward compared to other Rebols, when it comes to ‘big picture’ stuff like isotopes and definitional returns. It’s on the little quibbles, like ‘which datatypes do we want’, that personal preference comes into play more than it does with Haskell or Lisp.)</p> ]]></description>
        <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179#post_3</link>
        <pubDate>Fri, 03 May 2024 23:54:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7288</guid>
      </item>
      <item>
        <title>Making CALL Raise a (definitional) Error For Bad Exit Codes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2068">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It twists the CALL* function so that it always waits (vs. spawn a separate process and return a process ID to wait on).</p>
<p>Then it offers a /RELAX setting for getting the exit code back, if you don't want the definitional error behavior.</p>
</blockquote>
</aside>
<p>So I twisted the bootstrap executable to this notion of CALL waiting-by-default...and also treating a non-zero exit code as an error unless you said CALL/RELAX.</p>
<p>This made me wonder though: <strong>what should the result of CALL be if you don't say /RELAX</strong> ?</p>
<p>If it's still going to be a status, it will always be 0.  But this suggests you might have something to learn by testing the result.</p>
<p>A misguided person might write:</p>
<pre><code>if 1 = call ["something.exe" (filename)] [
   print "This could never happen since CALL would error on non-0 exit code"
]
</code></pre>
<p>This is where we might argue that using trash as the "useless success result" could be beneficial... <em><strong>if</strong></em> trash wasn't something you could use plain comparison on.  That was the case in Rebol2 with unsets:</p>
<pre><code>rebol2&gt;&gt; #[unset!] = #[unset!]
** Script Error: Operator is missing an argument
</code></pre>
<p>But Red and R3-Alpha allow it...</p>
<pre><code>r3-alpha&gt;&gt; #[unset] = #[unset]
== true

red&gt;&gt; #(unset) = #(unset)  ; yes, a third trivially different notation
== true
</code></pre>
<p>Ren-C has thus far followed suit, without backing away from the idea that you can compare trash to itself (or other values).</p>
<pre><code>ren-c&gt;&gt; ~ = ~
== ~true~  ; anti
</code></pre>
<p>But is this progress?</p>
<p><a href="https://forum.rebol.info/t/the-truthiness-of-trash/2180">I just posted a challenge to the value of considering trash to be neither truthy nor falsey</a>.  Note that conditional orneryness is somewhat pointless, as it provides a protection that wouldn't help the case you're supposedly distinguishing from: if CALL returned an integer unconditionally a blind conditional check would be a bug, since all integers (including zero) are truthy in the language.</p>
<p>If equality tests to trash were ornery that seems it <em>would</em> help something.  So I think it's worth asking what would be broken if you couldn't.</p>
<p>In any case...I didn't change plain CALL without /RELAX to return trash yet, but I might do so.  It has the benefit of omitting an "==" output as well due to the <a href="https://forum.rebol.info/t/console-treatment-of-void-vs-trash/2045">console suppression of trash</a>.</p>
<pre><code>&gt;&gt; call/shell "dir"
 Volume in drive C has no label.
 Volume Serial Number is 72AF-4302

 Directory of C:\Projects\ren-c\prebuilt

03/09/2024  08:32 AM    &lt;DIR&gt;          .
04/26/2024  03:36 PM    &lt;DIR&gt;          ..
11/07/2014  02:53 PM           563,560 r3-alpha
04/27/2019  04:01 PM         1,363,856 r3-linux-x64-8994d23
10/20/2023  01:23 PM         1,298,055 r3-windows-x86-8994d23.exe
10/20/2023  01:20 PM             1,656 README.md
10/22/2023  01:37 AM           864,256 rebol2.exe
03/09/2024  08:30 AM         1,607,680 red.exe
               6 File(s)      5,699,063 bytes
               2 Dir(s)  1,592,278,437,888 bytes free

&gt;&gt;
</code></pre>
<p>If 0 was left as the result, that would say "== 0" before the "&gt;&gt;"</p> ]]></description>
        <link>https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068#post_2</link>
        <pubDate>Fri, 03 May 2024 18:54:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7287</guid>
      </item>
      <item>
        <title>The Truthiness of Trash</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>After a couple months of being otherwise occupied, I now have some time to get back to things here...</p>
<p>Picking up around where I left off...I was deep into making a new bootstrap executable, as part of being able to implement the new <a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">FENCE! array type</a>.  This new executable was being aligned to "modern" conventions <em>(though often doing a weakened version of them)</em>.  Doing that triggered a lot of...thoughts.  Here's another.</p>
<hr>
<p><strong>Does it really add value to consider <strong><a href="https://forum.rebol.info/t/why-trash-is-the-name-for-unset-state/2078">the trash state</a></strong> (an antiform blank held by unset variables) to be neither truthy nor falsey?</strong></p>
<p>Here's a quick survey of how UNSET! (the most trash-like thing in historical Rebol) is handled:</p>
<h3>
<a name="rebol2-1" class="anchor" href="https://forum.rebol.info#rebol2-1"></a>Rebol2</h3>
<pre><code>rebol2&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
** Script Error: either is missing its condition argument

rebol2&gt;&gt; unset? all [get/any 'asdf]
== true

rebol2&gt;&gt; unset? any [get/any 'asdf]
== true

rebol2&gt;&gt; case [get/any 'asdf [print "truthy"]]
** Script Error: Block did not return a value
</code></pre>
<h3>
<a name="r3-alpha-2" class="anchor" href="https://forum.rebol.info#r3-alpha-2"></a>R3-Alpha</h3>
<pre><code>r3-alpha&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
** Script error: either does not allow unset! for its condition argument

r3-alpha&gt;&gt; unset? all [get/any 'asdf]
== true

r3-alpha&gt;&gt; unset? any [get/any 'asdf]
== false  ; ...huh?

r3-alpha&gt;&gt; any [get/any 'asdf 1020]   
== 1020

r3-alpha&gt;&gt; case [get/any 'asdf [print "truthy"]]
** Script error: block did not return a value
</code></pre>
<h3>
<a name="red-3" class="anchor" href="https://forum.rebol.info#red-3"></a>Red</h3>
<pre><code>red&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
*** Script Error: block did not return a value

red&gt;&gt; unset? all [get/any 'asdf]
== true

red&gt;&gt; unset? any [get/any 'asdf]
== true

red&gt;&gt; case [get/any 'asdf [print "truthy"]]
*** Script Error: block did not return a value
</code></pre>
<h2>
<a name="oldes-rebol3-4" class="anchor" href="https://forum.rebol.info#oldes-rebol3-4"></a>Oldes Rebol3</h2>
<p>Transparent in <a href="https://github.com/Oldes/Rebol3/commit/2ba01ead3b5da1ab609fa25a0c675b30e96bb163">ANY and ALL</a> (like a Ren-C void), but presumably still an error in plain IF or EITHER or CASE...</p>
<h2>
<a name="ren-cs-always-error-is-more-consistent-but-5" class="anchor" href="https://forum.rebol.info#ren-cs-always-error-is-more-consistent-but-5"></a>Ren-C's "Always Error" Is More <em>Consistent</em>, But...</h2>
<p>Clearly people have been pushing away from it being an error.</p>
<p>So does being "ornery" for conditional logic really help matters?  When we consider the dual role of trash as an "uninteresting, but successful" result, might we get as much (or more?) value from considering it to be always truthy?</p>
<p>For example: Ren-C uses trash as the result of PRINT when the print actually produces output.  Otherwise, you get NULL.</p>
<pre><code>&gt;&gt; message: "Hello"
== "Hello"

&gt;&gt; print message  ; won't have a console "==" due to being a trash result
Hello

&gt;&gt; trash? print message
Hello
== ~true~  ; anti

&gt;&gt; message: null
== ~null~  ; anti

&gt;&gt; print maybe message
== ~null~  ; anti

&gt;&gt; print []
== ~null~  ; anti
</code></pre>
<p>Trash has the property of suppressing console output, which is desirable in most print cases--at least those that do print output.  And if you said <code>(x: print "Hello")</code> you'd get a variable that would create an error on access, which seems also desirable.</p>
<p>If trash was truthy, that makes it easier to act on the trash-vs-null distinction in something like an ANY or ALL construct.</p>
<h2>
<a name="should-meaningless-but-truthy-unset-variable-state-6" class="anchor" href="https://forum.rebol.info#should-meaningless-but-truthy-unset-variable-state-6"></a>Should "Meaningless but Truthy" = "Unset Variable State"?</h2>
<p>A related question may be if functions like PRINT should be returning the same value as what is held by an unset variable.</p>
<p>Now that non-antiform BLANK! itself is truthy, might it be a better choice?</p>
<pre><code>&gt;&gt; print "Hello"
Hello
== _
</code></pre>
<p>But then...</p>
<ul>
<li>
<p>For the visual we seek, the console would need to not print BLANK!.  But I find it unsatisfying to have a non-antiform be what has "no representation".</p>
</li>
<li>
<p>If you assigned the result of this "meaningless" value to a variable, you wouldn't have that added protection that the variable would appear unset.</p>
</li>
</ul>
<h2>
<a name="truthy-trash-seems-to-have-more-pluses-than-minuses-7" class="anchor" href="https://forum.rebol.info#truthy-trash-seems-to-have-more-pluses-than-minuses-7"></a>Truthy Trash Seems To Have More Pluses than Minuses</h2>
<p>My "semantic safety" bias initially had made me think that when you have a function like PRINT, it's nice to catch potential mistakes when you tried to act like it was a function that could meaningfully be tested for some kind of logical result.  So I pushed R3-Alpha's error from IF and EITHER further into ANY and ALL.</p>
<p>Then I went and made it so that when the PRINT received an opted-out input, it gave back NULL instead of trash.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20">  So it was something you could act on with ELSE, but not other conditional constructs.</p>
<p>The evolution from UNSET! to the blank-antiform that is today's trash has been a long and winding one.  Working around its ornery-ness gave rise to all kinds of interesting designs like voids, and invisibles like ELIDE PRINT.</p>
<p>But though I'm sure that I haven't considered all the angles yet...having trash be neither-true-nor-false is looking more like a dying historical artifact than something with a clear motivation applicable to the present.</p>
<p>Trash being always truthy offers consistency...and it's possible to ELIDE it to get "no vote" so it won't affect an ANY or ALL (the way Oldes R3 treats unsets).  Yet having the vote isn't entirely useless either.  I can't think of a whole lot of downside, so I think it's worth trying.</p>
<hr>
<p>A better axis of orneryness that may actually catch more problems in practice is: <strong><a href="https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068/2">Should Trash be Illegal in Comparisons</a></strong></p>
<p>(I point out in that discussion that simply disabling the ability to check trash for truthiness/falseyness is kind of a strange counterpart to a routine that returns--say--an INTEGER! in all cases, where you get zero information from testing an integer conditionally but without anything to stop you...making the disablement of testing trash conditionally seem like a fairly empty gesture.)</p> ]]></description>
        <link>https://forum.rebol.info/t/the-truthiness-of-trash/2180#post_1</link>
        <pubDate>Fri, 03 May 2024 17:27:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7286</guid>
      </item>
      <item>
        <title>RE: The Ordering and Priorities of the Ren-C Project</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="bradrn" data-post="6" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/6">Speed of UPARSE</a>
</div>
<blockquote>
<p>Remember, I come from well outside the Rebol world.</p>
</blockquote>
</aside>
<p>Yes, though also remember... <img src="https://forum.rebol.info/images/emoji/twitter/warning.png?v=12" title=":warning:" class="emoji" alt=":warning:" loading="lazy" width="20" height="20">  I'm not advertising anything here...not fit for any purpose, or any use!</p>
<p>(I also didn't make this forum.  That was done by <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>, and I initially protested it as something that would fall in my lap as yet-another-maintenance-headache.  But I found Discourse could be a rather good notebook, with easy wiki-like reorganization features to mean the site wouldn't wind up stale and useless.  So I ended up embracing it.)</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="6" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/6">Speed of UPARSE</a>
</div>
<blockquote>
<p>The reason I don’t understand is, to a large extent, because this way of reasoning about code is one I’ve never seen before in my life.</p>
</blockquote>
</aside>
<p>I first met Carl Sassenrath at a party in Los Angeles.  Rebol was not open source at the time. I'm a pretty big believer in Stallman's <a href="https://www.gnu.org/philosophy/shouldbefree.en.html">"Why Software Should Be Free"</a></p>
<p><em>(I also believe FSF should flip the acronym as "Foundation for Software Freedom", and that generally "Freedom" should be used where "Free" creates many confusions with "Gratis".  But Stallman's idealism/autism makes him convinced that retaking the term "Free" to mean "Freedom" is so inherently logical that putting his thumb on the scale will change how everyone else hears the word.)</em></p>
<p>Carl had resisted open-sourcing Rebol.  Over whiskey at the party's open bar, I lobbied him on the inevitability of developer tools as open source, and that closed-source couldn't be profitable.  Much more profit would be opened up by being a steward of a successful open source project.</p>
<p>He said he didn't keep it closed-source to make money, rather that he <em>"didn't want anybody messing with his art."</em>  Rebol was his "grand experiment" and he had very specific opinions about what was or wasn't an improvement of it.</p>
<p>Eventually it was open sourced.  He came to face the fact he wasn't going to be able to deliver Rebol 3 himself, in the time he had, with the methods he'd been using.  He wanted to move on with other things (went to work for Roku, on embedded-C products, closer to his EE background).  So now it's in the hands of others.</p>
<p>While Carl and I may disagree about what exactly the artistic vision is, we do agree that it is an art... the medium is unique... and driven by a certain <em>je ne sais quoi</em> of what makes a good or bad decision.  A big part of what we both believe is that dependency control is critical, and that a useful implementation can be made and understood without requiring a very advanced toolchain (and that the substrate not be intrinsically obfuscating, <a href="https://arstechnica.com/security/2024/04/what-we-know-about-the-xz-utils-backdoor-that-almost-infected-the-world/">see recent xz hack</a> for how important this all is).</p>
<p>The time I can put into the project is not infinite...and I haven't had much time in March (and will likely not have a whole lot in April, either).  And I am a semi-retired person who is not paid to do this, so I heavily prioritize whether I'm having fun or not.  It can be a real slog at times, and if a novel mechanism doesn't pop up every now and then to renew my interest...I can lose motivation.</p>
<p>I'm grateful that this year started off with cracking some of the rationale for how binding has to work, so thank you for your contributions to that!  It gave a boost and a renewed faith that good-enough answers are possible.  I've been letting that settle a bit, and sometimes these things take time to shake out vs. being able to finish the design all at one time.  So I work on other things--sometimes just what interests me--while experience is gathered to realize where to point the big design questions.</p>
<p>But I don't expect anything to happen overnight.  This has been a long haul project which needs a marathon mentality, and so patience is mandatory.</p> ]]></description>
        <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179#post_2</link>
        <pubDate>Tue, 09 Apr 2024 13:19:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7285</guid>
      </item>
      <item>
        <title>RE: The Ordering and Priorities of the Ren-C Project</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/5">Speed of UPARSE</a>
</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/4">Speed of UPARSE</a>
</div>
<blockquote>
<p>I’ll be blunt: this, to me, sounds unusably slow. Beyond the very simplest tasks, I can’t imagine a situation where I’d deliberately choose to take a 250× performance drop.</p>
</blockquote>
</aside>
<p>This is a first-of-its-kind design. And if you don't understand why I'm building things the way I'm building them, then...to be blunt...there's not much point in me listening to your feedback regarding the order in which I do things.</p>
</blockquote>
</aside>
<p>Remember, I come from well outside the Rebol world. The reason I don’t understand is, to a large extent, because this way of reasoning about code is one I’ve never seen before in my life. This is the reason I’m asking so many questions, setting out my opinions, and having these discussions with you… precisely so that I can begin to understand why it is that way.</p> ]]></description>
        <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179#post_1</link>
        <pubDate>Sat, 06 Apr 2024 19:16:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7284</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="Brett" data-post="9" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/brett/40/177_2.png" class="avatar"> Brett:</div>
<blockquote>
<p><code>; Yen is in whole numbers.</code></p>
</blockquote>
</aside>
<p>You keep your money in Yen?  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<aside class="quote no-group" data-username="Brett" data-post="9" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/brett/40/177_2.png" class="avatar"> Brett:</div>
<blockquote>
<p>I guess UPARSE wouldn't have that problem if an <code>UNLESS</code> took some of the role of <code>NOT</code>.</p>
</blockquote>
</aside>
<p>I don't know that people would comprehend the difference between UNLESS vs. NOT.</p>
<p>If we're looking for uniform operators, it seems there are NOT-AHEAD and ONE-IF-NOT-AHEAD, where ONE-IF-NOT-AHEAD simply takes the next single item if the rule doesn't match:</p>
<pre><code>&gt;&gt; parse ["a"] [one-if-not-ahead [integer! integer!]]
== "a"
</code></pre>
<p>This ONE-IF-NOT-AHEAD operator is kind of clunky, though similar to how SET works in Rebol2/Red, to take the first item of a match (vs UPARSE's last synthesized product of "a block combinator").</p>
<pre><code>rebol2&gt;&gt; parse ["a" "b"] [set x [string! string!]]
== true

rebol2&gt;&gt; x
== "a"
</code></pre>
<p><strong>one-if-not-ahead rule</strong> is simply <strong>[not-ahead rule, one]</strong> (in the current <a href="https://forum.rebol.info/t/killing-off-historical-skip-in-parse/1557/15">ONE-is-historical-SKIP</a> model)</p>
<p>It would work with anything... but I'd personally rather have a NOT that wasn't compatible with everything, but covered common cases.  And if someone actually wanted ONE-IF-NOT-AHEAD they could write <strong>[not ahead rule, one]</strong> for themselves.</p>
<aside class="quote no-group" data-username="bradrn" data-post="8" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I’m still not sure I see why NOT should exist as its own combinator.</p>
</blockquote>
</aside>
<p>It wouldn't really be a combinator, but a "combinator modifier".</p>
<p>Let me reiterate it's simply about being able to pass a refinement to combinators, even if they are triggered by a datatype and hence nowhere to put the refinement.</p>
<p>e.g. you can write <strong><code>ahead/not</code></strong> but you can't write <strong><code>#a/not</code></strong></p>
<p>I think <strong><code>not *combinator*</code></strong> being able to do this modification is a cool idea.</p>
<p>Though of course allowing general "combinator modifiers" creates a lot of obfuscations, due to the backchannel.  If I'm trying to make a debugger, then these refinements slipping in have to be presented somehow... otherwise once you've stepped into the <strong>not</strong> and all you see is <strong><span class="hashtag">#a</span></strong> it will be confusing when <strong><span class="hashtag">#b</span></strong> looks to be a match of <strong><span class="hashtag">#a</span></strong>.</p>
<p>Maybe negation is the <em>only</em> combinator modifier, so the system can account for it.</p>
<h2>
<a name="conservative-choice-for-now-1" class="anchor" href="https://forum.rebol.info#conservative-choice-for-now-1"></a>Conservative Choice For Now</h2>
<p>A conservative thing to do may just be to rename NOT as NOT-AHEAD and work on higher priority tasks.</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_10</link>
        <pubDate>Wed, 03 Apr 2024 07:56:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7283</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@Brett]]></dc:creator>
        <description><![CDATA[ <p>In case it's of relevance or interest..</p>
<p>In Rebol 2 parse does not have a not, so <code>parsing-unless</code> is the function I use to implement the guard behaviour of <code>not ahead</code>.  I use it a lot, like in this code to parse the adhoc syntax of my bank account transactions:</p>
<pre><code>fxamt: [opt sp some digit opt [#"." some digit] sp cur-code] ; Yen is in whole numbers.
not-fxamt: parsing-unless [fxamt]
not-br: parsing-unless [{&lt;BR&gt;}]
nsp: complement charset { }

loc-word: [not-fxamt some [not-br nsp]]
</code></pre>
<p>So the <code>nsp</code> here is indeed a <code>some not space</code> in the positive sense. I use that a lot too but for my complex rules for me in Rebol 2 it will be some <code>[not-thing skip]</code></p>
<p>I do use the two senses a lot in practice:</p>
<ul>
<li>the negative/guard sense - I'm guarding the rest of the rule with the negated result of the match - the "unless".</li>
<li>the positive sense - I want the positive match of something that isn't the thing.</li>
</ul>
<p>The wrinkle I've had with guard rules is when I'm using some <a href="http://www.rebol.org/documentation.r?script=load-parse-tree.r">routine</a> that collects the input matched by rules that succeed - the guard rules succeed but I don't want their matching input (even if empty). For example, if I specified that I want to collect FXAMT then my routine will match when the <code>fxamt</code> inside <code>not-fxamt</code> succeeds.  My simple workaround is to create another rule with the same structure but different name.  I guess UPARSE wouldn't have that problem if an <code>UNLESS</code> took some of the role of <code>NOT</code>.</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_9</link>
        <pubDate>Sun, 31 Mar 2024 04:16:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7282</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Rules of program optimization:</p>
<ol>
<li>Don't do it.</li>
<li>(Experts Only) Don't do it... yet.</li>
</ol>
</blockquote>
</aside>
<p>And that’s how you end up with slow software!</p>
<p>To make myself entirely clear, this is certainly a position I can sympathise with. My main language is Haskell, which is difficult to optimise, so often I don’t bother. But Haskell still makes it <em>possible</em> to write fast programs, and eventually there comes a time when I do need to dig into the internals and speed up my code. It’s hard, but certainly worth the effort.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But to give you a sense of the tip of the iceberg: UPARSE uses raised ERROR! object antiforms on each unsuccessful match. This means that other values are "in-band" as potential synthesized combinator results (including packs). But it also means that for a combinator to fail, it has to make an object.</p>
</blockquote>
</aside>
<p>This is interesting… to me, this sounds more like an issue with the interpreter being too slow, rather than UPARSE itself. What makes objects so slow to construct?</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Perhaps it's time for you to get your hands dirty and read to understand what UPARSE is doing in terms of how it is implemented</p>
</blockquote>
</aside>
<p>I have been doing so, on and off, when I get the time. It’s difficult code to understand, and I can’t say I understand precisely how it works yet, but I do at least have some vague idea of what the major components are.</p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_6</link>
        <pubDate>Sat, 30 Mar 2024 14:56:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7281</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>UPARSE is such a key part of Ren-C that I think time spent optimising it would be time well spent.</p>
</blockquote>
</aside>
<p>UPARSE is a flagship dialect, where getting the design correct--including making sure all the necessary infrastructure for debug stepping and proper error delivery--is time well spent...</p>
<p>Rules of program optimization:</p>
<ol>
<li>Don't do it.</li>
<li>(Experts Only) Don't do it... yet.</li>
</ol>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I’m wondering, then… to what extent would it be possible to optimise it without nativising? It would be very interesting to see how far we could get with just Ren-C.</p>
</blockquote>
</aside>
<p>Optimizing before nativizing is certainly a good first pass.</p>
<p>But to give you a sense of the tip of the iceberg: UPARSE uses raised ERROR! object antiforms on each unsuccessful match.  This means that other values are "in-band" as potential synthesized combinator results (including packs).  But it also means that for a combinator to fail, it has to make an object.</p>
<p>It is possible for the objects to be created once and then reused, but that wouldn't permit parametrization.  An error can say "didn't match" or it can say "didn't match the character <span class="hashtag">#a</span>" with a parameter, and the latter is more informative.</p>
<p>Generating an error object isn't particularly cheap, even natively.  And if you look at the usermode RAISE function <em>(was FAIL, which is now built on top of RAISE, so comments a bit out of date there)</em>, you can see that the process for going from a text string to an error isn't trivial:</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/d8212c6d2de996f33f2142ebce40c328088f24bf/src/mezz/base-funcs.r#L777" class="inline-onebox">ren-c/src/mezz/base-funcs.r at d8212c6d2de996f33f2142ebce40c328088f24bf · metaeducation/ren-c · GitHub</a></p>
<p>Does this mean that the concept to use custom raised errors as a signal for parser mismatching is fundamentally flawed?  I don't think so.  As I say, this is a flagship for exploring the concepts of what's possible in the medium.  It's supposed to have the bells and the whistles and show what you can really accomplish if you stretch.</p>
<p>Making a crappier version of UPARSE that cheaps out on features and can't be stepwise debugged will be a trivial exercise for those who want to do it.  Red has every opportunity to go after the market of people who thirst for that school of thought.  I'm happy to let them.</p>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I’ll be blunt: this, to me, sounds unusably slow. Beyond the very simplest tasks, I can’t imagine a situation where I’d deliberately choose to take a 250× performance drop.</p>
</blockquote>
</aside>
<p>Perhaps it's time for you to get your hands dirty and read to understand what UPARSE is doing in terms of how it is implemented, to get a sense of the kinds of power I'm trying to put in the hands of people using a new kind of technology...and why I'm interested in this kind of prototyping ability regardless of its initial costs.</p>
<p>This is a first-of-its-kind design.  And if you don't understand why I'm building things the way I'm building them, then...to be blunt...there's not much point in me listening to your feedback regarding the order in which I do things.</p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_5</link>
        <pubDate>Sat, 30 Mar 2024 14:22:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7280</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I’m wondering, then… to what extent would it be possible to optimise it without nativising? It would be very interesting to see how far we could get with just Ren-C.</p>
<p>(Of course, it’s perfectly possible to get good performance by writing the important bits in a fast language — it’s what Python does. But I have a great dislike of Python, and this is one of the reasons why.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Several orders of magnitude slower. When I first tinkered with nativizing it, it was about 700x slower just on some arbitrary case:</p>
<p><a href="https://forum.rebol.info/t/progress-on-nativizing-parser-combinators/1636">Progress on Nativizing Parser Combinators</a></p>
<p>But, an hour of tinkering at the time got it to 250x slower.</p>
</blockquote>
</aside>
<p>I’ll be blunt: this, to me, sounds unusably slow. Beyond the very simplest tasks, I can’t imagine a situation where I’d deliberately choose to take a 250× performance drop. UPARSE is such a key part of Ren-C that I think time spent optimising it would be time well spent.</p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_4</link>
        <pubDate>Sat, 30 Mar 2024 01:31:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7279</guid>
      </item>
      <item>
        <title>Should SET-WORD!s Propagate Undecayed Packs?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Packs are antiform blocks, which decay if not specifically handled.</p>
<pre><code>&gt;&gt; pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a: pack [1 2]
== 1

&gt;&gt; a
== 1
</code></pre>
<p>From time to time, I've wondered if there's a good reason why the plain SET-WORD! shouldn't propagate the pack:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (hypothetical)

&gt;&gt; a
== 1
</code></pre>
<p>One rationale is that intuitively, <strong>a:</strong> should be a synonym for <strong>[a]:</strong>, e.g. "unpack one item" is implicit.</p>
<p>But that just bumps the question to the next one we might ask: why doesn't a multi-return without a "circled" result just evaluate to the whole pack?</p>
<p>It looks to make some sense at first, it allows you to chain indefinitely:</p>
<pre><code>&gt;&gt; [a b]: [c d]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1

&gt;&gt; d
== 2
</code></pre>
<p>Though it feels a little bit unsettling when you drop it down:</p>
<pre><code>&gt;&gt; [a b]: [c]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1
</code></pre>
<p>But we could argue that if you're bothered, then you use circling (currently <code>@c</code>, but with FENCE! proposed to be <code>{c}</code>).  Note in the below example you'd have to use <code>/b</code> in order to indicate you were okay with unpacking more values than available.</p>
<pre><code>&gt;&gt; [a /b]: [{c}]: pack [1 2]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== ~null~  ; anti

&gt;&gt; c
== 1
</code></pre>
<p>We could then make a choice if <strong>a:</strong> was a synonym for <strong>[a]:</strong> or for <strong>[{a}]:</strong></p>
<h2>
<a name="most-recent-motivation-for-thinking-about-this-1" class="anchor" href="https://forum.rebol.info#most-recent-motivation-for-thinking-about-this-1"></a>Most Recent Motivation For Thinking About This</h2>
<p>I rewrote <a href="https://forum.rebol.info/t/speed-of-uparse/2177/3">some code in an example</a> from this:</p>
<pre><code>[^result' remainder]: parser input except e -&gt; [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
return unmeta result'  ; return successful parser result
</code></pre>
<p>...to this:</p>
<pre><code>return [@ remainder]: parser input except [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
</code></pre>
<p>The idea is that the parser being called has multiple return results... the first is the synthesized value, the second is the amount it advanced.  <em>(There's a third result on some parsers of "pending items", but this OPTIONAL combinator has an "autopipe" which is just bubbling the pending items through in the order of successful parsers called...so the third result is specialized out on its interface and on the parsers it calls.)</em></p>
<p><strong>However, the synthesized value can itself be a pack.</strong>  This means that if we named a variable in the slot where the <code>@</code> is, then that pack would be decayed to store in the variable unless we used a ^META result.</p>
<p>So does the act of not-naming and just circling subvert the decay?  Or should the circled result not be decayed even if the variable is?</p>
<pre><code>&gt;&gt; [{a} b]: pack [pack [1 2] 3]
== ~['1 '2]~  ; anti  (or should it be decayed to 1?)

&gt;&gt; a
== 1

&gt;&gt; b
== 3
</code></pre>
<p>It's a different--but related--question.  It seems it should align with the behavior of plain assignments:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (implied if the above behavior is chosen)

&gt;&gt; a
== 1
</code></pre>
<h2>
<a name="not-100-certain-but-i-think-undecayed-propagation-is-good-2" class="anchor" href="https://forum.rebol.info#not-100-certain-but-i-think-undecayed-propagation-is-good-2"></a>Not 100% Certain, But I Think Undecayed Propagation Is Good</h2>
<p>I'll point out that it's possible to DECAY things pretty easily, but you can't recover a pack after it has been decayed.</p>
<p>So I'm getting the feeling that it's probably best to decay the assignments, but propagate the undecayed pack.  It looks like the more general and useful behavior...even if it seems a bit confusing.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178#post_1</link>
        <pubDate>Fri, 29 Mar 2024 21:22:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7278</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code class="lang-plaintext">'optional combinator [
    "If applying parser fails, succeed and return NULL; don't advance input"
    return: "PARSER's result if it succeeds, otherwise NULL"
        [any-value? pack?]
    parser [action?]
    &lt;local&gt; result'
][
    [^result' remainder]: parser input except e -&gt; [
        remainder: input  ; succeed on parser fail but don't advance input
        return null
    ]
    return unmeta result'  ; return successful parser result
]
</code></pre>
</blockquote>
</aside>
<p>Speaking of optimizations, this doesn't even need the <strong>result'</strong> temporary.  Nor does it care what the raised error is, so the branch doesn't need to be a lambda:</p>
<pre><code>return [@ remainder]: parser input except [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
</code></pre>
<p><em>(Truly being equivalent <a href="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178">requires the @ to not decay synthesized pack results</a>, which should possibly be the same behavior you get if you'd named a variable, I need to look into this.)</em></p>
<p>Instead of a preemptive RETURN inside a RETURN, you could write that instead so the branch gives back the result and remainder as a pack (antiform block):</p>
<pre><code>return [@ remainder]: parser input except [
    pack [null input]
]
</code></pre>
<p>But I happen to be certain that would be slower... you pay to reduce <strong>[null input]</strong>, and then you have to pay for SET-BLOCK! to unpack the multi-return.</p>
<p>Neat as all that is (and I think it <em>is</em> neat), worrying over such details isn't really where I want to focus right now.</p>
<hr>
<p><em>Note that usermode micro-optimization can get fairly crazy, e.g. you know that NULL needs to do a WORD! lookup to fetch the value of NULL... but the quasiform <code>~null~</code> has a rote evaluative rule of just setting the quote byte of the quasiform from 2 to 0 to be an antiform... so <strong><code>return ~null~</code></strong> is faster than <strong><code>return null</code></strong>.  Many historical Rebol programmers were obsessed with this kind of detail...</em></p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_3</link>
        <pubDate>Fri, 29 Mar 2024 14:38:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7277</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Several orders of magnitude slower.  When I first tinkered with nativizing it, it was about 700x slower just on some arbitrary case:</p>
<p><a href="https://forum.rebol.info/t/progress-on-nativizing-parser-combinators/1636" class="inline-onebox">Progress on Nativizing Parser Combinators</a></p>
<p>But, an hour of tinkering at the time got it to 250x slower.</p>
<p>However, predictably that tinkering was quickly out of date, so that early nativization is inactive.  Things aren't set up to maintain nativized code in parallel to the usermode code, and it would be too much work to be justified until fully stable.</p>
<p>The baseline will be even slower today... because binding is slower, and because there's more hooking in it which was added for the <a href="https://forum.rebol.info/t/replpad-visual-parse-debugger/2063">debugging demo</a>.</p>
<p>If you watch the debugging video, it explains that the debugger works because each call to a combinated parser can be hooked... such that the hook is responsible for invoking the frame.  It can inspect the frame beforehand, and examine the multi-return result after it does the invocation.  (Or it can skip the invocation entirely, or duplicate the frame and invoke it twice, or mutate the frame before it runs it, etc.)  Each combinator just directly calls its subparser, but the subparser has been ENCLOSE'd with a wrapper:</p>
<pre><code> wrapper: func [
    "Enclosing function for hooking all combinators"
    return: [pack?]
    f [frame!]
][
    return either f.state.hook [
        run f.state.hook f
    ][
        run f
    ]
]
</code></pre>
<p>So that's overhead on each call to a parser that any other parser makes.  Of course the pattern of <strong><code>enclose :combinator :wrapper</code></strong> itself could be partially nativized in a semi-generic way, as something like:</p>
<pre><code>hookify :combinator 'f [f.state.hook]
</code></pre>
<p>But these things are patterns which should inform how to design the system in a more general sense.  I am trying to get some kind of story together for how dialects are debugged... as I've said, it's sort of like you make a choice if you want to take "assembly level stepping" (e.g. debug the Rebol instructions) or if you want to debug at the higher level of the dialect.  So I expect this hook to be a sunk cost of some kind.</p>
<p>Right now I'm doing other things, though <em>(as well as non-Rebol-related life stuff, which is going to mean Rebol development will get a bit more sporadic than it was in the first couple of months of the year.)</em></p>
<h2>
<a name="nativizing-plan-1" class="anchor" href="https://forum.rebol.info#nativizing-plan-1"></a>Nativizing Plan</h2>
<p>Ultimately, what I plan to do is make it so that all the combinators are in their own C files, where the usermode form is in a comment, something like:</p>
<pre><code>//
// File: %src/core/parse/optional-combinator.c
//

/* &lt;BEGIN USERMODE COMBINATOR&gt;

'optional combinator [
    "If applying parser fails, succeed and return NULL; don't advance input"
    return: "PARSER's result if it succeeds, otherwise NULL"
        [any-value? pack?]
    parser [action?]
    &lt;local&gt; result'
][
    [^result' remainder]: parser input except e -&gt; [
        remainder: input  ; succeed on parser fail but don't advance input
        return null
    ]
    return unmeta result'  ; return successful parser result
]

&lt;/END USERMODE COMBINATOR&gt; */

//
//  optional-combinator: native/combinator [
//
//  "If applying parser fails, succeed and return NULL; don't advance input"
//
//      return: "PARSER's result if it succeeds, otherwise NULL"
//          [any-value? pack?]
//      parser [action?]
//  ]
//
DECLARE_NATIVE(optional_combinator)
{
    INCLUDE_PARAMS_OF_OPTIONAL_COMBINATOR;

    Value* remainder = ARG(remainder);  // output (combinator implicit)

    Value* input = ARG(input);  // combinator implicit
    Value* parser = ARG(parser);
    UNUSED(ARG(state));  // combinator implicit

    enum {
        ST_OPT_COMBINATOR_INITIAL_ENTRY = STATE_0,
        ST_OPT_COMBINATOR_RUNNING_PARSER
    };

    switch (STATE) {
      case ST_OPT_COMBINATOR_INITIAL_ENTRY :
        goto initial_entry;

      case ST_OPT_COMBINATOR_RUNNING_PARSER :
        goto parser_result_in_out;

      default : assert(false);
    }

  initial_entry: {  //////////////////////////////////////////////////////////

    Push_Parser_Sublevel(OUT, remainder, parser, input);

    STATE = ST_OPT_COMBINATOR_RUNNING_PARSER;
    return CATCH_CONTINUE_SUBLEVEL(SUBLEVEL);

} parser_result_in_out: {  ///////////////////////////////////////////////////

    if (not Is_Raised(OUT))  // parser succeeded...
        return OUT;  // so return its result

    Set_Var_May_Fail(remainder, SPECIFIED, input);  // convey no progress made
    return Init_Nulled(OUT);  // null result
}}
</code></pre>
<p>This way the two can be maintained in parallel, and a debug mode could switch between them to make sure they produce identical results in the tests.</p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_2</link>
        <pubDate>Fri, 29 Mar 2024 14:34:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7276</guid>
      </item>
      <item>
        <title>Speed of UPARSE</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I’m just wondering if any benchmarking has been done on UPARSE. How does it compare to PARSE in Red or in Rebol? Or to parser combinators in Haskell? For that matter, how does it compare to an ordinary recursive-descent parser handwritten in Ren-C?</p>
<p>(Yes, I know UPARSE is unoptimised and slow. But it would be interesting to know <em>how</em> slow.)</p> ]]></description>
        <link>https://forum.rebol.info/t/speed-of-uparse/2177#post_1</link>
        <pubDate>Fri, 29 Mar 2024 06:47:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7275</guid>
      </item>
      <item>
        <title>VOID Branches (not branches that evaluate to void)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I've mentioned before that <a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">AUGMENT can be used to implement the legacy SWITCH/DEFAULT behavior</a>.</p>
<p>But looking at what seems like the "correct" formulation of that code today, we get:</p>
<pre><code>switch-d: enclose (augment :switch [
    /default "Default case if no others are found"
        [block!]
]) lambda [f [frame!]] [
    let def: f.default
    eval f else (maybe def)
]
</code></pre>
<p>It points out the existence of <em>void branches</em>... so not branches that evaluate to void (e.g. <code>[void]</code>) but code that evaluates to a branch to run, and that branch is void.</p>
<p>Considering this specific usage only, it suggests a semantic for ELSE of a VOID branch, which is that you want it to act like there was no branch at all.  e.g. as if you'd written just <strong><code>eval f</code></strong> with no ELSE.</p>
<pre><code> &gt;&gt; if false [1 + 2]
 == ~void~  ; anti

 &gt;&gt; if false [1 + 2] else [10 + 20]
 == 30

 &gt;&gt; if false [1 + 2] else (void)
 == ~void~  ; anti
</code></pre>
<p>Would the same apply to THEN?</p>
<pre><code> &gt;&gt; if true [1 + 2]
 == 3

 &gt;&gt; if true [1 + 2] then [10 + 20]
 == 30

 &gt;&gt; if true [1 + 2] then (void)
 == 3
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>I don't know if it's great, but it's certainly better than evaluating to NULL (via some void-in-null-out rationale) because that would trigger an ELSE branch.</p>
<pre><code> &gt;&gt; if true [1 + 2] then (void) else [print "we don't want this."]
 we don't want this.
</code></pre>
<p>But what should other branching constructs do, like CASE or SWITCH?  Might a void branch suggest "opting out" of that particular branch?</p>
<pre><code> case [
     1 &lt; 2 (void)
     3 &lt; 4 [print "Should this run?"]
 ]
</code></pre>
<p>A CASE (at least CASE/ALL) is supposed to be synonymous with a series of IF statements.  And IF can't exactly do that, unless it decided to be NIHIL...</p>
<pre><code>&gt;&gt; 1 + 2 if false (void)
== 3
</code></pre>
<p>That would be a bit weird, but, it does sort of parallel what happens when ELSE and THEN effectively vaporize themselves.</p>
<p>As with most things on the edge of usefulness, I don't know about this... other than the situation of wanting to revoke the ELSE branch in SWITCH-D.  I'll keep an eye on it.</p> ]]></description>
        <link>https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176#post_1</link>
        <pubDate>Thu, 28 Mar 2024 13:07:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7274</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I’m still not sure I see why NOT should exist as its own combinator. The disadvantages seem to outweigh the disadvantages: it adds a lot of complexity, and as you note there’s some cases where it doesn’t even seem to make sense.</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_8</link>
        <pubDate>Tue, 26 Mar 2024 02:32:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7273</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So my main concern is just the mechanics:</p>
</blockquote>
</aside>
<p>One observation is that it probably breaks the ability to take any isolated rule and put it in a BLOCK!, since the block combinator isn't generically negatable.</p>
<p>So <strong><code>not [integer!]</code></strong> wouldn't work, when <strong><code>not integer!</code></strong> would.</p>
<p>I don't know that trying to special case it works.  e.g. hacking it up to do <strong><code>not [integer! | word!]</code></strong>.  That case may seem to work, but what if you mixed concepts of negation... like <strong><code>not [integer! | ahead word!]</code></strong> ?</p>
<p>It's sort of like I said: that NOT becomes a way to slipstream a refinement into a single combinator for its meaning of negation.  You can't do that with a composite rule.</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_7</link>
        <pubDate>Tue, 26 Mar 2024 02:13:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7272</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="5" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>But then there’s the other problem I mentioned: what if you <em>do</em> want to invert the parser’s failure state?</p>
</blockquote>
</aside>
<p>I think that's covered well enough by NOT AHEAD.</p>
<p>AHEAD is a nice generic combinator for <em>"take your combinated parser argument, apply it, but don't advance the input (or apply any 'pending' effects).  just stop the match if it didn't succeed, or continue if it did."</em></p>
<p>So having NOT AHEAD be the implementation of NOT-FOLLOWED-BY feels good.</p>
<aside class="quote no-group" data-username="bradrn" data-post="5" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I see no particular reason to merge all these things under a single NOT combinator.</p>
</blockquote>
</aside>
<p>I like the brevity, and it feels "English-like" to me to be context-sensitive.</p>
<pre><code>&gt;&gt; parse ["a"] [not ahead integer!, text!]
== "a"

&gt;&gt; parse ["a"] [not integer!]
== "a"

&gt;&gt; parse ["a"] [not some integer!]
** Error: SOME combinator cannot be negated with NOT
</code></pre>
<p>So my main concern is just the mechanics: does it break something interesting.  (And as usual I'm suggesting it before actually trying it, which means I do not know if I will hit a contradiction while implementing it.)</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_6</link>
        <pubDate>Sun, 24 Mar 2024 05:50:46 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7271</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>A little touchy-feely perhaps that each parser can decide if there's a meaning to its negation (or if negation has no meaning at all) as opposed to something that has to be black-box decided from the parameterized parser's result. But it seems learnable to me.</p>
</blockquote>
</aside>
<p>But then there’s the other problem I mentioned: what if you <em>do</em> want to invert the parser’s failure state? For instance, in <a href="https://github.com/bradrn/brassica/blob/b627a345043760a3b403bdbacf0c56c47f7ca992/src/Brassica/SoundChange/Parse.hs#L218">this parser</a> I used <code>notFollowedBy (symbol "//")</code> to match only the case with a single slash. But if <code>not "/"</code> instead matches anything except for <code>"/"</code>, then that leaves me no easy way to get that logic.</p>
<p>I think the cleanest design here would be to recognise that there’s two very different cases here, and therefore treat them differently:</p>
<ul>
<li>The ‘fail on success’ logic can apply to any other combinator, so give it its own dedicated name, like NOT-FOLLOWED-BY or something. (That name’s verbose, but this combinator is uncommon, so it wouldn’t matter a huge amount.)</li>
<li>Other meanings of ‘negation’ are essentially parser-specific, so treat them as refinements for the individual parsers, like AHEAD/NOT. Characters can’t be refined, so we could make a new combinator for them (call it something like EXCEPT-FOR). I see no particular reason to merge all these things under a single NOT combinator.</li>
</ul> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_5</link>
        <pubDate>Sun, 24 Mar 2024 05:46:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7270</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>But especially the last quoted paragraph seems to be conflating them. It sounds like you want NOT to sometimes invert the failure state, and sometimes change the characters that are matched. That strikes me as possibly being quite difficult to reason about.</p>
</blockquote>
</aside>
<p>You're more or less giving some parsers a refinement.  So AHEAD has AHEAD/NOT.  But it's letting people write that out as <strong>not ahead</strong>.  And when combinators are triggered by datatype, you can get the feature of slipstreaming that refinement to the combinator when there's nowhere to put the /NOT.</p>
<p>A little touchy-feely perhaps that each parser can decide if there's a meaning to its negation (or if negation has no meaning at all) as opposed to something that has to be black-box decided from the parameterized parser's result.  But it seems learnable to me.</p>
<p>The question of if this little backdoor communication breaks some other more interesting composability feature in UPARSE is the main one to answer.  <em>(It isn't the only such suggestion... I've wondered about a similar backchannel to suppress an error from the "null combinator", which a MAYBE combinator could uniquely suppress an error from.)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_4</link>
        <pubDate>Sun, 24 Mar 2024 04:08:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7269</guid>
      </item>
      <item>
        <title>Double Negation in PARSE is NOT NOT NOT Cool</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="1536">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I was reading some code using NOT that was like <strong>some [not space, one]</strong>.</p>
<p>Hence effectively this is <strong>some [not ahead space, one]</strong> e.g. some number of times look ahead to see a thing isn't a space, then consume one item (whatever the not space thing was).</p>
<p>This made me a bit disgruntled that I couldn't write <strong>some not space</strong>, which on the surface seems like a coherent thought... vs. something that acts like an <strong>some not ahead space</strong> e.g. an infinite loop.</p>
<p>[…]</p>
<p>e.g. AHEAD could be a negatable combinator, producing a negatable parser. And maybe a single character, single byte, or single value combinator would be willing to be negated--with the negated rule being any single value that's not that. We could also negate character sets in the same way.</p>
</blockquote>
</aside>
<p>I feel there’s some confusion between two completely different notions of negation here:</p>
<ul>
<li>Complement of a character set: that is, ‘match any character which is not in this set’</li>
<li>Inversion of parser success: that is, ‘make a parser which fails when another succeeds’</li>
</ul>
<p>In Haskell, the latter is (as you note) <a href="https://hackage.haskell.org/package/megaparsec-9.6.1/docs/Text-Megaparsec.html#v:notFollowedBy"><code>notFollowedBy</code></a>, and the former needs to be created ad-hoc using combinators like <a href="https://hackage.haskell.org/package/megaparsec-9.6.1/docs/Text-Megaparsec.html#v:satisfy"><code>satisfy</code></a>. Ren-C could do a bit better than Haskell there, since it reifies character sets as values.</p>
<p>But especially the last quoted paragraph seems to be conflating them. It sounds like you want NOT to sometimes invert the failure state, and sometimes change the characters that are matched. That strikes me as possibly being quite difficult to reason about. Not only that, it would create difficulties in cases where both are plausible — e.g. if <code>not space</code> matches everything except spaces, then how do I create a parser which fails if a space is present?</p> ]]></description>
        <link>https://forum.rebol.info/t/double-negation-in-parse-is-not-not-not-cool/1536#post_3</link>
        <pubDate>Sun, 24 Mar 2024 03:52:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7268</guid>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>Case Insensitivity vs. Case-Preservation (can&#39;t have both?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="rgchris" data-post="10" data-topic="1439">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>As a side note, was just futzing with some JS code that capitalized its camel-cased class names and did not for it's derivatives.</p>
<pre><code>class GreenThing {...}
greenThing = new GreenThing(...)
</code></pre>
<p>Whatever funkiness currently exists with associating binding with cased represention, it is not as bad as this.</p>
</blockquote>
</aside>
<p>After looking at a lot of codebases that named their types in UpperCamelCase, I've decided that I rather like it.  It's done in Rust:</p>
<p><a href="https://rust-lang.github.io/api-guidelines/naming.html" class="inline-onebox">Naming - Rust API Guidelines</a></p>
<p>R3-Alpha's sources used all-caps and incorporated "REB" into the names, perhaps as part of an attempt to avoid collisions if working with libraries:</p>
<pre><code>REBBLK *blk;  // a "block" (actually an array, as the series could be used by groups)
REBVAL *val;  // values
</code></pre>
<p>Ren-C has been reorganized and doesn't mix these internal names with external codebases due to how well the libRebol API works for writing extension code.  I also put moved the asterisk to indicate the pointer as part of the type (more a C++ convention).  So the internals look along the lines of:</p>
<pre><code>Array* new_array;
Value* v;
KeyList* keylist;
StackValue(*) stack_value;
</code></pre>
<p>Whether Rebol code would be better if it went this way, I dunno.</p>
<pre><code>foo: function [arg [Block Integer]] [...]
bar: make Object [x: 10 y: 20]

foo: function [arg [block! integer!]] [...]
bar: make object! [x: 10 y: 20]
</code></pre>
<p>Just wanted to mention that the internals have moved to UpperCamelCase for types in the C code, and it's a pretty radical improvement for readability.</p> ]]></description>
        <link>https://forum.rebol.info/t/case-insensitivity-vs-case-preservation-cant-have-both/1439?page=2#post_21</link>
        <pubDate>Sat, 09 Dec 2023 19:22:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6752</guid>
      </item>
      <item>
        <title>Web Build Performance Stats</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Circa January 2021, I did a capture of some statistics about the web build.  It looked like this right after booting the console:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1468">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>ren-c/web&gt;&gt; stats/profile
== make object! [
    evals: 65422
    series-made: 28569
    series-freed: 11160
    series-expanded: 419
    series-bytes: 1731611
    series-recycled: 8669
    made-blocks: 16447
    made-objects: 109
    recycles: 1
]
</code></pre>
</blockquote>
</aside>
<p>I thought I might run it again here 3 years later.  And I was a bit shocked initially, because <em>at first glance it seems like things have gotten completely out of hand</em>:</p>
<pre><code>&gt;&gt; stats/profile
== make object! [
    evals: 3277865
    series-made: 928871
    series-freed: 646233
    series-expanded: 6312
    series-bytes: 6159217
    series-recycled: 196735
    blocks-made: 86893
    objects-made: 220
    recycles: 13
]
</code></pre>
<p>That's a factor of 50 more "evals"... with a factor of 32 more series... just to boot the web console, what the heck happened?</p>
<h2>
<a name="series-count-is-misleading-1" class="anchor" href="https://forum.rebol.info#series-count-is-misleading-1"></a>Series Count Is Misleading</h2>
<p>The first thing to notice is that the console doesn't take 50x as long to load as it used to.  That should be a hint that something about the statistics may have gotten thrown off.</p>
<p>One thing that's grossly overinflating the "series" count is that <a href="https://forum.rebol.info/t/the-sea-of-words/1564">Sea of Words</a> invented a new mechanism for binding in modules.  This method makes tiny series "stubs" that get linked onto canon symbols to hold indices during a binding operation.  They're very cheap to make and to destroy and aren't involved in GC.  They account for at least 1/3 of those "series" being made.</p>
<p>These statistics need to be adjusted somehow to break those out differently.</p>
<h2>
<a name="eval-count-is-misleading-2" class="anchor" href="https://forum.rebol.info#eval-count-is-misleading-2"></a>Eval Count Is Misleading</h2>
<p>Due to stackless processing, what counts as an "eval tick" has multiplied by a lot.  It used to be that something like a REDUCE operation would count as one tick, and then each eval step it did would be a tick.  Now each time the REDUCE yields to the evaluator to ask for another evaluation, that's a tick...then the evaluator ticks.</p>
<p><em>(While these added steps may sound like a burden, it actually accelerates the web build.  Because it means we're building an unwindable stack that can yield to the browser's event loop, without relying on a crutch like binaryen that would bloat up the entire runtime with "stackless emulation"...that would fail anyway on deep stacks.  For a reminder of why this is necessary: <a href="https://forum.rebol.info/t/switching-to-stackless-why-this-why-now/1247">"Switching to Stackless: Why This, Why Now?"</a>)</em></p>
<p>Also, parsing got subsumed into the tick count.  Even PARSE3 breaks its operations down into ticks now.  So if you say <strong>parse3 "aaaabbbb" [some ["a" | b"]]</strong> that's not one tick, it's at least 8 * 3 or 24.</p>
<h2>
<a name="the-real-villain-uparse-3" class="anchor" href="https://forum.rebol.info#the-real-villain-uparse-3"></a>The Real "Villain": UPARSE</h2>
<p>Once you've cut out some basic accounting anomalies, there's still certainly a lot of work to do.  But reading between the lines, there's a clear central source of resource usage going through the roof...which is quite simply, UPARSE.</p>
<p>Not that the web console uses it all that terribly much.  But using it pretty much <em>at all</em> will explode the amount of interpreter code that runs, quickly eclipsing everything else.</p>
<p>I don't think the best way to frame it is negative.  <strong>The way I see this is as a big, real, challenge for the system.</strong>  UPARSE is the most real, most powerful, <a href="https://github.com/metaeducation/ren-c/tree/master/tests/parse">and most tested</a> dialect implementation that the Redbol world has ever seen.</p>
<h2>
<a name="so-what-can-be-done-4" class="anchor" href="https://forum.rebol.info#so-what-can-be-done-4"></a>So... What Can Be Done?</h2>
<p>Counting up all the ways in which UPARSE pays the price for its current all-usermode implementation is to big for this post.  But it's important to realize that the costly mechanisms it uses all have motivations.  Meeting those needs with more efficient tools means other dialects can use those tools too.</p>
<p>To name an example off the top of my head, would be how every combinator function is pre-hooked with code enclosing each call with a test for <em>"are we hooked, if so call the hook with the frame, otherwise just call the frame."</em>  That's screaming for some kind of generalized answer where you don't have to hook in advance, but be able to inject the hooks later on some category of functions.  But using the massively inefficient approach is how we can test the viability of something like the <a href="https://forum.rebol.info/t/replpad-visual-parse-debugger/2063">Stepwise PARSE Debugger</a>.</p>
<p>But at the end of the day, it does come down to the fact that parsing is just too general-purpose and useful to be done with usermode code.  It would be nice if we had a language like Red/System to write the combinators in...which could be compiled to WebAssembly in the browser and x86 or ARM on the desktop.  Yet the option on the table right now is hand-coding C for the combinators and the combinating processes.</p>
<h2>
<a name="prioritization-is-difficult-5" class="anchor" href="https://forum.rebol.info#prioritization-is-difficult-5"></a>Prioritization Is Difficult</h2>
<p>While UPARSE clearly needs to be reviewed and nativized, I'm still not sure if this is the next item of business in the priority queue.  Binding casts a dark shadow over the entire system--and has its own performance quandaries.  Not to mention that it hasn't been figured out how variables can be instantiated in mid-parse with something like a "LET combinator".</p>
<p>Any investments in making UPARSE faster that also make it harder to modify and test under new designs has to be considered carefully.  Also, being written in usermode exposes pitfalls that you wouldn't see otherwise--<a href="https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066">like the need for definitional CONTINUE</a> that was exposed.</p>
<p>Anyway... data is data, and wanted to look at it.  This is where things are at the moment.</p> ]]></description>
        <link>https://forum.rebol.info/t/web-build-performance-stats/1468#post_3</link>
        <pubDate>Fri, 08 Dec 2023 19:04:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6751</guid>
      </item>
      <item>
        <title>8 Queens Problem</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2071">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm not sure why you would have ever done this:</p>
</blockquote>
</aside>
<p>Coming from R2 and Red and just testing for the refinement, there had been some changes with how they were handled, and just coming up with a way that worked for my case. It is a single check so performance-wise it is not important. I just got this working as is, which was the important part.</p>
<p>And about the slowness, sure it is compared to compiled and yes even those will face increasingly hard times for larger tasks. The nice thing though is that Rebol / Ren-C allows for this kind of solution by their flexing-skills and to my personal taste I think this solution is much more intuitive than the regular algorithms used to program this in other languages.</p> ]]></description>
        <link>https://forum.rebol.info/t/8-queens-problem/2071#post_3</link>
        <pubDate>Fri, 08 Dec 2023 09:08:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6749</guid>
      </item>
      <item>
        <title>Simple Sudoku Solver</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><a href="https://github.com/metaeducation/ren-c/blob/master/tests/examples/sudoku-solver.test.reb">I've also adapted this example to make it a test.</a></p>
<p>It needed to update the PATH!s to TUPLE!s, because Ren-C uses tuples to pick fields out of objects.</p>
<pre><code> append output grid/:i
</code></pre>
<p>I deprecated this syntax, because I didn't believe that GET-WORD!s belonged in PATH! or TUPLE! slots.</p>
<p>So you'd instead write:</p>
<pre><code> append output grid.(i)
</code></pre>
<p>The rationale behind not having GET-WORD!s in tuple slots (besides that I think it looks ugly) is that if you could put a GET-WORD! in the first slot, you wouldn't know what this is:</p>
<pre><code>:grid.1
</code></pre>
<p>Is that a GET-PATH! with a WORD! in the first slot?  Or is it a plain PATH! with a GET-WORD! in the first slot?  Similar arguments for why you don't want SET-WORD!s apply for the tail.</p>
<p>Overall I feel this prohibition has held up as a good rule.</p> ]]></description>
        <link>https://forum.rebol.info/t/simple-sudoku-solver/2070#post_2</link>
        <pubDate>Fri, 08 Dec 2023 09:06:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6748</guid>
      </item>
      <item>
        <title>8 Queens Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I didn't notice this when it was originally posted.  <a href="https://github.com/metaeducation/ren-c/blob/master/tests/examples/n-queens.test.reb">I've reformulated it so that it can serve as a test.</a>  So thanks for the contribution.  <img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=12" title=":+1:" class="emoji" alt=":+1:" loading="lazy" width="20" height="20"></p>
<hr>
<p>I'm not sure why you would have ever done this:</p>
<pre><code>either "/countonly" = mold countonly [
    set-countonly-true
][
    set-countonly-false
]
</code></pre>
<p>Testing for refinements being true or false has always been doable with just <strong>either countonly</strong>.  And setting a logic variable to 1 or 0 undermines the existence of a logic type...?</p>
<hr>
<p>I changed the function to do a multi-return, where a list of the board configurations that match is the second value (if you don't say /countonly).</p>
<pre><code>[num boards]: solve-n-queens 4
all [
    num = 2
    boards = apply :reduce [/predicate :trim, [
        {. Q . .
         . . . Q
         Q . . .
         . . Q .}

        {. . Q .
         Q . . .
         . . . Q
         . Q . .}
    ]]
]
</code></pre>
<p>It's a bit unfortunate that we no longer have the ability to have a function like SOLVE-N-QUEENS "sense" whether the second parameter is being requested, and use that to decide whether to count-only or not.  But that feature broke multi-return function composition, and the cases that want to be conditional like this are somewhat rare.  But when they show up, I do feel a bit of a loss.</p>
<hr>
<blockquote>
<p>If we want to know how slow REN-C is on my machine</p>
</blockquote>
<p>Regarding performance...unfortunately, current Ren-C is even slower than older Ren-C.  But this is a by-product of pursuing big design questions and trying to hammer out the essential character of the language.</p>
<p>I'm sure it can be improved significantly with an investment of effort.  But no matter how much better it gets, there are going to be limits with the medium.  Interpreted code doing calculation is never going to rival native or JIT-compiled code.  So the answer for people who reach those limits--but want to stay somewhat within the medium--would be to use something along the lines of a Red/System that can be compiled but still pick apart blocks and dialects.</p>
<p>But still, any brute force algorithm will hit limits regardless of language.  If Ren-C clogs up with an approach at 14 you'll probably find a faster language taking the same approach would do poorly at 28, any N^2 algorithm will eventually cripple your machine.</p> ]]></description>
        <link>https://forum.rebol.info/t/8-queens-problem/2071#post_2</link>
        <pubDate>Fri, 08 Dec 2023 08:58:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6747</guid>
      </item>
      <item>
        <title>Displaying Prime Factors</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Four years later, I've <a href="https://github.com/metaeducation/ren-c/blob/master/tests/examples/prime-factors.test.reb">added this to the tests</a>.</p>
<p>Small changes needed:</p>
<pre><code>if 1. * m * m &gt; n [
    append a n 
    n: 1
]
</code></pre>
<p>A new thing is that <strong><code>1.</code></strong> is a tuple now.  If you want the decimal number, you have to write <strong><code>1.0</code></strong></p>
<pre><code>&gt;&gt; length of 1.
== 2

&gt;&gt; first 1.
== 1

&gt;&gt; second 1.
== _

&gt;&gt; to block! 1.
== [1 _]
</code></pre>
<p>The rationale behind this is that the dialecting part is more useful.  If you want to write something like:</p>
<pre><code> my-dialect: [
     1. {First things first}
     2. {Second things second}
 ]
</code></pre>
<p>Then having them be TUPLE! preserves the notation.  If they were LOAD-ed as decimal numbers then they would be canonized as 1.0 and 2.0 in subsequent molds, and you'd lose the distinction between 1. and 1.0</p>
<p>(By the same token, <strong>.1</strong> and <strong>.2</strong> are also TUPLE!, and if you want the decimals you should write 0.1 and 0.2)</p>
<p>Also the locals-gathering FUNCTION is deprecated.  There are simply too many dialect purposes for SET-WORD! that should not make locals.  So explicit <code>&lt;local&gt;</code> definitions or LETs are needed:</p>
<pre><code>prime-factors: func [n [integer!]][
    let m: 2 
    let s: 1 
    let a: copy[]
    ...
</code></pre>
<p>Eventually, FUNC is scheduled to be a synonym for FUNCTION.</p> ]]></description>
        <link>https://forum.rebol.info/t/displaying-prime-factors/2072#post_2</link>
        <pubDate>Fri, 08 Dec 2023 08:20:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6746</guid>
      </item>
      <item>
        <title>Making CALL Raise a (definitional) Error For Bad Exit Codes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Before definitional errors existed, I noticed that <a href="https://forum.rebol.info/t/the-need-to-rethink-error/1371/2">@gchiu had some uses of CALL</a> that weren't checking the return code.</p>
<pre><code>call [
    gs -sDEVICE=pngmono -o (join root "-%02d.png") -r600 (pdfname)
]

call [
    gs -sDEVICE=eps2write -sPAPERSIZE=a4
        -o (join root "-%02d.eps") (pdfname)
]
</code></pre>
<p>I wanted the default to raise an error if the <strong>gs</strong> (GhostScript) process did not return a 0 exit code.  But I wanted that error to be a result of CALL... so it would be distinct from other errors (like a typo in the code in the groups inside, <code>pfdname</code> instead of <code>pdfname</code> or whatever).</p>
<p><code>CALL</code> was already a wrapper on top of an internal <code>CALL*</code> function, so I thought "why not expand upon that?"</p>
<h2>
<a name="a-cool-enclose-of-an-augment-of-a-specialize-1" class="anchor" href="https://forum.rebol.info#a-cool-enclose-of-an-augment-of-a-specialize-1"></a>A Cool ENCLOSE of an AUGMENT of a SPECIALIZE!</h2>
<pre><code>call: enclose (
    augment (specialize :call* [wait: #]) [
        /relax "If exit code is non-zero, return the integer vs. raising error"
    ]
) func [f [frame!]] [
    let relax: f.relax
    let result: do f
    if relax or (result = 0) [
        return result
    ]
    return raise make error! compose [
        message: ["Process returned non-zero exit code:" exit-code]
        exit-code: (result)
    ]
]
</code></pre>
<p>I think that's pretty neat.</p>
<p>It twists the CALL* function so that it always waits (vs. spawn a separate process and return a process ID to wait on).</p>
<p>Then it offers a /RELAX setting for getting the exit code back, if you don't want the definitional error behavior.</p>
<p>But then, by default it will RAISE an error.   You can get that error via EXCEPT or you can do TRY CALL if you just want to ignore any errors.</p>
<h2>
<a name="issue-exposed-whos-actually-to-blame-2" class="anchor" href="https://forum.rebol.info#issue-exposed-whos-actually-to-blame-2"></a>Issue Exposed: Who's Actually To Blame?</h2>
<p>While making this I noticed that there were actually several points of failure:</p>
<ul>
<li>
<p>The guts of CALL might not be able to find the file you're asking to execute</p>
</li>
<li>
<p>The executable may run, but return a non-zero exit code</p>
</li>
<li>
<p>If you're running through CALL/SHELL and delegating to it to call a process, then the shell may have its own exit status distinct from the process you tried to call</p>
</li>
</ul>
<p>It seems there's not really any great way to untangle the return results of a shell from that of a process it executes.  <a href="https://en.wikipedia.org/wiki/Exit_status">Here's some of the informal conventions of UNIX shells</a>:</p>
<blockquote>
<p><em>"When a command is terminated by a signal whose number is N, a shell sets the variable $? to a value greater than 128. Most shells use 128+N, while ksh93 uses 256+N."</em></p>
<p><em>"If a command is not found, the shell should return a status of 127. If a command is found but is not executable, the return status should be 126."</em></p>
</blockquote>
<p>So I'm a little shaky on what exactly a TRY CALL should be ignoring.  It's one thing to ignore a program's exit status, and another to ignore whether the program was on disk at all.</p>
<p>TAKE of a BLOCK only has a definitional failure when the block is empty, so you know what TRY TAKE means.  But it may be that you should more or less never say TRY CALL, and always specifically handle the errors that arise from it.  I think this may be a common theme of definitional errors coming out of complicated functions which have more than a single way to fail.</p>
<p>But... in any case, it's progress.  Because we're not conflating typos or other incidental errors to those that are coming from CALL.  And I like the default that it has an error on non-zero exit statuses.</p> ]]></description>
        <link>https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068#post_1</link>
        <pubDate>Fri, 08 Dec 2023 02:49:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6741</guid>
      </item>
      <item>
        <title>Using Invisibles To Opt Out of Functions In a Chain</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="gchiu" data-post="1" data-topic="2036">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/gchiu/40/22_2.png" class="avatar"> gchiu:</div>
<blockquote>
<pre><code>sharpen: either sharpen [:sharpenf] [:nihil]
blur: either blur [:blurf] [:nihil]
pixelise: either pixelize [:pixelf] [:nihil]

return sharpen blur pixelise data
</code></pre>
</blockquote>
</aside>
<p>This kind of application no longer works, as it was a casualty of scaling back what "invisibility" could do.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>"Non-Interstitial Invisibility" was removed for good reasons that are outlined here:</p>
<p><a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034" class="inline-onebox">Invisibility Reviewed Through Modern Eyes</a></p>
<p>So to have invisibles vaporize anything, you'd need to go through a COMPOSE or REDUCE step and then DO the result... so not that succinct.  CHAIN is a better bet here.</p>
<p>Though at time of writing, you can get the original intent with macros:</p>
<pre><code>sharpen: macro [] [return if sharpen [sharpenf]]
blur: macro [] [return if blur [blurf]]
pixelise: macro [] [return if pizelize [pixelf]]

return sharpen blur pixelise data
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/using-invisibles-to-opt-out-of-functions-in-a-chain/2036#post_3</link>
        <pubDate>Fri, 08 Dec 2023 02:08:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6740</guid>
      </item>
      <item>
        <title>Accepting the availability of stdint.h and stdbool.h</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>One of Carl's comments in R3-Alpha complained about the lack of a standardization of integer sizes in C:</p>
<blockquote>
<p><em>"One of the biggest flaws in the C language was not to indicate bitranges of integers. So, we do that here.  You cannot 'abstractly remove' the range of a number.  It is a critical part of its definition."</em></p>
</blockquote>
<p>So he did some empirical platform detection to define things like REBI32 for a signed 32-bit integer, REBU64 for an unsigned 64-bit integer, etc.</p>
<p>But once C99 arrived, the file &lt;stdint.h&gt; offered several basic types, and basically covered the needs with types that had names like <strong>int32_t</strong> and <strong>uint64_t</strong>:</p>
<p><a href="http://en.cppreference.com/w/c/types/integer" class="inline-onebox">Fixed width integer types (since C99) - cppreference.com</a></p>
<p>So Ren-C was changed to use the C99 names and include <code>&lt;stdint.h&gt;</code>.  For pre-C99 compilers, it used a portable shim called "pstdint", which it maintained its own copy of in the repository:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/e6e3e7fe0fcff165557f9ffc3de3e6713a50f99a/src/include/pstdint.h">src/include/pstdint.h</a></strong></p>
<p>By similar reasoning, booleans were shimmed with another found-file:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/e6e3e7fe0fcff165557f9ffc3de3e6713a50f99a/src/include/pstdbool.h">src/include/pstdbool.h</a></strong></p>
<h2>
<a name="ren-c-has-embraced-c99-so-why-keep-these-shims-1" class="anchor" href="https://forum.rebol.info#ren-c-has-embraced-c99-so-why-keep-these-shims-1"></a>Ren-C Has Embraced C99, So Why Keep These Shims?</h2>
<p>C99 is now a prerequisite for building the system.</p>
<p>It may be that some pre-C99 standards compiler <em>could</em> still build Ren-C with these shims, though it would need variadic macro support.  The odds of a compiler having that support yet lacking things like <strong>bool</strong> and <strong>int32_t</strong> are fairly slim.</p>
<p>In any case, these esoteric compilation environments could be "shimmed" by hacking in versions of stdint.h and stdbool.h to their include directories.  I feel like that's the responsibility of the build environment at this point... and that the Ren-C codebase need not be carrying the baggage.</p>
<p>So I'm pulling the files out.  If anyone is on an esoteric platform and trying to build but finds these definitions being missing is the only problem, then they should dig up pstdint and pstdbool.</p> ]]></description>
        <link>https://forum.rebol.info/t/accepting-the-availability-of-stdint-h-and-stdbool-h/2067#post_1</link>
        <pubDate>Thu, 07 Dec 2023 18:40:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6739</guid>
      </item>
      <item>
        <title>Should ANY-VALUE! Include Isotopes?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2026">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So if you don't put any type restrictions on a parameter, right now, that is a synonym for ANY-VALUE!</p>
</blockquote>
</aside>
<p>This wasn't always the case...</p>
<h2>
<a name="originally-any-value-did-not-include-null-1" class="anchor" href="https://forum.rebol.info#originally-any-value-did-not-include-null-1"></a>Originally, ANY-VALUE! did not include NULL</h2>
<p>Typesets were implemented as bitsets based on the cell type byte.  Nulls had a distinguished type byte of zero.  Then the corresponding bit for null was not set in ANY-VALUE!.</p>
<p>So an ANY-VALUE! was considered everything but a null.  If you wanted a function to be able to take a null argument, you'd have to say <strong><code>[&lt;opt&gt; any-value!]</code></strong></p>
<p>Back then I claimed that NULL was a "non-valued state", with the terminology that <em>"it's not a value, because you can't put it in a block"</em>.</p>
<p>Nevertheless, the variables at the time could hold nulls.  This runs up against my new competing terminological idea: <em>"values are anything you can put into variables."</em></p>
<h2>
<a name="excluding-isotopes-by-default-seems-appealing-2" class="anchor" href="https://forum.rebol.info#excluding-isotopes-by-default-seems-appealing-2"></a>Excluding Isotopes By Default Seems Appealing</h2>
<p>When users reach for a type constraint to say "I purposefully mean to accept many values", it's nice if isotopes aren't included in that.</p>
<p>NULL exclusion is a good one, with a historical basis.  Much of the reason for existence of NULL is that it's rejected by most functions (outside of things like IF which are deliberately testing for nulls).  Functions generally shouldn't take them.</p>
<p><strong>Another big-new-cool reason is that it would exclude "ACTIONs".</strong>  If you can't get the activated form of an action by default, your code doesn't have to be paranoid about putting in GET-WORD!s everywhere to disable them.</p>
<p><em>(NONEs are already excluded from normal parameters now, you have to use a ^META parameter to get them.)</em></p>
<p>Excluding isotopes would exclude things like logic ~true~ and ~false~, along with splices and other things.  I don't have a problem personally with routines that care about logic needing to explicitly add LOGIC? to the type constraints.</p>
<h2>
<a name="the-code-sticks-us-with-values-meaning-3" class="anchor" href="https://forum.rebol.info#the-code-sticks-us-with-values-meaning-3"></a>The Code Sticks Us With Value*'s Meaning</h2>
<p>All things being equal, I might say that "variables can hold values -or- stable isotopes (or voids)" would be good for being able to say ANY-VALUE? instead of ANY-ELEMENT?</p>
<p>But the code... has a meaning for Value*, and it really is pretty much literally "the kind of state that can be held by a variable".</p>
<p>The implication here is that all the places that say <strong><code>[&lt;opt&gt; any-value?]</code></strong> right now are redundant...that ANY-VALUE? includes null, and if you want to exclude nulls you have to use ANY-ELEMENT? and add in the isotopes you want from there.</p>
<h2>
<a name="biggest-cold-feet-issue-action-isotopes-by-default-4" class="anchor" href="https://forum.rebol.info#biggest-cold-feet-issue-action-isotopes-by-default-4"></a>Biggest Cold-Feet Issue: ACTION Isotopes By Default</h2>
<p>I started reviewing this point when I was right on the brink of turning all the <code>[&lt;opt&gt; any-value?]</code> into <code>[any-value?]</code> and just moving along...saying what's done is done.</p>
<p>But this means you can be receiving something that will execute when you reference it by word...as a common default.</p>
<p>A bit part of me wants to say that functions won't accept frame isotopes (e.g. actions) and you have to ^META them, the same way you have to do with void isotopes representing unset values.</p>
<p>But features break.  COLLECT is implemented by passing the block you give it to a function with an argument KEEP, and passes the keeper function as that parameter.  The function builder takes care of the binding.  I also use the feature in UPARSE, where the incoming PARSERs are live actions as well as parameters.</p>
<p>Some comfort can be taken that at least this is a place where you have a type block to enforce the policy of your choosing.  What worried me more about things like code enumerating blocks is you didn't get that choice.</p>
<h2>
<a name="long-story-being-short-any-value-includes-isotopes-5" class="anchor" href="https://forum.rebol.info#long-story-being-short-any-value-includes-isotopes-5"></a>Long Story Being Short: ANY-VALUE? Includes Isotopes</h2>
<p>It does make me wonder, though, if a different parameter convention for accepting "live" actions is needed.  GET-WORD! was once proposed as a good visual cue:</p>
<pre><code> foo: func [value [any-value?]] [...]   ; would reject ACTIONs despite ANY-VALUE?
 bar: func [:value [any-value?]] [...]  ; accepts the live action
</code></pre>
<p>This would attack the problem without saying that a live action wasn't an ANY-VALUE... it would just be prohibited by some other rule (much like how NONE is prohibited for another reason contextual to parameters).</p>
<p>But that's a separate design question, and for now the definition stands:</p>
<h3>
<a name="a-value-is-any-state-that-can-be-stored-in-a-variable-6" class="anchor" href="https://forum.rebol.info#a-value-is-any-state-that-can-be-stored-in-a-variable-6"></a><strong>A "Value" is any state that can be stored in a variable</strong>.</h3> ]]></description>
        <link>https://forum.rebol.info/t/should-any-value-include-isotopes/2026#post_3</link>
        <pubDate>Thu, 07 Dec 2023 17:52:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6738</guid>
      </item>
      <item>
        <title>Definitional Break and Continue... the Time is Now</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I was writing what I thought to be a clever bit of code, <a href="https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065">discussed here</a></p>
<pre><code>for-each file ... [
    parse file [thru any [".reb" ".r"] &lt;end&gt; | (continue)]
    ...
]
</code></pre>
<p>I thought it was pleasing to have the CONTINUE in the rules themselves.</p>
<p>Pleasing, except... a bit displeasing considering <strong>it didn't work.</strong></p>
<p>BREAK and CONTINUE would break or continue the first loop they found above them in the stack.  Since PARSE is currently written in usermode code, it uses loops in its implementation (to loop over the rules).  <em>so you wind up continuing some arbitrary loop inside the combinators, having random effects</em>!</p>
<p>Happily Ren-C has pioneered answers to this kind of problem with definitional returns.  But loops just have to get with the program and make CONTINUE and BREAK definitional in their bodies.</p>
<p>So I did it!  And most things appeared to work (like the motivating example).</p>
<h2>
<a name="still-complexity-for-loops-implemented-without-loops-1" class="anchor" href="https://forum.rebol.info#still-complexity-for-loops-implemented-without-loops-1"></a>Still Complexity For Loops Implemented Without "Loops"</h2>
<p>In bootstrap, there was some code implementing FOR-EACH-PLATFORM.  Hand-waving a bit, it initially looked like this:</p>
<pre><code> for-each-platform: func ['var [word! tuple!] body [block!]] [
     parse platforms-table [
         while [not &lt;end&gt;] [
              ...  ; rules that build up an OBJECT! 
              (set var obj, do body)
         ]
     ]
 ]
</code></pre>
<p>But that didn't make CONTINUE work:</p>
<pre><code> for-each-platform p [
     if p.name = 'HaikuOS [continue]
     ...
 ]
</code></pre>
<p>So I'd hacked up something at one point in history which looked like this monstrosity:</p>
<pre><code>    completed*: false
    running*: false
    while [true] [  ; must be in loop for BREAK or CONTINUE
        if running* [  ; must have had a CONTINUE
            completed*: true
            break
        ]
        running*: true
        do body
        completed*: true
        break
    ]
    if not completed* [return null] 
</code></pre>
<p>That depended on non-definitional CONTINUE happening inside BODY finding the enclosing WHILE.</p>
<p>But now, that CONTINUE isn't definitionally bound anywhere.  So that CONTINUE is just a reference to a default CONTINUE function in LIB, which will error telling you there are no loops providing continue available.</p>
<p>For the modern world, this <em>works</em>:</p>
<pre><code> repeat 1 body else [return null]
</code></pre>
<p>Reserving the pure NULL return value for BREAK means you can get that communication of when BREAK was encountered out of the return result.  And in this case, CONTINUE is just supposed to bypass the remainder of code in BODY and go on parsing.  So it works.</p>
<p>But it's suboptimal as the binding of the body to BREAK and CONTINUE happens on each run instead of once.  Doing that more efficiently would need some new techniques and case studies.</p>
<p>Overall though, it's progress...in the sense that there's an answer that works slowly, vs. not working at all!</p> ]]></description>
        <link>https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066#post_1</link>
        <pubDate>Thu, 07 Dec 2023 16:29:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6737</guid>
      </item>
      <item>
        <title>Deceptive Incomplete Parsing: A Common Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Some code I'd written checked for file extensions, wanting only %.r and %.reb files to be processed.  It looked like this:</p>
<pre><code> for-each file ... [
     parse file [thru ".reb" | thru ".r"] else [continue]
     ...
 ]
</code></pre>
<p>That doesn't work anymore, because PARSE raises an error instead of returning null.  The ELSE needs to be an EXCEPT, or you have to use IF NOT OK?, or some other solution.</p>
<p>My first thought on fixing it was why not just put the CONTINUE inside the parse...</p>
<pre><code> for-each file ... [
     parse file [thru ".reb" | thru ".r" | (continue)]
     ...
 ]
</code></pre>
<p>That's a neat Rebolism that shows the kind of malleability other languages just don't have.</p>
<p>But it has a problem.  Can you spot it?</p>
<h2>
<a name="old-redbol-conventions-wouldnt-catch-the-mistake-1" class="anchor" href="https://forum.rebol.info#old-redbol-conventions-wouldnt-catch-the-mistake-1"></a>Old Redbol Conventions Wouldn't Catch The Mistake</h2>
<p>Imagine if the file is named <strong>%foo.reb.zip</strong> or <strong>%foo.rar</strong>.  One of the THRUs succeeds, so it won't run the continue alternate.  But it won't reach the end of the filename.</p>
<p>Historical Redbol would have had the PARSE return false, but would have just blindly continued running, passing those unintended filenames!!!</p>
<p>Now we're a step ahead, because PARSE will error if it doesn't reach the end!  <img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=12" title=":clap:" class="emoji" alt=":clap:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="but-how-to-stop-the-error-2" class="anchor" href="https://forum.rebol.info#but-how-to-stop-the-error-2"></a>But How To Stop the Error?</h2>
<p>We don't want an error if it doesn't terminate in %.r or %.reb, we want to continue the loop.</p>
<p>This will work:</p>
<pre><code> parse file [thru ".reb" &lt;end&gt; | thru ".r" &lt;end&gt; | (continue)]
</code></pre>
<p>And it's not catastrophically bad.  But it feels weird.</p>
<p>You can remove the <code>&lt;end&gt;</code> duplication:</p>
<pre><code> parse file [thru [".reb" | ".r"] &lt;end&gt; | (continue)]
</code></pre>
<p>You can also do that with ANY:</p>
<pre><code> parse file [thru any [".reb" ".r"] &lt;end&gt; | (continue)]
</code></pre>
<p>You can of course go for the conventional forms:</p>
<pre><code>parse file [thru ".reb" | thru ".r"] except [continue]

if not ok? parse file [thru ".reb" | thru ".r"] [continue]
</code></pre>
<p>But I feel like there's something missing when you write something like this without making the <code>&lt;end&gt;</code> explicit...because it leads to someone getting the bright idea (as I did) to reformulate it without taking the <code>&lt;end&gt;</code> into account.</p>
<h2>
<a name="in-any-case-this-being-overlooked-is-now-caught-3" class="anchor" href="https://forum.rebol.info#in-any-case-this-being-overlooked-is-now-caught-3"></a>In Any Case, This Being Overlooked Is Now Caught!</h2>
<p>It's food for thought on what style you want. But no matter what style you like, I think it shows a clear win for raising the error when the parse doesn't reach the end.</p>
<p>That %foo.rar or %foo.reb.zip -- when they occur -- will not be accepted quietly in the reformulation!</p> ]]></description>
        <link>https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065#post_1</link>
        <pubDate>Tue, 28 Nov 2023 03:33:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6736</guid>
      </item>
      <item>
        <title>TRY PARSE + PARSE EXCEPT : *FAIL* On Mismatch</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1924">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Or if you just wanted it to ignore success or failure in a "classic" way, use TRY:</p>
<pre><code>root: try parse pdfname [between &lt;here&gt; ".pdf"]
</code></pre>
<p><em>That seems a good enough way to ask for the bad enough thing.</em> It will give you a NULL if there's no ".pdf" anywhere, and what's before .pdf for anything up-to-and-including <strong><code>something.pdfoobar</code></strong></p>
</blockquote>
</aside>
<p>So this is good when you're writing an expression that's supposed to return a value.  But if you're only interested in if the parse reached the end or not, it's not good enough.</p>
<pre><code>&gt;&gt; try parse "aaabbb" [some "a" try some "b"]
== ~null~  ; isotope
</code></pre>
<p>That parse reached the end, but the product of the TRY combinator inside the parse block when it doesn't succeed is NULL.  So <strong>if try parse ...</strong> is unfortunately not a general answer to testing if a parse completed.</p>
<ul>
<li>
<p><strong>if not raised? parse ...</strong> works but is overly verbose.</p>
</li>
<li>
<p><strong>if unraised? parse ...</strong> is a little shorter but awkward.</p>
</li>
<li>
<p><strong>if ok? parse ...</strong> uses a very old idea of OK? meaning not-errored, but a bit nebulous in what it means, and perhaps looks a little "cheap" and abbreviated.</p>
</li>
<li>
<p><strong>if okay? parse ...</strong> looks a little less cheap and abbreviated but I don't know if the added length vs. OK? really pays for itself.</p>
</li>
<li>
<p><strong>if try? parse ...</strong> builds on the existing TRY concept so you can see the relationship, but is a bit weird.</p>
</li>
<li>
<p><strong>if did parse ...</strong> looks nice but DID is taken for something else, that I don't think should be conflated with error defusion.</p>
</li>
<li>
<p><strong>if success? parse ...</strong> or <strong>if succeeded? parse ...</strong> is a little bit like OK? in the sense that success is a pretty open-ended concept.  But TRY is tied up a bit with "success" so SUCCESS? as the complement to RAISED? isn't a terrible thing.</p>
</li>
<li>
<p><strong>if good? parse ...</strong> is weird, and the suggestion of BAD? as  a synonym for RAISED? is weird also.  But it reads a little better than IF OK?</p>
</li>
<li>
<p><strong>if parse? ...</strong> as a different form of PARSE that just returns true or false based on reaching the end is something that has shown up from time to time, but I've never been crazy about it.  Functions ending in question mark tend to take one argument.  This is like it's testing if something is a parse-state object or similar, and I can't quite read it as "if parse reached end".</p>
</li>
<li>
<p><strong>if completed? parse ...</strong> is appealing, it's a bit of a parallel to Rebol2's FOUND? to pair with FIND.  It leads to a world where <strong>completed? null</strong> is true.  While not being a generic word it would function generically to other things that might raise failures leading to misuse, and it's a long word.</p>
</li>
</ul>
<p>Everything has its upsides and downsides.  I'm not crazy about <strong>if ok? parse...</strong> but I like it better than <strong>if parse? ...</strong> and it's still brief.  And it gives OK? as a generic NOT RAISED? , as well as <strong>if not ok?</strong> as a way of saying <strong>if raised?</strong> if you liked that better.</p>
<h2>
<a name="or-a-refinement-to-parse-or-combinator-1" class="anchor" href="https://forum.rebol.info#or-a-refinement-to-parse-or-combinator-1"></a>Or... A Refinement to PARSE, or Combinator?</h2>
<p>For the sake of covering all the bases, I'll mention this could be attacked on the insides of parse, as well.</p>
<pre><code>if parse/completed "aaabbb" [some "a" try some "b"] ...

if parse/tail? "aaabbb" [some "a" try some "b"]

if parse "aaabbb" [completed? [some "a" try some "b"]] ...

if parse "aaabbb" [some "a" try some "b" || accept &lt;end?&gt;] ...
</code></pre>
<p>I'm actually not hating PARSE/COMPLETED.  Maybe something shorter...in the spirit of PARSE/DONE but better?</p>
<p>But if you get it shorter to PARSE/OK you aren't really doing better than OK? PARSE and losing generality.</p>
<h2>
<a name="experience-probably-informs-this-2" class="anchor" href="https://forum.rebol.info#experience-probably-informs-this-2"></a>Experience Probably Informs This</h2>
<p>I think it's hard to see clearly in particular having seen so many different return modes of PARSE over time.</p>
<p>As you get experience in the new world with "parse raises an error if it doesn't reach the end" then a generic tool like OK? for "checks to see if it raises an error" might seem to make perfect sense.  You just have to be used to the idea of errors, and not expect anything otherwise...so of course you need some kind of weird error-detecting construct.</p>
<p>Trying it out a little, SUCCESS? is definitely more literate than OK?.  But I don't know that the length is worth it, and OK? seems pretty learnable.</p>
<p>People can of course easily make their own shorthands, even PARSE?, if they like it.</p> ]]></description>
        <link>https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924#post_4</link>
        <pubDate>Tue, 28 Nov 2023 00:39:13 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6735</guid>
      </item>
      <item>
        <title>Intentionally Specializing With NONE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1168">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But what if you want to actually SPECIALIZE a function with NONE, e.g.:</p>
<pre><code>unset: specialize :set [value: ~]
</code></pre>
</blockquote>
</aside>
<p>The simple answer here is simply that functions can't take NONE as a normal parameter.</p>
<p>Even though it's a "stable" isotope, you have to make a parameter ^META to receive it.</p>
<p>This means you'd write:</p>
<pre><code>unset: specialize :set [value: '~]  ; e.g. value is ~
</code></pre>
<p>The downside of this is that any value put in the frame for SET would have be META.</p>
<pre><code>set-to-5: specialize :set [value: meta 5]  ; e.g. value is '5
</code></pre>
<p>The alternative would be to disallow SET to a none value.</p>
<p>A function like APPLY can do this automatically.  It's in control of the assignments so it can look at the parameter it's assigning and do the right thing with the product of the evaluation it did.</p>
<p>But the code inside of the block passed to SPECIALIZE is freeform and it's not in control of the assignment statements.  So by the time your code is done running, it's too late to know if <code>value: ~</code> meant you didn't assign it or you assigned it deliberately.</p>
<p>I've tried to minimize the number of places that ^META parameters show up.  But when they show up, anything that manipulates frames directly has to know about that to write correct code.</p> ]]></description>
        <link>https://forum.rebol.info/t/intentionally-specializing-with-none/1168#post_2</link>
        <pubDate>Sun, 26 Nov 2023 05:31:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6734</guid>
      </item>
      <item>
        <title>Dialect Meaning of Non-Words in Function Parameter Spec Blocks</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Historical Redbol only had WORD!s in the BLOCK! that came after a parameter:</p>
<pre><code>foo: func [
    arg [block! word! number!]  ;  all words in block
] ...
</code></pre>
<p>But when Ren-C introduced the paradigm-breaking NULL that could not be put in arrays, that meant there was no <code>null!</code> datatype.  To fill the gap, the tag <code>&lt;opt&gt;</code> was chosen to indicate the parameter as optional--hence possibly null:</p>
<pre><code>foo: func [
    arg [&lt;opt&gt; block! word! number!]  ;  now it's WORD!s and TAG!s
] ...
</code></pre>
<p>I liked using a TAG! for how it stood out (though in retrospect I'd have probably chosen <code>&lt;null&gt;</code>, but everything was named differently then).  Other quirky ideas were floated, like being able to put a leading slash on the typeset block:</p>
<pre><code>foo: func [
    arg /[block! word! number!]  ; like a refinement, but on the types
] ...
</code></pre>
<p>That didn't gain traction, and probably shouldn't have.</p>
<p>Then when early efforts faced another value state that couldn't be put in a block and didn't have a type, <strong><code>&lt;void&gt;</code></strong> came onto the scene...because as with there being no NULL!, there was no VOID! datatype.</p>
<h2>
<a name="tag-modifiers-which-werent-type-checkers-showed-up-1" class="anchor" href="https://forum.rebol.info#tag-modifiers-which-werent-type-checkers-showed-up-1"></a>Tag Modifiers Which Weren't Type Checkers Showed Up</h2>
<p>The ability to take a parameter but get an immutable view of it was added as <strong><code>&lt;const&gt;</code></strong>.</p>
<p>Parameters that would accept being at the end of input and evaluate to null in that case were <strong><code>&lt;end&gt;</code></strong></p>
<p><strong><code>&lt;variadic&gt;</code></strong> and <strong><code>&lt;skippable&gt;</code></strong> came into existence.</p>
<p>These "parameter-control tags" seemed to me to be a distinct category from typecheckers like <strong><code>&lt;opt&gt;</code></strong> and <strong><code>&lt;void&gt;</code></strong>.   Having them all use TAG! felt like <em>too many tags.</em></p>
<p>So I mused about splitting the roles, something like:</p>
<pre><code>[&lt;const&gt; #null type!]
-or-
[#const &lt;null&gt; type!]
</code></pre>
<p>But I didn't like the look of it enough to move on it.  So things like <strong><code>[&lt;const&gt; &lt;opt&gt; type!]</code></strong> stuck around while I wondered about it.</p>
<h2>
<a name="today-you-can-specify-any-type-check-by-function-2" class="anchor" href="https://forum.rebol.info#today-you-can-specify-any-type-check-by-function-2"></a>Today, You Can Specify Any Type Check By Function</h2>
<p>There's still no NULL! or VOID!.  But with the way things work now, you can use functions as "type predicates" to recognize things that aren't datatypes in their own right:</p>
<pre><code>foo: func [
    arg [null? block! word! number!]
] ...
</code></pre>
<p>What's good:</p>
<ul>
<li>It leaves TAG! for the properties like <strong><code>&lt;const&gt;</code></strong> that don't have to do with type recognition... but rather controlling the parameter in a more special way.</li>
</ul>
<p>What's bad:</p>
<ul>
<li>It loses that kind of special look that tags gave to arguments that could take null.  It blurs together, especially with things like SPLICE? and LOGIC? and CHAR? for other non-fundamental datatypes (characters are just single-character issues now, and ~true~ and ~false~ isotopes of WORD! implement logic)</li>
</ul>
<h2>
<a name="a-modern-option-null-for-taking-null-3" class="anchor" href="https://forum.rebol.info#a-modern-option-null-for-taking-null-3"></a>A Modern Option: ~NULL~ for Taking Null</h2>
<p>I made an experiment so if you used a QUASI-WORD!, then it would match an isotope of that form.</p>
<p>It's a kind of pleasingly distinct look:</p>
<pre><code>foo: func [
    arg [~null~ block! word! number!]
] ...
</code></pre>
<p>And it mixes better with the tags:</p>
<pre><code>foo: func [
    arg [~null~ &lt;const&gt; block! word! number!]
] ...
</code></pre>
<p>It also works for "nones" (isotopic voids) and doesn't look too bad there, e.g. for RETURN:</p>
<pre><code>foo: func [
    return: [~]  ; as opposed to `return: [none?]`
 ] ...
</code></pre>
<p>That doesn't work for voids, and the current idea is that there's no VOID! because TYPE OF VOID gives back NULL.  This is consistent with void-in-null out in general, although it might confuse people who expect to do:</p>
<pre><code>switch type of value [
    null [print "This means value was void, not null"]
    ...
]
</code></pre>
<p>So the idea there was that perhaps TYPE OF NULL is an error, and this guides you to another solution like <strong>switch/type</strong> where you can use <strong>&amp;[null?]</strong> or <strong>&amp;[void?]</strong> as type predicates and get what you actually want.</p>
<p><em>(I still don't think defining <strong>null!: &amp;[null?]</strong> is a good idea, because it looks like a fundamental datatype, and you cannot <strong>make null! ...</strong> etc.  Maybe <strong>null?!: &amp;[null?]</strong> or something like that would be a bit less noisy at usage sites, enough to be worth it?)</em></p>
<h2>
<a name="allowing-null-and-null-as-choices-seems-good-4" class="anchor" href="https://forum.rebol.info#allowing-null-and-null-as-choices-seems-good-4"></a>Allowing NULL? and ~NULL~ As Choices Seems Good</h2>
<p>I think we can live with <strong>void?</strong> in function specs for functions that deliberately take voids.  It's also more legitimate--voids are more neutral than nulls in the current formulation--e.g. <strong>append [a b c] void</strong> is [a b c].</p>
<p>I like the option of <strong>~null~</strong> instead of <strong>null?</strong> to call out the more rare-and-alarming idea of accepting null parameters.</p>
<h2>
<a name="what-about-return-nihil-and-return-none-5" class="anchor" href="https://forum.rebol.info#what-about-return-nihil-and-return-none-5"></a>What about <code>return: &lt;nihil&gt;</code> and <code>return: &lt;none&gt;</code>
</h2>
<p>These two special uses of tag! with no block have been used to say you don't need a RETURN statement at all... the function just gives back none or nihil respectively when the body completes.</p>
<p>How necessary is it?  Well, you either write things like:</p>
<pre><code>comment: func [
    return: [nihil?]
    discarded [any-value!]
][
    return nihil
]
</code></pre>
<p>Or you have the contraction:</p>
<pre><code>comment: func [
    return: &lt;nihil&gt;
    discarded [any-value!]
][
]
</code></pre>
<p>This style of "don't even worry about writing a RETURN" has the widest applicability to NONE and NIHIL.  We don't strictly need it, but I've gotten used to it.</p>
<p>I mention <strong>return: [~]</strong> as a possible alternative for saying none is a return type using the quasiform-means-isotope idea.  And since none falls out of function bodies by default with no return, it's not strictly necessary to have <strong><code>return: &lt;none&gt;</code></strong> as any kind of special operation.</p>
<p>Again, how does that look?</p>
<pre><code>foo: func [
    return: [~]
 ] ...
</code></pre>
<p>If you're going to break the pattern and not say <strong><code>return: [none?]</code></strong>  then I may call that a break-even alternative to <strong><code>return: &lt;none&gt;</code></strong>.  A little more symbol-y, but doesn't break the rhythm of type specs being blocks.</p>
<p>This leaves the nihil case.  We could say <strong>return: [~[]~]</strong> and have that mean "I return an empty pack" but in that case you'd still need an explicit return:</p>
<pre><code>comment: func [
    return: [~[]~]
    discarded [any-value!]
][
    return nihil
]
</code></pre>
<p>But I think I like <strong><code>return: [nihil?]</code></strong> better than that.  Compared to <strong><code>return: [~]</code></strong> the <strong><code>[~[]~]</code></strong> is a bridge too far.</p>
<p>Anyway, the reason this is a struggle is that <strong><code>return: &lt;none&gt;</code></strong> has just become so pervasive that it's hard to see that changed to <strong><code>return: [none?]</code></strong>.  But standardizing on blocks and moving away from the tags for this application may be the best idea.</p> ]]></description>
        <link>https://forum.rebol.info/t/dialect-meaning-of-non-words-in-function-parameter-spec-blocks/2064#post_1</link>
        <pubDate>Sat, 25 Nov 2023 08:25:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6733</guid>
      </item>
      <item>
        <title>PATH! and TUPLE! compression, explained</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Almost 5 years ago (!) I optimized PATH! and TUPLE! that looked like <strong><code>/foo</code></strong> (or <strong><code>foo/</code></strong>, or <strong><code>.foo</code></strong>, or <strong><code>foo.</code></strong>) to cost no more than the R3-Alpha REFINEMENT!... at 4 platform pointers.</p>
<p>Without the optimization, the 2-element paths cost 20 platform pointers:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1008">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But let's say instead of a block, you were doing a PATH!, like the proposed 2-element path for <strong>/refinement</strong> (a BLANK! that's not rendered, and then the WORD! "refinement"). What would a 2-element array cost?</p>
<p>You've still got the 4 pointer cell and the 8 pointer series stub. But now you need a dynamic allocation to hold the 2 cells, so that would be 8 more platform pointers.</p>
<p><em>Grand Total:</em> 4 + 8 + 8 =&gt; <strong>20 platform pointers</strong>...for something that took only 4 before! So <strong>[1 1]</strong> is 5x as big as <strong>1</strong>, and on a 64-bit platform we're talking 160 bytes. For a refinement like <strong>[_ refine]</strong> that's not even counting the storage for the UTF-8 name of the refinement and overhead for that...this is how much it costs just to <em>point</em> to it!</p>
</blockquote>
</aside>
<p>The optimization is great, but you can't apply that trick to <strong><code>foo.bar</code></strong> or <strong><code>foo/bar</code></strong> (or <strong><code>foo/[bar]</code></strong> etc.)  Without the blank, you need two cells.</p>
<p>So I had an idea: to reuse the mechanic behind PAIR! that manages to store two cells and skips the array node.  So it's 4 + 8 = 12 platform pointers, instead of 20 for these cases.</p>
<p>It was very close to being implemented, and while going over the code I realized that all the disclaimers about it not being implemented were taking up more space and concern than just going ahead and writing it.  All the hard work was done--and powering the relatively-few PAIR! that I ever use.</p>
<h2>
<a name="how-much-does-it-save-1" class="anchor" href="https://forum.rebol.info#how-much-does-it-save-1"></a>How Much Does It Save?</h2>
<p>I don't know how typical the boot code is, but if you boot the system there are 1,648 of these 2-element PATH!s/TUPLE!s being created in memory.</p>
<p>So on a plain boot of a system, it's saving 1,648 * 8 = 13184 platform pointers.  On a 64-bit system that's 105,472 bytes (half that on 32-bit)</p>
<p>It's not a "ton" (though 105K here, 105K there, eventually you're talking megabytes).  But it could provide another benefit in the form of locality.  It means that when something like <strong>block.1</strong> is being processed, it can use the node in the TUPLE! directly, instead of needing to follow it to a dynamic allocation.</p>
<p>In practice, it seems the code as written right now is more or less breaking even.  So running the code for detecting the new form basically equals hopping through to the array.  Hence it's really just the memory benefit for now...though I imagine with some tuning that could change.</p>
<p>Anyway, 105K memory savings at runtime seems like the kind of thing that's worth it, so... it's in now.</p> ]]></description>
        <link>https://forum.rebol.info/t/path-and-tuple-compression-explained/1008#post_3</link>
        <pubDate>Wed, 22 Nov 2023 08:40:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6732</guid>
      </item>
      <item>
        <title>Very Creaky (but still interesting) Debug Step *DEMO*</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>In 2019, I made a small debugging demo:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1154">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So the last few days I've frittered around with a very-buggy-proof-of-concept for single-stepping.<br>
...<br>
It's important to emphasize <strong>this is still sticks and glue at this point</strong>.</p>
</blockquote>
</aside>
<p>The "bad" (actually good) news is that those sticks and glue are all gone.  <a href="https://forum.rebol.info/t/stackless-is-here-today-now/1844">Switching to stackless</a> removed the hooks for writing code that intercepted the evaluator.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1154">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Something I really wanted to see was the debugger generalizing to parse.</p>
</blockquote>
</aside>
<p>The "good" (no, actually good) news is that I've accomplished this using modern methods:</p>
<p><a href="https://forum.rebol.info/t/replpad-visual-parse-debugger/2063" class="inline-onebox">ReplPad Visual PARSE Debugger</a></p>
<p>The methods that accomplish this are legitimate, and not likely to be overturned in the design.</p>
<p>However, they aren't part of a <em>generalized</em> notion of debugging.  This debugger is tailored to PARSE, and parse only.</p>
<p>Not only that...it works only on a <em>single parse call</em>.  You make a specific call to parse parameterized with a hook, e.g. PARSE-DEBUG.  Only that call should be hooked.  So if the debugger uses PARSE in its own implementation (which it does) it needs to use the non-DEBUG form to do so, otherwise it would break the in-progress debug session by interfering with its interface.</p>
<h2>
<a name="could-the-evaluator-use-the-same-methodology-1" class="anchor" href="https://forum.rebol.info#could-the-evaluator-use-the-same-methodology-1"></a>Could The Evaluator Use The Same Methodology?</h2>
<p>PARSE-DEBUG is based on the idea of hooking a frame... using ENCLOSE.  All parser combinators are ENCLOSE'd when they are built, with the ability to be hooked.</p>
<p>I've discussed the idea of the main evaluation process being driven by EVALUATORs, much like PARSE uses COMBINATORs.  So you'd have a SET-WORD! evaluator function that took the SET-WORD! it was invoked with, and a variadic feed of code coming after it.</p>
<p>Under this idea, you could actually create something like REDBOL-DO, which had a different EVALUATOR for PATH! to do variable picking (while Ren-C's default evaluator would do variables with TUPLE!).</p>
<p>I think it could work.  But it does mean that variadics are needed by the language, because the FRAME! built for evaluators can't see to the end of how much that evaluator is going to consume.  (I'd been mulling over killing variadics as a "it's too much" feature now and again, but this kind of proves that's a bad idea...and they actually just need to be fixed up to be less of a mess.)</p>
<p>It would be a pretty gnarly performance penalty to turn every SET-WORD! or GET-TUPLE! into a function call.  But I have an inkling on how to make it cheaper.  As it happens, there's a stack frame already for the right hand side of the evaluation... and what this could do would be to morph that stack frame on-demand so it looked like a function call...but only when the debugger looked at it.  It just might work.</p>
<h2>
<a name="could-parse-debug-and-evaluator-debug-unify-2" class="anchor" href="https://forum.rebol.info#could-parse-debug-and-evaluator-debug-unify-2"></a>Could PARSE-Debug and EVALUATOR-Debug Unify?</h2>
<p>You run into some interesting questions in terms of whether you want to debug the combinators of a PARSE, or if you want to debug the evaluator implementing parse.  Or if there's some way of switching modes.</p>
<p>Being able to switch modes on a whim would be something like being able to switch into an assembly view of an already-running C function in a C debugger.</p>
<p>Right now the PARSE debug demo is dependent on the hooked parse building up and tearing down its own stack level list in the combinator hook.  That's already a problem, because it means that you can't trigger a breakpoint at an arbitrary point in the parse...because it only maintained this level list if it was tracing.</p>
<p>So the unified model would depend on some way to enumerate the stack API, and be able to make decisions about who to ask about rendering a stack level.  Because a combinator is both an evaluator level and a parse level.</p>
<h2>
<a name="prototyping-eval-debugging-in-replpad-is-probably-best-3" class="anchor" href="https://forum.rebol.info#prototyping-eval-debugging-in-replpad-is-probably-best-3"></a>Prototyping EVAL Debugging in ReplPad is Probably Best</h2>
<p>After having put together the PARSE stepping demo, I think that it makes the most sense to build debugger prototypes in the browser.</p>
<p>I continue to think this needs to be pushed on sooner rather than later.  (I know it seems quite a bit "later" in the scheme of things, but there's always more later to come.  :-P)</p> ]]></description>
        <link>https://forum.rebol.info/t/very-creaky-but-still-interesting-debug-step-demo/1154#post_2</link>
        <pubDate>Wed, 22 Nov 2023 00:01:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6731</guid>
      </item>
      <item>
        <title>Why can&#39;t you PROTECT individual cells in an array?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>You can PROTECT a variable:</p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; protect 'x

&gt;&gt; x: 20
** Access Error: variable x locked by PROTECT (see UNPROTECT)
</code></pre>
<p>And you can PROTECT an array pointed to by a variable:</p>
<pre><code>&gt;&gt; array: [&lt;a&gt; b #c]

&gt;&gt; protect array

&gt;&gt; append array ["d"]
** Access Error: series read-only due to PROTECT (see UNPROTECT)

&gt;&gt; array: [&lt;q&gt; r #s]  ; variable holding array not protected

&gt;&gt; array
== [&lt;q&gt; r #s]
</code></pre>
<p>...but you can't PROTECT a cell resident inside an array:</p>
<pre><code>&gt;&gt; array: [&lt;a&gt; b #c]

&gt;&gt; protect 'array.2  ; this doesn't work

&gt;&gt; array.2: "z"
; you'd expect an error here if it did work

&gt;&gt; array.3: 1020
; you'd expect no error here if it did work
</code></pre>
<p>R3-Alpha didn't have the feature, and Ren-C hasn't added it.  Why?</p>
<h2>
<a name="making-this-work-would-add-significant-complexity-1" class="anchor" href="https://forum.rebol.info#making-this-work-would-add-significant-complexity-1"></a>Making This Work Would Add Significant Complexity</h2>
<p>Your first thought (well, mine) would be that this is about efficiency.  e.g. if you were going to write something like <strong>clear block</strong>, the existence of PROTECT'd cells inside that block would mean you'd have to visit all the cells before knowing if it was okay to clear it.  Other code that already has to visit the cells in order to copy them would still pay a little more too... like <strong>take/part</strong>.</p>
<p><em>But that's not where the real problem is.</em>  Paying a little more for mutating operations is only slightly relevant.  The real problem has to do with a pointer to a cell not being able to answer the question of its own mutability--since it can't speak for the container's protection status.</p>
<p>In more detail:</p>
<p>Ren-C's clever management of immutability uses the C <code>const</code> designator.  What the const means on a <em>series</em> is that the series may be mutable, but hasn't had a runtime check yet to flip it over to being readable.  And what the const means on <em>cells</em> is that the cell was <em>extracted</em> from a series that may be mutable, but hadn't had the runtime check applied.</p>
<p>This way, casual code that just messes around reading cells and series can be written easily, using const pointers and not paying for runtime checks.  And you can be certain of not skipping the runtime checks in the places where you want to get mutable access.  (R3-Alpha was full of bugs from "just forgetting".)</p>
<p>The problem with getting a granularity of cell-level mutability is that right now, there's just one runtime check that gives you a mutable cell pointer...done at the array level:</p>
<pre><code>Cell* tail;
Cell* cell = VAL_ARRAY_AT_ENSURE_MUTABLE(&amp;tail, block);
</code></pre>
<p>There are multiple checks done, here.  The BLOCK! cell passed in may or may not carry a CONST cell bit--which is to say, that particular reference to the BLOCK! might be const (even if the underlying array hasn't been PROTECT'd).  And then, there's the protection status of the array...which can also become protected during enumerations of the array, or if it is executing currently in the evaluator.</p>
<p>If this code doesn't trigger a failure from discovering a form of mutability, then the non-const <code>Cell*</code> is given back.</p>
<p>But then...the code will increment that cell pointer to find other cells in the array.  And incrementing a mutable pointer gives you another mutable pointer.</p>
<p>It may seem we <em>could</em> make <code>Cell(*)</code> in the C++ debug build a smart pointer class that gives you back a <code>Cell(const*)</code> when incremented.  And then say that there's a way to promote a const cell reference to a mutable cell reference with a runtime check.</p>
<p>But this would be deceptive.  We already know that if you have a const reference to a cell that lives in the middle of an array, that a runtime check of the containing array for that cell hasn't been done yet.</p>
<p>In other words: once you have your hands on a cell pointer, it's too late to ask about <em>that</em> cell's mutability.  The knowledge is up to the container.</p>
<p>Trying to solve this would be a mess.  e.g. making a kind of Cell(const*) that was the size of two pointers, but held a reference to the array the cell was resident in...in case you wanted to do the runtime check asking for a promotion to a Cell(*).</p>
<p>I've been moving in the other direction...paring away complexities in the source where possible.  Something like that doesn't belong in the codebase--especially to implement a feature that I can only vaguely imagine uses for.</p>
<h2>
<a name="so-dont-expect-cell-level-protectever-2" class="anchor" href="https://forum.rebol.info#so-dont-expect-cell-level-protectever-2"></a>So Don't Expect Cell-Level PROTECT...Ever</h2>
<p>Every now and again I've looked at the flag and thought "why does this apply only to variable cells?"  So I wanted to hammer out the reasoning, and confirm that it wasn't just about performance.</p>
<p>From my point of view, it's about creating a situation of a flag that needs to be checked, and which the code has no (reasonable) systemic way to enforce that checking.</p> ]]></description>
        <link>https://forum.rebol.info/t/why-cant-you-protect-individual-cells-in-an-array/2062#post_1</link>
        <pubDate>Tue, 21 Nov 2023 22:52:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6729</guid>
      </item>
      <item>
        <title>Executable Size circa 2023...and tweaking INLINE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A modern Ren-C non-debug executable on Linux--with https and the libuv filesystem and networking code (which supports asynchronous file I/O etc.) is about 1.7 MB when it is built at an O2 level of optimization (optimize for speed).</p>
<p>When built at Os optimization it's about 1.2 MB, sacrificing 40% of the speed to get the compression.  (In the modern era, most people would say that the extra size isn't a big deal to get that much of a speed improvement.)</p>
<p>By comparison, an R3-Alpha Linux executable is about 0.56 MB at O2.  And a Red CLI-only binary on Linux is about 1.0 MB.</p>
<h2>
<a name="why-has-size-gone-up-1" class="anchor" href="https://forum.rebol.info#why-has-size-gone-up-1"></a>Why Has Size Gone Up?</h2>
<p>I've looked under the hood at the differences with R3-Alpha to see what accounts for the disparity with modern Ren-C.  libuv accounts for a couple 100k, and is worth it--it would be especially so if taking advantage of things like the async file I/O.</p>
<p>But the rest just generally comes down to the fact that it's about twice as much code.  If you enjoy using ADAPT or ENCLOSE or SPECIALIZE, well, there's code that implements it.  And it's a deeper, safer, far more advanced codebase that just does more.</p>
<h2>
<a name="i-actually-pared-out-about-600k-by-tweaking-inlining-2" class="anchor" href="https://forum.rebol.info#i-actually-pared-out-about-600k-by-tweaking-inlining-2"></a>I Actually Pared Out About 600K By Tweaking Inlining</h2>
<p>When I started looking at size, the O2 binary was like 2.4 MB.  That was more than I expected, so I decided to look under the hood into why.</p>
<p>I used Google's tool <a href="https://github.com/google/bloaty">Bloaty McBloatface</a> to get some insight, and to my surprise...some rather small functions had a disproportionate amount of code attributed to them.</p>
<p>It turned out that this was due to putting functions in header files and inlining them with <code>static inline</code>.  When I moved 5 of these functions into the .c files instead of the .h files, that saved 400k in one blow... and the executable only got 0.4% slower (four tenths of a percent) as a result.</p>
<p>Then I managed to make it so the C++ build was about 140K lighter by changing the <code>static inline</code> on the remaining functions to a macro of INLINE that's either <code>inline</code> in the C++ build, or <code>static inline</code> in the C build.</p>
<p>I guess the takeaway here is that even if you notice that something is getting bigger due to good reasons of having more code, it always pays to look under the hood a bit when you can.  A few hours of work can get some low-hanging fruit.</p>
<p>(Another takeaway is that being able to build a C codebase as C++--if you want to--continuously pays dividends...)</p>
<p>Here's some notes on the INLINE macro:</p>
<pre><code class="lang-auto">
//=//// INLINE MACRO FOR LEVERAGING C++ OPTIMIZATIONS /////////////////////=//
//
// "inline" has a long history in C/C++ of being different on different
// compilers, and took a long time to get into the standard.  Once it was in
// the standard it essentially didn't mean anything in particular about
// inlining--just "this function is legal to appear in a header file and be
// included in multiple source files without generating conflicts."  The
// compiler makes no particular promises about actually inlining the code.
//
// R3-Alpha had few inline functions, but mostly used macros--in unsafe ways
// (repeating arguments, risking double evaluations, lacking typechecking.)
// Ren-C reworked the code to use inline functions fairly liberally, even
// putting fairly large functions in header files to give the compiler the
// opportunity to not need to push or pop registers to make a call.
//
// However, GCC in C99 mode requires you to say `static inline` or else you'll
// get errors at link time.  This means that every translation unit has its
// own copy of the code.  A study of the pathology of putting larger functions
// in headers as inline with `static inline` on them found that about five
// functions were getting inlined often enough to add 400K to the executable.
// Moving them out of .h files and into .c files dropped that size, and was
// only about *0.4%* slower (!) making it an obvious win to un-inline them.
//
// This led to experimentation with C++ builds just using `inline`, which
// saved a not-insignificant 8% of space in an -O2 build, as well as being ever
// so slightly faster.  Even if link-time-optimization was used, it still
// saved 3% on space.
//
// The long story short here is that plain `inline` is better if you can use
// it, but you can't use it in gcc in C99 mode (and probably not other places
// like TinyC compiler or variants). So this clunky INLINE macro actually
// isn't some pre-standards anachronism...it has concrete benefits.
//
#if CPLUSPLUS_11
    #define INLINE inline
#else
    #define INLINE static inline
#endif
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/executable-size-circa-2023-and-tweaking-inline/2061#post_1</link>
        <pubDate>Tue, 21 Nov 2023 05:02:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6728</guid>
      </item>
      <item>
        <title>Taking ACTION! on &quot;Function vs. Action&quot;</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="596">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Trying This Would Raise Many Questions</p>
</blockquote>
</aside>
<p>This may deserve the understatement of the year award!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/trophy.png?v=12" title=":trophy:" class="emoji only-emoji" alt=":trophy:" loading="lazy" width="20" height="20"></p>
<p>Nevertheless, after many hours of hacking around, I've gotten it to <em>sort of</em> work!!</p>
<h2>
<a name="overall-use-impressions-are-mostly-positive-heavy_plus_sign-1" class="anchor" href="https://forum.rebol.info#overall-use-impressions-are-mostly-positive-heavy_plus_sign-1"></a>Overall Use Impressions Are Mostly Positive <img src="https://forum.rebol.info/images/emoji/twitter/heavy_plus_sign.png?v=12" title=":heavy_plus_sign:" class="emoji" alt=":heavy_plus_sign:" loading="lazy" width="20" height="20">
</h2>
<p>Behold:</p>
<pre><code>&gt;&gt; f: make frame! :append
== make frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]

&gt;&gt; f.value: 100

&gt;&gt; ap100: isotopic f  ; synonymous in this case with `runs f`
== ~make frame! [
    series: ~
    value: 100
    part: ~
    dup: ~
    line: ~
]~  ; isotope

&gt;&gt; ap100 [a b c]
== [a b c 100]
</code></pre>
<p><em>That's extremely cool.</em>  Something to really like about it is how it demystifies aspects of how actions are manufactured, making it easier for people to write their own SPECIALIZE-like and APPLY-like tools in usermode...without relying on voodoo inside SPECIALIZE or APPLY natives!</p>
<p><em>Or so it would seem..</em> <strong>BUT</strong>... a bunch of broken cases draws attention to some of the "hidden" logic that makes specialization not so simple.</p>
<p>For instance: if you create functions like <strong>adp: :append/dup/part</strong>, then it loses the /DUP and /PART refinements and instead always takes them, having 4 normal parameters.  And if you said instead <strong>apd: :append/part/dup</strong> then APD would also take 4 normal parameters, but with the PART and DUP in a reversed order from ADP.  The mechanics which encode this aren't visible in the FRAME!... they're little chains of hidden state.  And if you MAKE FRAME! on ADP or APD, then set PART: or DUP: then those chains currently need to be fixed up to know that the fields are specialized out and should no longer be mentioned.</p>
<p>All that has historically been magically covered by SPECIALIZE, which was creating an opaque ACTION! where internally all the bookkeeping was handled for you.  If you are just poking values into a FRAME! and then off the cuff running it--expecting it to act partially specialized--then the current data structures can get out of sync and crash.</p>
<p><strong>It is clearly looking like a massive amount of work to rethink this.  But I believe the product of that rethinking would lead to more complete and coherent model of FRAME!, making it a more powerful user-exposed facility for building actions.</strong></p>
<p>So I think I'm sold on this.  That said, here's some more to say.</p>
<h2>
<a name="plain-frames-in-blocks-execute-2" class="anchor" href="https://forum.rebol.info#plain-frames-in-blocks-execute-2"></a>Plain FRAME!s In BLOCK!s Execute</h2>
<p>This throws a bit of a curveball into how I'd historically segmented FRAME! and ACTION! in my mind...where if you COMPOSE a FRAME! into a block, that it is active:</p>
<pre><code>&gt;&gt; frame: make frame! :add

&gt;&gt; do compose [(frame) 10 20]
== 30
</code></pre>
<p>But if we didn't choose this semantic, then since you can't put isotopes themselves into blocks... all invocations of functions would have to be triggered by word references to isotopic frames.</p>
<p>e.g. if we left frames inert when encountered directly by the evaluator, you'd always need to go through words-pointing-at-isotopes like RUN or APPLY to get execution:</p>
<pre><code>&gt;&gt; do compose [(frame) 10 20]
== 20  ; let's imagine this falls out, last of three inert things

&gt;&gt; do compose [run (frame) 10 20]
== 30
</code></pre>
<p>But then this costs a WORD! lookup and an extra function call, which strikes me as unacceptable overhead to <em>require</em> in order to execute a function.  It's almost as bad as requiring a declaration.</p>
<pre><code>&gt;&gt; do compose [let act: ~(frame)~ act 10 20]  ; just added: quasicompose!
== 30
</code></pre>
<p>It could perhaps be done through some kind of terminal-slash semantic:</p>
<pre><code>&gt;&gt; do compose [(frame)/ 10 20]
== 30
</code></pre>
<p>But that's contentious with my terminal-slash APPLY semantics.  And since frames can't be put in paths directly, it would have to be put in a group in a terminal-slash path, so more cost and complexity added there.</p>
<p><strong>This is all a rehash of things I dealt with back when isotopic actions were first introduced</strong> <a href="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/3">(...and you can read through the stumbling around of that era...)</a>.  I was a bit uncomfortable that the "inert" form of ACTION! would execute when encountered literally in block evaluation.  Sure, it was inert when fetched via word, but was very alive if you composed it in.</p>
<p>Eventually I decided that as long as the key behavior of being fetched via word being inert was met, the semantics when seen literally during a block evaluation didn't matter.  After all, WORD!s require a similar caution to be quoted.</p>
<p>This idea of FRAME! executing seems more unsettling, considering how frames have been inert like objects for so long.  But when you start thinking that FRAME! has <em>execution potential</em>... like GROUP! and WORD! and GET-BLOCK!, etc... then imagining it executing isn't as much of a stretch.  Especially under a new model where it's only an isotope away from running if fetched via word.</p>
<p>Incidentally, if you read the old isotope stumbling around thread, I did mention the idea of isotopic frames executing, July 2022:</p>
<blockquote>
<p><em>What if it's only isotopic ACTION!s that execute implicitly? And what if you can make an isotopic FRAME! that does the same?</em></p>
</blockquote>
<p><strong>How big of an issue this really is depends on how often people compose FRAME! into blocks and execute them when they <em>-DON'T-</em> intend to run them.</strong>  The main case to worry about is the MAKE OBJECT COMPOSE [...] scenario, but I've pointed out how you've got to fret over GROUP! and WORD! and PATH! and any other evaluator-active types.</p>
<p>I <em>think</em> it's acceptable to have FRAME! be another evaluator-active type.  And people who aren't used to it being anything else won't see it through the same lens I'm seeing it now.  Maybe they'll think "hey, it's one isotope away from being WORD!-active, why wouldn't it run?"</p>
<h2>
<a name="messy-molding-3" class="anchor" href="https://forum.rebol.info#messy-molding-3"></a>MESSY MOLDING</h2>
<p>This isn't an entirely new problem, as historical Rebol always had a problem rendering functions.</p>
<p>But Ren-C had been molding ACTION!s compactly as just the cached name of the action (from the last SET-WORD! it was used with), along with a compact list of the parameters.  However, FRAME!s were molded like ordinary objects.</p>
<p>Now it's a bit of a quandary to decide how to do the rendering.  We could say that if the console is showing you an isotopic FRAME!, then it does a light rendering looking like a historical action... but if the frame is normal, then you get the fields.  Which is something I'm probably going to do shortly.  If QUASI-FRAME!s were given this treatment as well, most actions would appear compact.</p>
<p>Anyway, like I say, not particularly a new problem.  The limits of a text console really bite us here...maybe the web REPL can do better.</p>
<h2>
<a name="make-frame-action-of-binding-of-4" class="anchor" href="https://forum.rebol.info#make-frame-action-of-binding-of-4"></a>MAKE FRAME! ACTION OF BINDING OF</h2>
<p>Consider this case of leveraging the linked relationship between an action and a frame:</p>
<pre><code>foo: func [x] [
   f: make frame! action of binding of 'return
   probe f
]
</code></pre>
<p>Now let's say you call it with <strong>foo 1020</strong>.  I would expect <strong>f.x</strong> to be unset, because what we effectively asked for was to <strong>make frame! :foo</strong></p>
<p>But if there was no such question as ACTION OF, and you instead wrote:</p>
<pre><code>foo: func [x] [
   f: make frame! binding of 'return
   probe f
]
</code></pre>
<p>This would mean MAKE FRAME! is taking a FRAME! as input, and in that input frame, X is 1020.</p>
<p>Is it clearly implied that all the variables should be zeroed out?</p>
<p>If this were the case, we'd expect the same from MAKE OBJECT! of an existing object...to get the fields and not the values:</p>
<pre><code> &gt;&gt; obj: make object! [x: 10 y: 20]

 &gt;&gt; obj2: make object! obj
 == make object! [
        x: ~
        y: ~
    ]
</code></pre>
<p>That's not how Red works...it seems to be a synonym for COPY OBJECT.  FWIW, neither Rebol2 nor R3-Alpha permit it.</p>
<h2>
<a name="debugger-queries-find-any-calls-to-action-x-on-stack-5" class="anchor" href="https://forum.rebol.info#debugger-queries-find-any-calls-to-action-x-on-stack-5"></a>Debugger Queries: "Find Any Calls to Action X On Stack"</h2>
<p>There was an old feature in the now-very-defunct-debugger, which allowed you to look above you for stack levels that were "instances of a specific function".</p>
<p>This would be defeated by specialization.  So let's say you made a specialization of append that fixed the value at 5:</p>
<pre><code>ap5: specialize :append [value: 5]
</code></pre>
<p>Calls to this function would not match as calls to APPEND.  They're calls to ap5--and the fact that there's a relationship between AP5 and APPEND would be wiped out.</p>
<p>But now, it's sort of defeated in all cases... because there's not a concept of ACTION OF.</p>
<p>However, maybe this is something that can be worked through in a better way.  <em>A frame with fields filled in, turned into an isotope, is enough to be executable.</em>  So if you want to make a specialization now, you don't go through the opaque step of forming a new action.  The only time you create opaque levels is if you do something like an ENCLOSE or ADAPT.</p>
<p>So there could be something like an "action" in the sense of identity, that you could ask for the "outermost function generator in charge".  It would give the same answer for <strong>:append</strong> and <strong>:ap5</strong> in the new model.  It's kind of like an answer to BODY-OF.</p>
<h2>
<a name="hijack-semantics-6" class="anchor" href="https://forum.rebol.info#hijack-semantics-6"></a>HIJACK Semantics</h2>
<p>HIJACK is one of those things in the system that really throws a wrench into just about everything.  The design is about as clean and clever as I think I can make it, but every time I meddle in the frame and action mechanics something related to HIJACK trips up.</p>
<p>Unfortunately we are now completely dependent on it working, as it's how things like the ReplPad hook into providing its own handling for PRINT and such.</p>
<p>In any case, the granularity for HIJACK was on ACTION!s... not FRAME!s.  So with the two unified into one umbrella idea of a FRAME!, we're only able to hijack "legacy-action-like" FRAME!s and not arbitrary "context-like" FRAME!s.  We can offer an operator to turn a context-like frame into a legacy action frame (you could just ADAPT it with an empty block and get one)...and you could then hijack the result of that.  But you can't specifically hijack the context-like FRAME!s.</p>
<p>It may be that this can be solved with some kind of magic, but I haven't wrapped my head around it, and there are a zillion other things to be solved first.  Suffice to say that the black art of hijacking just got a little darker.</p>
<h2>
<a name="this-is-the-tip-of-the-iceberg-but-7" class="anchor" href="https://forum.rebol.info#this-is-the-tip-of-the-iceberg-but-7"></a>This Is The Tip Of The Iceberg, BUT...</h2>
<p>...I still think it's a winner.  Again... when I look at this, I feel satisfied... the annoyance of ACTION! vs. ACTIVATION! is all washed away:</p>
<pre><code>foo: function [frame [frame!]] [if true [run frame arg1 arg2]]

bar: function [action [action?]] [if true [action arg1 arg2]]

baz: function [frame [frame!]] [let action: runs frame, action arg1 arg2]
</code></pre>
<p>Conceptually, getting to a point where "ACTION" and FRAME! are seen as two sides of the same coin seems coherent: a frame needs to encompass everything you need to know about an action in suspended animation.  I may not be able to get that fully sorted right now, but it points a compass toward how to make decisions in the future.</p>
<p>But it's likely going to force some big internal name changes.  I'd been calling the stack levels internal to the system juggled by the stackless trampoline "Frames"...because whenever you extracted an object-like thing from a FRAME! you'd get it as a "Context".  But now, the design is necessitating a fusion of the guts of what was an "Action" with a "Context" to make a new abstraction...and it seems fated that this abstraction needs to be called a "Frame".</p>
<p>Right now, I'm reusing "Action" as the name of the fused entity...and saying that when it's "legacy-action-like" it's a "Phase", but when it's context like it's an "Exemplar".  But naming disconnects like this create a lot of problems.</p>
<p>So I'll likely rename the internal trampoline entities "Level", and give "Frame" to be what is held by FRAME! values.  There's actually some good arguments for why Level is different from what you'd think of as a traditional "stack frame".  I don't mind it, but it's just a lot of churn...(oh, why do we store source code in ASCII still?)</p> ]]></description>
        <link>https://forum.rebol.info/t/taking-action-on-function-vs-action/596#post_7</link>
        <pubDate>Mon, 13 Nov 2023 10:08:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6727</guid>
      </item>
      <item>
        <title>Taking ACTION! on &quot;Function vs. Action&quot;</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="596">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Whatever we call the "thing-that-is-now-ACTION!", it will come in two forms...</p>
<p><em>The plain form will not execute without an apply.</em></p>
<p><em>The isotopic form will run when referenced through a WORD!</em></p>
</blockquote>
</aside>
<p>Something sort of clicked around in my head when I wondered...</p>
<h2>
<a name="what-if-actions-were-just-isotopic-frames-1" class="anchor" href="https://forum.rebol.info#what-if-actions-were-just-isotopic-frames-1"></a>What if ACTION!s were just isotopic FRAME!s?</h2>
<p><img src="https://forum.rebol.info/images/emoji/twitter/exploding_head.png?v=12" title=":exploding_head:" class="emoji only-emoji" alt=":exploding_head:" loading="lazy" width="20" height="20"></p>
<p>It looks... good.</p>
<pre><code>foo: function [frame [frame!]] [if true [run frame arg1 arg2]]

bar: function [action [action?]] [if true [action arg1 arg2]]

baz: function [frame [frame!]] [let action: runs frame, action arg1 arg2]
</code></pre>
<ul>
<li>
<p>It's clear that FRAME won't do anything when you reference it from a word</p>
</li>
<li>
<p>It's clear that ACTION will run when you reference it from a word</p>
</li>
<li>
<p>It leaves the word FUNCTION free (which over the ages has been determined non-negotiable as semantically meaning MAKE-FUNCTION)</p>
</li>
<li>
<p>Mutating between a frame and an action is easy and obvious</p>
</li>
</ul>
<h2>
<a name="can-it-work-2" class="anchor" href="https://forum.rebol.info#can-it-work-2"></a>Can It Work?</h2>
<p>ACTION!s and FRAME!s actually line up very closely.  They each have as many slots as a function has parameters and locals.  But they use these slots differently.</p>
<p>ACTION!s hold type checking information in the slots for arguments, and the frames point to the actions they were made from to get this information.  This is because the FRAME! slots need to hold actual argument values.  When you DO a FRAME!, it follows the link it kept to its action to do the type checking.</p>
<p><em>Yet in some sense, this is an implementation detail.</em>  There's not really a reason why every frame couldn't have made its own copy of the parameter descriptions...and no reason why the original frame couldn't have empty argument slots.  You could just say that immutable frames "throw away" their argument slots...and copied frames inherit their parameter lists.</p>
<p>The differences could be glossed over by magic under the hood, retaining the current efficiency.  Basically the FRAME! datatype cell would just be able to hold the guts of what an ACTION! cell currently holds as a potential alternative to what it holds currently, and expose those guts as if it were an immutable frame.</p>
<h2>
<a name="usage-difference-3" class="anchor" href="https://forum.rebol.info#usage-difference-3"></a>Usage Difference</h2>
<p>As currently designed, the system would have a bit of a chicken-and-egg problem... you need an ACTION! to make a FRAME!... e.g. <strong><code>make frame! :append</code></strong></p>
<p>But if APPEND was an isotopic frame, and the MAKE FRAME! in this case was just doing basically <strong><code>copy noquote :append</code></strong> ?</p>
<p>In such a world, you'd presumably want to PROTECT or CONST the frame behind APPEND, or you'd wind up with it being too easy to change functions:</p>
<pre><code>&gt;&gt; f: noquote :append
&gt;&gt; f.value: [d e]  ; is actually specializing APPEND!

&gt;&gt; block: [a b c]

&gt;&gt; append block [x y z]
== [x y z]

&gt;&gt; block
== [a b c [d e]]
</code></pre>
<p>But that's fixable with a trustworthy system of immutability (which Ren-C has).</p>
<p>A plain FRAME! that was found inline would have to execute a copy of itself, the way a plain action does today, so this wouldn't do what you likely expected:</p>
<pre><code>make object! compose [f: (frame)]  ; would execute the frame
</code></pre>
<p>This isn't exactly a dealbreaker, because it's par for the course:</p>
<pre><code>make object! compose [w: (word)]  ; would evaluate the word
</code></pre>
<p>So you'd have the usual tools available, same as for other types:</p>
<pre><code>make object! compose [f: '(frame)]
make object! compose [f: (quote frame)]

make object! compose [f: ^(frame)]
make object! compose [f: (meta frame)]
</code></pre>
<h2>
<a name="trying-this-would-raise-many-questions-4" class="anchor" href="https://forum.rebol.info#trying-this-would-raise-many-questions-4"></a>Trying This Would Raise Many Questions</h2>
<p>It's a bizarre thing to do if the <em>only</em> reason is to sift out the naming for a word-inactive vs. word-active function invocation.  Though it does seem to solve it nicely: <em><strong>"ACTION!s are isotopic FRAME!s which DO (a COPY of) themselves if referenced via WORD!"</strong></em></p>
<p>But there are other advantages to reducing the total number of exposed types.</p>
<p>I can think of one advantage already...which is the PARSERs passed to combinators in UPARSE.  Today they are ACTION!s formed from specialized frames, to make them easy to call.  But I noticed that passing them as FRAME!s would be cheaper...as well as permit the choice to execute the frame directly without making a copy, if you were going to call it only once.</p>
<p>There's a disadvantage I can think of too... which is loss of flexibility for interpretation of field selection out of ACTION!s.  Under this model, <strong><code>append.value</code></strong> should be an unset value...as APPEND is an immutable "archetype" frame.  I'd hoped that the <strong>action.xxx</strong> space could be taken for special fields that were associated with the functions, things like <strong><code>append.help</code></strong> for example would be picking from an object associated with APPEND, as opposed to picking useless fields out of the unspecialized frame that APPEND represents.</p>
<p>(Of course, Ren-C has other tricks up its sleeve, and might be able to do this with something like <strong>append..help</strong> for instance.  Today this information is accessed through the peculiarly-named <strong>adjunct of</strong>)</p>
<p>Anyway, still just a thought.  But maybe a unifying thought that's good enough to see what came up trying to implement it.</p> ]]></description>
        <link>https://forum.rebol.info/t/taking-action-on-function-vs-action/596#post_6</link>
        <pubDate>Sun, 12 Nov 2023 00:42:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6726</guid>
      </item>
      <item>
        <title>Rebol And Scopes: Well, Why Not?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>people might say that the Xs and Ys can all resolve to something different.</p>
<pre><code>&gt;&gt; print [x x x y y y]
10 20 "foo" 30 40 "bar"
</code></pre>
<p>I find it personally frustrating when this is pronounced with glee<br>
(...)<br>
If you received a BLOCK! and wanted to go through and say that every SET-WORD! that starts with a vowel is going to be bound to some new object, but others will be left as-is, you can do that.</p>
</blockquote>
</aside>
<p>In thinking about whether or not there's something intrinsically necessary about a per-block (or per-group) differentiation of word-binding, I thought of a case where I'd used this.</p>
<p>In SPECIALIZE, it only binds the SET-WORD!s to the frame you are specializing.  Regular words (and anything else, refinements, etc.) are left bound as they were:</p>
<pre><code>&gt;&gt; value: [d e]

&gt;&gt; apde: specialize :append [
       value: value  ; SET-WORD! is bound to specialization's frame
   ]

&gt;&gt; apde [a b c]
== [a b c [d e]]
</code></pre>
<p>This saves you from the COMPOSE step you'd need otherwise, which is what you have to do with objects:</p>
<pre><code>&gt;&gt; value: [d e]

&gt;&gt; obj: make object! [value: value]
** Script Error: value is ~ isotope

&gt;&gt; obj: make object! compose [value: (value)]
== make object! [
    value: [d e]
]
</code></pre>
<p><strong>I'm not sure it's a critical feature to preserve.</strong>  If it turned out some alternative conception of binding wouldn't permit the inconsistency... and that conception offered some great advantage... I'd be willing to lose it.  There are legitimate arguments against doing such trickery behind people's backs, maybe the COMPOSE helps you keep it straight:</p>
<pre><code>&gt;&gt; value: [d e]

&gt;&gt; ap5: specialize :append [
       value: 5
       assert [value = 5]  ; assertion failure, but I just set it!
   ]
</code></pre>
<p>But I wanted to catalog it as a case of "arbitrary binding logic" that's in place at present.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751#post_6</link>
        <pubDate>Sat, 11 Nov 2023 23:02:07 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6725</guid>
      </item>
      <item>
        <title>Lisps, Kernel, Clojure: limits of &quot;Code is Data and Data is Code&quot;</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I had little-to-no Lisp experience when I encountered Rebol.  I just knew the general concept of "code is data, and data is code", and assumed they were similar.</p>
<p>But as it turns out, <em>executing arbitrary structures of code constructed at runtime is taboo in most Lisps.</em>  This comes under the umbrella of "EVAL", and <a href="https://stackoverflow.com/questions/2571401/why-exactly-is-eval-evil">warned against for all the reasons that people say it's bad in any language</a>...such as why you wouldn't want to run an arbitrary string of JavaScript code.  About the only exception they seem to consider is the Read-Eval-Print-Loop: <strong><code>(loop (print (eval (read))))</code></strong>.</p>
<p>There are warnings about the inefficiency of EVAL not being compiled...or the security concerns of running fully arbitrary code that is cobbled together from possibly unsanitized sources (which Rebol deliberately ignores).</p>
<p>If you're willing to ignore that, you still face the Big Mechanical Problem:</p>
<blockquote>
<p><em>"[EVAL] evaluates under the global environment, losing your local context."</em></p>
</blockquote>
<h2>
<a name="but-if-so-how-do-branches-work-in-lisps-1" class="anchor" href="https://forum.rebol.info#but-if-so-how-do-branches-work-in-lisps-1"></a>But If So... How Do Branches Work in Lisps?</h2>
<p>If you have a branching function like EITHER, and it has two legs of the branch with the intent to only run one of them... doesn't that require selectively running an "EVAL"?  The EITHER receives a condition and then two "blocks" (lists) specifying arbitrary code.  If you lose all your local variables known at the callsite of the EITHER, how can it work?</p>
<p>The answer depends on which Lisp variation you are using.  If you are using a classical Lisp (or Clojure), it simply has a list of exceptions... or "special forms".  These constructs are treated weirdly by the compiler and it's just swept under the rug.  For example:</p>
<p><strong><a href="https://clojure.org/reference/special_forms">Special Forms in Clojure</a></strong></p>
<p>Another possibility would be if there was some kind of environment capture at the callsite, and the EITHER received this environment as a parameter.  Then it could pass that environment to EVAL...so the eval would happen as if it were at the callsite.</p>
<p>Were that written in a Rebol-like syntax, it would be quoting all its arguments and look like:</p>
<pre><code> either: func [
     'condition [group!]  ; conditions would have to be grouped
     'true_branch [block!]
     'false_branch [block!]
     &lt;environment&gt; env  ; implicit capture of environment at callsite
 ][
     if do/environment condition env [  ; let's say IF is a native
         return do/environment true_branch env
     ]
     return do/environment false_branch env
 ]
</code></pre>
<p>Now that you're familiar with the idea, here is that written in how the <a href="https://web.cs.wpi.edu/~jshutt/kernel.html">"Kernel" Lisp Variant</a> does it:</p>
<pre><code>($define! $either
   ($vau (condition true_branch false_branch) env
       ($if (&gt;=? (eval condition env) 0)
           (eval true_branch env)
           (eval false_branch env))))
</code></pre>
<p>Notably, <strong>Kernel is considered a very experimental black-sheep of the Lisp world</strong>, due to how much slower this generalized method of thinking is.  Special forms understood by the compiler are the norm.</p>
<p>However, being able to pass environments to EVAL is <a href="https://www.gnu.org/software/texinfo/gsoc-2017-js-example/kawa/Eval-and-Environments.html">seemingly endorsed in modern Scheme</a>.  But that's not a feature of Clojure.</p>
<h2>
<a name="macros-cover-some-monkeying-with-code-structure-cases-2" class="anchor" href="https://forum.rebol.info#macros-cover-some-monkeying-with-code-structure-cases-2"></a>Macros Cover Some Monkeying-With-Code-Structure Cases</h2>
<p>Lisp Macros can be used for source-to-source transformations, manipulating structure in the free-wheeling way we might think of doing in Rebol.  But that transformation happens only once.</p>
<p>This Reddit question <a href="https://www.reddit.com/r/lisp/comments/13rmllb/difference_between_function_with_quoted_arguments/">asks about the difference between macros and receiving arguments unevaluated</a>:</p>
<blockquote>
<p><em>"If we put a backtick in front of the body of a function and we pass arguments quoted when calling it, wouldn't the function work the same as a macro (except that macros are evaluated in an earlier stage)? What would be the difference in practice? And how does this approach compare to fexpr?"</em></p>
</blockquote>
<p>The answers outline the difference... macros just run once, and they don't call EVAL on the code they get... they just return new code which will be evaluated later.  If you wrote something like an EITHER as a macro, you would have to transform it into IFs, and be dependent on the special forms to do the actual "weird" mechanic.</p>
<h2>
<a name="isnt-this-kind-of-weak-for-the-data-is-code-mantra-3" class="anchor" href="https://forum.rebol.info#isnt-this-kind-of-weak-for-the-data-is-code-mantra-3"></a>Isn't This Kind of Weak for the "Data is Code" Mantra?</h2>
<p>It does seem disappointing.  :-/</p>
<p>But Lisps haven't taken over the world, and maybe this is part of why.</p> ]]></description>
        <link>https://forum.rebol.info/t/lisps-kernel-clojure-limits-of-code-is-data-and-data-is-code/2060#post_1</link>
        <pubDate>Sat, 11 Nov 2023 21:52:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6724</guid>
      </item>
      <item>
        <title>The Language World&#39;s Weirdest COMMA! Mechanic</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1387">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>e.g. <em>How bad would it be if the BARRIER_HIT mechanics went away, and we simply leveraged the idea that commas evaluated to nihil...and most functions refuse nihil arguments?</em></p>
</blockquote>
</aside>
<h2>
<a name="so-the-bad-news-is-i-dont-think-this-holds-water-1" class="anchor" href="https://forum.rebol.info#so-the-bad-news-is-i-dont-think-this-holds-water-1"></a>So the <em>Bad</em> news is, I don't think this holds water...</h2>
<p>If you have functions that can take a varying number of arguments, and <strong>(foo 10)</strong> means something different and legitimately distinct from <strong>(foo)</strong>...</p>
<p>... then you probably want <strong>(foo, foo)</strong> to act equivalently to <strong>((foo) (foo))</strong>, and not give an error.</p>
<p>And if you try to accomplish that by saying COMMA! vaporizes as NIHIL, but then establish that anything evaluating to NIHIL acts as an expression barrier, it's bad.  Worse now <a href="https://forum.rebol.info/t/why-doesnt-print-return-void-or-vaporize-via-nihil/1466/5">in a world where PRINT returns NIHIL</a>...</p>
<p>Why worse?  Because it means <strong>foo print "Hi"</strong> will act like <strong>(foo) print "Hi"</strong>.  That's not intuitive, if you think of foo as a function that generally takes arguments.  PRINT doesn't seem like something that has this magic "stopping power" of things on its left (or right) from consuming arguments.</p>
<p>So do I have to bring back those clunky and non-configurable internal BARRIER_HIT mechanics?  <strong>NO</strong>...because....</p>
<h2>
<a name="the-good-news-is-a-new-isotope-can-solve-it-atom_symbol-2" class="anchor" href="https://forum.rebol.info#the-good-news-is-a-new-isotope-can-solve-it-atom_symbol-2"></a>The <em>Good</em> News is, A New Isotope Can Solve It!  <img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=12" title=":atom_symbol:" class="emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20">
</h2>
<p>We essentially just need a way for constructs to generate an isotope which disappears in interstitals like an empty pack (nihil)... <em>but</em> represents the additional nuance of expression-barrier-ness with simulating <code>&lt;end&gt;</code> and curtailing lookahead.</p>
<p><strong>COMMA! Isotopes Are Up For The Job!</strong></p>
<p>If we let commas evaluate to comma isotopes and give them this behavior, then anyone who wants to mimic it can simply have their function return an isotopic comma...and they'll act like a barrier too.  So let's call a comma isotope a BARRIER.</p>
<p>It may sound like a headache to check for another type.  But having a test which checks for either NIHIL? or BARRIER? is easy enough to make for if you don't care about the difference.  I chose to call that ELISION? because trying to find another word that means nothing (e.g. well, NOTHING?) would throw in a fair bit of confusion with whether that subsumed VOIDs or NONEs.</p>
<h2>
<a name="it-gets-rid-of-this-weird-workaround-3" class="anchor" href="https://forum.rebol.info#it-gets-rid-of-this-weird-workaround-3"></a>It Gets Rid Of This Weird Workaround</h2>
<p>I mentioned how PACK was built on REDUCE-EACH and was having trouble putting nihils in packs with commas.  That problem goes away now, so this is no longer necessary:</p>
<pre><code>; REDUCE-EACH is the basis of functions like PACK, and hence by default it
; wants to skip over commas.  However, there's an option which will give you
; the isotopic word ~comma~ when it gets a barrier.  This will be conflated
; with evaluations that produce ~comma~ unless ^META variable used.
[
    (['3 '30 ~comma~] = collect [
        reduce-each x [1 + 2, 10 + 20 ~comma~] [keep ^x]
    ])
    (['3 ~comma~ '30 ~comma~] = collect [
        reduce-each/commas x [1 + 2, 10 + 20 ~comma~] [keep ^x]
    ])

    ([''3 ''30 '~comma~] = collect [
        reduce-each ^x [1 + 2, 10 + 20 ~comma~] [keep ^x]
    ])
    ([''3 ~comma~ ''30 '~comma~] = collect [
        reduce-each/commas ^x [1 + 2, 10 + 20 ~comma~] [keep ^x]
    ])
]
</code></pre>
<h2>
<a name="but-is-this-too-many-moving-parts-face_with_spiral_eyes-4" class="anchor" href="https://forum.rebol.info#but-is-this-too-many-moving-parts-face_with_spiral_eyes-4"></a>But Is This Too Many Moving Parts?  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_spiral_eyes.png?v=12" title=":face_with_spiral_eyes:" class="emoji" alt=":face_with_spiral_eyes:" loading="lazy" width="20" height="20">
</h2>
<p><strong>I'm pretty sure it isn't.</strong></p>
<p>The reason I say this is simply because flags like FEED_FLAG_BARRIER_HIT were instituted a long, long time ago.  They were products of necessity, because I've always felt that Rebol without some kind of expression barrier concept was downright unreadable.</p>
<p>But my tries to implement this have always represented a thorn in terms of hidden state.  I had to imagine strange places to represent the barrier-ness, like <em>"what if that's what being enfix but taking no arguments meant"</em>.</p>
<p>This brings it all out in the open.  Some routines will hide it, and others won't.  It's already showing much more promise than what it was replacing.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387#post_7</link>
        <pubDate>Thu, 02 Nov 2023 17:47:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6722</guid>
      </item>
      <item>
        <title>Semantics of UPARSE&#39;s FURTHEST</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1868">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I made <strong>FURTHEST</strong> a multi-return value. The hooked combinators are run, and then if they succeed they're checked to see if they got further than any previous combinator. If so they update furthest.</p>
<pre><code>&gt;&gt; [_ furthest]: uparse "aaabbb" [some "a" some "c"]
; null

 &gt;&gt; furthest
 == "bbb"
</code></pre>
</blockquote>
</aside>
<p><strong>Giving back FURTHEST as a multi-return had to be axed, for several reasons.</strong></p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/axe.png?v=12" title=":axe:" class="emoji only-emoji" alt=":axe:" loading="lazy" width="20" height="20"></p>
<p>For one thing: <strong><a href="https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924">PARSE now raises a definitional error when it does not reach the end of input.</a></strong>  Returning an error isotope is fundamentally incompatible with unpacking return values from a returned block isotope, you can't do both!</p>
<p>And secondly: PARSE is designed to allow you to use the full bandwidth of return values, including multi-returns.  This means combinators themselves might be multi-returns <em>(I've suggested TALLY could be a multi-returner, giving the count as a primary product but also including the synthesized product)</em>:</p>
<pre><code> &gt;&gt; [count result]: parse "aaa" [tally ["a" ('a)] | tally ["b" ('b)]]]
 == 3

 &gt;&gt; count
 == 3

 &gt;&gt; result
 == a
</code></pre>
<p>Or you can just explicitly evaluate to a muti-return PACK from a group evaluation, for whatever reason...</p>
<pre><code>parse "..." [... accept (pack [&lt;a&gt; 2]) ...]
</code></pre>
<h2>
<a name="stop-gap-measure-a-crappy-furthest-hook-1" class="anchor" href="https://forum.rebol.info#stop-gap-measure-a-crappy-furthest-hook-1"></a>Stop-Gap Measure: a "Crappy" FURTHEST Hook</h2>
<p>An early adaptation of <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a>'s Query had used the FURTHEST return value from UPARSE.  But that needed to backtrack into painful inclusion of <strong><code>furthest: &lt;here&gt;</code></strong> markers in every rule.  That's no good.</p>
<p>But UPARSE's generic hookability allows for a <strong><a href="https://forum.rebol.info/t/visualizing-parse/1639/8">rule-stepwise debugger</a></strong> <img src="https://forum.rebol.info/images/emoji/twitter/eyes.png?v=12" title=":eyes:" class="emoji" alt=":eyes:" loading="lazy" width="20" height="20"></p>
<p>So of course, simply asking how far it got is not hard to ask for.  Just use a hook which writes to a variable you specify.  I hacked this up separately as PARSE-FURTHEST:</p>
<pre><code>&gt;&gt; parse-furthest "aaabbb" [some "a" some "c"] 'far except [
       print ["Furthest was:" mold far]
   ]

Furthest was: "bbb"
</code></pre>
<p>Well, it's better than nothing!</p>
<h2>
<a name="but-what-do-we-really-want-2" class="anchor" href="https://forum.rebol.info#but-what-do-we-really-want-2"></a>But What Do We Really Want?</h2>
<p>One way of looking at this could be that FURTHEST is a field in the error that gets returned.</p>
<pre><code>&gt;&gt; parse "aaabbb" [some "a" some "c"] except e -&gt; [
       assert [e.id = 'incomplete-parse]  ; only raised error?
       print ["Furthest was:" mold e.furthest]
   ]
</code></pre>
<p>That's not bad, other than it seems there might be a lot of things you want to know about a failed parse besides just FURTHEST.  You'd want to know the actual parse position, but other aspects about the rule state as well.  Is it too much stuff to pack into an error object?</p>
<p>You might have been keeping running track of the line and column (which I've wanted to find a way to expose via <strong><code>&lt;line&gt;</code></strong> and <strong><code>&lt;column&gt;</code></strong> combinators, where applicable).  That has to be updated as the parse proceeds, you wouldn't want to have to recalculate that in case of an error...?</p>
<p>So it seems to me that there may be need for a parse state object which can be made available to reflect after a parse that's successful -or- unsuccessful.  The PARSE function would be a convenient wrapper on top of this, but you could dig deeper for more serious needs.</p>
<p>For right now, the PARSE-FURTHEST hack keeps the mechanism behind the functionality tested, but there's clearly a lot to think about here (and I believe looking at Haskell for inspiration on these kinds of questions is wise).</p> ]]></description>
        <link>https://forum.rebol.info/t/semantics-of-uparses-furthest/1868#post_2</link>
        <pubDate>Thu, 02 Nov 2023 04:54:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6721</guid>
      </item>
      <item>
        <title>ReplPad Visual PARSE Debugger</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Great video. A pity I will not be able to watch it (again) because of YT's crusade against ad-blockers. I stopped using YT and started to boycot its advertisers and gave them notice of why I returned my orders.</p> ]]></description>
        <link>https://forum.rebol.info/t/replpad-visual-parse-debugger/2063#post_3</link>
        <pubDate>Fri, 27 Oct 2023 20:31:13 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6720</guid>
      </item>
      <item>
        <title>ReplPad Visual PARSE Debugger</title>
        <dc:creator><![CDATA[@BlackATTR Black Attr]]></dc:creator>
        <description><![CDATA[ <p>Bravo ! Nicely done !</p> ]]></description>
        <link>https://forum.rebol.info/t/replpad-visual-parse-debugger/2063#post_2</link>
        <pubDate>Thu, 26 Oct 2023 14:47:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6719</guid>
      </item>
      <item>
        <title>ReplPad Visual PARSE Debugger</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Hey!  I've gotten UPARSE hooked up to a debugger:</p>
<p><a href="https://www.youtube.com/watch?v=doS7NgajRxI">Ren-C PARSE Hook Demo: Debugging</a></p>

<p>The ability to step in at every level shows just how granular the hook is.  It's not a terrible lot of code:</p>
<p><a href="https://github.com/hostilefork/replpad-js/blob/eb8a62054d345f798b3b87364943df3534a7b92e/eparse.reb#L334">https://github.com/hostilefork/replpad-js/blob/eb8a62054d345f798b3b87364943df3534a7b92e/eparse.reb#L334</a></p>
<p>It's barely tested, but it is public on the ReplPad if anyone wants to throw something at it.</p>
<h2>
<a name="what-concerns-did-writing-this-raise-1" class="anchor" href="https://forum.rebol.info#what-concerns-did-writing-this-raise-1"></a>What Concerns Did Writing This Raise?</h2>
<p>Having the debugger in the ReplPad gives an immediate user annoyance: <em>Why can't I type in the console while the debugger is running?</em>  (That's a huge can of worms and requires several posts of its own to talk about.)</p>
<p>The design of UPARSE is that you can provide your own set of combinators to use.  You can give it a new WORD! combinator that does something besides fetch what the word looks up to and "act like it would if it were written there".  While this simple tracing facility can handle generic interpretations, the generality could subvert the usefulness of higher level tools.</p>
<p>Beyond that problem of "words may not look things up at all", there's also the problem of "discovery".  Everything is "discovered" as you go along--there's not a list supplied up front.  That may not be a fit for some tools, so they could end up asking you to pass in the names of all the rules of interest even though they don't need to be "instrumented".</p>
<p>I thought of adding a BREAKPOINT combinator, so you could break in mid-parse.  But I was only building up a list modeling the stack for frames while you were interacting with the buttons.  Having the stack always available at an arbitrary moment would mean that the stack model would have to be updated on every call to the hook.  Effectively this duplicates information held in the "real stack"--the subset of function calls that represent combinators.  So it's tempting to find a way to label stack frames and enumerate them generically, vs. expecting all debuggers like this to maintain their own.</p>
<p>There's a lot to think about, here.  But as Rebol in the browser goes, this really is the only game in town, and it's holding up pretty well whenever I exercise it!</p> ]]></description>
        <link>https://forum.rebol.info/t/replpad-visual-parse-debugger/2063#post_1</link>
        <pubDate>Thu, 26 Oct 2023 02:19:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6718</guid>
      </item>
      <item>
        <title>Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1825">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'll give it a shot and see what the effects are.</p>
</blockquote>
</aside>
<p>So I rather quickly ran into the fact that PICK is shared code with what you get when you are using a tuple.  So <strong>pick block 3</strong> acts like <strong>block.3</strong>, and <strong>pick obj 'field</strong> acts like <strong>obj.field</strong>, etc.</p>
<p>But there's an important difference: <strong>obj.field</strong> can run a function.  And if you write <strong>try obj.field</strong> the expectation is that your TRY is processing the result of that function...not errors arising from the field selection itself.  :-/</p>
<p>A thought that crossed my mind was that perhaps <strong>/obj.field</strong> could be a notation for "field presence is optional" and give back null if it's not there, and <strong>/block.3</strong> could do the same thing.  I'd often thought that refinements were wasted as being inert, and since they exist in other places meaning "optionality" then something like this could be an application.</p>
<p>But <a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">new APPLY uses inert refinements to good effect</a>, so I'm reluctant to pursue something like that.</p>
<p><strong>Long Story Short: There's no real reason why <code>(pick block 3)</code> and <code>(block.3)</code> can't have different error modes, but <code>(try block.3)</code> can't defuse a definitional error for the pick without generating a disconnect from <code>(try object.funcname)</code></strong>.</p>
<p>For the moment, picking things that aren't there gives null on blocks, and errors on objects.  It's a bit misshapen but some code would be more laborious to write if things like <code>block.3</code> would error, forcing you to use (try pick block 3).  And you really would have to put it in parentheses in many cases, because expressions like (block.3 = 'foo) would require ((try pick block 3) = 'foo)</p>
<p>Maybe it should be laborious?  Anyway, food for thought.</p> ]]></description>
        <link>https://forum.rebol.info/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825#post_4</link>
        <pubDate>Tue, 24 Oct 2023 16:10:28 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6717</guid>
      </item>
      <item>
        <title>Visualizing PARSE</title>
        <dc:creator><![CDATA[@Brett]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1639">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I assume it's probably using methods that parallel parse-analysis-view.r.</p>
</blockquote>
</aside>
<p>Similar, though if I've understood on my brief glance, it looks like it's attempting to scan the rules to track events. I went with the dumber/simpler/possibly less fragile - let the user decide which rules to track and wrap those to create the event tracking.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1639">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Boris doesn't seem to have done blocks.</p>
</blockquote>
</aside>
<p>I win <img src="https://forum.rebol.info/images/emoji/twitter/laughing.png?v=12" title=":laughing:" class="emoji" alt=":laughing:" loading="lazy" width="20" height="20">  or won nearly 20 years ago <img src="https://forum.rebol.info/images/emoji/twitter/face_with_open_eyes_and_hand_over_mouth.png?v=12" title=":face_with_open_eyes_and_hand_over_mouth:" class="emoji" alt=":face_with_open_eyes_and_hand_over_mouth:" loading="lazy" width="20" height="20"></p> ]]></description>
        <link>https://forum.rebol.info/t/visualizing-parse/1639#post_7</link>
        <pubDate>Tue, 24 Oct 2023 06:18:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6716</guid>
      </item>
      <item>
        <title>MOLD/ONLY vs. MOLD SPREAD</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Historically, the way you would ask to mold an array without its delimiters was with MOLD/ONLY:</p>
<pre><code>rebol2&gt;&gt; mold [a b c]
== "[a b c]"

rebol2&gt;&gt; mold/only [a b c]
== "a b c" 
</code></pre>
<p>In Ren-C this raises some existential questions, like how should quoted arrays be handled?</p>
<pre><code>mold/only first [''(a b c) d e]  ; ???
</code></pre>
<p>But I think there's a better answer: <em>use SPREAD and splice isotopes</em>.  If you want to mold the contents of an array, then turning it into a splice seems the natural answer.  And since you can't have splices of quoted things...there's a nice unambiguous answer.</p>
<pre><code>&gt;&gt; mold [a b c]
== "[a b c]"

&gt;&gt; mold spread [a b c]
== "a b c"
</code></pre>
<p>It does raise the question of what to do if you have something that might be an array or might not.  How do you tell it to mold as is if it's not an array, or without the delimiters if it is?  That's what MOLD/ONLY did, after all:</p>
<pre><code>rebol2&gt;&gt; mold/only [b l o c k]
== "b l o c k"

rebol2&gt;&gt; mold/only &lt;tag&gt;
== "&lt;tag&gt;"
</code></pre>
<p><em>"SPREAD won't SPREAD tags..."</em> you say.  And no, it won't.  But I think this is a rare case... and the neat thing about putting the bit on the value (as opposed to a refinement) is you can make functions like SPREAD-OR-AS-IS.  Or SPREAD-IF-PATH-OR-GROUP.  You can really tweak this however you want.</p>
<pre><code>&gt;&gt; mold spread-or-as-is &lt;tag&gt;
== "&lt;tag&gt;"

&gt;&gt; mold spread-or-as-is "[b l o c k]"
== "b l o c k"

&gt;&gt; spread-if-path-or-group 'p/a/t/h
== ~(p a t h)~  ; isotope

&gt;&gt; mold spread-if-path-or-group 'p/a/t/h
== "p a t h"
</code></pre>
<p>How about THAT?  All of this hinges on the idea that MOLD doesn't generally know how to mold isotopes, as they have no representation.  It just chooses to interpret the request to mold a splice isotope as "contents matter, no delimiters".</p>
<p>More control, more clarity, and the death of another /ONLY.  What more could you ask for?</p> ]]></description>
        <link>https://forum.rebol.info/t/mold-only-vs-mold-spread/2059#post_1</link>
        <pubDate>Sun, 22 Oct 2023 23:59:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6715</guid>
      </item>
      <item>
        <title>Visualizing PARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Boris has made something called "Parse SEE", which is a less-featured variation of parse-analysis-view.r.</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/4fd781b0ea4c1fd06c1df4b40edb3983f6d96d4e.png" data-download-href="https://forum.rebol.info/uploads/default/4fd781b0ea4c1fd06c1df4b40edb3983f6d96d4e" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/4fd781b0ea4c1fd06c1df4b40edb3983f6d96d4e.png" alt="image" data-base62-sha1="bojrkY59mTHxpbcb6XhsaCZ1Jxk" width="385" height="500" data-dominant-color="F6F1C7"></a></div><p></p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/66cc390d8ffc243f8ea67e6144b2e43469ca754b.gif" alt="demo-parsee-case-xml" data-base62-sha1="eFoflcNN8bDuUw0MeIpjvylB7Fp" width="419" height="500" class="animated"></p>
<p><a href="https://codeberg.org/hiiamboris/red-spaces/src/branch/master/programs/parsee.red">Here's the code for %parsee.red</a>.</p>
<p>I'm a bit confused because I thought Red offered some kind of events back from PARSE as callbacks and this would be based on that, but I see no indication that the call to PARSE uses the /TRACE refinement.  Without an in-depth analysis of uncommented code, I assume it's probably using methods that parallel parse-analysis-view.r.</p>
<p>There's one comment, about needing to "extract the names":</p>
<pre><code>;; I haven't found any other way to extract the names
;; I tried collecting first words of the 'fetch' event,|
;; but sometimes it may be at 'opt name' and who knows what other cases are possible
</code></pre>
<aside class="quote no-group" data-username="Brett" data-post="1" data-topic="1639">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/brett/40/177_2.png" class="avatar"> Brett:</div>
<blockquote>
<p>Mapping strings was easy, mapping block input was a pain.</p>
</blockquote>
</aside>
<p>Boris doesn't seem to have done blocks.</p> ]]></description>
        <link>https://forum.rebol.info/t/visualizing-parse/1639#post_6</link>
        <pubDate>Sun, 22 Oct 2023 14:16:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6714</guid>
      </item>
      <item>
        <title>UNION, INTERSECT, DIFFERENCE...and Splices</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2058">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>In the Rebol model, "modify by default" is how things like APPEND or REVERSE work.</p>
</blockquote>
</aside>
<p>There's a mechanical question of what this would mean for series not at their head:</p>
<pre><code>&gt;&gt; block: [a b c d]

&gt;&gt; union skip block 2 spread [b e]
== [c d b e]

&gt;&gt; block
== [a b c d b e]
</code></pre>
<p>I ran across this when I tried to implement a little hack to test and see what the general experience of mutable set operations would be like.  The need for this behavior breaks the hack.  :-/</p> ]]></description>
        <link>https://forum.rebol.info/t/union-intersect-difference-and-splices/2058#post_2</link>
        <pubDate>Sun, 22 Oct 2023 08:31:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6713</guid>
      </item>
      <item>
        <title>UNION, INTERSECT, DIFFERENCE...and Splices</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>There is a pattern that comes up a lot in Query which looks like this:</p>
<pre><code>if not find qe.clause-list 'update [append qe.clause-list 'update]
</code></pre>
<p>You could use an operation like UNION here, but since UNION only works on arrays you'd have to put UPDATE in a block:</p>
<pre><code>qe.clause-list: union qe.clause-list [update]
</code></pre>
<p>If the word to update with was in a variable (e.g. <strong>word: 'update</strong>), you couldn't do that block literally...so you'd need some blockifying function to do it:</p>
<pre><code>qe.clause-list: union qe.clause-list compose [(word)]

qe.clause-list: union qe.clause-list reduce [word]

qe.clause-list: union qe.clause-list :[word]

qe.clause-list: union qe.clause-list enblock word
</code></pre>
<h2>
<a name="semantics-of-operating-on-arrays-1" class="anchor" href="https://forum.rebol.info#semantics-of-operating-on-arrays-1"></a>Semantics of Operating on Arrays</h2>
<p>Historical Rebol would only accept BLOCK!s as the second argument to these operations.  I didn't see any reason not to generalize it, so I allowed GROUP!s as well:</p>
<pre><code>&gt;&gt; intersect [a b c d] '(b c e)
== [b c]

&gt;&gt; intersect '(a b c d) [b c e]
== (b c)
</code></pre>
<p>But there's a little bit of a question there about the result type.  Both arrays are taken account in terms of the elements, but only the first determines the type.  That's a little bit odd.</p>
<p>Furthermore, what if you wanted to intersect an array as an item?  The following wouldn't give you what you intended:</p>
<pre><code>item: [b]
collection: [[a] [b] [c] [d]]

collection: intersect collection item
</code></pre>
<p>You'd have to put the block into another block.  This is another one of those /ONLY style problems...</p>
<h2>
<a name="with-spread-we-can-do-this-better-2" class="anchor" href="https://forum.rebol.info#with-spread-we-can-do-this-better-2"></a>With SPREAD, we can do this better!</h2>
<p>We can make it so that UNION and friends assume you mean just one item by default, and you need to SPREAD the second argument to get it considered itemwise:</p>
<pre><code>&gt;&gt; union [a b c d] 'e
== [a b c d e]

&gt;&gt; union [[a] [b] [c] [d]] [e]
== [[a] [b] [c] [d] [e]]

&gt;&gt; union [[a] [b] [c] [d]] spread [e]
== [[a] [b] [c] [d] e]
</code></pre>
<p>So this means the operation from Query could be a little more succinct:</p>
<pre><code>if not find qe.clause-list 'update [append qe.clause-list 'update]
=&gt;
qe.clause-list: union qe.clause-list 'update
</code></pre>
<p>But more importantly, the as-is nature would avoid needing to jump through hoops for single-item operands:</p>
<pre><code> word: update
qe.clause-list: union qe.clause-list word
</code></pre>
<p>There are some questions about whether there is a guarantee of where the update would be added if it wasn't there... does it matter if it's added at the beginning or the end?</p>
<p>This is not a new question for these operations... the blocks are being treated as sets, so theoretically multiple answers could be valid:</p>
<pre><code>&gt;&gt; intersect [a b c d] spread [c b e]
== [b c]

 &gt;&gt; intersect [a b c d] spread [c b e]
== [c b]  ; what promises this wouldn't be the answer?
</code></pre>
<p>I think it's likely beneficial to make some kind of promise here.</p>
<h2>
<a name="should-unionetc-mutate-by-default-3" class="anchor" href="https://forum.rebol.info#should-unionetc-mutate-by-default-3"></a>Should UNION/etc. mutate by default?</h2>
<p>I point out that you'd have to write:</p>
<pre><code>qe.clause-list: union qe.clause-list 'update
</code></pre>
<p>In the Rebol model, "modify by default" is how things like APPEND or REVERSE work.  That would suggest you could write:</p>
<pre><code>union qe.clause-list 'update
</code></pre>
<p>And if you didn't want to modify qe.clause-list directly, you could copy it:</p>
<pre><code>result: union copy qe.clause-list 'update
</code></pre>
<p>If the interface to these functions was changed to work with splices and treat everything else as-is by default, it seems like a good time to make this change for consistency.</p> ]]></description>
        <link>https://forum.rebol.info/t/union-intersect-difference-and-splices/2058#post_1</link>
        <pubDate>Sun, 22 Oct 2023 06:06:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6712</guid>
      </item>
      <item>
        <title>Why Doesn&#39;t `(third [1 2])` Trigger A Range Check Error?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1825">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So I guess I'll just say that experience has borne out that soft failure is a more convenient for functions like THIRD than raising an error. If anyone finds a case where they don't think so, I'd be interested to see it.</p>
</blockquote>
</aside>
<p>Nowadays there's an option on the table for raising <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">definitional errors</a>, which could easily be turned into nulls with <strong>try third (...)</strong></p>
<pre><code>&gt;&gt; third [a b]
** Error: Cannot pick 3 of BLOCK! (or somesuch)

&gt;&gt; try third [a b]
== ~null~  ; isotope
</code></pre>
<p><sub><em>(I've mentioned that this is different from the limited design of Rebol's historical errors, e.g. if you said <strong>attempt [third [a b]]</strong> in an R3-Alpha or Red that errored, it would give null back...but so would <strong>attempt [thirrd [a b]]</strong> because the lack of definitional-ism means it couldn't discern errors arising from a direct call from typos or other downstream errors.)</em></sub></p>
<p>For cases where you would have been trusting a THIRD that returns NULL to trigger downstream errors, this gives better error locality.  e.g. <strong>append [a b c] third [d e]</strong> would blame the THIRD, not the append.</p>
<p>And for cases where you might not be able to trust that NULL wouldn't be interpreted as an error downstream, it would be more robust.  Also you'd give readers a clue at the callsite when you actually were intending that the operation might fail by the presence of the TRY.</p>
<p>This comes down down to the behavior of PICK (since FIRST is a specialization of PICK).  I was just thinking about that with respect to objects:</p>
<pre><code>&gt;&gt; obj: make object! [x: 10]

&gt;&gt; pick obj 'x
== 10

&gt;&gt; pick obj 'y
** Error: y is not a field of object

&gt;&gt; try pick obj 'y
== ~null~
</code></pre>
<p>If we raised a definitional error out of pick in this case, then you could <strong>try pick</strong> and get null.</p>
<p>When you think about PICK in general beyond just the block case, it does seem like more uniformly giving an error which can be "softened" via TRY would be a good idea.  I'll give it a shot and see what the effects are.</p> ]]></description>
        <link>https://forum.rebol.info/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825#post_3</link>
        <pubDate>Sat, 21 Oct 2023 14:58:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6711</guid>
      </item>
      <item>
        <title>From Liability to Asset: WORD! and PATH! always running code</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1354">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But being able to make member access look the same when calling a function or not is a sought-after ability in other languages. Most discussions of the feature involve <em>"Property Getters and Setters"</em>...where you can override non-parentheses access and assignment for a field.</p>
</blockquote>
</aside>
<p>I found another case where this would have come in handy...</p>
<p>Some code was written to access global variables in Query, that I moved into an object.</p>
<p>To change less code, I thought about just making a shorthand to pick the member out of the object.  It would only be able to read, but most usages were reads.  You could even PROTECT it, to stop you from overwriting the helper.  Like this:</p>
<pre><code>sc: does [qe.sc], protect 'sc
</code></pre>
<p>The hope was that existing references to the global as just <strong><code>sc</code></strong> would continue to work.</p>
<p>It works for retrieving the object, but not selecting fields out of it.</p>
<pre><code>&gt;&gt; sc
== make object! [...]

&gt;&gt; sc.field
** Script Error: sc is ~#[action! {sc} []]~ isotope (see ^(...) and GET/ANY)
</code></pre>
<p>The tuple reference is trying to pick FIELD out of the <em>function itself</em>, not out of the result of the function.  You have to write <strong><code>(sc).field</code></strong></p>
<p>If SC had some magic to make it a property getter/setter, then both assignments and references could be made to work.  It's worth thinking about...</p> ]]></description>
        <link>https://forum.rebol.info/t/from-liability-to-asset-word-and-path-always-running-code/1354#post_7</link>
        <pubDate>Fri, 20 Oct 2023 15:31:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6710</guid>
      </item>
      <item>
        <title>How to deal with users mutating DATE! and TIME! to be invalid?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="240">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One difference is sort of a technical issue with comparison semantics. Right now comparison is based on a function that returns -1 for less than, 0 for equal, or 1 for greater than. This means there's no way to have a different error condition regarding the precision based on whether you're doing a test for equality or greater than / less than, because the comparison function doesn't know which is being requested.</p>
<p>Hence these tests fail, just as doing the other comparisons do:</p>
<pre><code>(not equal? date-110 date-100)
(not equal? date-111 date-100)
</code></pre>
</blockquote>
</aside>
<p>Pragmatically speaking, it has turned out that not being able to do comparisons or equality on dates with different specificity is a pain.  When I actually had to deal with this by working on the Query dialect, it made a mess of things.  Being forced to canonize the dates in the code generated ugly output, and then forced every other comparison down the pipe to canonize...it spreads like a virus.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>So I've instead decided to go with the idea that dates are equal if you compare a less-specific to a more specific one with the same parts.</p>
<pre><code>&gt;&gt; 26-Jul-2021/7:41:45.314 = 26-Jul-2021
== ~true~  ; isotope
</code></pre>
<p>If there are time zones involved, then the time is adjusted to UTC before the comparison.  There's not really another sensible way to approach the problem--you don't want comparisons to be based on the local machine's time zone (for instance) so different machines would compare the same literal values differently.</p>
<p>I made the greater and less than comparisons come back false:</p>
<pre><code>&gt;&gt; 26-Jul-2021/7:41:45.314 &gt; 26-Jul-2021
== ~false~  ; false

&gt;&gt; 26-Jul-2021/7:41:45.314 &lt; 26-Jul-2021
== ~false~  ; isotope
</code></pre>
<p>This break with the tradition in Rebol that plain &gt; and &lt; are based on strict equality (there's no strict-greater-than? and strict-lesser-than?).  That generates some odd behavior, where e.g. floating point values can be both less than <em>and</em> equal to each other:</p>
<pre><code>r3-alpha/red&gt;&gt; -4.94065645841247E-324 &lt; 0.0
== true

r3-alpha/red&gt;&gt; -4.94065645841247E-324 = 0.0
== true
</code></pre>
<p>Comparisons are still just a slippery topic across the board, which I don't have an answer for (other languages struggle with all this as well).  But my hand got forced to dealing with this particular issue in dates, and making it more practical.</p> ]]></description>
        <link>https://forum.rebol.info/t/how-to-deal-with-users-mutating-date-and-time-to-be-invalid/240#post_10</link>
        <pubDate>Fri, 20 Oct 2023 02:19:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6708</guid>
      </item>
      <item>
        <title>How Much Determinism Should Be Pursued?</title>
        <dc:creator><![CDATA[@BlackATTR Black Attr]]></dc:creator>
        <description><![CDATA[ <p>If I'm not mistaken in SQL, there is no expectation of the result set coming back in a consistent order unless you specify so in the SQL. You would use an ORDER BY clause to do this:</p>
<p><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/     where 'size &gt; 100 and 'date = 26-Jul-2021     order by 'name asc</code></p>
<p>The options in this clause are ASC (ascending) or DESC (descending) based on the chosen column.</p> ]]></description>
        <link>https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057#post_2</link>
        <pubDate>Thu, 19 Oct 2023 21:01:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6707</guid>
      </item>
      <item>
        <title>How Much Determinism Should Be Pursued?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>While writing tests for the QUERY dialect against some sample files in a directory, it ran into an issue of the order those files were given back.  <em>Operating system APIs generally do not return the list of files in a determined order, and the ordering across filesystems also varies.</em></p>
<p>This means that even with the same files, you could have the lists come back differently.  One OS could say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Disk50.txt 26-Jul-2021]
2 [%tests/file-tests/11barz99.txt 26-Jul-2021]
3 [%tests/file-tests/Apple3.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
...
</code></pre>
<p>While another would say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Apple3.txt 26-Jul-2021]
2 [%tests/file-tests/Banana1.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Disk50.txt 26-Jul-2021]
5 [%tests/file-tests/11barz99.txt 26-Jul-2021]
...
</code></pre>
<p>This made getting reproducible outputs to verify was hard.</p>
<h2>
<a name="i-made-query-use-sortcase-on-the-read-dir-result-1" class="anchor" href="https://forum.rebol.info#i-made-query-use-sortcase-on-the-read-dir-result-1"></a>I Made QUERY use SORT/CASE on the READ DIR Result</h2>
<p>Getting determinism in the output meant using a function that guarantees an ordering for filenames:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/11barz99.txt 26-Jul-2021]
2 [%tests/file-tests/Apple3.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/Disk50.txt 26-Jul-2021]
...
</code></pre>
<p>Having to pay for the sort adds a little bit of overhead, but it's not that significant.</p>
<h2>
<a name="should-read-dir-be-sorted-by-default-2" class="anchor" href="https://forum.rebol.info#should-read-dir-be-sorted-by-default-2"></a>Should READ DIR be Sorted By Default?</h2>
<p>WASI in WebAssembly is looking to chase down sources of non-determinism and see what it can do to stop it.  They mention directory listing order as one potential for problems:</p>
<p><a href="https://github.com/WebAssembly/WASI/issues/190" class="inline-onebox">Roadmap to determinism in WASI · Issue #190 · WebAssembly/WASI · GitHub</a></p>
<p>They seem to believe that on the same OS the directory ordering would be deterministic for the same files, but I don't know of any guarantee of that.</p>
<h2>
<a name="all-this-points-to-bigger-issues-about-reproducibility-3" class="anchor" href="https://forum.rebol.info#all-this-points-to-bigger-issues-about-reproducibility-3"></a>All This Points to Bigger Issues About Reproducibility</h2>
<p>We can pick many examples... like whether a MAP! will always enumerate in the same order on different platforms, or with the same contents.  Using a deterministically sorted implementation of map would seem to have a number of advantages.</p>
<p>Especially since there's a growing push in software for giving deterministic outputs by default.  If you want some reasoning, see this article:</p>
<p><a href="https://buttondown.email/nelhage/archive/determinism-in-software-engineering/" class="inline-onebox">Determinism in software engineering • Buttondown</a></p>
<p>The more testing one does, the more important it seems.</p> ]]></description>
        <link>https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057#post_1</link>
        <pubDate>Thu, 19 Oct 2023 19:34:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6706</guid>
      </item>
      <item>
        <title>Joe Marshall on Rebol Binding</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p>This is what Joe Marshall <a href="http://arcanesentiment.blogspot.com/2008/08/better-rebol-info.html">wrote about Rebol Binding in 2008</a> in a comment on a blog called <em>"Arcane Sentiment"</em>.</p>
</blockquote>
<hr>
<p>The binding model I used for Rebol 1.0 was basically a standard implementation of lexical binding. A lexical environment was carried around by the interpreter and when values were needed they were looked up. The only twist was that Carl wanted symbol instances to have lexical scope. So suppose you had this rebol function:</p>
<pre><code>func [a] [ return 'a ]
</code></pre>
<p>The symbol that is returned can be evaluated in any context and it will return the value that was passed in to func. The trick was to close over the symbol. I had to tweak some of the other symbol routines to deal with this idea of closed over symbols, but it worked. (I don't think it was a good idea, but it was easy to implement.)</p>
<p>He wanted it to be the case that if you forced the evaluation of a symbol or block that you'd get the lexically scoped value. So you could return a block as a list of tokens and then call `do' on it and run it as if it were a delayed value. That's an interesting idea, but extending it to symbols themselves is probably going too far.</p>
<p>Carl never seemed to `get' how lexical environments work. The shape of the environment is constant from invocation to invocation, and this is how you get lexical addressing, but the <em>instance</em> of the environment changes.</p>
<p>When Carl ditched my code he went back to his original plan of allocating a binding cell for each lexical mention of the symbol in the source text. Imagine your source is like a Christmas calendar with the chocolate goodies behind each date. Behind each binding location is a box where the value is stored. This model has bizarre semantics. The first (and most obvious) problem is that it isn't re-entrant. If you recursively call a function, you'll end up smashing the values that are there for the outer invocation. The first release of Rebol 2.0 had this bug.</p>
<p>Carl patched this up with the following hack. If a cell is unbound, then binding it causes it to be assigned a value. If the cell already has a value, that value is saved away on the stack while the function is called, and then restored to the cell when the function returns. That fixes the re-entrancy problem, but you still have other issues.</p>
<p>The mechanism of saving the old binding away on the stack is plain-old bog-simple shallow dynamic scoping. But because Carl has a value cell for each binding site, rather than a single global cell, you only see the dynamic binding effect within a single function at a time. This makes it less likely that you'll suffer from inadvertant variable capture, but it doesn't eliminate it completely.</p>
<p>Carl's hack of leaving the previous binding in place if the cell was unbound before gives you a strange effect that variables can be used for some time after they are bound. Unfortunately, if a call to the routine that bound them occurs, the value gets smashed. This is `indefinite extent' in the truest sense --- you simply can't tell how long the variable will retain its value.</p>
<p>So Carl's binding methodology is a weird cross behind static binding, where each formal parameter has its own value cell, and shallow dynamic binding where the value is saved on the stack when a function is re-entered.</p>
<p>Carl's implementation has one other weird feature. If you copy a block of code, you also end up copying the value cells that are associated with the bindings in the code. Some rather enterprising Rebolers have used this trick to implement a `poor-man's lexical binding' by unsharing the dynamically bound value cells before leaving a function and thus getting the value to persist.</p>
<hr>
<blockquote>
<p>Joe also <a href="https://github.com/akavel/sherman">published his Lisp implementation of Rebol 1.0's methods</a> as something called "Sherman".  Whether the implementation is interesting or not, his take on Rebol 2.0 is worth noting.</p>
</blockquote>
<p>Carl abandoned my implementation after I left Rebol Technologies. He completely rewrote the interpreter and, in the process, substantially changed the semantics of the language. Rebol 2.0 is a quirky and bizarre language. I don't see any opportunity in the language so I never tried to write a compiler for Carl's semantics. Rebol seems to still be popular in France, but I think the company has shrunk down to be just Carl and his wife.</p>
<hr>
<blockquote>
<p>On MIT's "Lightweight Languages" mailing list post, <a href="http://ll1.ai.mit.edu/">Joe had this remark</a></p>
</blockquote>
<p>I wrote the Rebol 1.0 interpreter.  (but left the company right afterwards)</p>
<p>Rebol is <em>extremely</em> difficult to compile in any meaningful sense.  Since the parse tree can change dynamically at runtime, there is a combinatoric explosion of code paths.  You can constrain things a bit by allowing the user to declare procedure arity, though.</p>
<hr>
<blockquote>
<p>On his own blog, "Abstract Heresies", <a href="https://funcall.blogspot.com/2023/06/tail-recursion-in-rebol.html">Joe has another explanation of the Lisp implementation mechanics</a>.  After describing it, he remarks:</p>
</blockquote>
<p>With it’s Polish notation, tail recursion, and first-class continuations, REBOL was described as an unholy cross between TCL and Scheme. “The result of Outsterhout and Sussman meeting in a dark alley.”</p>
<p>Current versions of REBOL use a simplified interpreter that does not support tail recursion or first-class continuations.</p>
<hr>
<blockquote>
<p>Besides not believing in Carl's direction after the Lisp implementation, <a href="https://groups.google.com/g/comp.lang.lisp/c/vWfjkdG0lME/m/K48slCehF1AJ">a post on comp.lang.lisp</a> suggests that Joe was also opposed on principle to Rebol's parentheses-less-ness:</p>
</blockquote>
<p>[Not using parentheses] turns out to be a bad idea. Not only does it greatly complicate the interpreter and compiler, it turns out to be rather <em>un</em>readable in practice. As an example, here is a line from the REBOL BBS tutorial:</p>
<pre><code>update-topic topic-id length? msgs first last msgs
</code></pre>
<p>Certainly REBOL knows how many arguments each function takes (and which of those identifiers refer to functions), but if <em>you</em> don't know, you can't parse it.</p> ]]></description>
        <link>https://forum.rebol.info/t/joe-marshall-on-rebol-binding/2074#post_1</link>
        <pubDate>Mon, 18 Aug 2008 04:00:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6755</guid>
      </item>
      <item>
        <title>Ladislav Mecir&#39;s &quot;Bindology&quot;</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h2>
<a name="functions-with-make-object-like-handling-of-local-words-1" class="anchor" href="https://forum.rebol.info#functions-with-make-object-like-handling-of-local-words-1"></a>Functions with MAKE OBJECT!-like handling of local words</h2>
<p>Before we try to model the function evaluation, we can ask whether we can use the same method of the local words handling as the CONTEXT function uses.</p>
<p>The answer is positive and the function able to do this is defined below.</p>
<p>First of all a function that can extract all local words of a function from its SPEC:</p>
<pre><code>locals?: func [
    {Get all locals from a spec block.}
    spec [block!]
    /args {get only arguments}
    /local locals item item-rule
] [
    locals: make block! 16
    item-rule: either args [[
	refinement! to end (item-rule: [end skip]) |
	set item any-word! (insert tail locals to word! :item) | skip
    ]] [[
	set item any-word! (insert tail locals to word! :item) | skip
    ]]
    parse spec [any item-rule]
    locals
]

set-words: func [
    {Get all set-words from a block}
    block [block!]
    /deep {also search in subblocks/parens}
    /local elem words rule here
] [
    words: make block! length? block
    rule: either deep [[
        any [
            set elem set-word! (
                insert tail words to word! :elem
            ) | here: [block! | paren!] :here into rule | skip
        ]
    ]] [[
        any [
            set elem set-word! (
                insert tail words to word! :elem
            ) | skip
        ]
    ]]
    parse block rule
    words
]

funcs: func [
    {Define a function with auto local and static variables.}
    [throw]
    spec [block!] {Help string (opt) followed by arg words with opt type and string}
    init [block!] {Set-words become static variables, shallow scan}
    body [block!] {Set-words become local variables, deep scan}
    /local svars lvars
] [
    ; Preserve the original Spec, Init and Body
    spec: copy spec
    init: copy/deep init
    body: copy/deep body
    ; Collect static and local variables
    svars: set-words init
    lvars: set-words/deep body
    unless empty? svars [
        ; create the static context and bind Init and Body to it
        use svars reduce [reduce [init body]]
    ]
    unless empty? lvars: exclude exclude lvars locals? spec svars [
        ; declare local variables
        insert any [find spec /local insert tail spec /local] lvars
    ]
    do init
    make function! spec body
]
</code></pre>
<h2>
<a name="model-of-rebol-functions-2" class="anchor" href="https://forum.rebol.info#model-of-rebol-functions-2"></a>Model of Rebol functions</h2>
<p>Our model of Rebol functions will be a Rebol object FUNCTION!-MODEL having the appropriate attributes. The totally necessary attributes of Rebol functions are SPEC and BODY.</p>
<p>To model the current behaviour of Rebol functions accurately our FUNCTION!-MODEL needs CONTEXT, CONTEXT-WORDS and RECURSION-LEVEL attributes to model the behaviour of Rebol functions during recursive calls:</p>
<pre><code>function!-model: make object! [
    spec: none
    body: none
    context: none
    context-words: none
    recursion-level: none
]
</code></pre>
<h3>
<a name="model-of-the-func-function-3" class="anchor" href="https://forum.rebol.info#model-of-the-func-function-3"></a>Model of the FUNC function</h3>
<p>This function gets the SPEC and BODY attributes, creates a new FUNCTION!-MODEL and initializes it.</p>
<pre><code>func-model: function [
    {create a function!-model}
    spec [block!]
    body [block!]
] [result aw] [
    result: make function!-model []

    ; SPEC and BODY are deep copied
    result/spec: copy/deep spec
    result/body: copy/deep body

    result
]
</code></pre>
<h3>
<a name="model-of-the-function-call-stack-4" class="anchor" href="https://forum.rebol.info#model-of-the-function-call-stack-4"></a>Model of the function call stack</h3>
<p>The call stack is empty when the interpreter starts.</p>
<pre><code>call-stack-model: make block! []
</code></pre>
<h3>
<a name="model-of-function-evaluation-5" class="anchor" href="https://forum.rebol.info#model-of-function-evaluation-5"></a>Model of function evaluation</h3>
<p>Our simulation begins when the values of the function arguments are collected and their types checked.</p>
<p>The evaluation function obtains a FUNCTION!-MODEL together with a block of values it shall store to its local context words (i.e. all values of its arguments, optional arguments, refinements and local words).</p>
<p>We model only the morst frequent case of a function without the THROW/CATCH attributes.</p>
<p>The first part of our model executes the body:</p>
<pre><code>exec: func [body] [do body]
</code></pre>
<p>The simulation:</p>
<pre><code>evaluate-model: function [
    {evaluate a function!-model}
    f-model {the evaluated function!-model}
    values [block!] {the supplied values}
] [old-values result] [
    ; detect recursive call
    if (f-model/recursion-level: f-model/recursion-level + 1) &gt; 1 [
        ; push the old values of context words to the stack
        insert/only tail call-stack-model second f-model/context
    ]
    set/any f-model/context-words values

    ; execute the function body
    error? set/any 'result exec f-model/body

    ; restore the former values from the stack, if needed
    if (f-model/recursion-level: f-model/recursion-level - 1) &gt; 0 [
        ; pop the old values of the context words from the stack
        set/any f-model/context-words last call-stack-model
        remove back tail call-stack-model
    ]

    return get/any 'result
]
</code></pre>
<p>Our model uses just one context for the whole lifetime of the FUNCTION!-MODEL without need to change the binding of its BODY. I call this behaviour a Dynamic Recursion Patch.</p>
<p>Some tests:</p>
<pre><code>probeblk: func [] [
    prin mold blk
    prin ": "
    print mold reduce blk
]

recfun: func-model [x] [
    append blk 'x
    either x = 2 [
        probeblk
    ] [
        evaluate-model recfun [2]
    ]
]

blk: copy []
evaluate-model recfun [1] ; [x x]: [2 2]
probeblk ; [x x]: [1 1]
</code></pre>
<p>If we compare the simulated behaviour with the real Rebol functions, we get:</p>
<pre><code>recfun: func [x] [
    append blk 'x
    either x = 2 [
        probeblk
    ] [
        recfun 2
    ]
]

blk: copy []
recfun 1 ; [x x]: [2 2]
probeblk ; [x x]: [1 1]
</code></pre>
<p>This shows that the simulation is really accurate and that Rebol functions use the Dynamic Recursion Patch too.</p>
<p>Although the Dynamic Recursion Patch can speed up the evaluation under some circumstances it has got its drawbacks:</p>
<pre><code>f-returning-x: func [x] [
    func [] [x]
]

f-returning-ok: f-returning-x "OK"
f-returning-ok ; == "OK"
f-returning-bug: f-returning-x "BUG!"
; so far so good, but now:
f-returning-ok ; == "BUG!"
</code></pre>
<h2>
<a name="computed-binding-functions-closures-6" class="anchor" href="https://forum.rebol.info#computed-binding-functions-closures-6"></a>Computed binding functions (Closures)</h2>
<p>As we have seen above Computed binding has got its merits while the Dynamic recursion patch isn't ideal. The results inspired me to implement the Computed binding functions and compare their behaviour with the behaviour of the Dynamic recursion patch functions.</p>
<p>The Computed binding functions shall create a new context every time they are called and bind their bodies accordingly. We can even use a part of the above simulation to implement them.</p>
<pre><code>closure: func [
    [catch]
    spec [block!] {Help string (opt) followed by arg words (and opt type and string)}
    body [block!] {The body block of the closure}
    /local spc item result
] [
    spc: make block! 1 + (2 * length? spec)
    insert/only spc [throw]
    result: make block! 5 + length? spec
    insert result reduce [:do :make :function! spc body]
    parse spec [
        any [
            set item any-word! (
                insert tail result to word! :item
                insert tail spc to get-word! :item
                insert/only tail spc [any-type!]
            ) | skip
        ]
    ]
    throw-on-error [make function! spec result]
]
</code></pre>
<p>The first test:</p>
<pre><code>recfun: closure [x] [
    append blk 'x
    either x = 2 [
        probeblk
    ] [
        recfun 2
    ]
]

blk: copy []
recfun 1 ; [x x]: [1 2]
probeblk ; [x x]: [1 2]
</code></pre>
<p>This surely looks better than before. The second test:</p>
<pre><code>f-returning-x: closure [x] [
    func [] [x]
]

f-returning-ok: f-returning-x "OK"
f-returning-ok ; == "OK"
f-returning-bug: f-returning-x "BUG!"
; so far so good, but now:
f-returning-ok ; == "OK"
</code></pre>
<p>The end.</p> ]]></description>
        <link>https://forum.rebol.info/t/ladislav-mecirs-bindology/2073#post_2</link>
        <pubDate>Fri, 12 May 2006 04:02:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6754</guid>
      </item>
      <item>
        <title>Ladislav Mecir&#39;s &quot;Bindology&quot;</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p>This is an archive of <a href="https://en.wikibooks.org/wiki/Rebol_Programming/Advanced/Bindology">Ladislav's well-known "Bindology" article</a>. It's not as important to have a backup of it as some other things, since it's on WikiBooks and will probably stay there.</p>
<p>Ladislav put it on WikiBooks in 2016, but the article is more circa a decade earlier, as the code from the article was <a href="http://www.rebol.org/view-script.r?script=contexts.r">uploaded to rebol.org in 2006</a></p>
<p>It's too long for a single post, so I split it into two.</p>
</blockquote>
<hr>
<h2>
<a name="acknowledgments-1" class="anchor" href="https://forum.rebol.info#acknowledgments-1"></a>Acknowledgments</h2>
<p>I would like to thank the men that influenced this article in some way. Those are especially Galt Barber, Brian D., Mark Dickson, Elan Goldman, Brian Hawley, Gregg Irwin, Thomas Jensen, Pierre Johnson, Holger Kruse, Volker Nitsch, Larry Palmiter, Patrick Philipot, Gabriele Santilli, Carl Sassenrath, Frank Sievertsen and Romano Paolo Tenca. Any errors are my copyright.</p>
<h2>
<a name="references-2" class="anchor" href="https://forum.rebol.info#references-2"></a>References</h2>
<p>The code in this article was tested in Rebol/View 2.7.6.3.1. It is possible that other versions of the interpreter yield different results.</p>
<p>A reader who wants to check all the examples can run this code:</p>
<pre><code>do http://www.rebol.org/download-a-script.r?script-name=contexts.r
</code></pre>
<p>...which defines all functions from this article.</p>
<h2>
<a name="word-types-3" class="anchor" href="https://forum.rebol.info#word-types-3"></a>Word types</h2>
<p>Rebol words like all Rebol values have type. Let's have a look at all available word types:</p>
<pre><code>type? first [rebol] ; == word!
type? first [rebol:] ; == set-word!
type? first [:rebol] ; == get-word!
type? first ['rebol] ; == lit-word!
type? first [/rebol] ; == refinement!
</code></pre>
<p>Moreover, all Rebol words have a common pseudo-type ANY-WORD!:</p>
<pre><code>any-word? first [rebol] ; == true
any-word? first [rebol:] ; == true
any-word? first [:rebol] ; == true
any-word? first ['rebol] ; == true
any-word? first [/rebol] ; == true
</code></pre>
<h2>
<a name="spelling-4" class="anchor" href="https://forum.rebol.info#spelling-4"></a>Spelling</h2>
<p>Every word has got a spelling. The spelling of a word is a string and it is one of the properties the above example words have in common. We can obtain the spelling of a word using the TO-STRING function:</p>
<pre><code>to-string first [rebol] ; == "rebol"
to-string first [rebol:] ; == "rebol"
to-string first [:rebol] ; == "rebol"
to-string first ['rebol] ; == "rebol"
to-string first [/rebol] ; == "rebol"
</code></pre>
<p>Observation (Unusual spellings): Words normally don't have some spellings like spellings containing spaces, spellings starting with a colon, etc. On the other hand, it is possible to create a word having any spelling as follows:</p>
<pre><code>unusual: make word! ":unusual word:"
type? unusual ; == word!
to-string unusual ; == ":unusual word:"
</code></pre>
<p>Observation (Spelling and word equality): Words with strict equal spelling are equal.</p>
<p>Illustration:</p>
<pre><code>equal? first [rebol] first [rebol:] ; == true
</code></pre>
<p>The reverse implication does not hold (since Rebol supports aliases). Nevertheless, we can reverse the implication at least in some way.</p>
<p>Observation (SAME? and spelling): If two words are the same according to the SAME? function then they have got strict equal spelling.</p>
<h2>
<a name="variables-5" class="anchor" href="https://forum.rebol.info#variables-5"></a>Variables</h2>
<p>A very important property of words is the ability to serve as variables (refer to Rebol values). To set a variable 'rebolution to refer to a Rebol string "uprising" we can pick one of the following:</p>
<pre><code>rebolution: "uprising"
set 'rebolution "uprising"
set/any 'rebolution "uprising"
set first [rebolution:] "uprising"
</code></pre>
<p>etc.</p>
<p>To get the value a variable refers to we can pick one of the following:</p>
<pre><code>:rebolution
get 'rebolution
get/any 'rebolution
</code></pre>
<p>etc.</p>
<p>Observation (Variables): The ability of words to serve as variables is closely related to a word property called binding. A word is a variable if and only if it is bound to a context (has a context, is in a context).</p>
<p>Illustration:</p>
<pre><code>; a refinement
get/any /rebol
** Script Error: rebol word has no context
** Near: get/any /rebol
</code></pre>
<p>The easiest way how to find out if a word is a variable is to use the properties of the BIND? function, which returns NONE for words that aren't variables:</p>
<pre><code>variable?: func [
    {is the given WORD a variable?}
    word [any-word!]
] [
    found? bind? :word
]
</code></pre>
<p>Tests:</p>
<pre><code>variable? 'rebol ; == true
variable? /rebol ; == false
</code></pre>
<p>Observation (Context uniqueness): As the BIND? function helps us to find out, for every Rebol word there is at most one context the given word is bound to.</p>
<p>Corollary (Context hierarchy): From the above observation follows that in Rebol there is no context hierarchy, because a context hierarchy would require some word being bound to at least two distinct contexts, one being "smaller" than the other.</p>
<p>Observation (Word sameness): According to the SAME? function two words are the same if and only if they have strict equal spelling and equal binding.</p>
<p>Observation (The result of the BIND? function): When the BIND? function is used to obtain the context of a word in an object, the result of the BIND? function "is not considered identical" with the object.</p>
<p>Illustration:</p>
<pre><code>o: make object! [a: none]
o-context: bind? in o 'a
same? o o-context ; == false
</code></pre>
<p>Observation (Equal words need not have equal binding): In fact, the opposite is true. For any word we can create a word having strict equal spelling, equal type and different binding.</p>
<pre><code>different-binding: func [
    {
        for a given WORD yield a word having
        strict equal spelling, equal type and different binding
    }
    word [any-word!] {the given word}
] [
    bind :word use reduce [to word! :word] reduce [to lit-word! :word]
]
</code></pre>
<p>Let's test, whether the function does what we declared:</p>
<pre><code>word1: 'a ; == a
word2: different-binding word1 ; == a
strict-equal? to-string word1 to-string word2 ; == true
equal? type? word1 type? word2 ; == true
equal? bind? word1 bind? word2 ; == false
set word1 1
set word2 2
get word1 ; == 1
get word2 ; == 2
</code></pre>
<p>The test shows that WORD1 and WORD2 have strict equal spelling and equal type. Their bindings are different. They can refer to different values at the same time, so they are distinct variables. Another test:</p>
<pre><code>word1: /a ; == /a
word2: different-binding word1 ; == /a
same? word1 word2 ; == false
equal? bind? word1 bind? word2 ; == false
</code></pre>
<h2>
<a name="the-bind-function-6" class="anchor" href="https://forum.rebol.info#the-bind-function-6"></a>The BIND function</h2>
<p>When we need to get a word having the spelling and type a given WORDS word has and the context a given KNOWN-WORD has, we can use the BIND function.</p>
<p>This is how the BIND function works:</p>
<h3>
<a name="binding-to-no-context-7" class="anchor" href="https://forum.rebol.info#binding-to-no-context-7"></a>Binding to no context</h3>
<p>Observation (Binding to no context): If the KNOWN-WORD has no context, BIND causes an error.</p>
<p>Illustration:</p>
<pre><code>a-word: second first context [rebol: 1] ; == rebol
bind? a-word ; == none
bind 'a a-word
** Script Error: rebol word has no context
** Near: bind 'a a-word
</code></pre>
<h3>
<a name="binding-when-the-words-argument-is-a-word-8" class="anchor" href="https://forum.rebol.info#binding-when-the-words-argument-is-a-word-8"></a>Binding when the WORDS argument is a word</h3>
<p>Observation (Effective bind): If it is possible, the BIND function yields a word having the spelling and type of the WORDS argument and the context of the KNOWN-WORD argument.</p>
<p>Illustration:</p>
<pre><code>words: 'a ; == a
known-word: use [a b] ['b] ; == b
result: bind words known-word ; == a
equal? bind? known-word bind? result ; == true
same? words known-word ; == false
</code></pre>
<p>We observe that the result has got the spelling and the type of the WORDS word, but it isn't the WORDS word because it is bound to the same context as the KNOWN-WORD is.</p>
<p>Observation (Equal words and effective bind): If WORD1 is a variable having a context CONTEXT and WORD2 is equal to WORD1 then WORD2 can be bound to CONTEXT too.</p>
<p>Observation (Ineffective bind): In case the BIND function cannot yield a word having the spelling and type of the WORDS argument and the binding of the KNOWN-WORD argument, BIND returns the WORDS argument.</p>
<pre><code>words: 'c ; == c
known-word: use [a b] ['b] ; == b
result: bind words known-word ; == c
same? words result ; == true
</code></pre>
<p>In this case BIND simply returned the WORDS word.</p>
<h3>
<a name="binding-when-the-words-argument-is-a-block-9" class="anchor" href="https://forum.rebol.info#binding-when-the-words-argument-is-a-block-9"></a>Binding when the WORDS argument is a block</h3>
<p>Observation (Binding block without copying): If the /COPY refinement isn't used, BIND replaces the elements of the block by results of their binding. There is one exception to this rule: BIND doesn't bind refinements contained in the block.</p>
<h2>
<a name="aliases-10" class="anchor" href="https://forum.rebol.info#aliases-10"></a>Aliases</h2>
<p>Definition (Aliases): Equal words that do not have strict equal spelling we call aliases.</p>
<p>This is our definition translated to Rebol:</p>
<pre><code>aliases?: func [
    {find out, if WORD1 and WORD2 are aliases}
    word1 [any-word!]
    word2 [any-word!]
] [
    found? all [
        equal? :word1 :word2
        strict-not-equal? to-string :word1 to-string :word2
    ]
]
</code></pre>
<p>Corollary (Word equality): Two words are equal if and only if one of the following conditions holds:</p>
<ul>
<li>the words have strict equal spelling</li>
<li>the words are aliases</li>
</ul>
<p>Corollary (Aliases and SAME?): The SAME? function yields FALSE when comparing two aliases.</p>
<p>Proof: See the (SAME? and spelling) observation and our definition of aliases.</p>
<p>Observation (Automatic aliases): Since Rebol tries to be case-insensitive, the interpreter usually (except for inconsistencies) "considers" words with spellings differing only in case to be aliases.</p>
<p>Observation (ALIAS): Aliases can be defined explicitly using the ALIAS function.</p>
<pre><code>; let's create an alias 'revolutionary for the word 'rebol
alias 'rebol "revolutionary"
; 'rebol and 'revolutionary will be equal words with different spelling:
equal? 'rebol 'revolutionary ; == true
strict-equal? to-string 'rebol to-string 'revolutionary ; == false
aliases? 'rebol 'mean ; == false
aliases? 'rebol 'rebol ; == false
aliases? 'rebol 'revolutionary ; == true
aliases? 'system 'SYSTEM ; == true
</code></pre>
<p>Observation (ALIAS return value): The ALIAS function returns unbound words.</p>
<pre><code>y: alias 'x "xx" ; == xx
bind? y ; == none
</code></pre>
<p>Observation (Variable sameness): Two words are one variable if and only if they are equal and their bindings are equal too.</p>
<pre><code>same-variable?: func [
    {are WORD1 and WORD2 the same variable?}
    word1 [any-word!]
    word2 [any-word!]
] [
    found? all [
        equal? :word1 :word2
        equal? bind? :word1 bind? :word2
    ]
]
</code></pre>
<p>Observation (Alternative definition of ALIASES?): According to our previous observations this definition is equivalent to our original definition:</p>
<pre><code>aliases?: func [
    {find out, if WORD1 and WORD2 are aliases}
    word1 [any-word!]
    word2 [any-word!]
    /local context
] [
    found? all [
        equal? :word1 :word2
        (
            if context: any [bind? :word1 bind? :word2] [
                word1: in context :word1
                word2: in context :word2
            ]
            ; WORD1 and WORD2 have equal binding now
            not same? :word1 :word2
        )
    ]
]
</code></pre>
<p>The alternative definition looks more complicated, but it is faster due to the fact that it does not need to manipulate strings.</p>
<h2>
<a name="context-words-11" class="anchor" href="https://forum.rebol.info#context-words-11"></a>Context words</h2>
<p>The BIND? function allows us to find the context of a given word. The reverse task is a task to find all words that are in a given CONTEXT context. It can be done as follows:</p>
<pre><code>context-words?: func [
    {get the words in a given CONTEXT}
    context [object!]
] [
    bind first context context
]
</code></pre>
<p>Observation (Simplified set of context words): The block obtained as the result of the <code>first context</code> expression is a simplified set of context words. As opposed to the result of the above function it contains unbound words. Moreover, similarly as the result of the above function it doesn't contain aliases of its words and it contains only words of the WORD! datatype.</p>
<p>Illustration:</p>
<pre><code>alias 'rebol "rebellious"
o: make object! [rebellious: 1]
first o ; == [self rebellious]
bind? first first o ; == none
in o 'rebol ; == rebol
</code></pre>
<h2>
<a name="the-global-context-12" class="anchor" href="https://forum.rebol.info#the-global-context-12"></a>The global context</h2>
<p>Definition (Global context): The global context can be defined e.g. as follows:</p>
<p><code>global-context: bind? 'system</code></p>
<p>Note: This is not the only option, another one is to define it as the SYSTEM/WORDS object. The above definition gives us the simplest possible definition of global words.</p>
<p>Definition (Global words/global variables): The words that are bound to the global context we call global words (global variables):</p>
<pre><code>global?: func [
    {find out if a WORD is global}
    word [any-word! object!]
] [
    same? global-context bind? :word
]
</code></pre>
<p>Observation (MAKE, TO, LOAD, BIND and the global context): The words created by MAKE WORD!, MAKE SET-WORD!, MAKE GET-WORD!, MAKE LIT-WORD!, MAKE REFINEMENT!, TO WORD!, TO SET-WORD!, TO GET-WORD!, TO LIT-WORD!, TO REFINEMENT!, LOAD and BIND WORD 'SYSTEM are global.</p>
<p>Illustration:</p>
<pre><code>global? make word! first first rebol/words ; == true
global? to word! first first rebol/words ; == true
</code></pre>
<p>Observation (Automatic growth): The global context can be enlarged using the MAKE, TO, LOAD and BIND functions. On the other hand, the IN function doesn't enlarge the global context.</p>
<p>Observation (MAKE, TO and unbound words): All words contained in a result block of MAKE BLOCK!, TO BLOCK! and in its subblocks are unbound if the SPEC argument is a string.</p>
<p>Illustration:</p>
<pre><code>bind? first make block! "unbound" ; == none
bind? first first first make block! "[[unbound-too]]" ; == none
</code></pre>
<h2>
<a name="local-contexts-13" class="anchor" href="https://forum.rebol.info#local-contexts-13"></a>Local contexts</h2>
<p>Definition (Local words/local variables): The words that are neither unbound nor global we call local words (local variables):</p>
<pre><code>local?: func [
    {find out, if a WORD is local}
    word [any-word!]
] [
    not any [
        none? bind? :word
        global? :word
    ]
]
</code></pre>
<p>Definition (Local context): A context is called local context if its words are local words.</p>
<p>Observation (Local context types): User defined objects, function contexts and USE contexts are local contexts. In addition to these we can use the BIND? function to "convert" user defined objects and ports to contexts and using the DISARM function we can convert errors to objects. All the results are local contexts. The main distinction between the function- and USE- contexts and all other context types lies in the fact that the function- and USE- contexts don't need to contain a word equal to the word 'self.</p>
<p>Observation (Enlarging local contexts): Local contexts aren't enlargeable.</p>
<p>Observation (The result of the DIFFERENT-BINDING function): The result of the DIFFERENT-BINDING function as we defined it above is always a local word.</p>
<h2>
<a name="computed-binding-14" class="anchor" href="https://forum.rebol.info#computed-binding-14"></a>Computed binding</h2>
<p>Let's observe the behaviour of the Rebol interpreter when evaluating an example code string:</p>
<pre><code>code-string: {'f 'g 'h use [g h] [colorize "USE 1" 'f 'g 'h use [h] [colorize "USE 2" 'f 'g 'h]]}
</code></pre>
<p>The COLORIZE function will colorize the code listing as follows:</p>
<ul>
<li>the unbound words will be <span>brown</span>
</li>
<li>the global words will be <span>blue</span>
</li>
<li>the words bound by the first USE evaluation will be <span>red</span>
</li>
<li>the words bound by the second USE evaluation will be <span>magenta</span>
</li>
</ul>
<p>Here is the code:</p>
<pre><code>emit: func [text [char! string! block!]] [
    append result either block? text [rejoin text] [text]
]

colorize: func [
    {emit a table row containing text and the colorized code block}
    text [string!]
    /local space?
] [
    emit ["^/|-^/| " text "^/| "]
    space?: ""
    parse code-block rule: [
        (
            emit [space? #"["]
            space?: ""
        )
        any [
            [
                set word any-word! (
                    emit [
                        space?
                        {&lt;font color="}
                        case [
                            not bind? :word ["brown"]
                            global? :word ["blue"]
                            equal? bind? :word bind? code-block/6/4 ["red"]
                            equal? bind? :word bind? code-block/6/8/5 [
                                "magenta"
                            ]
                        ]
                        {"&gt;}
                        mold :word
                        &lt;/font&gt;
                    ]
                ) | into rule | set word skip (
                    emit [space? mold :word]
                )
            ]
            (space?: " ")
        ]
    ]
]
</code></pre>
<p>Let's watch how the code is being interpreted:</p>
<pre><code>; the result will be a wikitable
result: {^{| class="wikitable" border="1"
|-
! Text
! Code}

; first, the interpreter creates a code block
code-block: make block! code-string
colorize "String to block conversion"

; next, the code block is bound to the global context
bind code-block global-context
colorize "Code block bound to the global context"

; and then the code block is interpreted
do code-block

; now we close the table
emit "^/|}^/"

write clipboard:// result
</code></pre>
<p>The rendering result in a Wiki site is:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/9ee5657fb81d179b484e0637da55bd1c83fbeb08.png" data-download-href="https://forum.rebol.info/uploads/default/9ee5657fb81d179b484e0637da55bd1c83fbeb08" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/9ee5657fb81d179b484e0637da55bd1c83fbeb08.png" alt="image" data-base62-sha1="mFEV2zcXBrq4yRjjfZ210vNygty" width="690" height="146" data-dominant-color="E7E6ED"></a></div><p></p>
<p>The result proves that:</p>
<ul>
<li>
<p>After the string to block conversion all words in the CODE-BLOCK were unbound</p>
</li>
<li>
<p>After the CODE-BLOCK was bound to the global context all words in the CODE-BLOCK were global</p>
</li>
<li>
<p>The first USE call replaced all words 'g and 'h from its body block and its subblock with local USE 1 words</p>
</li>
<li>
<p>The second USE call replaced the 'h in the innermost block with the local USE 2 word</p>
</li>
</ul>
<p>Observation (Computed binding): During the interpretation the binding of Rebol words contained in the code is changed (i.e. the words are being replaced by words with different binding) until they are bound correctly and evaluated. That is why the creator of Rebol calls this behaviour "Computed binding".</p>
<h2>
<a name="scope-15" class="anchor" href="https://forum.rebol.info#scope-15"></a>Scope</h2>
<p>It looks like we observed a "scope hierarchy" during the execution of the above Rebol code. As we have demonstrated, it was only a side effect of the computed binding.</p>
<p>With a help of the computed binding we can easily create code samples, which do not exhibit any "scope" property:</p>
<pre><code>; create a block CODE-BLK containing a word 'a
code-blk: copy [a]
a: 12

; now append another word 'a to CODE-BLK
make object! [append code-blk 'a a: 13]

code-blk ; == [a a]

; test if CODE-BLK contains equal words
equal? first code-blk second code-blk ; == true

; prove that the CODE-BLK is not a "scope"
equal? bind? first code-blk bind? second code-blk ; == false
</code></pre>
<p>The CODE-BLK example demonstrates that for a code block there is no such thing as its "current context" in Rebol because in Rebol only individual words are associated with context.</p>
<h2>
<a name="the-use-function-16" class="anchor" href="https://forum.rebol.info#the-use-function-16"></a>The USE function</h2>
<p>To be as precise as possible we will write the description of the USE function behaviour in Rebol.</p>
<p>The following function creates a new context, in which all words are unset:</p>
<pre><code>make-context-model: func [
    {context creation simulation}
    words [block!] {context words, needs to be non-empty}
] [
    bind? first use words reduce [reduce [first words]]
]
</code></pre>
<p>The description of USE:</p>
<pre><code>use-model: function [
    {USE simulation, works for non-empty WORDS block}
    [throw]
    words [block!] "Local word(s) to the block"
    body [block!] "Block to evaluate"
] [new-context] [
    unless empty? words [
        ; create a new context
        new-context: make-context-model words
        ; bind the body to the new Context
        bind body new-context
    ]
    do body
]
</code></pre>
<p>Observation (USE-MODEL and BODY): USE-MODEL modifies its BODY argument when it binds it to the new context. If we wanted to leave the BODY argument unmodified, we should have used BIND/COPY instead of the present BIND.</p>
<p>Let's compare USE-MODEL's behaviour and the behaviour of USE:</p>
<pre><code>body: ['a]
body-copy: copy body
same? first body first body-copy ; == true
use [a] body
same? first body first body-copy ; == false
</code></pre>
<p>As we made sure, the same is true for both USE-MODEL and the original USE. The simulation is so accurate that it helped us to reveal a bug in the following code:</p>
<pre><code>f: func [x] [
    use [a] [
        either x = 1 [
            a: "OK"
            f 2
            a
        ] [
            a: "BUG!"
            "OK"
        ]
    ]
]
f 1 ; == "BUG!"
</code></pre>
<p>Explanation/correction:</p>
<p>The observed USE property caused that the body of the function F got modified during the second USE execution. After that modification it no longer contained the word 'a that was set to "OK" during the first invocation of F. Instead it contained only the word 'a set to the "BUG!" value during the second invocation of F.</p>
<p>If we preserve the body of the F somehow, we can get the correct behaviour:</p>
<pre><code>f: func [x] [
    use [a] copy/deep [
        either x = 1 [
            a: "OK"
            f 2
            a
        ] [
            a: "BUG!"
            "OK"
        ]
    ]
]
f 1 ; == "OK"
</code></pre>
<p>Another way how to correct the behaviour is to use our own version of USE that will not modify its body argument:</p>
<pre><code>nm-use: func [
    {
        Defines words local to a block.
        Does't modify the BODY argument.
    }
    [throw]
    words [block!] {Local words to the block}
    body [block!] {Block to evaluate}
] [
    use words copy/deep body
]
</code></pre>
<h2>
<a name="make-object-17" class="anchor" href="https://forum.rebol.info#make-object-17"></a>MAKE OBJECT!</h2>
<p>We need a function that evaluates the SPEC argument like MAKE OBJECT! does, which means that it has to catch  RETURN, THROW and BREAK:</p>
<pre><code>spec-eval: func [
    {evaluate the SPEC like MAKE OBJECT! does}
    spec [block!]
] [
    any-type? catch [loop 1 spec]
]
</code></pre>
<p>The MAKE OBJECT! simulation:</p>
<pre><code>make-object!-model: function [
    {MAKE OBJECT! simulation}
    spec [block!]
] [set-words object sw] [
    ; find all set-words in SPEC
    set-words: copy [self]
    parse spec [
        any [
                copy sw set-word! (append set-words sw)
            |
                skip
        ]
    ]
    ; create a context with the desired local words
    object: make-context-model set-words
    ; set 'self in object to refer to the object
    object/self: object
    ; bind the SPEC to the blank object
    bind spec in object 'self
    ; evaluate it
    spec-eval spec
    ; return the value of 'self as the result
    return get/any in object 'self
]
</code></pre>
<p>Observation (MAKE-OBJECT!-MODEL and SPEC): MAKE-OBJECT!-MODEL modifies its SPEC argument when it binds it to the new context. If we wanted to leave the SPEC argument unmodified, we should have used BIND/COPY instead of the present BIND.</p>
<p>The described behaviour leads to a bug similar to the bug described in the USE section:</p>
<pre><code>f: func [x] [
    get in make-object!-model [
        a: "OK"
        if x = 1 [
            a: "BUG!"
            f 2
            a: "OK"
        ]
    ] 'a
]
f 1 ; == "BUG!"
</code></pre>
<p>The explanation and the correction are similar as for the USE function. The word a: in the a: "OK" line positioned after the recursive call to F and bound to the object F created first was replaced by a word a: bound to the object F created during the recursive call. Consequently, the expression a: "OK" had no effect on the object F created first and therefore it retained the last value of 'a, which was "BUG!". If we preserve the body of F, we can get the correct behaviour:</p>
<pre><code>f: func [x] [
    get in make object! copy/deep [
        a: "OK"
        if x = 1 [
            a: "BUG!"
            f 2
            a: "OK"
        ]
    ] 'a
]
f 1 ; == "OK"
</code></pre>
<p>As you might have seen, the above code deep copies the BODY block before binding it to the context. Analogical bugs were discovered when the deep copying was not used when the FUNC function created Rebol functions.</p>
<h2>
<a name="make-proto-18" class="anchor" href="https://forum.rebol.info#make-proto-18"></a>MAKE PROTO</h2>
<p>This is a simulation of the situation when the MAKE function obtains a prototype of the object it has to create. First of all, we need a special BIND-like function:</p>
<pre><code>specbind: function [
    {bind only known-words}
    block [block!]
    known-words [block!]
] [p w bind-one kw] [
    bind-one: [
        p:
        [
            copy w any-word! (
                if kw: find known-words first w [
                    change p bind w first kw
                ]
            ) | copy w [path! | set-path! | lit-path!] (
                if kw: find known-words first first w [
                    change p bind w first kw
                ]
            ) | into [any bind-one] | skip
        ]
    ]
    parse block [any bind-one]
    block
]
</code></pre>
<p>And here is the simulation:</p>
<pre><code>make-proto: function [
    {MAKE PROTO simulation}
    proto [object!]
    spec [block!]
] [set-words object sw word value spc body pwords] [
    ; get local words from proto
    set-words: copy first proto

    ; append all set-words from SPEC
    parse spec [
        any [
            copy sw set-word! (append set-words sw) |
            skip
        ]
    ]

    ; create a blank object with the desired local words
    object: make-context-model set-words
    object/self: object

    ; copy the contents of the proto
    pwords: bind first proto object
    repeat i (length? first proto) - 1 [
        word: pick next first proto i
        any-type? set/any 'value pick next second proto i
        any [
            all [string? get/any 'value set in object word copy value]
            all [
                block? get/any 'value
                value: specbind copy/deep value pwords
                set in object word value
            ]
            all [
                function? get/any 'value
                spc: load mold third :value
                body: specbind copy/deep second :value pwords
                set in object word func spc body
            ]
            any-type? set/any in object word get/any 'value
        ]
    ]

    bind spec object
    spec-eval spec
    return get/any in object 'self
]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/ladislav-mecirs-bindology/2073#post_1</link>
        <pubDate>Fri, 12 May 2006 04:00:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6753</guid>
      </item>
  </channel>
</rss>

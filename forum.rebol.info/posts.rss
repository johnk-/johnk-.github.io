<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>ENHEX and DEHEX testing, another &quot;Micro-Dialect&quot;</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Sometimes it's the small examples that I think drive home what the project is about most clearly.  And this is pretty darn close to the essential complexity of the problem being addressed.</p>
<p>So I thought maybe it would be good to look at the impact of a decision like arity-2 COMPOSE here, just to see it "in context".</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">parse compose $() [
    "a%20b" &lt;-&gt; "a b"
    "a%25b" &lt;-&gt; "a%b"
    "a%ce%b2c" -&gt; "aβc" -&gt; "a%CE%B2c"  [1]
    "%2b%2b" -&gt; "++" -&gt; "++"  [2]
    "a%2Bb" -&gt; "a+b" -&gt; "a+b"  [2]
    "a%62c" -&gt; "abc" -&gt; "abc"  [2]
    "a%CE%B2c" &lt;-&gt; "aβc"
    (as text! #{2F666F726D3F763D254335253939}) -&gt; "/form?v=ř"
][ some [
    let encoded: text!
    let arrow: ['&lt;-&gt; | '-&gt;]
    let decoded: text!
    let re-encoded: [when (arrow = '-&gt;) ['-&gt; text!] | (encoded)]
    optional block!  ; headnote comment
    (
        let de: dehex encoded
        if de != decoded [
            fail ["Decode of" @encoded "gave" @de "expected" @decoded]
        ]
        let en: enhex decoded
        if en != re-encoded [
            fail ["Encode of" @decoded "gave" @en "expected" @re-encoded]
        ]
    )
]]
</code></pre>
<p>So the question I might ask is: <em>try and compare it with fresh eyes...what does that adjustment feel like?</em></p>
<p>Does it feel like a "wart" appeared?  Does it feel like a "missing parameter" showed up?</p>
<p>I'll stress again that COMPOSE on a string can't work unless it either takes this parameter to draw a binding from, or unless COMPOSE "sneakily" captures the binding environment in which it is executing.</p>
<p>I've suggested that the sneaky form use <code>compose*</code>, so let's look at that as well:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">parse compose* [
    "a%20b" &lt;-&gt; "a b"
    "a%25b" &lt;-&gt; "a%b"
    "a%ce%b2c" -&gt; "aβc" -&gt; "a%CE%B2c"  [1]
    "%2b%2b" -&gt; "++" -&gt; "++"  [2]
    "a%2Bb" -&gt; "a+b" -&gt; "a+b"  [2]
    "a%62c" -&gt; "abc" -&gt; "abc"  [2]
    "a%CE%B2c" &lt;-&gt; "aβc"
    (as text! #{2F666F726D3F763D254335253939}) -&gt; "/form?v=ř"
][ some [
    let encoded: text!
    let arrow: ['&lt;-&gt; | '-&gt;]
    let decoded: text!
    let re-encoded: [when (arrow = '-&gt;) ['-&gt; text!] | (encoded)]
    optional block!  ; headnote comment
    (
        let de: dehex encoded
        if de != decoded [
            fail ["Decode of" @encoded "gave" @de "expected" @decoded]
        ]
        let en: enhex decoded
        if en != re-encoded [
            fail ["Encode of" @decoded "gave" @en "expected" @re-encoded]
        ]
    )
]]
</code></pre>
<p>To me, this is more unsettling than the <code>$()</code>.  It seems so much easier to explain that if you'd said <code>${&lt;?&gt;}</code> instead then it would have looked for FENCE!s beginning with <code>&lt;?&gt;</code></p>
<p>(I'll intentionally paste it all out again here, because I'm trying to make a point.)</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">parse compose ${&lt;?&gt;} [
    "a%20b" &lt;-&gt; "a b"
    "a%25b" &lt;-&gt; "a%b"
    "a%ce%b2c" -&gt; "aβc" -&gt; "a%CE%B2c"  [1]
    "%2b%2b" -&gt; "++" -&gt; "++"  [2]
    "a%2Bb" -&gt; "a+b" -&gt; "a+b"  [2]
    "a%62c" -&gt; "abc" -&gt; "abc"  [2]
    "a%CE%B2c" &lt;-&gt; "aβc"
    {&lt;?&gt; as text! #{2F666F726D3F763D254335253939}} -&gt; "/form?v=ř"
][ some [
    let encoded: text!
    let arrow: ['&lt;-&gt; | '-&gt;]
    let decoded: text!
    let re-encoded: [when (arrow = '-&gt;) ['-&gt; text!] | (encoded)]
    optional block!  ; headnote comment
    (
        let de: dehex encoded
        if de != decoded [
            fail ["Decode of" @encoded "gave" @de "expected" @decoded]
        ]
        let en: enhex decoded
        if en != re-encoded [
            fail ["Encode of" @decoded "gave" @en "expected" @re-encoded]
        ]
    )
]]
</code></pre>
<p>Anyway, I'm very reticent to make plain <code>compose</code> capture its calling environment.  And if I'm not willing to do that, the options are that it take the binding from its template argument (won't work for strings, and a bit of a weird behavior to use as a default for lists), or it be arity-2.</p>
<p>I feel like arity-2 is winning, for me, so far.</p> ]]></description>
        <link>https://forum.rebol.info/t/enhex-and-dehex-testing-another-micro-dialect/2323#post_2</link>
        <pubDate>Fri, 22 Nov 2024 06:37:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7928</guid>
      </item>
      <item>
        <title>Abbreviations As Synonyms</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1211">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>I Propose Abbreviations As Synonyms For What They Abbreviate</strong></p>
<p>Purely synonyms. <code>/FUNC: FUNCTION/</code>.</p>
</blockquote>
</aside>
<p>Well, five years ago I put this idea forth.</p>
<p>Since locals-gathering function has been dead for some time now, I decided the <a href="https://forum.rebol.info/t/dropping-with-in-static/2335/2">end of the PARSE-based wrapper</a> that implemented the "higher-level" function was as good a time as any to finally make the change.</p>
<p>The FUNCTION native is now shorthanded as FUNC, as full synonyms.</p>
<p>Red still operates on the old idea:</p>
<pre><code>red&gt;&gt; x: 10
red&gt;&gt; foo: function [y] [x: y]
red&gt;&gt; foo 20
red&gt;&gt; x
== 10

red&gt;&gt; x: 10
red&gt;&gt; bar: func [y] [x: y]
red&gt;&gt; bar 20
red&gt;&gt; x
== 20
</code></pre>
<p>But as I point out at the top of this thread, <a href="https://forum.rebol.info/t/rethinking-auto-gathered-set-word-locals/1150">and in other posts</a>, it's just not good.</p>
<p>So nice to finally get this crossed off.</p> ]]></description>
        <link>https://forum.rebol.info/t/abbreviations-as-synonyms/1211#post_4</link>
        <pubDate>Fri, 22 Nov 2024 05:14:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7927</guid>
      </item>
      <item>
        <title>SET-WORD! To Initialize Locals In Function Specs?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>When <a href="https://forum.rebol.info/t/dropping-with-in-static/2335">the higher-level FUNCTION code</a> was removed, that removed the code for assigning default values to locals.</p>
<p>As I mentioned, it was done with GROUP!s:</p>
<pre><code>/foo: function [arg1 arg2 &lt;local&gt; x y (1 + 2) z (null)] [...body...]
</code></pre>
<p>The way it worked was to augment the function's body:</p>
<pre><code>/foo: function [arg1 arg2 &lt;local&gt; x y z] [
   y: '3
   z: ~null~
   (...body...)
]
</code></pre>
<p>It evaluated the expression once, and then used a ^META of the evaluation product as the thing to assign.</p>
<h2><a name="p-7926-native-local-handling-brings-long-desired-advantage-1" class="anchor" href="https://forum.rebol.info#p-7926-native-local-handling-brings-long-desired-advantage-1"></a>Native <code>&lt;local&gt;</code> Handling Brings Long-Desired Advantage</h2>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2210">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>As it so happens, there's potential to exploit this for efficiency. The frame mechanics have a slot for each local in the function archetype that currently just holds nothing (~ antiform), and it could hold this default value / expression. So it wouldn't just save on typing the local name and then later the name again and the expression...but you're avoiding the need to perform the evaluation to do the assignment on each call!</p>
</blockquote>
</aside>
<p>This theoretical advantage was not realized by the FUNCTION abstraction, as it was just injecting assignments into the body.</p>
<p>But now that the FUNC native is orchestrating the situation, the advantage is there.</p>
<h2><a name="p-7926-feature-question-multi-returns-2" class="anchor" href="https://forum.rebol.info#p-7926-feature-question-multi-returns-2"></a>Feature Question: Multi-Returns</h2>
<p>When I brought up the question of <strong><code>[&lt;local&gt; word: expr]</code></strong> instead of <strong><code>[&lt;local&gt; word (expr)]</code></strong>, I didn't consider whether you could do multi-returns:</p>
<pre><code>/bar: function [arg &lt;local&gt; [begin end]: (find series "a")] [...]
</code></pre>
<p>First of all, I'm not certain that feels like it "belongs" in the spec.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_raised_eyebrow.png?v=12" title=":face_with_raised_eyebrow:" class="emoji" alt=":face_with_raised_eyebrow:" loading="lazy" width="20" height="20"></p>
<p>Secondly, this would require some significant redesign.  <img src="https://forum.rebol.info/images/emoji/twitter/fearful.png?v=12" title=":fearful:" class="emoji" alt=":fearful:" loading="lazy" width="20" height="20"></p>
<p>The problem is, that at the time of the spec processing, there's no object in existence to bind into and do such an evaluation.</p>
<p>So this would have to somehow collect the words inside the SET-BLOCK, save the expression, make the archetypal frame, bind into the <em>archetypal frame</em> and evaluate into its locals.</p>
<p>Continuing on this...</p>
<h2><a name="p-7926-set-words-not-being-bound-has-other-consequences-3" class="anchor" href="https://forum.rebol.info#p-7926-set-words-not-being-bound-has-other-consequences-3"></a>SET-WORD!s Not Being Bound Has Other Consequences</h2>
<p>Evaluating the expression, and then writing it into a slot of a partially constructed archetypal FRAME! has other things that are ruled out:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2210">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>What binding rules is it using? Could you initialize local3 and then say <strong><code>local4: (local2 * arg1)</code></strong>?</p>
<ul>
<li>Almost certainly not, and it would just be using the binding of the spec block</li>
</ul>
</blockquote>
</aside>
<p>So that can't work, because what's happening is that the expression is just being evaluated and put in a spot that represents local4.  No "SET" is actually happening, because there's no completed context to assign it to.</p>
<p>That rules out other ideas, like <a href="https://forum.rebol.info/t/a-dream-for-debugging-generalized-accessors/2259">assigning an "accessor"</a>.</p>
<p>When put this way, it makes it seem like using a GROUP! is clearer, because it makes you aware that there's no actual SET-WORD! to assign to.</p>
<h2><a name="p-7926-does-this-suggest-a-redesign-is-needed-4" class="anchor" href="https://forum.rebol.info#p-7926-does-this-suggest-a-redesign-is-needed-4"></a>Does This Suggest A Redesign Is Needed?</h2>
<p>The system <em>could</em> generate the archetypal frame, with nothing in the local slots, and then bind the expressions into it and run them...just as they would run had it been an instantiated function.</p>
<p>So this would be a two-phase thing, that would enable things like multi-returns, accessors, weird-infix-functions that capture the thing they're assigning to in order to know their names...etc.</p>
<p><strong>It's definitely a lot more than I bargained for when I suggested the feature.</strong>  So what would happen here is that only a subset would be implemented, with the rest being done at a future date...</p>
<p><strong>What it does point out is the set of things that the GROUP!-based syntax cannot do.</strong></p>
<pre><code> /foo: function [arg1 arg2 &lt;local&gt; x y (1 + 2) z (null)] [...body...]
</code></pre>
<p>So the big question is whether that's by design ("we don't plan to implement anything more, it's a simple low-hanging fruit you can take advantage of if it fits")... or if it's too limited.</p>
<h2><a name="p-7926-then-is-freeform-dialecting-good-5" class="anchor" href="https://forum.rebol.info#p-7926-then-is-freeform-dialecting-good-5"></a>Then... Is Freeform Dialecting Good?</h2>
<p>It forces the question of "is the word and set-word mix good"</p>
<pre><code> /foo: function [arg1 arg2 &lt;local&gt; x y: 1 + 2 z: null] [...body...]
</code></pre>
<p><em>Instinctually, I feel uneasy about that.</em></p>
<p>If we went that direction, I'd kind of rather have all the locals be SET-WORD!, and allow you to chain the assignments:</p>
<pre><code> /foo: function [arg1 arg2 &lt;local&gt; x: y: z: ~] [...body...]
</code></pre>
<p>I think that if people were hinted that they <em>could</em> assign the locals there, and if they found out this gave them an efficiency boost, the feature might be taken advantage of more.</p>
<p>But they would not be able to be assigned in terms of arguments, so that's a limitation.</p>
<p>And if it's going to be limited anyway, might it be best to let people in on the limitations and just keep it as WORD! plus GROUP! ?</p>
<h2><a name="p-7926-leaning-to-stick-with-word-optional-group-6" class="anchor" href="https://forum.rebol.info#p-7926-leaning-to-stick-with-word-optional-group-6"></a>Leaning To: Stick With WORD! + optional GROUP!</h2>
<p>Really, what we're talking about here is an optimization.</p>
<ol>
<li>
<p>If a local wants a fixed value upon entry to the function on each call, that fixed value can be stored by the archetypal frame and copied into a new instance's cell, at the same cost that initializing it with nothing would cost.</p>
</li>
<li>
<p>If you are initializing a local in such a way, you don't have to repeat its name to initialize it... because you're putting the initial value beside it.</p>
</li>
</ol>
<p>If the function creation process becomes two-pass, doing strange bindings/etc., you're starting to drift from the "optimizing" part of the optimization.  And I'm concerned about the complexity cost of that code.  Thinking about it now, there are details to where I'm not sure how it would work.</p>
<p>Evaluating a GROUP! and dropping its value into the slot of an incomplete archetype you're building is cheap-as-free, and not complicated.</p>
<p>It's a natural extension of just listing out locals as words, and I think it turns out to probably be for the best.</p> ]]></description>
        <link>https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210#post_2</link>
        <pubDate>Fri, 22 Nov 2024 04:04:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7926</guid>
      </item>
      <item>
        <title>Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2335">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Feature-wise, there's a slight loss of the commentary capacity of <code>&lt;with&gt;</code>.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">global-var: 10

foo: function [arg1 arg2 &lt;with&gt; global-var] [  ; no-op, but useful?
    global-var: 20
    return arg1 + arg2
]
</code></pre>
</blockquote>
</aside>
<p>So... deleting this information does seem lossy.  It's helpful to see when something uses non-local declarations.</p>
<p>But the premise of the language is that you get these things as visible by default.</p>
<p>Some time ago I wondered about the idea that only functions would have this visibility, and any non-functions you would need <code>&lt;with&gt;</code> to see and modify.</p>
<p>Today that would mean you'd have to explicitly bind it:</p>
<pre><code>global-var: 10

foo: function [
    arg1 arg2
]
bind @global-var [
    global-var: 20
    return arg1 + arg2
]
</code></pre>
<p>But this feels like an uphill battle, and you're probably inconveniencing as many or more situations than you are clarifying.</p>
<p>Perhaps it's better to just count one's small victories...e.g. that you have to pre-declare <code>global-var</code>, and typos like <code>globl-var:</code> won't work.</p>
<p>A lot of these cases are really situations where you should make an object with data members and methods, anyway... vs. have some sneaky relationship between global variables and certain functions.</p>
<h2><a name="p-7925-i-decided-to-tolerate-with-in-the-specs-for-now-1" class="anchor" href="https://forum.rebol.info#p-7925-i-decided-to-tolerate-with-in-the-specs-for-now-1"></a>I decided to tolerate <code>&lt;with&gt;</code> in the specs for now</h2>
<p>What the native code actually does is a better-than-nothing enforcement, that it checks to make sure the thing you mention for with has a binding.  This caught some stale <code>&lt;with&gt;</code>.</p>
<h2><a name="p-7925-and-i-might-bring-back-static-2" class="anchor" href="https://forum.rebol.info#p-7925-and-i-might-bring-back-static-2"></a>and... I <em>Might</em> Bring Back <code>&lt;static&gt;</code></h2>
<p>Since I've been able to easily implement the <code>&lt;local&gt;</code> initialization feature, as well as settle on <a href="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210/2">why it uses a WORD!+GROUP! instead of a SET-WORD</a>, I might be willing to add the feature back.</p>
<p>But as that thread explains, the notation of WORD!+GROUP! limits you in terms of what you can do with your assignments.  The workaround for locals is to put the assignments in the body.  The workaround for statics is to use BIND.</p>
<p>I'll weigh the pros and cons, but for right now BIND is getting exercised...and the PARSE wrapper that slowed down every function generation is gone.</p> ]]></description>
        <link>https://forum.rebol.info/t/dropping-with-in-static/2335#post_3</link>
        <pubDate>Fri, 22 Nov 2024 00:31:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7925</guid>
      </item>
      <item>
        <title>Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <h2><a name="p-7924-the-dying-parse3-based-func-wrapper-1" class="anchor" href="https://forum.rebol.info#p-7924-the-dying-parse3-based-func-wrapper-1"></a>The Dying PARSE3-BASED FUNC Wrapper</h2>
<p>Here's a snapshot of the code that was written to PARSE the spec, and produce a new one...creating any necessary objects for <code>&lt;static&gt;</code> etc.</p>
<p>As a shortcut, it first did a search with FIND to see if the spec contained any TAG!.  If it did not, it would fall through to the normal func.  <em>(Though this did mean that any <code>&lt;local&gt;</code> tags would trigger the longer version, even though that was supplied by FUNC.)</em></p>
<p>It used PARSE3 because UPARSE was built on top of it, and because it would of course be way too slow at this time.</p>
<p><strong>As I often say about these things... as grotesque as they may seem, they exercise the system asking if we can do certain things in usermode.</strong>  And it shows a good bet for not having written this as tailored native code, because that would all be getting thrown out right now!</p>
<p>And it's not getting <em>completely</em> thrown out... because it's shifting to be part of the test code (and I'm making it use UPARSE, since the performance no longer matters).</p>
<pre><code>/function: func [
    "Augment action with &lt;static&gt;, &lt;in&gt;, &lt;with&gt; features"

    return: [action?]
    spec "Help string (opt) followed by arg words (and opt type and string)"
        [block!]
    body "The body block of the function"
        [&lt;const&gt; block!]
    &lt;local&gt;
        new-spec var loc other
        new-body defaulters statics
][
    ; The lower-level FUNC is implemented as a native, and this wrapper
    ; does a fast shortcut to check to see if the spec has no tags...and if
    ; not, it quickly falls through to that fast implementation.
    ;
    all [
        not find spec tag?/
        return func spec body
    ]

    ; Rather than MAKE BLOCK! LENGTH OF SPEC here, we copy the spec and clear
    ; it.  This costs slightly more, but it means we inherit the file and line
    ; number of the original spec...so when we pass NEW-SPEC to FUNC or PROC
    ; it uses that to give the FILE OF and LINE OF the function itself.
    ;
    ; !!! General API control to set the file and line on blocks is another
    ; possibility, but since it's so new, we'd rather get experience first.
    ;
    new-spec: clear copy spec  ; also inherits binding

    new-body: null
    statics: null
    defaulters: null
    var: #dummy  ; enter PARSE with truthy state (gets overwritten)
    loc: null

    parse3 spec [opt some [
        :(if var '[  ; so long as we haven't reached any &lt;local&gt; or &lt;with&gt; etc.
            var: [
                &amp;set-word? | &amp;get-word? | &amp;any-word? | &amp;refinement?
                | quoted!
                | the-group!  ; new soft-literal format
            ] (
                append new-spec var
            )
            |
            other: block! (
                append new-spec other  ; data type blocks
            )
            |
            other: across some text! (
                append new-spec spaced other  ; spec notes
            )
        ] else [
            'bypass
        ])
    |
        other: group! (
            if not var [
                fail [
                    ; &lt;where&gt; spec
                    ; &lt;near&gt; other
                    "Default value not paired with argument:" (mold other)
                ]
            ]
            defaulters: default [inside body copy '[]]
            append defaulters spread compose [
                (var): default (meta eval inside spec other)
            ]
        )
    |
        (var: null)  ; everything below this line resets var
        bypass  ; failing here means rolling over to next rule
    |
        '&lt;local&gt; (append new-spec &lt;local&gt;)
        opt some [var: word! other: opt group! (
            append new-spec var
            if other [
                defaulters: default [inside body copy '[]]
                append defaulters spread compose [  ; always sets
                    (var): (meta eval inside spec other)
                ]
            ]
        )]
        (var: null)  ; don't consider further GROUP!s or variables
    |
        '&lt;in&gt; (
            new-body: default [
                copy:deep body
            ]
        )
        opt some [
            other: [object! | word! | tuple!] (
                if not object? other [
                    other: ensure [any-context?] get inside spec other
                ]
                new-body: bind other new-body
            )
        ]
    |
        '&lt;with&gt; opt some [
            other: [word! | path!]  ; !!! Check if bound?
        |
            text!  ; skip over as commentary
        ]
    |
        ; For static variables to see each other, the GROUP!s can't have an
        ; hardened context.  We ignore their binding here for now.
        ;
        ; https://forum.rebol.info/t/2132
        ;
        '&lt;static&gt; (
            statics: default [copy inside spec '[]]
            new-body: default [
                copy:deep body
            ]
        )
        opt some [
            var: word!, other: opt group! (
                append statics setify var
                append statics any [
                    bindable maybe other  ; !!! ignore binding on group
                    '~
                ]
            )
        ]
        (var: null)
    |
        &lt;end&gt; accept (~)
    |
        other: &lt;here&gt; (
            fail [
                ; &lt;where&gt; spec
                ; &lt;near&gt; other
                "Invalid spec item:" @(other.1)
                "in spec" @spec
            ]
        )
    ]]

    if statics [
        statics: make object! statics
        new-body: bind statics new-body
    ]

    ; The constness of the body parameter influences whether FUNC will allow
    ; mutations of the created function body or not.  It's disallowed by
    ; default, but TWEAK can be used to create variations e.g. a compatible
    ; implementation with Rebol2's FUNC.
    ;
    if const? body [new-body: const new-body]

    return func new-spec either defaulters [
        append defaulters as group! bindable any [new-body body]
    ][
        any [new-body body]
    ]
]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/dropping-with-in-static/2335#post_2</link>
        <pubDate>Thu, 21 Nov 2024 23:29:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7924</guid>
      </item>
      <item>
        <title>Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>In R3-Alpha, there was the idea that FUNC was lower-level, <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28C1-L56C2">and "FUNCTION" was built on top of it</a>.</p>
<p>Its principal difference was automatically collecting SET-WORD!s as locals.  But it added two refinements: <strong>/WITH</strong> and <strong>/EXTERN</strong>.</p>
<p>/EXTERN was a way of saying what shouldn't get collected as a local variable due to being a SET-WORD!:</p>
<pre><code>global-var: 10

foo: function/extern [arg1 arg2] [
    local-var: "hi"
    global-var: 20  ; /EXTERN protected this from being collected local
    return arg1 + arg2
] [global-var]
</code></pre>
<p>/WITH was a way of making static variables:</p>
<pre><code>accumulate: function/with [x] [
   return state: state + x
] [state: 0]
</code></pre>
<h2><a name="p-7923-early-on-ren-c-moved-everything-into-the-spec-1" class="anchor" href="https://forum.rebol.info#p-7923-early-on-ren-c-moved-everything-into-the-spec-1"></a>Early On, Ren-C Moved Everything Into The Spec</h2>
<p>I didn't like seeing the refinement arguments at the end (of what could be a very long function definition).</p>
<p>It didn't occur to me to suggest that <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">refinement arguments be moved to the head</a> (which they probably should).  But what did occur to me was that the function spec could incorporate these properties.</p>
<p>I actually thought <code>&lt;with&gt;</code> seemed better than extern, as a nicer word for "Use these existing variables".  And <code>&lt;static&gt;</code> seemed like a well-known term for static variables:</p>
<pre><code>foo: function [arg1 arg2 &lt;with&gt; global-var] [
    local-var: "hi"
    global-var: 20
    return arg1 + arg2
]

accumulate: function [x &lt;static&gt; state (0)] [
   return state: state + x
]
</code></pre>
<p>The subtlety of wanting to use an object instance was also added, as <code>&lt;in&gt;</code>:</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [x &lt;in&gt; obj] [
   return a + b + x
]
</code></pre>
<p>To my eyes, that all seemed like improvement.</p>
<p><strong>But it didn't come without cost: The spec had to be transformed into something the lower-level FUNC could understand.</strong></p>
<p>This meant there was a layer of parsing and production of a new spec that was a tax on every function creation.</p>
<h2><a name="p-7923-time-passes-set-word-gathering-is-panned-2" class="anchor" href="https://forum.rebol.info#p-7923-time-passes-set-word-gathering-is-panned-2"></a>Time Passes, SET-WORD! Gathering Is Panned</h2>
<p>It didn't take long for me to decide that <a href="https://forum.rebol.info/t/rethinking-auto-gathered-set-word-locals/1150">SET-WORD! locals-gathering was bad</a>... a gimmick that only made sense in very limited domains (perhaps code-golf)</p>
<p>This motivated having an answer for how to implement LET, as "virtual binding" became the new plan.</p>
<p>Once that transition went through, the effect of <strong><code>&lt;with&gt;</code></strong> was to become commentary.  Since all it did was remove SET-WORD!s from the collection list, and there was no collection any longer.</p>
<p>Though virtual binding did open up a new possibility, that if your block had a different binding than the spec, then the WITH might import visibility of terms to that block:</p>
<pre><code>global-variable: 10

block: /get-block-from-somewhere ...  ; doesn't know about GLOBAL-VARIABLE

/foo: function [x &lt;with&gt; global-variable] block
</code></pre>
<p>But this would be a binding operation, that is better generalized as:</p>
<pre><code>/foo: function [x] (bind @global-variable block)
</code></pre>
<h2><a name="p-7923-pushing-the-features-to-bind-make-the-most-sense-3" class="anchor" href="https://forum.rebol.info#p-7923-pushing-the-features-to-bind-make-the-most-sense-3"></a>Pushing The Features To BIND Make The Most Sense</h2>
<p>Not just <code>&lt;with&gt;</code>, but the <code>&lt;static&gt;</code> and <code>&lt;in&gt;</code> features seemed to be better as BIND operations as well.</p>
<p>The static syntax of not using SET-WORD!s was based on the idea that SET-WORD!s were reserved for local variables (and RETURN: syntax).  So it was a WORD! followed by a GROUP! to initialize.</p>
<p>I think it's better done with just <a href="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139">BIND to a FENCE!</a></p>
<pre><code>accumulate: function [
    x
] bind {state: 0} [
   return state: state + x
]
</code></pre>
<p><code>&lt;in&gt;</code> is similar.</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [
   x
] bind obj [
   return a + b + x
]
</code></pre>
<h2><a name="p-7923-uglier-maybe-more-general-yes-faster-definitely-4" class="anchor" href="https://forum.rebol.info#p-7923-uglier-maybe-more-general-yes-faster-definitely-4"></a>Uglier?  Maybe.  More General?  Yes.  Faster?  Definitely.</h2>
<p>Feature-wise, there's a slight loss of the commentary capacity of <code>&lt;with&gt;</code>.</p>
<pre><code>global-var: 10

foo: function [arg1 arg2 &lt;with&gt; global-var] [  ; no-op, but useful?
    global-var: 20
    return arg1 + arg2
]
</code></pre>
<p>But besides that, there's no loss of features to move everything to a BIND operation on the body.</p>
<p>Not having to PARSE the spec and generate a whole new one is a big performance win.</p>
<p>So I'm letting go of those features.</p> ]]></description>
        <link>https://forum.rebol.info/t/dropping-with-in-static/2335#post_1</link>
        <pubDate>Thu, 21 Nov 2024 22:06:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7923</guid>
      </item>
      <item>
        <title>Red&#39;s Take on String Interpolation</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I'm a bit torn regarding default interpolation (and COMPOSE in general).</p>
<p>Conventional wisdom for interpolation or templating would be to use something fairly uncommon.</p>
<p>But if you can customize it and choose alternatives, that makes it seem like maybe you should capitalize on a more common thing...even if it competes for the notational space.</p>
<p><a href="https://github.com/red/REP/issues/112">Red gives some examples, e.g. in URL interpolation</a>, so consider something like:</p>
<pre><code>&gt;&gt; compose* http://(site)/(resource)?param=(date as "yyyy")
== http://example.com/whatever.html?param=1998
</code></pre>
<p>Compare that to:</p>
<pre><code>&gt;&gt; compose* http://{{site}}/{{resource}}?param={{date as "yyyy"}}
== http://example.com/whatever.html?param=1998
</code></pre>
<p>Something gets lost, there.</p>
<p>Single braces might be more out-of-band than parentheses, while not looking all that bad, and maybe two stars could be used when you want to double them up:</p>
<pre><code>&gt;&gt; compose* http://{site}/{resource}?param={date as "yyyy"}
== http://example.com/whatever.html?param=1998

&gt;&gt; compose** http://{{site}}/{{resource}}?param={{date as "yyyy"}}
== http://example.com/whatever.html?param=1998
</code></pre>
<p>Though it still doesn't look quite as good as the plain parentheses do.  And it has the problem that you're frequently interpolating braced strings:</p>
<pre><code>compose* -{Here's your {1 + 2} escape}-

compose* -{Here's your (1 + 2) escape}-  ; feels better
</code></pre>
<p>Parentheses could use the doubled-up shorthand idea with <code>**</code>:</p>
<pre><code>&gt;&gt; compose* http://(site)/(resource)?param=(date as "yyyy")
== http://example.com/whatever.html?param=1998

&gt;&gt; compose** http://((site))/((resource))?param=((date as "yyyy"))
== http://example.com/whatever.html?param=1998
</code></pre>
<p>There's a sort of weird logic to going with plain parentheses that I'm finding compelling.  On the surface it's naive, but in practice it may be that if you offer enough ways to raise and alter the escaping then picking something that simple makes sense.</p>
<p>I think that having the "real" COMPOSE be arity-2 helps the whole thing come across as less naive, because you're passing in not just a pattern but also a binding environment.  So saying <em>"look, this <code>compose*</code> and <code>print*</code> stuff is just for convenience, the real COMPOSE is solid"</em> feels more intelligent.</p>
<p>There's a non-zero benefit to aligning with historical Rebol in this design aspect.  (But certainly a lot of benefit from being able to customize the pattern!)</p> ]]></description>
        <link>https://forum.rebol.info/t/reds-take-on-string-interpolation/2121#post_7</link>
        <pubDate>Thu, 21 Nov 2024 08:18:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7922</guid>
      </item>
      <item>
        <title>First Bootstrap In At Least 6 Months: Watershed Changes</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Evolving Ren-C is a messy and difficult balancing act.  Due to the experimental nature and bus-factor-of-one staffing, it's not always a good use of time to completely push through a change in all code...until it's seen to be a good change.</p>
<p>The adoption of dozens of experimental ideas had led to a situation where being able to bootstrap the codebase stalled... for possibly the longest period yet.  This is to say that while the old 2018-era executable is used to make all the <code>.h</code> and <code>.c</code> files to build the current sources, the executable it built would be unable to do so.</p>
<p>But a few days ago, I managed to accomplish bootstrap. And I've gotten several other codebases that had been atrophying (Whitespacers, Rebol-HTTPD, Query) up to date.</p>
<p>While there are a lot of shaky parts (in particular, the workings of the new form of methodization that relies on <a href="https://forum.rebol.info/t/word-as-member-selection/1843/3">leading-dot <strong>.member</strong> accesses</a>), I'd say overall things are very promising.</p>
<p>One of the toughest points was the institution of "strict mode"... where you cannot assign to a variable that has not been pre-declared in some way (either as a module-level declaration, a LET, a <code>&lt;local&gt;</code>, made with WRAP, etc.)  This is a big change, but a good one... for all the reasons "strict mode" is known to be good, but also because it eliminated <a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128">"attachment binding"</a></p>
<h2><a name="p-7921-not-easy-but-very-instructive-1" class="anchor" href="https://forum.rebol.info#p-7921-not-easy-but-very-instructive-1"></a>Not Easy, But Very Instructive</h2>
<p>In some ways, the story of Ren-C's evolution is told by Rebmake, and the process which produces all the <strong><code>.h</code></strong> and <strong><code>.c</code></strong> files that the build relies on.</p>
<p>It's certainly one of the top 3 biggest and snakiest Rebol codebases (I'd argue it's probably the <em>trickiest</em> codebase of its size, moreso than Red or Atronix Zoe).  And it contains the code of Carl, Shixin, Brett, BrianH, myself, and others... a mixture of styles, and patches, and hacks.  Some huge bends come from needing to run in an executable that's not much beyond a patched version of what ran in 2018.</p>
<p>I've also explained why <a href="https://forum.rebol.info/t/new-build-executables-new-build-strategy/1432">adopting Rebmake was very consequential, and complicating</a>.   It brought concerns to the build process to be a superset of CMake and GNU make, instead of being narrow and focused like other approaches (Giulio and Andreas tried their hands at much more succinct ideas, and Oldes <a href="https://forum.rebol.info/t/siskin-builder-rebol-based-build-tool-by-oldes/1672">is using something much lighter in daily work today</a>).</p>
<p>But this has informed the design, hardened it, and challenged it.</p>
<h2><a name="p-7921-a-new-weird-world-driven-by-reason-and-experience-2" class="anchor" href="https://forum.rebol.info#p-7921-a-new-weird-world-driven-by-reason-and-experience-2"></a>A New "Weird" World: Driven By Reason and Experience</h2>
<p>With changes like <strong><code>:refinement</code></strong> instead of <strong><code>/refinement</code></strong>, and the switch to where actions are assigned as <strong><code>/foo: func [...] [...]</code></strong>, plus member variables being indicated with <strong><code>.field</code></strong> -- things are starting to look quite different.</p>
<p><em>But I can say with confidence that from a usage perspective, it is very clearly better.</em></p>
<p>The slashes for functions is quite empowering.  Unlike the pox of <strong><code>:deactivating</code></strong> GET-WORD!s, slashes tell you <strong>what you know</strong> instead of <strong>what you DON'T know</strong>.</p>
<p>Refinements being done with colons does come out as what seems like a casualty of that, where you can have something like:</p>
<pre><code>data: copy:part series pos
</code></pre>
<p>It mingles refinements and assignments notationally, which some might find bad.  Though I think it's nothing like mingling field accesses and refinements with both being slashes.</p>
<p>And once you get used to it, I think it actually is nice to have the colons blend more quietly.  This allows the slashes to stand out, and it really is a better use of it popping.</p>
<p>The <strong><code>.field</code></strong> accesses are--I think--a pretty definite win.  I've made it so that the lone period (<strong><code>.</code></strong>) defaults to one of those sneaky functions that looks at the current environment, and gives you the object that the <strong><code>.field</code></strong> accesses are from.  So if you really want to bring all those fields into scope where you can use them undecorated, you'd be able to do something along the lines of:</p>
<pre><code>use &lt;*&gt; .
print ["Now I can access" field "without dots"]
</code></pre>
<p><em>(Though the notation for that is still in flux.)</em></p>
<p>But really, it's very hard to keep things straight and know what's an argument and what's a member... so I <em>like</em> the dots.  (They were added on purpose...and are harder to implement than just doing lookup in the object as a higher priority for regular words, so of course I must like them!)</p>
<h2><a name="p-7921-sowhats-not-working-well-3" class="anchor" href="https://forum.rebol.info#p-7921-sowhats-not-working-well-3"></a>So...What's NOT Working Well?</h2>
<p>One of the biggest problems I've run into is that the easy interplay between WORD! and SET-WORD! and GET-WORD! has been replaced by some really finicky sequence mechanics.</p>
<p>For instance, this no longer works:</p>
<pre><code> &gt;&gt; to word! first [a: 10]
 ** Error
</code></pre>
<p>TO's rule is reversibility.  And <strong><code>(to chain! 'a)</code></strong> shouldn't be biased to either <strong><code>a:</code></strong> or <strong><code>:a</code></strong></p>
<p>Maybe you could argue for saying that <strong><code>a:</code></strong> is more useful, and so TO for sequences should put words at the head.  But that's not really the case for <strong><code>a.</code></strong> or <strong><code>a/</code></strong>, is it?</p>
<p>Then you have composites like <strong><code>/a:</code></strong>, and the question of just how many routines have to deal with these composites... and what the rules are.  If you do a <strong>SET</strong> of plain <strong>a</strong> to an action, should that be an error unless you change it to set <strong>/a</strong> ?  Should SET support <strong>/a:</strong> or make you extract things down?</p>
<p>I've been building little parts to help attack this, such as a function RESOLVE for picking the variable out of a sequence:</p>
<pre><code>&gt;&gt; resolve first [/a:]
== a

&gt;&gt; resolve first [a.b/]
== a.b
</code></pre>
<p>And that's the kind of thing that helps pick up the slack from things like TO WORD!.</p>
<p>It's still new and awkward territory.  There's certainly going to be some amount of irreducible complexity that comes from working with these new parts, but I'm hopeful that I'll be able to reduce the pain as things develop.</p>
<h2><a name="p-7921-overall-things-are-reasonably-strong-4" class="anchor" href="https://forum.rebol.info#p-7921-overall-things-are-reasonably-strong-4"></a>Overall, Things Are Reasonably Strong</h2>
<p>I talk about how Ren-C's development methodology just keeps solidifying, to let it move on to building higher things.</p>
<p>Even with many pieces teetering on the edge, there's still a solidity underneath it all that means I almost never wind up chasing Heisenbugs.  When a part needs to be hardened, it can be hardened.</p>
<p>In any case, it's good to see it bootstrapping after a long time of not.  I'm hopeful that by the end of the year I'll feel comfortable enough to make new bootstrap executables and push out the web build, so expect a big "drop" sometime in December.</p> ]]></description>
        <link>https://forum.rebol.info/t/first-bootstrap-in-at-least-6-months-watershed-changes/2334#post_1</link>
        <pubDate>Thu, 21 Nov 2024 05:08:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7921</guid>
      </item>
      <item>
        <title>Red&#39;s Take on String Interpolation</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>The key is making it very light, and not to break the readability flow.</p>
<p><strong><code>print*</code></strong> might be light enough, with the <code>*</code> warning "I'm doing extra processing on this string" (and "I'm doing implicit environment capture"?)</p>
<pre><code>&gt;&gt; print* "Number is {{num}}"
Number is 10
</code></pre>
<p>There's also <strong><code>print+</code></strong>... a little less noisy, but maybe too much so... the <code>+</code> blends a bit and looks like a T, right against a T.</p>
<pre><code>&gt;&gt; print+ "Number is {{num}}"
Number is 10
</code></pre>
<p>I can empathize that there needs to be <em>something</em> there to clue you into the extra work going on.</p>
<p>It may look nicer--but it is less efficient to have to scan the code every time.  (Though investing on making that scan fast helps the whole system.)</p> ]]></description>
        <link>https://forum.rebol.info/t/reds-take-on-string-interpolation/2121#post_6</link>
        <pubDate>Thu, 21 Nov 2024 01:41:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7920</guid>
      </item>
      <item>
        <title>Red&#39;s Take on String Interpolation</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>On PRINT, I tend towards not doing implicit interpolation there. But it could work quite well as a refinement: <code>print:interpolate "Number is {{num}}"</code>.</p> ]]></description>
        <link>https://forum.rebol.info/t/reds-take-on-string-interpolation/2121#post_5</link>
        <pubDate>Thu, 21 Nov 2024 01:38:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7919</guid>
      </item>
      <item>
        <title>Red&#39;s Take on String Interpolation</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hiiamboris" data-post="3" data-topic="2121">
<div class="title">
<div class="quote-controls"></div>
 hiiamboris:</div>
<blockquote>
<p><em>"Try to look at these expressions and visualize how the resulting string will look like, and if I've got all spaces and quotes right. Not a human task, eh?"</em></p>
</blockquote>
</aside>
<p>I've proposed that COMPOSE be arity-2 and able to interpolate strings, e.g.</p>
<pre><code>&gt;&gt; num: 10

&gt;&gt; print compose ${{}} "Number is {{num}}, so there."
Number is 10, so there.
</code></pre>
<p>Having to say <strong>compose ${{}}</strong> is <em>noisy</em> for day to day use of a common construct like PRINT.</p>
<p>But even this trivial case shows a benefit of being able to put the comma right up against the number if you want to.  That's hard to do, as PRINT typically adds spaces around everything.  So you have to do something like this:</p>
<pre><code>&gt;&gt; print unspaced ["Number is" _ num ", so there."]
Number is 10, so there.
</code></pre>
<p>An experiment interprets BLOCK! in the source as grouping things tightly:</p>
<pre><code>&gt;&gt; print ["Number is" [num ","] "so there."]
Number is 10, so there.
</code></pre>
<p>Still, it's lousy compared to interpolation (see hiiamboris's examples for other ones).</p>
<h2><a name="p-7918-what-if-print-of-a-text-did-sneaky-interpolation-1" class="anchor" href="https://forum.rebol.info#p-7918-what-if-print-of-a-text-did-sneaky-interpolation-1"></a>What If PRINT of a TEXT! did "Sneaky Interpolation"?</h2>
<p>We could make it so that PRINT is one of the sneaky constructs that captures the binding from its callsite, and that it assumes some interpolation delimiter:</p>
<pre><code>&gt;&gt; num: 10

&gt;&gt; print "Number is {{num}}, so there."
Number is 10, so there.
</code></pre>
<p>Then we could say that if you don't want that, you can put the string in a block:</p>
<pre><code>&gt;&gt; print ["When using a block, {{...}} would not interpolate."]
When using a block, {{...}} would not interpolate.
</code></pre>
<p>There's another option to pass PRINT an <code>@var</code>, and if you did then that would suppress interpolation as well.</p>
<pre><code>&gt;&gt; str: "Number is {{num}}, so there."

&gt;&gt; print str
Number is 10, so there.

&gt;&gt; print [str]
Number is {{num}}, so there.

&gt;&gt; print @str
Number is {{num}}, so there.
</code></pre>
<h2><a name="p-7918-it-could-be-an-option-2" class="anchor" href="https://forum.rebol.info#p-7918-it-could-be-an-option-2"></a>It Could Be An Option</h2>
<p>There could be some way of turning this behavior on or off, and specifying what the delimiters are.</p>
<p>Maybe the default PRINT wouldn't have it, but you could say:</p>
<pre><code>/print: make-sneaky-print '(())  ; note unbound, since it captures binding
</code></pre>
<p>It's a little bit of a relearning of habits to know that plain <strong>print str</strong> would have this extra processing overhead.  But, I think it is learnable, and I'd definitely use it.</p>
<h2><a name="p-7918-other-options-brief-operators-other-names-3" class="anchor" href="https://forum.rebol.info#p-7918-other-options-brief-operators-other-names-3"></a>Other Options: Brief Operators, Other Names</h2>
<p>This could be a different word like <strong><code>echo</code></strong> or <strong><code>say</code></strong> or something like that, though I'm not crazy about either of those.</p>
<p>It could also be an operator you could make arbitrarily brief:</p>
<pre><code>print op "Number is {{num}}, so there."
</code></pre>
<p>But I don't know there's anything on the <a href="https://forum.rebol.info/t/tapping-the-untapped-potential-of-short-words/395">list of short words</a> that would make the cut.</p>
<p>It could be the result of some decoration:</p>
<pre><code>print @["Number is {{num}}, so there."]
</code></pre>
<p>But that's not what that is intended to mean.</p>
<p>It could be done with a different string type:</p>
<pre><code>print %"Number is {{num}}, so there."

print &lt;Number is {{num}}, so there.&gt;
</code></pre>
<p>The TAG! doesn't seem completely crazy, though I have other ideas for what TAG! means in PRINT as a formatting instruction.</p>
<p>It seems to me that giving the power to a plain PRINT is the most useful.</p>
<h2><a name="p-7918-most-likely-alternative-sneaky-compose-4" class="anchor" href="https://forum.rebol.info#p-7918-most-likely-alternative-sneaky-compose-4"></a>Most Likely Alternative: Sneaky COMPOSE</h2>
<p>I've debated if COMPOSE should use sneaky binding, and maybe it should.</p>
<p>Maybe its default should be <strong>{{...}}</strong> as well, and just make that out of band, as something that doesn't get other meaning in the system.</p>
<pre><code>&gt;&gt; compose '[(1 + 2) {{3 + 4}} {5 + 6}]
== [(1 + 2) 7 {5 + 6}]

print compose "Number is {{num}}, so there."

print compose:with $() "Number is (num), so there."
</code></pre>
<p>Or maybe the default should stay at <code>(...)</code> for the natural brevity:</p>
<pre><code>&gt;&gt; compose '[(1 + 2) {{3 + 4}} {5 + 6}]
== [3 {{3 + 4}} {5 + 6}]

print compose "Number is (num), so there."

print compose:with ${{}} "Number is {{num}}, so there."
</code></pre>
<p>It's just that parentheses seem so common in code and text that you'd often be pushing them out of the way.</p>
<p><em>I still feel like having it built into PRINT is a sort of convenience that it's hard to like any extra word in there, even just COMPOSE.</em>  And if it's built-in, then {{...}} seems better than (...)</p> ]]></description>
        <link>https://forum.rebol.info/t/reds-take-on-string-interpolation/2121#post_4</link>
        <pubDate>Wed, 20 Nov 2024 20:17:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7918</guid>
      </item>
      <item>
        <title>Design for IMPORT</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I like the idea of separating USE and IMPORT like that. It feels like a very clean design to me.</p>
<p>As for ‘opt all in’, I like the syntax <code>use &lt;*&gt; object</code> or <code>use # object</code>. I don’t feel like a specialisation or refinement is necessary. There’s probably further dialecting possibilities for the first argument of USE, if we just think about what people would want to do.</p> ]]></description>
        <link>https://forum.rebol.info/t/design-for-import/1570#post_5</link>
        <pubDate>Wed, 20 Nov 2024 05:32:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7917</guid>
      </item>
      <item>
        <title>Value (vs. Series) Modification Bit: CONST and MUTABLE</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>The const feature was implemented via CELL_FLAG_CONST, a bit that a cell could have set (or not) in its header.</p>
<p>But there was a second bit... called CELL_FLAG_EXPLICITLY_MUTABLE.</p>
<p>This bit protected a block from the "wave of constness".</p>
<p>It was necessitated by some behaviors that I ultimately deemed to be bugs.  Now that those bugs are gone, it's no longer mandatory to have it.</p>
<p>So I took it out, but found it broke a test:</p>
<pre><code>block: mutable [a b c]
eval compose:deep $() [repeat 2 [append (block) &lt;legal&gt;]]
assert [block = [&lt;legal&gt; &lt;legal&gt;]]
</code></pre>
<p>So previously, that mutable would put the CELL_FLAG_EXPLICITLY_MUTABLE bit on.  Then, when the COMPOSE ran, you'd get:</p>
<pre><code> eval [repeat 2 [append [a b c] &lt;legal&gt;]]
</code></pre>
<p>Because REPEAT is iterative, it applies CONST to its body.  And that CONST would get applied to the <code>[a b c]</code>...but, CELL_FLAG_EXPLICITLY_MUTABLE overruled it.</p>
<h2><a name="p-7916-but-i-dont-like-cell_flag_explicitly_mutable-1" class="anchor" href="https://forum.rebol.info#p-7916-but-i-dont-like-cell_flag_explicitly_mutable-1"></a>But I Don't Like CELL_FLAG_EXPLICITLY_MUTABLE</h2>
<p>There are other ways to get past the const wave, such as quoting it:</p>
<pre><code>block: [a b c]
eval compose:deep $() [repeat 2 [append '(block) &lt;legal&gt;]]
</code></pre>
<p>Or you could do <strong>append mutable</strong>:</p>
<pre><code>block: [a b c]
eval compose:deep $() [repeat 2 [append mutable (block) &lt;legal&gt;]]
</code></pre>
<p>Admittedly, these require you to have some control of the code the block is being fed into, vs. being able to put a "magic bit" on the block to counteract the const wave.</p>
<p>But the semantics of this magic bit are nebulous.  I would not have added such a thing if it wasn't for working around the things I decided were bugs.  It's not clear when (if ever) it should stop protecting the value, and that just opens a can of worms.</p>
<p>Cell flags are a pretty scarce resource, and giving one up for something that makes the code harder to understand than a simple CONST bit that's on or off is not a good investment.</p> ]]></description>
        <link>https://forum.rebol.info/t/value-vs-series-modification-bit-const-and-mutable/976#post_6</link>
        <pubDate>Wed, 20 Nov 2024 04:12:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7916</guid>
      </item>
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>So I went ahead and did the transition to arity-2 COMPOSE, so I could see the effects.</p>
<p>Since bootstrap needs to still work, I needed to have a name for the arity-1 version, and I called it <strong><code>compose1</code></strong>  <em>Which actually isn't a terrible name for the arity-1 version.</em>  Maybe <strong><code>compose-1</code></strong> would separate the <strong>e</strong> and the <strong>1</strong> a little better, but it also adds noise.</p>
<p>There's also the possibility of <strong><code>compose*</code></strong>, though adding a star usually means "lower level version".  But more generally it could be argued that it's a "special version".</p>
<p>What its doing is actually:</p>
<pre><code>compose1 list
=&gt;
compose (inside list '()) list
</code></pre>
<p>So maybe calling it <strong><code>compose-inside</code></strong> would be more informative, but that wouldn't tell you that you were using groups, so it's <strong><code>compose-groups-inside</code></strong>...</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Stealing the binding from the tip of the block you're composing and using that in the slots is a kind of "weird backchannel". If that's what you're doing, <em>you're the weird one</em>, so maybe your code should reflect that.</p>
</blockquote>
</aside>
<p>Well, when I put it that way, <strong><code>COMPOSE*</code></strong> might be good for this.</p>
<p>Anyway, I think the competition is between calling it <strong><code>COMPOSE*</code></strong> or <strong><code>COMPOSE1</code></strong></p>
<p>If we had <a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">CHAIN! dialecting</a>, it might permit:</p>
<pre><code>&gt;&gt; compose [a (1 + 2) b]
== [a 3 b]

&gt;&gt; compose:${{}} [(a) {{1 + 2}} {b}]
== [(a) 3 {b}]
</code></pre>
<p>But that feature is very speculative, and binding issues may make it non-feasible.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="5" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But, It Would Drive The "Noise" Level Higher...</p>
<p>Some (like <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>) do not like symbols in code at all.</p>
<p>Having COMPOSE frequently instantiated as <strong><code>compose $() [...]</code></strong> would be a thorn. (Though as I've stated, I think you really should be doing <strong><code>compose $() '[...]</code></strong> much more than one would think).</p>
</blockquote>
</aside>
<p><strong>This is a pretty tough call, but I think I'm on the side of saying that COMPOSE should be arity-2.</strong></p>
<p>Beyond the necessity of providing a binding environment when you want to apply COMPOSE to strings, I'm seeing too many places where an arity-1 COMPOSE <em>can't</em> do what you want.</p>
<p>I also feel like taking away the assumption of COMPOSE being groups is good--it's not groups, it's the pattern you choose.  I like <strong><code>{{...}}</code></strong> because at least now, that has no meaning and stands out a lot better.</p>
<p><strong>The harsh reality is that to really make things work... binding has to be thrust into the awareness of those who are building and composing code.</strong></p>
<p>Being able to evaluate templated code groups (or blocks, or fences...) in an environment that is different than the environment of the surrounding code is not something that has been easy before.</p>
<p>But I think it's foundational--and as I've said, the most common surrounding context is likely <em>no</em> context... with the intention of inheriting the meaning from wherever you are putting the composed code.</p> ]]></description>
        <link>https://forum.rebol.info/t/envelop-and-compose-by-example/2294#post_6</link>
        <pubDate>Wed, 20 Nov 2024 00:32:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7915</guid>
      </item>
      <item>
        <title>hiiamboris&#39;s WITH</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2138">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">with x  [..]          == bind [..] x
with 'x [..]          == bind [..] 'x
with :fun [..]        == bind [..] :fun
with [:fun] [..]      == bind [..] :fun
with [x y 'z] [..]    == bind bind bind [..] 'z y x
with [x: 1 y: 2] [..] == bind [..] context [x: 1 y: 2]
</code></pre>
</blockquote>
</aside>
<p>So I was wondering in the design of the WITH-like BIND what plain words should do, as opposed to <code>@word</code>.</p>
<p>One concept I had was that with plain words, BIND could serve the role of "old USE" and create new bindings.  Then, an <code>@word</code> would mean that you wanted to bind to that particular word.</p>
<pre><code>x: 10
y: 20
eval bind [@x y] [
   x: 100  ; overwrites X
   y: 200  ; would not overwrite as plain Y word made new variable
]
</code></pre>
<p>That would be making a distinction between words and <code>@word</code> that lines up with how FOR-EACH and others treat variables.  It was chosen over <code>$word</code> due to the ability to pass the variable reference without a block:</p>
<pre><code>iterate @var [...]   ; the @ sticks, but $var makes a plain bound word
</code></pre>
<p>But BIND has a competing intent, which is when you want to bind to the thing the word points to.</p>
<pre><code>foo: make object! [x: 10 y: 20]
bar: make object! [z: 30]

eval bind [@foo @bar] [  ; alternative intent of @
   assert [all [x = 10, y = 20]]
   assert [z = 30]
]
</code></pre>
<p>This is more like the PARSE meaning of @ which means "dereference this word".</p>
<p>Another way of doing that could be GROUP! evaluations:</p>
<pre><code>eval bind [(foo) (bar)] [
   assert [all [x = 10, y = 20]]
   assert [z = 30]
]
</code></pre>
<p>It's worth pointing out that making new variables with BIND can be done easily another way, with FENCE!, so we could say:</p>
<pre><code>x: 10
y: 20
eval bind [x {y: ~}] [  ; instead of [@x y]
   x: 100  ; overwrites X
   y: 200  ; would not overwrite as {Y: ~} made new variable
]
</code></pre>
<p>And I think giving a value to a new variable is probably more common than not wanting to, anyway.</p>
<p>That frees up the <code>@foo</code> to mean "what I intend to bind to is what you get by dereferencing this" intent.</p>
<p>So binding a single word means bind using the binding of that word.</p>
<pre><code>block: [print ["The value of x is:" x]]

foo: func [x] [
    eval bind $x block
    eval bind [x] block
]

foo 10  ; would print the message with x as 10
</code></pre>
<p><strong>I can't necessarily prove it offhand, but I feel like having <code>bind [@x y]</code> mean something parallel to <code>for-each [@x y]</code> would be beneficial.</strong></p>
<p>That would indicate producing a new variable for Y, and reusing a binding for X.</p>
<p>This makes BIND able to function easily as a "LET that takes a block"</p>
<pre><code>let x
x: 10

bind 'x [x: 10]
</code></pre>
<p>Something about pushing on these symmetries seems more important than giving you a way to dereference variables to implicate the objects they point to, that's briefer than a GROUP!.</p>
<p>(Honestly, multiple binds are probably not that common, and in fact you wouldn't get a lot of benefit out of it by saying <strong><code>bind [(obj1) (obj2)] ...</code></strong> as opposed to <strong><code>bind obj1 bind obj2 ...</code></strong>)</p>
<h2><a name="p-7914-the-binding-dialect-likely-needs-more-features-1" class="anchor" href="https://forum.rebol.info#p-7914-the-binding-dialect-likely-needs-more-features-1"></a>The Binding Dialect Likely Needs More Features</h2>
<p>This is sort of the tip of the iceberg in "meanings you might have for binding requests".  So <strong></strong> could be another way of saying you should dereference, as part of a broader idea of TAG!-instructions:</p>
<pre><code>foo: make object! [x: 10 y: 20]
bar: make object! [z: 30]

eval bind [&lt;in&gt; foo &lt;in&gt; bar] [
   assert [all [x = 10, y = 20]]
   assert [z = 30]
]
</code></pre>
<p>So really we're talking about the needs of the most common form.</p>
<h2><a name="p-7914-althoughignoring-the-binding-is-annoying-2" class="anchor" href="https://forum.rebol.info#p-7914-althoughignoring-the-binding-is-annoying-2"></a>Although...Ignoring The Binding Is Annoying</h2>
<p>This has some consequence, for instance this would have the binding ignored and make a new variable:</p>
<pre><code> eval bind (bind obj 'x) code
</code></pre>
<p>While this would use the binding:</p>
<pre><code> eval bind (bind obj '@x) code
</code></pre>
<p>That would be true of FOR-EACH as well.</p>
<p>It does point out that if you want to bind to a single object's field and not all of it, then it would be helpful to have a notation for that.</p>
<pre><code>eval bind [@obj.x] code
</code></pre>
<p>This could suggest that maybe undecorated means "evaluate this", such that these would be equivalent:</p>
<pre><code> bind foo [...]
 bind [foo] [...]
</code></pre>
<p>As opposed to the FOR-EACH equivalency, which would be:</p>
<pre><code> bind 'foo [...]
 bind [foo] [...]
</code></pre>
<p>I don't know.  <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20">  I guess I'll just have to try things and see what's most useful.</p> ]]></description>
        <link>https://forum.rebol.info/t/hiiamboriss-with/2138#post_3</link>
        <pubDate>Mon, 18 Nov 2024 21:29:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7914</guid>
      </item>
      <item>
        <title>Design for IMPORT</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1570">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We could make an IMPORT that can tell when you've assigned it:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">zip-stuff: import &lt;ZipModule&gt;
</code></pre>
<p>Such a form could then avoid consuming a BLOCK! after it naming individual things to export, since you have named an aggregator:</p>
<p><code>import &lt;ZipModule&gt; [zip unzip]</code></p>
</blockquote>
</aside>
<p>So the idea of a construct that behaves differently based on whether there's something to its left <a href="https://forum.rebol.info/t/skip-able-arguments-2024-update-removed/1013">was lost when <code>&lt;skip&gt;</code>-able parameters were killed off</a>.</p>
<p>This means today when you write something like:</p>
<pre><code>vm: import %ws-runtime.reb
</code></pre>
<p>...you do get the module that was imported in the <strong>vm:</strong> variable, but it also brings all the exports into the local space as words, too.  It had no detection to tell it not to.</p>
<p>I'll re-emphasize that modern languages are stressing the idea that you <em>have</em> to namespace things in this way.</p>
<p>If you want to bring all of those exports into "scope", that could be done with the USE meaning I've been suggesting:</p>
<pre><code>use import %ws-runtime.reb
</code></pre>
<p>But that's kind of an all-or-nothing, where you'd imagine wanting to be able to name just some things to use:</p>
<pre><code>use:some [foo bar] import %ws-runtime.reb
</code></pre>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1570">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think the first lines of the file need to be as good as they can.</p>
</blockquote>
</aside>
<p>Something like <strong><code>use:some [foo bar] import</code></strong> seems to drift a bit from that.</p>
<p>Losing the detection-of-assignment-on-left does set this back a bit...and isn't something I realized was going away when <strong><code>&lt;skip&gt;</code></strong> was tossed.  But there were good reasons for killing that off, and those good reasons don't go away just because it helped one usage.</p>
<p>Making USE arity-2 could avoid the <strong><code>use:some</code></strong>, to be more like:</p>
<pre><code>use &lt;*&gt; import %ws-runtime.reb
use [foo bar] import %ws-runtime.reb
vm: import %ws-runtime.reb
</code></pre>
<p>What to say for "opt all in" could be something else, maybe <strong>#</strong>.  Or maybe it would look nicer as a specialization?</p>
<pre><code>use # import %ws-runtime.reb
use-all import %ws-runtime.reb
</code></pre>
<p>I dunno.  Anyway, the generic USE construct would be something you could apply to any object, to bring its definitions into "scope" for word lookup.</p>
<p>It's probably better to go this direction than have IMPORT use a <strong><code>&lt;skip&gt;</code></strong> parameter.</p>
<p>Anyway, the design grind goes on.</p> ]]></description>
        <link>https://forum.rebol.info/t/design-for-import/1570#post_4</link>
        <pubDate>Mon, 18 Nov 2024 20:06:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7913</guid>
      </item>
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Let's bring back an old term...and call it COMBINE.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; code: combine $() '[x + (var)]
== [x + y]  ; worked even though we passed in an unbound block!

&gt;&gt; eval compose [let x: 10 let y: 20 (as group! code)]
== 30
</code></pre>
<p>...Old COMPOSE Is Still Useful Day-To-Day</p>
<p>It's useful enough to keep its name, and do what it does. It works out a lot of the time.</p>
</blockquote>
</aside>
<p>So I've been stressing over the mental overhead of having two constructs, instead of just one.</p>
<h2><a name="p-7912-one-big-advantage-of-arity-2-compose-1" class="anchor" href="https://forum.rebol.info#p-7912-one-big-advantage-of-arity-2-compose-1"></a>One Big Advantage of ARITY-2 COMPOSE</h2>
<p>It's hard to think of a name for string interpolation, and expanding the scope of COMPOSE's powers seems like it would be a fit.</p>
<p>But that would <em>always</em> need you to give some capture of context as a parameter.</p>
<pre><code> &gt;&gt; compose $() "Strings (pick [do don't] 2) have binding"
 == "Strings don't have binding"
</code></pre>
<h2><a name="p-7912-composing-unbound-material-should-be-common-2" class="anchor" href="https://forum.rebol.info#p-7912-composing-unbound-material-should-be-common-2"></a>Composing Unbound Material Should Be Common</h2>
<p>In the modern binding model, unbound code is very much the default currency.</p>
<p>Many COMPOSEs should probably be making unbound material, and just aren't.  While we're getting away with not doing it, I think that's kind of accidental (and increasingly I've been running into problems where bound compose results are messing things up).</p>
<h2><a name="p-7912-would-stress-that-you-have-a-choice-3" class="anchor" href="https://forum.rebol.info#p-7912-would-stress-that-you-have-a-choice-3"></a>Would Stress That You Have a Choice</h2>
<p>If parentheses aren't the best choice for your situation, you can pick something else.</p>
<pre><code>&gt;&gt; compose ${{}} [{a} (b) [c] {{first [&lt;d&gt; #Z]}} {e}]
== [{a} (b) [c] &lt;d&gt; {e}]
</code></pre>
<h2><a name="p-7912-a-refinement-would-be-wordy-4" class="anchor" href="https://forum.rebol.info#p-7912-a-refinement-would-be-wordy-4"></a>A Refinement Would Be Wordy</h2>
<p>I'm questioning trying to differentiate the operations with a name difference (COMBINE vs. COMPOSE).  That's confusing.</p>
<p>A refinement makes more sense.  But even in the ideal case (where refinements are moved to the head) we'd have:</p>
<pre><code>compose:with $() [...]
</code></pre>
<p>And I don't know that ":WITH" is the best name, it acts as if it's adding something vs. overriding a default.  More honestly it would be:</p>
<pre><code>compose:pattern $() [...]
</code></pre>
<h2><a name="p-7912-weird-semantics-5" class="anchor" href="https://forum.rebol.info#p-7912-weird-semantics-5"></a>Weird Semantics...</h2>
<p>The behavior of stealing the binding from the block means that understanding COMPOSE as a specialization with $() is wrong.</p>
<p>Stealing the binding from the tip of the block you're composing and using that in the slots is a kind of "weird backchannel".  If that's what you're doing, <em>you're the weird one</em>, so maybe your code should reflect that.</p>
<h1><a name="p-7912-but-it-would-drive-the-noise-level-higher-6" class="anchor" href="https://forum.rebol.info#p-7912-but-it-would-drive-the-noise-level-higher-6"></a>But, It Would Drive The "Noise" Level Higher</h1>
<p>Some (like <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>) do not like symbols in code at all.</p>
<p>Having COMPOSE frequently instantiated as <strong><code>compose $() [...]</code></strong>  would be a thorn.  (Though as I've stated, I think you really should be doing <strong><code>compose $() '[...]</code></strong> much more than one would think).</p>
<p>And it is unfortunate that you need the $ to get the binding and suppress evaluation, plus you might think that would act on the pattern <strong><code>[... $(...) ...]</code></strong></p>
<p>But the game here is getting correctness.  And it seems to me that if you give people a powerful fundamental, they can adapt and specialize it to do whatever they want, under any name they want.</p>
<h2><a name="p-7912-should-sneaky-capture-be-the-default-7" class="anchor" href="https://forum.rebol.info#p-7912-should-sneaky-capture-be-the-default-7"></a>Should "Sneaky" Capture Be The Default?</h2>
<p>For COMPOSE to work with strings it either needs to take a pattern parameter, or be one of the sneaky constructs that uses the current context by default.</p>
<p>If it shifted to the "sneaky" behavior, then it would be more useful on unbound blocks:</p>
<pre><code>&gt;&gt; x: 10, compose '[a b (x + 1) c d]
== [a b 11 c d]

&gt;&gt; x: 10, compose "a b (x + 1) c d"
== [a b 11 c d]
</code></pre>
<p>But if you move code that says <strong><code>compose block</code></strong> from point A to point B, then you will be changing what it uses for its scope.  The same would be true of moving <strong><code>compose $() block</code></strong>, but at least there you can see the capturing construct... the <strong><code>$()</code></strong> should (?) call your attention to it.</p>
<hr>
<h1><a name="p-7912-i-think-my-biases-lead-me-to-arity-2-8" class="anchor" href="https://forum.rebol.info#p-7912-i-think-my-biases-lead-me-to-arity-2-8"></a>I Think My Biases Lead Me To Arity-2</h1>
<p>Looking at all the angles here, I just don't think it's that much of an imposition to pass the pattern.  And you live in a murky binding world if you don't.</p>
<p>If you are writing enough code where the <strong><code>compose $() [...]</code></strong> pattern is frequent enough to get on your nerves, then there are probably other ways you can attack that repetition that are even larger scale than just specializing that bit out.</p> ]]></description>
        <link>https://forum.rebol.info/t/envelop-and-compose-by-example/2294#post_5</link>
        <pubDate>Mon, 18 Nov 2024 19:16:30 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7912</guid>
      </item>
      <item>
        <title>Breaking MAKE OBJECT! Into Component Operations</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1442">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Since changing MAKE OBJECT! would be too far-reaching a change at the moment, I've retaken CONSTRUCT for this shallower version:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; x: 10
&gt;&gt; obj: construct [x: x * 2, f: func [] [print ["x is" x "and .x is" .x]]]
== make object! [
    x: 20
    f: ~#[frame! []]~
]

&gt;&gt; obj.f
x is 10 and .x is 20
</code></pre>
</blockquote>
</aside>
<p>I've had some success deploying this <strong><code>.word</code></strong> as member idea, with a shallow object creation... and it seems like the right fit for many cases--enough so that I think it should be the "default" for what we would traditionally think of as the creation of traditional "objects" and "classes".</p>
<p>But as expected, there are cases that don't fit.  For instance, in the bootstrap process, the configuration files make objects that are a bit more like modules:</p>
<pre><code>REBOL [Title: "Filesystem configuration file"]

name: 'Filesystem
source: %filesystem/mod-filesystem.c

os: platform-config.name
if os = 'Windows [  ; means OS as it was just defined...
    ...
]
</code></pre>
<p>This looks module-like, but it's done with objects (in particular because the bootstrap executable doesn't do modules correctly).  And additionally, it inherits from a base object.</p>
<p>So when I talk about the "component" operations, we have to consider:</p>
<ol>
<li>
<p>What kind of thing are we making (OBJECT!, MODULE!, ERROR!, ...)</p>
</li>
<li>
<p>Is there a parent to inherit from?  (if so, we presume this answers 1, which is why MAKE doesn't need to know the type if you pass an instance instead... you can't MAKE ERROR! from a parent that's a MODULE!)</p>
</li>
<li>
<p>Do you want the definitions of the object fields being defined to be visible to the code that's assigning those fields, or do you want the existing bindings to be visible?</p>
</li>
</ol>
<p>With the CONSTRUCT I mention above, that gives you an OBJECT! with no parent...and the fields of the object are not visible to the code doing the assigning.  (I propose this as the default behavior for FENCE!.)</p>
<p>I added a CONSTRUCT:WITH to pass in a parent, so you could add a parent...<a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">though it would be better if that argument came first</a></p>
<pre><code>construct:with [
    something: ...
    ...
] parent
</code></pre>
<p>vs.</p>
<pre><code>construct:with parent [
    something: ...
    ...
]
</code></pre>
<p>I could just go ahead and make it arity-2, though I'm not thrilled by it.</p>
<pre><code>construct object! [...]  ; shallow version, no parent
construct parent [...]  ; shallow version, parent

make object! [...]   ; inside version, no parent
make parent [...]   ; inside version, parent
</code></pre>
<h2><a name="p-7911-why-would-make-vs-construct-be-inside-binding-1" class="anchor" href="https://forum.rebol.info#p-7911-why-would-make-vs-construct-be-inside-binding-1"></a>Why would MAKE vs. CONSTRUCT Be "Inside Binding"?</h2>
<p>Outside of the inertia of history, I don't know how much sense this makes.  It could be <strong><code>construct:inside</code></strong> vs. plain <strong><code>construct</code></strong>.  :-/</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; construct [x: 20, y: x + 100]
== #{x: 20 y: 110}

&gt;&gt; x: 10
&gt;&gt; construct:inside [x: 20, y: x + 100]
== #{x: 20 y: 120}
</code></pre>
<p>The inside version being implemented by <strong><code>wrap:context</code></strong> was one idea I had:</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; wrap:context [x: 20, y: x + 100]
== #{x: 20 y: 120}
</code></pre>
<p>What this has going for it:</p>
<ul>
<li>
<p>"WRAP" really does sound like it's enclosing the code in a context</p>
</li>
<li>
<p>It aligns with what WRAP does to a BLOCK! normally... this would just say "make me a context out of that, vs. giving a block".</p>
</li>
</ul>
<p>But then you have the other parameterization points... MODULE! vs. OBJECT! etc., and whether you want to inherit or not.</p>
<p><strong>There's simply a lot of parameters here.</strong>  Anyway, there's a lot of new mechanics that need to settle out while contemplating this, just wanted to write that down.</p> ]]></description>
        <link>https://forum.rebol.info/t/breaking-make-object-into-component-operations/1442#post_5</link>
        <pubDate>Mon, 18 Nov 2024 02:14:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7911</guid>
      </item>
      <item>
        <title>.WORD as Member Selection</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>One little edge case on this, is whether to distinguish calling a member function from referencing a member variable.</p>
<pre><code>obj: {
    x: 10
    /foo: method [y] [return .x + y]
    /bar: method [z] [return .foo z]
}
</code></pre>
<p>It's unfortunate in my view that this isn't expressed as:</p>
<pre><code>/bar: method [z] [return /foo z]
</code></pre>
<p>The idea of "left hand side is implicit" that you get from <strong><code>.x</code></strong> for a non-method selection would be complemented nicely by <strong><code>/foo</code></strong> for a "left hand side is implicit" member.</p>
<p>Instead, what we get is that we've spent a character on a dot, and yet stayed in the domain of vagueness that a plain WORD! has in terms of whether it's a function call or not.</p>
<p>But staying in that domain of vagueness seems the best choice. I've found it too compelling to say:</p>
<pre><code>/foo: blah blah
</code></pre>
<p>And know from that source that FOO is an action antiform, with it not implying it's the member of any object.</p>
<p>So this means if you really want to clarify that you're calling a member function, you'd have to write the relatively ugly:</p>
<pre><code>/bar: method [z] [return /.foo z]
</code></pre>
<p>Ick.  <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=12" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<p>Well, for whatever it's worth... I haven't gotten the urge to go around sticking leading slashes on function calls on WORD! just for clarity's sake.  I only use it where it has meaning (e.g. PARSE to differentiate combinator invocation vs. plain function invocation with combinator-synthesized arguments).  This just feels a little different because it feels like it's a stand in for <strong><code>this.foo</code></strong>, which would error if foo was an action.</p>
<p>But sometimes when you're lining up puzzle pieces you hit these edges, and have to say "it's different when there's nothing to the left".  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p> ]]></description>
        <link>https://forum.rebol.info/t/word-as-member-selection/1843#post_4</link>
        <pubDate>Sun, 17 Nov 2024 17:05:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7910</guid>
      </item>
      <item>
        <title>TAG!s Angle Brackets: *They Aren&#39;t There!*</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>OK, I find that example more convincing than the TAG! one.</p> ]]></description>
        <link>https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326#post_6</link>
        <pubDate>Sun, 17 Nov 2024 02:52:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7909</guid>
      </item>
      <item>
        <title>Refinement Arguments at Head of Args List, Not Tail</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2331">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>In the corpus of code we have so far, it seems to me that when a refinement adds an argument to a function that it would be preferable if that argument would become the first parameter... not tacked onto the end.</p>
</blockquote>
</aside>
<p>As a counterexample... there's <strong><code>DO:ARGS</code></strong></p>
<pre><code>do %some-script.r

do:args %some-script.r ["hello" "world"]
</code></pre>
<p>That particular case has a possible workaround, that since DO is no longer used to evaluate blocks, the args could go in a block as part of a "do spec"</p>
<pre><code>do [%some-script.r, args: ["hello" "world"]]
</code></pre>
<p>I don't know, but I thought I'd point out the first example I'd noticed where injecting the argument first wasn't ideal.</p>
<p>Of course, these cases could do what we have to do with configuring refinements that aren't where we want them today, which is to use APPLY</p>
<pre><code>do // [%some-script.r :args ["hello" "world"]]
</code></pre>
<p><em>(Note: I'm still wondering if APPLY should use SET-WORD!s instead of ":refinements", there are tradeoffs for each...)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331#post_6</link>
        <pubDate>Sun, 17 Nov 2024 01:16:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7908</guid>
      </item>
      <item>
        <title>The Semantics of JOIN</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p><strong>As <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a>'s critique of yesteryear pointed out, <a href="https://forum.rebol.info/t/rejoin-ugliness-and-the-usefulness-of-tests/248">REJOIN sucked</a>.</strong></p>
<p>If naming were consistent, you might think from this pattern:</p>
<pre><code>append a reduce b &lt;=&gt; repend a b
</code></pre>
<p>...that the following would have been true:</p>
<pre><code>join a reduce b &lt;=&gt; rejoin a b  ; one would have perhaps thought?
</code></pre>
<p>But no...REJOIN was single arity (and was a mess).</p>
<h2><a name="p-7907-so-rejoin-is-in-the-trash-heap-but-what-about-join-1" class="anchor" href="https://forum.rebol.info#p-7907-so-rejoin-is-in-the-trash-heap-but-what-about-join-1"></a>So REJOIN is in the trash heap, but what about JOIN?</h2>
<p>JOIN implicitly reduced, and was basically this:</p>
<pre><code>join a b &lt;=&gt; append copy a reduce b
</code></pre>
<p>But <strong>b</strong> didn't have to be a BLOCK!, so if it was not, it wasn't reduced and just left as-is.</p>
<pre><code>rebol2&gt;&gt; join "abc" [1 + 2 3 + 4]
== "abc37"  ; so the block was reduced

rebol2&gt;&gt; d: 10
rebol2&gt;&gt; join "abc" 'd
== "abcd"  ; not abc10, so the word was *not* reduced
</code></pre>
<p>Red did not carry forward this definition:</p>
<pre><code>&gt;&gt; join
*** Script Error: join has no value
</code></pre>
<h2><a name="p-7907-next-level-join-allow-join-datatype-2" class="anchor" href="https://forum.rebol.info#p-7907-next-level-join-allow-join-datatype-2"></a>Next-Level JOIN: Allow JOIN  DATATYPE</h2>
<p>At some point, it occurred to me that if you could use JOIN with a datatype, it could step in to fill in the desires of REJOIN more clearly:</p>
<pre><code>&gt;&gt; join binary! [1 + 2 #{DECAFBAD} 2 + 3]
== #{03DECAFBAD05}
</code></pre>
<p>There really had been expressions of this like:</p>
<pre><code>rebol2&gt;&gt; rejoin [#{} 1 + 2 #{DECAFBAD} 2 + 3]
== #{03DECAFBAD05}
</code></pre>
<p>But see Brett's critique, if the surface-level badness isn't enough to convince you!</p>
<p>I also wanted to support things that Rebol2 probably meant to, but did not.  This should give a WORD! back:</p>
<pre><code>rebol2&gt;&gt; join 'a 'b
== "ab"  ; should be word! `ab`
</code></pre>
<p>Plus, I thought it might be nice to have a non-reducing variant, done with <code>@[...]</code></p>
<pre><code>&gt;&gt; join word! @[a 1 + 2]
== a1+2
</code></pre>
<p>I've mentioned elsewhere that I think having <em>join-like</em> actions be done with JOIN is superior to being some form of MAKE, when there's nebulousness for what MAKE means.</p>
<h2><a name="p-7907-making-peace-with-uneasiness-about-list-ambiguity-3" class="anchor" href="https://forum.rebol.info#p-7907-making-peace-with-uneasiness-about-list-ambiguity-3"></a>Making Peace (?) With Uneasiness About List Ambiguity</h2>
<p>Ergonomically, it's nice for JOIN to be able to take either a BLOCK! or some other type.</p>
<p>One of the biggest uses of JOIN is with files:</p>
<pre><code>join directory %foo.txt
</code></pre>
<p>It would be annoying if you had to write:</p>
<pre><code>join directory [%foo.txt]
</code></pre>
<p>But then, you have the problem that if you're joining onto a BLOCK!, then a BLOCK! is a legitimate thing to join:</p>
<pre><code>&gt;&gt; join [a b] [1 + 2 10 + 20]
== [a b 3 30]  ; "traditional" behavior

&gt;&gt; join [a b] [1 + 2]
== [a b [1 + 2 10 + 20]]  ; ...but this could be valid
</code></pre>
<p>We could "fix" this by defining JOIN as a non-reducing construct, then have people use SPREAD and REDUCE:</p>
<pre><code>&gt;&gt; join [a b] spread reduce [1 + 2 10 + 20]
== [a b 3 30]

&gt;&gt; join [a b] [1 + 2 10 + 20]
== [a b [1 + 2 10 + 20]]

&gt;&gt; join [a b] reduce [1 + 2 10 + 20]
== [a b [3 30]]
</code></pre>
<p>But this doesn't exactly square with the JOIN of a DATATYPE! case, and the most common desires.</p>
<p>If anything, I'd rather make JOIN always take a <strong><code>[...]</code></strong> or <strong><code>@[...]</code></strong> in the second argument, and then create some other non-reducing construct that slaps two things together.</p>
<pre><code>&gt;&gt; block: [a b]

&gt;&gt; adjoin block [c d]
== [a b [c d]]

&gt;&gt; adjoin block spread [e f]
== [a b [c d] e f]

&gt;&gt; block
== [a b]  ; unmodified (difference from append)
</code></pre>
<p>But asking people to write <strong><code>(adjoin directory %foo.txt)</code></strong> is... ugly.</p>
<p>A compromise is to narrow it, so that you could only use it with single items when joining with non-lists...</p>
<pre><code>&gt;&gt; join "abc" "def"
== "abcdef"

&gt;&gt; join [a b c] "def"
** Error: JOIN with a list must use [...] or @[...]
</code></pre>
<p>This would help steer you away from writing code like <strong><code>join list value</code></strong> and think it works, to only find it falling down when value becomes a BLOCK!.</p>
<h2><a name="p-7907-is-reduce-just-join-block-4" class="anchor" href="https://forum.rebol.info#p-7907-is-reduce-just-join-block-4"></a>Is REDUCE just JOIN BLOCK! ?</h2>
<p>The implementation of JOIN that I'm working on seems like a more powerful REDUCE.</p>
<p>But questions start to arise about the binding... what should the binding be?</p>
<pre><code>&gt;&gt; join [add 1] ['multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>In that case, I'm going to assume the produced block would have the binding of the [add 1] block.  Since multiply is <strong><code>'multiply</code></strong> and not <strong><code>$multiply</code></strong> it would be unbound and hence an evaluation would be driven by that first argument's binding.</p>
<p>But what if you just said:</p>
<pre><code>&gt;&gt; join block! ['add 1 'multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>Before, the second block's binding was disregarded in the product.  But when there's no first block to get the binding from, does it assume the binding of the second block?  And how would you get an unbound block if you wanted it?</p>
<p>We could say that you get an unbound block, but if you want a bound block, you'd say:</p>
<pre><code>&gt;&gt; join $[] ['add 1 'multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>Then we have similar questions for things like word!:</p>
<pre><code>&gt;&gt; join word! ["a" "b"]
== ab
</code></pre>
<p>I feel that pretty obviously should be unbound.  But words follow different rules:</p>
<pre><code>&gt;&gt; join $a ["b"]
== ab  ; can't necessarily be bound, just because a was...
</code></pre>
<p>That would suggest all words come back unbound from a joining process.</p>
<p>So no shortage of questions.  But in general, I think JOIN is on the right track, and splitting MAKE behaviors that are JOIN-like to it seems good.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-semantics-of-join/2333#post_1</link>
        <pubDate>Sat, 16 Nov 2024 18:33:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7907</guid>
      </item>
      <item>
        <title>TAG!s Angle Brackets: *They Aren&#39;t There!*</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>It's a choice.  The systemic pattern of letting you use quoted things to represent their molded representations gives you an economy I like:</p>
<pre><code>&gt;&gt; left: "foo"
&gt;&gt; right "bar"

&gt;&gt; unspaced [left '# right]
== "foo#bar"

&gt;&gt; unspaced [left "#" right]
== "foo#bar"
</code></pre>
<p>It's 3 fewer "ticks".</p>
<p>Of course, can't work for everything:</p>
<pre><code>&gt;&gt; unspaced [left "[" right]
== "foo[bar"
</code></pre>
<p>But where it does work, I think it's good.</p>
<p>People can make up their own minds on when it's more confusing than it is helpful.  Some might like it for string formation, but not string parsing.  Maybe even if a tag is a common parse instruction it might be in double quotes, while something like <strong><code>&lt;br /&gt;</code></strong> would be obviously not a parse instruction and matched by an apostrophe.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p> ]]></description>
        <link>https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326#post_5</link>
        <pubDate>Sat, 16 Nov 2024 15:36:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7905</guid>
      </item>
      <item>
        <title>Distinguishing Strings By Delimiters Used</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2236">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It may not be valueless to have a weak guarantee...that if a string does originate from a LOAD and you don't mess with it, you'll get the same delimiter forms back.</p>
</blockquote>
</aside>
<p>All things considered, I’m not sure that this is a desirable property. Because, if you’re only storing the string itself, this is an impossible goal. You’d have to store the original delimiter choice to do this… and is it really worth passing around an extra piece of data, just to make string printing look very slightly nicer?</p>
<p>For once, I think Red is on the right track. Choose a heuristic, ideally the most predictable one possible, and be done with it. <code>{foo}</code> and <code>"foo"</code> are the same string, and I don’t see why Ren-C should disguise that fact.</p>
<p>(Haskell has a similar issue, where strings with non-ASCII characters like <code>"é"</code> get printed back as <code>"\223"</code>. In practise it hasn’t caused too many problems — if you want a string to be printed a certain way, there are functions to do that.)</p> ]]></description>
        <link>https://forum.rebol.info/t/distinguishing-strings-by-delimiters-used/2236#post_4</link>
        <pubDate>Sat, 16 Nov 2024 15:12:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7904</guid>
      </item>
      <item>
        <title>Refinement Arguments at Head of Args List, Not Tail</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>TUPLE! is the lowest (giving the pleasing hierarchy in terms of "heft"...lighter things are tighter).</p>
<p>One of the problems with putting arguments into the chain/tuples is that binding gets tricky.  There's some open issues with that, but if you embed arguments into a sequence then you're tying their binding up in the binding of that sequence.  It's still a ways out.</p>
<p>I think I still would prefer the "configuring" refinements to put their arguments earlier, it really seems to be preferable in practice.</p>
<pre><code>&gt;&gt; join:with '+ fence! ['a 'b 'c]
== {a + b + c}
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331#post_5</link>
        <pubDate>Sat, 16 Nov 2024 15:12:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7903</guid>
      </item>
      <item>
        <title>Refinement Arguments at Head of Args List, Not Tail</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2331">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But I was thinking TUPLE! could do this more generically:</p>
<p><code>append:dup.2 [a b c] [d e]</code></p>
</blockquote>
</aside>
<p>Actually, this was what I wrote first… but then I remembered that CHAIN! binds tighter than TUPLE!, so this wouldn’t make sense. Or am I misremembering? If this can be done, I think it looks better than using CHAIN!.</p> ]]></description>
        <link>https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331#post_4</link>
        <pubDate>Sat, 16 Nov 2024 15:07:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7902</guid>
      </item>
      <item>
        <title>TAG!s Angle Brackets: *They Aren&#39;t There!*</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>Sure, I realise that you <em>can</em> do all these things. I’m just thinking that it seems less confusing to write their string representations as strings.</p> ]]></description>
        <link>https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326#post_4</link>
        <pubDate>Sat, 16 Nov 2024 15:05:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7901</guid>
      </item>
      <item>
        <title>Exact Matching of Variables with the @ Types In UPARSE</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>One downside I discovered of using a SIGIL! for "match anything" is that if you try and apply that more broadly outside of PARSE, you run into trouble if you're going to try using some sequence itself as a matching template.</p>
<p>For example, if you wanted <strong><code>a.1.2</code></strong> to match against <strong><code>@.1.2</code></strong>.   The <code>@</code> isn't in the first position, it's a decoration on <strong>.1.2</strong></p>
<p>Of course, there's going to be some trouble no matter what you pick... if it's legal to occur in that position, then you have to deal with the case that it's literally there.</p>
<p>But if it were <strong><code>*</code></strong> then it would at least afford:</p>
<pre><code>*.1.2  ; matches a.1.2

['*].1.2   ; matches *.1.2

['[*]].1.2  ; matches [*].1.2
</code></pre>
<p>etc.</p>
<p>This is sort of a tangentially related thing, because if you try and apply the logic of PARSE to this matching scenario, then pretty much everything has to be in a block to quote it literally.</p>
<p>So whatever this <em>"sequence-<a href="https://en.wikipedia.org/wiki/Glob_(programming)">globbing</a>"</em> domain is, would be different.</p>
<p>Also, given that I'm talking about something that doesn't exist, what would <code>*</code> really mean?</p>
<pre><code> a.b.c.1.2  ; would this match *.1.2 but not ?.1.2
</code></pre>
<p>If we were to say that PARSE needed to bow to this, then it kind of suggests that <strong><code>?</code></strong> would be "match any one item".</p>
<p>Anyway, just making the point here... that SIGIL!s are slippery.  If PARSE is trying to set a precedent for a systemic recognizable idea of "match single item" then maybe it shouldn't be done with a sigil.</p>
<p>(But note that <code>_</code> is equally problematic for sequences, as it makes the slot disappear--and moreover, is no longer legal except in head and tail sequence positions.  So it wouldn't be better than <code>@</code>)</p> ]]></description>
        <link>https://forum.rebol.info/t/exact-matching-of-variables-with-the-types-in-uparse/1643#post_8</link>
        <pubDate>Sat, 16 Nov 2024 13:51:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7900</guid>
      </item>
      <item>
        <title>Refinement Arguments at Head of Args List, Not Tail</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Using another CHAIN! element was intended to let you drop the refinement altogether, to accomplish briefer things like:</p>
<pre><code>append:2 [a b c] [d e]
</code></pre>
<p>But I was thinking TUPLE! could do this more generically:</p>
<pre><code>append:dup.2 [a b c] [d e]
</code></pre>
<p>Even so, if you used a variable, it would probably have to be decorated:</p>
<pre><code>append:dup.(n + 1) [a b c] [d e]

append:dup.@n [a b c] [d e]
</code></pre>
<p>The relatively "noiseless" injection to the head of the args list feels like a better answer to me:</p>
<pre><code>append:dup 2 [a b c] [d e]

append:dup n [a b c] [d e]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331#post_3</link>
        <pubDate>Sat, 16 Nov 2024 12:59:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7899</guid>
      </item>
      <item>
        <title>TAG!s Angle Brackets: *They Aren&#39;t There!*</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2326">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>But what if (for whatever reason) you did want to match the quoted tag <code>'&lt;end&gt;</code>, say, in an input block?</p>
</blockquote>
</aside>
<p>You can say:</p>
<pre><code>&gt;&gt; parse ['&lt;end&gt; asdf] [''&lt;end&gt; to &lt;end&gt; &lt;input&gt;]
== ['&lt;end&gt; asdf]
</code></pre>
<p>Or alternately, <a href="https://forum.rebol.info/t/exact-matching-of-variables-with-the-types-in-uparse/1643/7">you can use LITERAL</a>:</p>
<pre><code>&gt;&gt; parse ['&lt;end&gt; asdf] [literal '&lt;end&gt; to &lt;end&gt; &lt;input&gt;]
== ['&lt;end&gt; asdf]
</code></pre>
<p>Abbreviated:</p>
<pre><code>&gt;&gt; parse ['&lt;end&gt; asdf] [lit '&lt;end&gt; to &lt;end&gt; &lt;input&gt;]
== ['&lt;end&gt; asdf]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326#post_3</link>
        <pubDate>Sat, 16 Nov 2024 12:46:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7898</guid>
      </item>
      <item>
        <title>Refinement Arguments at Head of Args List, Not Tail</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>A thought… might it be possible to do something like this?</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">append:dup:2 [a b c] [d e]
</code></pre>
<p>Basically, this would mean that refinements don’t add new arguments <em>per se</em> — instead such cases can be unified with CHAIN! dialecting.</p>
<p>(I feel certain that we’ve discussed something like this before, but I can’t seem to find it with a quick search.)</p> ]]></description>
        <link>https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331#post_2</link>
        <pubDate>Sat, 16 Nov 2024 12:31:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7897</guid>
      </item>
      <item>
        <title>TAG!s Angle Brackets: *They Aren&#39;t There!*</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2326">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; parse "&lt;end&gt; asdf" ['&lt;end&gt; to &lt;end&gt; &lt;input&gt;]
== "&lt;end&gt; asdf"
</code></pre>
</blockquote>
</aside>
<p>But what if (for whatever reason) you did want to match the quoted tag <code>'&lt;end&gt;</code>, say, in an input block? I don’t think there’s much advantage over just writing <code>["&lt;end&gt;" to &lt;end&gt; &lt;input&gt;]</code>, which is only one character longer, and strikes me as being clearer.</p> ]]></description>
        <link>https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326#post_2</link>
        <pubDate>Sat, 16 Nov 2024 12:23:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7896</guid>
      </item>
      <item>
        <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I like this idea. You know I’ve been somewhat unhappy about the way Ren-C currently represents datatypes; making them antiforms feels right to me, and could act as a good step towards a full solution.</p> ]]></description>
        <link>https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324#post_2</link>
        <pubDate>Sat, 16 Nov 2024 12:20:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7895</guid>
      </item>
      <item>
        <title>Embracing A &quot;Useless&quot; Definition of TO</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>So as a first cut of getting family of equivalencies and reversibility, I wound up with something like this:</p>
<pre><code>&gt;&gt; to path! [a.b c.d]
== a.b/c.d  ; what we have "assumed" from history

&gt;&gt; to block! 'a.b/c.d
== [a.b c.d]  ; add in reversibility requirement

&gt;&gt; to text! [a.b c.d]
== "a.b c.d"

&gt;&gt; to path! "a.b c.d"
== a.b/c.d  ; being consistent within the equivalencies
</code></pre>
<p>This was making it a given that TO PATH! of a BLOCK! of items would item-wise join the things into a path.</p>
<p>When you turn the crank with the other rules about reversible transformations and equivalencies, that's just what you get.</p>
<p>BUT if all string classes act equivalently, then it breaks a behavior that was relied upon pretty heavily:</p>
<pre><code> &gt;&gt; to file! 'foo/baz.bar
 == %"foo baz.bar"  ; historical code was expecting %foo/baz.bar
</code></pre>
<p>It's a pretty uphill argument to say that's good.</p>
<h3><a name="p-7893-in-order-to-maintain-the-equivalencies-i-am-promoting-and-fix-this-i-think-we-have-to-push-away-from-the-idea-that-to-is-the-tool-you-reach-for-to-make-sequences-from-blocks-1" class="anchor" href="https://forum.rebol.info#p-7893-in-order-to-maintain-the-equivalencies-i-am-promoting-and-fix-this-i-think-we-have-to-push-away-from-the-idea-that-to-is-the-tool-you-reach-for-to-make-sequences-from-blocks-1"></a>In order to maintain the equivalencies I am promoting, and fix this, I think we have to push away from the idea that TO is the tool you reach for to make sequences from blocks.</h3>
<p>It forces our hand to:</p>
<pre><code>&gt;&gt; to block! 'a.b/c.d
== [a.b/c.d]

&gt;&gt; to path! [a.b/c.d]
== a.b/c.d
</code></pre>
<p>But as I've tried to explain, these are useful things--more than was realized.</p>
<p>And all is not lost...and arguably improved...because we have JOIN.  Right now I'm suggesting it would come in two varieties... reducing and non-reducing, based on whether you use a <strong><code>[...]</code></strong> or <strong><code>@[...]</code></strong></p>
<pre><code>&gt;&gt; join path! ['a.b 'c.d]
== a.b/c.d

&gt;&gt; join path! @[a.b c.d]
== a.b/c.d

&gt;&gt; block: [a.b c.d]

&gt;&gt; inert block
== @[a.b c.d]

&gt;&gt; join path! inert block
== a.b/c.d
</code></pre>
<p>So there's some flexibility there.</p>
<h3><a name="p-7893-this-continues-to-shake-the-foundations-of-what-we-might-have-thought-we-knew-about-to-but-it-feels-like-a-path-of-improvement-2" class="anchor" href="https://forum.rebol.info#p-7893-this-continues-to-shake-the-foundations-of-what-we-might-have-thought-we-knew-about-to-but-it-feels-like-a-path-of-improvement-2"></a>This continues to shake the foundations of what we might have thought we knew about TO, but it feels like a path of improvement.</h3>
<p>Honestly, isn't JOIN clearer than TO, in terms of telling you what's going on?</p> ]]></description>
        <link>https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325#post_2</link>
        <pubDate>Fri, 15 Nov 2024 00:27:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7893</guid>
      </item>
      <item>
        <title>hiiamboris&#39;s WITH</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>So I think it's best to kill off the <strong><code>&lt;static&gt;</code></strong> annotation in function specs, replacing it with something like WITH.</p>
<pre><code>accumulate: function [
    return: [integer!]
    num [integer!]
    &lt;static&gt; state (0)
][
    return state: state + num
]
</code></pre>
<p>transitioning to...</p>
<pre><code>accumulate: function [
    return: [integer!]
    num [integer!]
] with {state: 0} [
    return state: state + num
]
</code></pre>
<p>It looks a little more awkward (maybe?).</p>
<p>But statics are a fairly rarely-used ability, and leveraging a generic part like WITH is just a better bet.</p>
<hr>
<aside class="quote no-group">
<blockquote>
<p>WHY IS IT DESIGNED LIKE THIS?</p>
<p><code>with</code> does not evaluate the block, so:</p>
<ul>
<li>
<p>it can be used after <code>context</code>s, <code>if</code>s, <code>loop</code>s, <code>func</code>s, etc.</p>
</li>
<li>
<p>it can be chained <code>with x with y ...</code>I've found that this makes code much more readable than it would be with <code>bind</code>.</p>
</li>
</ul>
<p>Prefix it with <code>do</code> if you want immediate evaluation.</p>
</blockquote>
</aside>
<p>So Ren-C DO is for running whole scripts or code from any language (e.g. JavaScript and CSS instead of Rebol), requires a header on Rebol scripts, etc.  It's not for evaluating blocks.  You have to use EVAL (or unabbreviated EVALUATE).</p>
<p>So instead of <strong>do with</strong> you'd say <strong>eval with</strong>.</p>
<p>EVAL WITH would thus be similar to (but more powerful than) what has historically been known as USE.</p>
<pre><code>x: 10 y: 20
use [x y] [  ; Redbol USE
    x: 100 y: 200
    print ["Inside the USE X and Y are" x y]  ; 100 200
]
print ["Outside the USE X and Y are" x y]  ; 10 20
</code></pre>
<p>There's not a lot of that in Ren-C.  Instead it uses LET, which is generally preferable since it doesn't make you indent your code.</p>
<p>In the narrow cases where I would want to do this, I don't feel it would be that terrible to say:</p>
<pre><code>x: 10 y: 20
eval with [x y] [  ; could be (with {x: y: ~})
    x: 100 y: 200
    print ["Inside the EVAL WITH X and Y are" x y]  ; 100 200
]
print ["Outside the EVAL WITH X and Y are" x y]  ; 10 20
</code></pre>
<p>Especially because you often could do the assignments right in place, as you can here:</p>
<pre><code>x: 10 y: 20
eval with {x: 100, y: 200} [
    print ["Inside the EVAL WITH X and Y are" x y]  ; 100 200
]
print ["Outside the EVAL WITH X and Y are" x y]  ; 10 20
</code></pre>
<p>My concept for retaking the word USE is to import things into the current scope.  So like WITH, but not requiring a level of indentation.</p>
<pre><code>obj: {foo: 1000 bar: 2000}

use obj
print ["FOO is" foo "and BAR is" bar]  ; 1000 2000
</code></pre>
<p>Among the many uses for such a thing would be bringing GATHER'd declarations inside a PARSE into scope:</p>
<pre><code>if 1 &lt; 2 [
    let filename: "demo.txt"
    use parse filename [gather [
        emit base: between &lt;here&gt; "."
        emit extension: thru &lt;end&gt;
    ]] else [
        fail "Not a file with an extension"
    ]
    print ["The base was" base]  ; demo
    print ["The extension was" extension]  ; txt
]
; base and extension would not be defined here!
</code></pre>
<h2><a name="p-7892-is-with-the-right-word-for-with-1" class="anchor" href="https://forum.rebol.info#p-7892-is-with-the-right-word-for-with-1"></a>Is WITH the Right Word for WITH?</h2>
<p>The thing that bothers me is that WITH is a very generic term, that seems to me to be a good refinement.</p>
<pre><code>&gt;&gt; join:with "," tag! ["abc" "def" "ghi"]
== &lt;abc,def,ghi&gt;
</code></pre>
<p>This is really a bind-specific operation.  And I wonder if perhaps, since it is going in the direction of dialecting, if it should be the BIND dialect itself?</p>
<pre><code>accumulate: function [
    return: [integer!]
    num [integer!]
] bind {state: 0} [
    return state: state + num
]
</code></pre>
<p>In this model, BIND's first argument is the binding instructions, and the second argument is the block (or whatever) to bind.</p>
<p>This would kill the idea I had of the "arity-0 BIND", but that would just be a synonym for the <strong><code>$</code></strong> operator, and since there's a short operator for it the name of it doesn't have to be quite that short or critical.</p>
<p><strong>I think that it's probably best to say that this is what BIND is.</strong>  People can just learn that the second argument is the thing that gets bound.</p> ]]></description>
        <link>https://forum.rebol.info/t/hiiamboriss-with/2138#post_2</link>
        <pubDate>Thu, 14 Nov 2024 04:28:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7892</guid>
      </item>
      <item>
        <title>.WORD as Member Selection</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1843">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I had a lot of trouble deciphering Rebmake due to not knowing what was a function, an object, a member, or a global. It's a big advantage just to have dots for member selection distinct from slashes for refinements. But it would be a bigger advantage to be able to see at a glance that something was a member with the relatively brief dot annotation on <strong>.member</strong></p>
<p>As with most things pertaining to binding, I have no real clue how to make it work or cohere.</p>
</blockquote>
</aside>
<p>Pure Virtual Binding opened the door to this, so I tried it.</p>
<p>I made the CONSTRUCT primitive a version of MAKE OBJECT! that didn't bind everything inside the block.  It only binds the SET-WORDs at the top level, so you can do things like this:</p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; construct [x: x + 10]
== make object! [x: 20]
</code></pre>
<p>Then, my "naive" first approach to enable .WORD was simply to make tuple selection stow the object that it picked out of in the function value returned.</p>
<pre><code>&gt;&gt; global: ~

&gt;&gt; obj: construct [x: 10, set $global /foo: does [.x]]

&gt;&gt; obj/x
== 10

&gt;&gt; /test: obj.x/
== ~#[frame! []]~  ; anti

&gt;&gt; test
== 10

&gt;&gt; global
** Error: .x has no object coupling in effect
</code></pre>
<p>In the case where you're extracting the action value to store in TEST, the value you get has a pointer to the OBJ object embedded inside it.  So it knows how to run it.</p>
<p>But the global variable that was set didn't get that.  It just has the uncoupled function.  There's a way for you to fix that:</p>
<pre><code> &gt;&gt; /global: couple global/ obj

 &gt;&gt; global
 == 10
</code></pre>
<p>We could make that easier, by letting you pass in a variable to update instead of an "immediate" ACTION! value, e.g. <strong><code>couple $global obj</code></strong>.  <em>(Being able to do both might be interesting for more functions of this nature.)</em></p>
<p>In any case, I don't really have a problem with the fact that doing something like that gives you an "uncoupled" method.  That seems fine.</p>
<p>But other things raise questions, some easier to address than others.</p>
<h2><a name="p-7891-what-about-enumerations-1" class="anchor" href="https://forum.rebol.info#p-7891-what-about-enumerations-1"></a>What About Enumerations?</h2>
<pre><code>obj: make object! [x: 10, /foo: lambda [y] [.x + y]]

for-each [key ~/val] [  ; proposed notation for "maybe action"
    if action? val/~ [  ; proposed notation for "don't run, maybe action"
        print [val 1000]
    ]
]
</code></pre>
<p>If this is going to work, then the enumeration behind FOR-EACH has to add the coupling.</p>
<h2><a name="p-7891-when-to-override-2" class="anchor" href="https://forum.rebol.info#p-7891-when-to-override-2"></a>When To Override?</h2>
<p>The current idea is that once an action gets a coupling, it sticks.</p>
<pre><code>&gt;&gt; obj1: make object! [x: 10, /foo: does [.x]]

&gt;&gt; obj2: make object! [x: 20, foo: ~]

&gt;&gt; /obj2.foo: obj1.foo/

&gt;&gt; obj2/foo
== 10
</code></pre>
<p>If you don't want this, you'd have to store an UNCOUPLE-d version of the function.</p>
<pre><code>&gt;&gt; /obj2.foo: uncouple obj1.foo/

&gt;&gt; obj2/foo
== 20
</code></pre>
<p>I don't really have a problem with that.</p>
<h2><a name="p-7891-should-all-functions-get-couplings-3" class="anchor" href="https://forum.rebol.info#p-7891-should-all-functions-get-couplings-3"></a>Should ALL Functions Get Couplings?</h2>
<p>For starters, METHOD and FUNCTION were synonyms.  All actions would get "couplings" when picked out of contexts.</p>
<p>This is a bit dodgy in the sense that it seems to put the information in places that it doesn't belong.</p>
<p>So you might argue that if you fetch a function out of a word, then it should get a special state that isn't just "uncoupled", but "anti-coupled", e.g. it won't <em>ever</em> pick up a coupling (until you uncouple it).</p>
<p>Then we might ask how this should behave:</p>
<pre><code> obj: construct [
     x: 10
     /foo: func [y] [
        helper: does [print [.x + y]]
        helper
    ]
 ]
</code></pre>
<p>In order for that to work, the "anti-coupled" state would have to keep climbing the virtual bind chain vs. stopping at the frame for DOES, to use the <strong>.x</strong> from FOO.</p>
<p>The problems here don't seem insurmountable...but I'm definitely mulling over whether the picking up of couplings should be limited to a different kind of function, e.g. a METHOD.  It seems to me like it's good documentation, but it would help avoid contention:</p>
<pre><code> obj: construct [
     x: 10
     /foo: method [y] [
        helper: does [print [.x + y]]
        helper
    ]
 ]
</code></pre>
<p>With a situation like that, it could be the non-method character of DOES which you can use to trust that it won't have a competing meaning for <strong>.x</strong></p>
<p>This stuff is all in its early stages, but it really is way more promising than what came before it...</p>
<p><strong>I am pretty sure that CONSTRUCT--not propagating the binding deeply of the object onto everything inside the object--is the better answer for the default of making objects, e.g. <code>{x: x}</code></strong></p>
<p>The other idea, of making something that spreads its influences deeply, should probably have a name.</p>
<p><strong><code>CONTEXT</code></strong> wouldn't be a bad name, actually (and has historical precedent as an alias for MAKE OBJECT!), but I'm using that word with another nuance.  It's the same functionality as WRAP but just returning the context, so maybe <strong><code>wrap:context</code></strong> could say that you want the context back, not the block?</p> ]]></description>
        <link>https://forum.rebol.info/t/word-as-member-selection/1843#post_3</link>
        <pubDate>Thu, 14 Nov 2024 00:20:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7891</guid>
      </item>
      <item>
        <title>Distinguishing Strings By Delimiters Used</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I'm a few weeks into having FENCE! exist.  The fence part was trivial: just another array type with different delimiters.  What was harder was the string part.</p>
<p>I decided the easiest thing to do was to make the scanner code between the bootstrap executable and the current executable roughly compatible.  So I backpatched a lot of modernness onto the bootstrap EXE in just that part.  So now you can scan strings like <strong><code>-{foo}-</code></strong> and <strong><code>--{foo}--</code></strong>.</p>
<p><strong>But the molding questions are trickier.</strong>  Historical heuristics are weird so even if you say <strong><code>"foo"</code></strong> you can get <strong><code>{foo}</code></strong> in some cases.</p>
<p>Red is similarly lossy, though their heuristics are different...but what they share in common is to try and dodge escaping.</p>
<pre><code>red&gt;&gt; str: "I am a (quoted string) ^"but^" that's not preserved"
== {I am a (quoted string) "but" that's not preserved}
</code></pre>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2236">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Some strings are created programmatically and don't come from a LOAD, so they have no initial delimiters.</p>
</blockquote>
</aside>
<p>It may not be valueless to have a weak guarantee...that if a string does originate from a LOAD and you don't mess with it, you'll get the same delimiter forms back.</p>
<p>But getting the <em>identical</em> representation back is still hard, unless you store a copy of what was scanned.  Because otherwise how would you tell if a codepoint was expressed literally or as an escaped value, if you're allowed to escape codepoints that can render literally?  And what if there are multiple forms of escaping, e.g. numeric or symbolic? (<strong><code>"foo^(TAB)bar"</code></strong>)</p>
<aside class="quote no-group" data-username="BlackATTR" data-post="1" data-topic="2236">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/blackattr/48/204_2.png" class="avatar"> BlackATTR:</div>
<blockquote>
<p>In other words, if you could transcode <code>{whatever}</code> and be able to identify it as a (making up this name) LONG-TEXT!, which is a form in the family of TEXT! with the same property as a SERIES.</p>
</blockquote>
</aside>
<p>If we subtyped strings, I kind of wonder if subtyping them into something that can't contain newlines vs. that can might have some kind of benefit.</p>
<p>I don't know.  But if we had LONG-TEXT! and TEXT!, then we'd end up with routines that wanted to take either form as taking ANY-TEXT!, and that seems a lot like ANY-STRING!.</p> ]]></description>
        <link>https://forum.rebol.info/t/distinguishing-strings-by-delimiters-used/2236#post_3</link>
        <pubDate>Wed, 13 Nov 2024 20:24:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7890</guid>
      </item>
      <item>
        <title>Refinement Arguments at Head of Args List, Not Tail</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>In the corpus of code we have so far, it seems to me that when a refinement adds an argument to a function that it would be preferable if that argument would become the first parameter... not tacked onto the end.</p>
<p>Some cases might not be completely obvious one way or another:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append:dup [a b c] [d e] 2  ; old way
== [a b c [d e] [d e]] 

&gt;&gt; append:dup 2 [a b c] [d e]  ; new idea
== [a b c [d e] [d e]]
</code></pre>
<p>I think it's better if it's first, but it's not earth-shattering.</p>
<p>But in other cases it seems very much an improvement.  Consider the positioning of the argument to FAIL:BLAME...</p>
<pre><code>foo: func [arg thing] [
    if arg &lt; 0 [
        fail:blame [
           "Here is some long error message:" @thing
           "Whatever..."
        ] $arg
    ]
]

foo: func [arg thing] [
    if arg &lt; 0 [
        fail:blame $arg [
           "Here is some long error message:" @thing
           "Whatever..."
        ]
    ]
]
</code></pre>
<p>Or an argument to COMPOSE giving a pattern to use:</p>
<pre><code>compose:pattern [
    some bunch of {{code that}} &lt;spans&gt;
    #multiple lines
    [and could go on for pages]
] ${{}}  ; afterthought...

compose:pattern ${{}} [  ; forethought
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]
</code></pre>
<p>This goes along with some Haskell philosophy I cited in <a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238">Parameter Order in Rebol</a>:</p>
<blockquote>
<p><em>"It's common practice in Haskell to order function parameters so that parameters which "configure" an operation come first, and the "main thing being operated on" comes last. This is often counter intuitive coming from other languages, since it tends to mean you end up passing the "least important" information first. It's especially jarring coming from OO where the "main" argument is usually the object on which the method is being invoked, occurring so early in in the call that it's out of the parameter list entirely!"</em></p>
</blockquote>
<p>These refinements typically seem to be <em>configuring</em>, as if they are changing the function itself, and belong at the head.</p>
<p>e.g. above, the function you're conceptually applying is <strong><code>(compose:pattern ${{}})</code></strong></p>
<h2><a name="p-7889-history-didnt-do-it-this-way-with-some-reasons-1" class="anchor" href="https://forum.rebol.info#p-7889-history-didnt-do-it-this-way-with-some-reasons-1"></a>History Didn't Do It This Way, With Some Reasons</h2>
<p>Refinements are typically listed at the end of the function spec.</p>
<p>From an implementation standpoint, that's also where their "slots" are in the argument list.</p>
<p>This means that as you are walking the argument list and fulfilling arguments from the callsite, if refinements were used you would have to skip over the "normal" arguments in a first pass, and then come back and fill them later.</p>
<p>Historical Redbols only had to be worried about the order of usage of refinements... if you used them out of order from the declaration, a second pass would be needed.  But using them in order would not require it.</p>
<p>This isn't a problem for Ren-C...it's designed for generic parameter reordering (refinements or otherwise) and it has an efficient way to beeline back to slots it skipped on a second pass.</p>
<p>So really the only issue is the mismatch between the visual order in the spec (which may be exposed mechanically by fixed orders of enumeration of FRAME! keys and values), compared with the gathering behavior.  But the disconnect of that order has always been there, with <strong>foo/refine1/refine2</strong> vs. <strong>foo/refine2/refine1</strong> in Redbol... the callsite order may not match the frame order.</p>
<h2><a name="p-7889-is-it-worth-changing-2" class="anchor" href="https://forum.rebol.info#p-7889-is-it-worth-changing-2"></a>Is It Worth Changing?</h2>
<p>The competing (complementary) idea of <a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">CHAIN! dialecting</a> offers something that's likely even more compelling:</p>
<pre><code>compose:pattern ${{}} [  ; better than today...
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]

compose:${{}} [  ; ...but this surpasses even that
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]
</code></pre>
<p>Though it's kind of up in the air if and when that's going to get attacked, and how well it will work (it may run afoul of problems in binding, etc.)</p>
<p>My instincts tell me that it's worth changing.  In practice, refinements that take arguments are not super common... but when they do happen, being up front seems to make the most sense.</p> ]]></description>
        <link>https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331#post_1</link>
        <pubDate>Tue, 12 Nov 2024 14:16:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7889</guid>
      </item>
      <item>
        <title>Full-Band Return Values from Generators/Yielders</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7888-i-described-the-design-of-yield-to-claude-1" class="anchor" href="https://forum.rebol.info#p-7888-i-described-the-design-of-yield-to-claude-1"></a>I Described The Design of YIELD To Claude:</h1>
<p>I have a special out-of-band state that I use to let you say you are done yielding, and this state is a "raised error". It can't be stored in variables like plain errors can, but it can be returned by functions.</p>
<p>So you can write <strong><code>yield done</code></strong> where <strong><code>done</code></strong> is a function that returns such a raised error. And yet, a generator can still return the non-raised state.</p>
<p>For performance, I've also added a variant called <strong><code>yield:final</code></strong> which lets you pass a value, but say that it's the last value you are giving back. So <strong><code>yield:final 1</code></strong> is equivalent to <strong><code>(yield 1, yield done)</code></strong>.</p>
<p>The concept was not to overrule the <strong><code>return</code></strong> word in a generator, so you can construct a generator inside a function and in the generator's body the <strong><code>return</code></strong> would still refer to the function's return, allowing you to execute that return inside the generator's body (which is considered to complete the body of the generator, so it will not yield more values).</p>
<p>But if you want the word <strong><code>return</code></strong> to mean return from the generator, you can define that by saying <strong><code>/return: yield:final/</code></strong> which asks for a local definition of return that means the same thing as <strong><code>yield:final</code></strong>.</p>
<p>So that seems to get pretty good coverage of interesting intents. I'm curious what other languages might have for covering these scenarios, can you compare/contrast?</p>
<hr>
<h1><a name="p-7888-claude-gets-it-mostly-2" class="anchor" href="https://forum.rebol.info#p-7888-claude-gets-it-mostly-2"></a>Claude Gets It... Mostly...</h1>
<blockquote>
<p>Let me break down how different languages handle these scenarios:</p>
<h3>Python's Approach:</h3>
<pre><code>def generator():
    yield 1        # regular yield
    return 2       # StopIteration(2) - the 2 can be captured
    # unreachable  # code after return is unreachable

# To get the return value:
gen = generator()
try:
    while True:
        next(gen)
except StopIteration as e:
    final_value = e.value  # gets 2
</code></pre>
<h3>JavaScript's Generator Returns:</h3>
<pre><code>function* generator() {
    yield 1;
    return 2;      // {value: 2, done: true}
    // unreachable
}

// Two ways to get the return value:
const gen = generator();
for (const value of gen) {
    console.log(value);  // only sees 1, not 2
}

// Or:
let result;
while (!(result = gen.next()).done) {
    console.log(result.value);
}
console.log(result.value);  // gets 2
</code></pre>
<h3>Ruby's Enumerators</h3>
<p>Ruby doesn't have a built-in way to return a final value, but you can do:</p>
<pre><code>enum = Enumerator.new do |y|
    y &lt;&lt; 1
    y &lt;&lt; 2
    break 3  # final value
end
</code></pre>
<p>Your approach has some unique and interesting characteristics:</p>
<ol>
<li>
<p>The separation of <code>yield done</code> vs <code>yield:final</code> gives explicit control over whether you want to pass a final value or just stop</p>
<ul>
<li>
<p>Most languages don't distinguish these cases clearly</p>
</li>
<li>
<p>Python and JavaScript bundle the "done" signal with an optional final value</p>
</li>
</ul>
</li>
<li>
<p>Your handling of <code>return</code> is novel:</p>
<ul>
<li>
<p>Keeping <code>return</code> bound to the outer function</p>
</li>
<li>
<p>Providing <code>/return: yield:final/</code> for local rebinding</p>
</li>
<li>
<p>This gives more flexibility than other languages where <code>return</code> in a generator body always means "return from generator"</p>
</li>
</ul>
</li>
<li>
<p>The "raised error" state as an out-of-band signal is interesting:</p>
<ul>
<li>
<p>Python uses exceptions (StopIteration)</p>
</li>
<li>
<p>JavaScript uses a {done: true} flag</p>
</li>
<li>
<p>Your approach keeps it distinct from regular error handling</p>
</li>
</ul>
</li>
</ol>
<h2>Some unique aspects of your design:</h2>
<h3>Explicit Final Value:</h3>
<pre><code>; Your language
yield 1
yield:final 2   ; Clear that 2 is the last value

# vs Python
yield 1
return 2        # Less clear this is yielding 2 as final value

# vs JavaScript
yield 1
return 2        // Similar ambiguity to Python
</code></pre>
<h3>Function Return Access:</h3>
<pre><code>; Your language
/fn: function [
    /gen: generator [
        if condition [return value]  ; returns from fn
        yield 1
    ]
    gen  ; returns generator
]

# vs Python - can't access outer function's return
def fn():
    def gen():
        if condition:
            return value  # returns from generator
        yield 1
    return gen()
</code></pre>
<h2>Summary</h2>
<p>Your design seems to offer more precise control over the different "ending" scenarios a generator might have. The distinction between:</p>
<ul>
<li>Yielding a final value</li>
<li>Just being done</li>
<li>Returning from the containing function</li>
</ul>
<p>...is clearer than in most other languages I've seen. The trade-off might be slightly more complexity in the conceptual model, but it gives users more expressive power when they need these distinctions.</p>
</blockquote>
<hr>
<h2><a name="p-7888-claudes-example-of-return-binding-isnt-useful-3" class="anchor" href="https://forum.rebol.info#p-7888-claudes-example-of-return-binding-isnt-useful-3"></a>Claude's Example of RETURN Binding Isn't Useful</h2>
<blockquote>
<pre><code>; Your language
/fn: function [
    /gen: generator [
        if condition [return value]  ; returns from fn
        yield 1
    ]
    gen  ; returns generator
]
</code></pre>
</blockquote>
<p>The generator is being returned to someone else to call.  So the RETURN inside the generator won't ever be useful--it will always abruptly fail because the function call is over.</p>
<p>That isn't an indictment of the feature.  You just have to be using the generator while the function is still running.</p> ]]></description>
        <link>https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329#post_2</link>
        <pubDate>Tue, 12 Nov 2024 11:46:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7888</guid>
      </item>
      <item>
        <title>Antiform Safety: Covariance and Contravariance</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2330">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The next two goals are somewhat maddeningly trickier... <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
</blockquote>
</aside>
<pre><code>template&lt;typename U&gt;
using IsReverseInheritable = typename std::enable_if&lt;
    std::is_same&lt;U,T&gt;::value or std::is_base_of&lt;U,T&gt;::value
&gt;::type;
</code></pre>
<p>Because this was such a PITA, I looked around for contravariance precedent in C++ and sort of... couldn't find any.</p>
<h2><a name="p-7887-claudeais-thoughts-on-why-1" class="anchor" href="https://forum.rebol.info#p-7887-claudeais-thoughts-on-why-1"></a>Claude.AI's Thoughts on Why</h2>
<blockquote>
<p>I think the reason there isn't more prior art for this pattern in C++ specifically is that C++'s type system historically encouraged a different way of thinking about inheritance. The standard pattern was that derived classes would <em>extend</em> base classes with new capabilities, rather than <em>constrain</em> them with narrower invariants.</p>
<p>Consider a typical C++ example:</p>
<pre><code>class Animal { 
    virtual void makeSound() = 0;
};

class Dog : public Animal {
    void makeSound() override { /* bark */ }
    void fetch();  // adds new capability
};
</code></pre>
<p>In this common pattern, <code>Dog</code> is "bigger" than <code>Animal</code> - it can do everything an <code>Animal</code> can do plus more. So the traditional covariant rules make sense: you can pass a <code>Dog*</code> anywhere that takes an <code>Animal*</code> because a <code>Dog</code> can fulfill all <code>Animal</code> contracts.</p>
<p>Your pattern is more in line with refinement types or subtyping based on invariants, where:</p>
<pre><code>class Number { /* can be any number */ };
class PositiveNumber : public Number { /* invariant: must be &gt; 0 */ };
</code></pre>
<p>Here <code>PositiveNumber</code> is actually "smaller" in terms of its valid state space. When initializing/writing, you want the reverse inheritance rule because you can't safely write an arbitrary <code>Number</code> into a <code>PositiveNumber</code> slot.</p>
<p>This kind of type refinement through inheritance is less common in C++, perhaps because:</p>
<ol>
<li>
<p>C++ lacks built-in support for invariant checking</p>
</li>
<li>
<p>The language encourages thinking about inheritance in terms of interface/capability extension</p>
</li>
<li>
<p>Many C++ codebases use inheritance primarily for runtime polymorphism rather than compile-time type constraints</p>
</li>
</ol>
<p>Your pattern seems more aligned with how some functional languages handle subtypes and refinement types. The fact that you're using it in a debug-time checking tool is interesting - it's bringing some of those functional programming type safety concepts into C++ through the back door.</p>
</blockquote>
<h2><a name="p-7887-so-c-can-do-it-but-its-just-painful-2" class="anchor" href="https://forum.rebol.info#p-7887-so-c-can-do-it-but-its-just-painful-2"></a>So C++ Can Do It, But It's Just Painful</h2>
<p>But... now it's written, and it works.  Using it is easy enough, and catches usage errors and misunderstandings on a daily basis.</p>
<p>I'd be interested to see how this would be implemented in a functional language, but I'm not going to be the one to do it.  Maybe some bored AI can do it someday.</p>
<p>In any case, it's tech and intelligence like this that puts Ren-C far beyond the competition.  <img src="https://forum.rebol.info/images/emoji/twitter/brain.png?v=12" title=":brain:" class="emoji" alt=":brain:" loading="lazy" width="20" height="20"></p>
<p>And it's the fact that it still builds as C (with the TinyC compiler, no less) that keeps it true to Rebol's roots.  <img src="https://forum.rebol.info/images/emoji/twitter/farmer.png?v=12" title=":farmer:" class="emoji" alt=":farmer:" loading="lazy" width="20" height="20"></p>
<p>In the C build, the definitions are simply:</p>
<pre><code>#if NO_CPLUSPLUS_11
    typedef RebolValue Atom;
    typedef RebolValue Value;
    typedef RebolValue Element;

    #define Sink(T) T *
    #define Need(TP) TP
#endif
</code></pre>
<p>I am starting to suspect this is the only codebase of its kind.</p> ]]></description>
        <link>https://forum.rebol.info/t/antiform-safety-covariance-and-contravariance/2330#post_2</link>
        <pubDate>Mon, 11 Nov 2024 10:00:07 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7887</guid>
      </item>
      <item>
        <title>Antiform Safety: Covariance and Contravariance</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Grafting antiforms onto a C codebase that had no such concept is fraught with disasters.</p>
<p>The semantics of unstable antiforms is particularly risky.  If you have a test like <strong><code>Is_Block(cell)</code></strong> that tells you whether a cell holds a BLOCK!, then what if that cell holds an antiform block?  Usermode code has the benefit of decay-by-default (unless you take a meta-parameter).  So if you ask <strong><code>BLOCK?</code></strong> on a parameter pack, it will decay to its first item and answer based on that.  The C implementation has no such "automatic" behavior.</p>
<p>Even "worse", what if <strong><code>cell</code></strong> contains an antiform error, and you quietly say "no it's not a block" and proceed on, ignoring situations when that should have raised an abrupt failure?</p>
<h2><a name="p-7886-creating-a-type-hierarchy-atom-value-element-1" class="anchor" href="https://forum.rebol.info#p-7886-creating-a-type-hierarchy-atom-value-element-1"></a>Creating A Type Hierarchy: Atom -&gt; Value -&gt; Element</h2>
<p>I've given names to the three broad categories of cells:</p>
<ul>
<li>
<p><strong>ELEMENT</strong> - anything that you can put in a List.  So this is "element" as in "array element".  Hence, no antiforms.  (It's not a perfect name in terms of correspondence to "chemical element" in terms of the abstract form that can come in isotopes, so think of it as array element)</p>
</li>
<li>
<p><strong>VALUE</strong> - anything that you can put in a Variable.  So it extends ELEMENT with stable antiforms.</p>
</li>
<li>
<p><strong>ATOM</strong> - anything, including unstable antiforms.</p>
</li>
</ul>
<p>Systemically, we want to stop antiforms from being put into the array elements of blocks, groups, paths, and tuples.  We also want to prevent unstable antiforms from being the values of variables.</p>
<p>To make it easier to do this, the C++ build offers the ability to make <code>Element</code> that can't hold any antiforms, <code>Value</code> that can hold stable antiforms, and <code>Atom</code> that can hold anything--including unstable isotopes.</p>
<ul>
<li>
<p><strong>Class Hierarchy:</strong> Atom as base, Value derived, Element derived (upside-down for compile-time error preferences--we want passing an Atom to a routine that expects only Element to fail)</p>
</li>
<li>
<p><strong>Primary Goal:</strong> Prevent passing Atoms/Values to Element-only routines, or Atoms to Value-only routines.</p>
</li>
<li>
<p><strong>Secondary Goal:</strong> Prevent things like passing Element cells to writing routines that may potentially produce antiforms in that cell.</p>
</li>
<li>
<p><strong>Tertiary Goal:</strong> Detect things like superfluous <code>Is_Antiform()</code> calls being made on Elements.</p>
</li>
</ul>
<p>The primary goal is achieved by choosing Element as a most-derived type instead of a base type.</p>
<p>The next two goals are somewhat maddeningly trickier... <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7886-sink-and-need-2" class="anchor" href="https://forum.rebol.info#p-7886-sink-and-need-2"></a><code>Sink(...)</code> and <code>Need(...)</code></h2>
<p>The idea behind a Sink() is to be able to mark on a function's interface when a function argument passed by pointer is intended as an output.</p>
<p>This has benefits of documentation, and can also be given some teeth by scrambling the memory that the pointer points at (so long as it isn't an "in-out" parameter).  But it also applied in CHECK_CELL_SUBCLASSES, by enforcing "covariance" for input parameters, and "contravariance" for output parameters.</p>
<p>If USE_CELL_SUBCLASSES is enabled, then the inheritance heirarchy has Atom at the base, with Element at the top.  Since what Elements can contain is more constrained than what Atoms can contain, this means you can pass Atom* to Element*, but not vice-versa.</p>
<p>However, when you have a Sink(Element) parameter instead of an Element*, the checking needs to be reversed.  You are -writing- an Element, so the receiving caller can pass an Atom* and it will be okay.  But if you were writing an Atom, then passing an Element* would not be okay, as after the initialization the Element could hold invalid states.</p>
<p>We use "SFINAE" to selectively enable the upside-down hierarchy, based on the <code>std::is_base_of&lt;&gt;</code> type trait.</p>
<h2><a name="p-7886-the-code-in-the-c-debug-build-3" class="anchor" href="https://forum.rebol.info#p-7886-the-code-in-the-c-debug-build-3"></a>The Code (in the C++ Debug Build)</h2>
<pre><code>template&lt;typename T, bool sink&gt;
struct NeedWrapper {
    T* p;
    mutable bool corruption_pending;  // can't corrupt on construct

  //=//// TYPE ALIASES ////////////////////////////////////////////////=//

    using MT = typename std::remove_const&lt;T&gt;::type;

    template&lt;typename U&gt;  // contravariance
    using IsReverseInheritable = typename std::enable_if&lt;
        std::is_same&lt;U,T&gt;::value or std::is_base_of&lt;U,T&gt;::value
    &gt;::type;

  //=//// CONSTRUCTORS ////////////////////////////////////////////////=//

    NeedWrapper() = default;  // or MSVC warns making Option(Sink(Value))

    NeedWrapper(nullptr_t) {
        p = nullptr;
        corruption_pending = false;
    }

    NeedWrapper (const NeedWrapper&lt;T,sink&gt;&amp; other) {
        p = other.p;
        corruption_pending = p and (other.corruption_pending or sink);
        other.corruption_pending = false;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper(U* u) {
        p = u_cast(T*, u);
        corruption_pending = p and sink;
    }

    template&lt;typename U, bool B, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper(const NeedWrapper&lt;U, B&gt;&amp; other) {
        p = u_cast(T*, other.p);
        corruption_pending = p and (other.corruption_pending or sink);
        other.corruption_pending = false;
    }

  //=//// ASSIGNMENT //////////////////////////////////////////////////=//

    NeedWrapper&amp; operator=(nullptr_t) {
        p = nullptr;
        corruption_pending = false;
        return *this;
    }

    NeedWrapper&amp; operator=(const NeedWrapper&lt;T,sink&gt; other) {
        if (this != &amp;other) {  // self-assignment possible
            p = other.p;
            corruption_pending = p and (other.corruption_pending or sink);
            other.corruption_pending = false;
        }
        return *this;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper&amp; operator=(const NeedWrapper&amp; other) {
        if (this != &amp;other) {  // self-assignment possible
            p = other.p;
            corruption_pending = p and (other.corruption_pending or sink);
            other.corruption_pending = false;
        }
        return *this;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper&amp; operator=(U* other) {
        p = u_cast(T*, other);
        corruption_pending = p and sink;
        return *this;
    }

  //=//// OPERATORS ///////////////////////////////////////////////////=//

    operator bool () const { return p != nullptr; }

    operator T* () const {
        if (corruption_pending) {
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
            corruption_pending = false;
        }
        return p;
    }

    T* operator-&gt;() const {
        if (corruption_pending) {
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
            corruption_pending = false;
        }
        return p;
    }

  //=//// DESTRUCTOR //////////////////////////////////////////////////=//

    ~NeedWrapper() {
        if (corruption_pending)
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
    }
};
</code></pre>
<p>So then the <code>Sink(...)</code> and non-corrupting version <code>Need(...)</code> for in/out parameters with contravariance checking are:</p>
<pre><code>#define Sink(T) \
    NeedWrapper&lt;T, true&gt;

#define Need(TP) \
    NeedWrapper&lt;typename std::remove_pointer&lt;TP&gt;::type, false&gt;
</code></pre>
<h2><a name="p-7886-notes-on-corrupting-4" class="anchor" href="https://forum.rebol.info#p-7886-notes-on-corrupting-4"></a>Notes on Corrupting</h2>
<p>The original implementation was simpler, by just doing the corruption at the moment of construction.</p>
<p>But this faced a problem:</p>
<pre><code>    bool some_function(Sink(char*) out, char* in) { ... }

    if (some_function(&amp;ptr, ptr)) { ...}
</code></pre>
<p>If you corrupt the data at the address the sink points to, you can actually be corrupting the value of a stack variable being passed as another argument before it's calculated as an argument.  So deferring the corruption after construction is necessary.  It's a bit tricky in terms of the handoffs and such.</p>
<p><em>(While this could be factored, function calls aren't inlined in the debug build, so given the simplicity of the code, it's repeated.)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/antiform-safety-covariance-and-contravariance/2330#post_1</link>
        <pubDate>Mon, 11 Nov 2024 09:49:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7886</guid>
      </item>
      <item>
        <title>Full-Band Return Values from Generators/Yielders</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Definitional Errors came into PARSE as an answer for how to make it possible to return any value... simply make a failed parse a definitional error.  Not only does it mean that NULL can be a legitimate synthesized product that you don't conflate with failure, but it also means that parse failures can give back more information in the error about what went wrong <em>(farthest parse point reached, etc.)</em>...</p>
<p>Looking at another problem where a sentinel NULL had been used... there's <a href="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311">Generators and Yielders</a>:</p>
<pre><code>&gt;&gt; g: generator [print "A" yield 1, print "B" yield 2, print "C"]

&gt;&gt; g
A
== 1

&gt;&gt; g
B
== 2

&gt;&gt; g
C
== ~null~  ; anti

&gt;&gt; g
== ~null~  ; anti

&gt;&gt; g
== ~null~  ; anti
</code></pre>
<p>But Generators and Yielders predate antiforms in general... they came at a time where there were just two forms of NULL: "heavy" and "light".  So the thought was that if you wanted to actually yield null, it would be the heavy form.</p>
<pre><code>&gt;&gt; g: generator ["Start", yield null, print "Done"]

&gt;&gt; g
Start
== ~[~null~]~  ; anti

&gt;&gt; g
Done
== ~null~  ; anti
</code></pre>
<p>But this isn't nearly as good as using a specific raised error.  If NULL is truly out of band, then you could use <strong><code>try g</code></strong> to get null when there are no more values.</p>
<p>If you try to YIELD or RETURN a raised error, then it would become an abrupt failure.  So you'd be assured that the only time you'd ever get a definitional error back from a generator or yielder would be if it had been exhausted.</p>
<h2><a name="p-7884-pack-returns-for-things-like-key-and-value-in-objects-1" class="anchor" href="https://forum.rebol.info#p-7884-pack-returns-for-things-like-key-and-value-in-objects-1"></a>PACK returns for things like KEY and VALUE in objects?</h2>
<p>As the enumeration routines are retooled to be based on generator functions, it struck me as very cool if generators returned packs, which could be decayed:</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20 c: 30]

&gt;&gt; g: each obj

&gt;&gt; g
; first in pack of 2 items
== a

&gt;&gt; meta g
== ~['b '20]~

&gt;&gt; [key {val}]: g
== 30

&gt;&gt; key
== c

&gt;&gt; g
** Error: Generator/Yielder exhausted

&gt;&gt; try g
== ~null~  ; anti
</code></pre>
<p>That's really cool, and seems like it would go along with decaying:</p>
<pre><code>for 'key each obj [...]

for [key val] each obj [...]
</code></pre>
<p>This looks pretty nice, however blocks used in FOR-EACH scenarios like this haven't meant "unpack", it has meant keep getting items and assign them to each.</p>
<p>It seems like it would be unfortunate if you had to write the object unpacking as:</p>
<pre><code>for [~[key val]~] each obj [...]
</code></pre>
<p>But that does seem sort of like what you'd have to do in order to make it generalized.  It doesn't look <em>that</em> bad, and it does have a theory behind it...</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20 c: 30]

&gt;&gt; for [~[key val]~ :otherkey] each obj [  ; leading colon for optionality
       print ["key:" key]
       print ["val:" val]
       if otherkey [
           print ["otherkey:" otherkey]
       ]
   ]

key: a
val: 10
otherkey: b
key: c
val: 30
</code></pre>
<p>This assumes that plain blocks might be taken for some other intent in the FOR.  If it were not:</p>
<pre><code>for [[key val] :otherkey] each obj [...]
</code></pre>
<p>But I had been thinking that plain BLOCK! would likely be good for type checking (<span class="mention">@hiiamboris</span> has some experiments in this vein):</p>
<pre><code>for [x [integer!] y [tag!]] each [1 &lt;a&gt; 2 &lt;b&gt;] [....]
</code></pre>
<h2><a name="p-7884-big-design-space-but-full-band-returns-opens-it-up-2" class="anchor" href="https://forum.rebol.info#p-7884-big-design-space-but-full-band-returns-opens-it-up-2"></a>Big Design Space, but Full-Band Returns Opens It Up</h2>
<p>I'd let the Generator and Yielder experiments atrophy while working on other things.  But I stopped today to try and get the basics working again, and it's interesting to see how isotopes bring a lot to the table...as they seem to have done with nearly everything.</p> ]]></description>
        <link>https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329#post_1</link>
        <pubDate>Sun, 10 Nov 2024 19:25:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7884</guid>
      </item>
      <item>
        <title>TRIPWIRE in The Wild</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <h2><a name="p-7883-tripwires-catch-bugs-failing-functions-wont-1" class="anchor" href="https://forum.rebol.info#p-7883-tripwires-catch-bugs-failing-functions-wont-1"></a>Tripwires Catch Bugs Failing Functions Won't</h2>
<p>Prior to the existence of tripwires, there were some functions in LIB for things like RETURN, CONTINUE, THROW, etc. to give you messages when you tried to use these definitional constructs in places that didn't provide them:</p>
<pre><code>/return: func [] [
    fail:blame "RETURN called when no generator is providing it" $return
]

/continue: func [] [
    fail:blame "CONTINUE called when no loop is providing it" $return
]

/throw: func [] [
    fail:blame "THROW called when no catch is providing it" $return
]

...
</code></pre>
<p>Passing the <code>$return</code> bound word as the <code>:BLAME</code> argument is a bit awkward to write.  But it means the error will blame the callsite, showing the error there--instead of implicating the FAIL itself inside the stub function.  That makes the error much more useful.</p>
<p><strong>But this still makes it look like the functions are available.</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>You won't get an error if you say <strong><code>return/</code></strong> to try and get a RETURN function.  You'll get a function--and it will pass the rule that things ending in slash must look up to functions--but it's not the kind of RETURN function you actually wanted.</p>
<p>This led to confusing downstream bugs when some code wasn't binding correctly, but proceeded merrily along as if it had gotten a RETURN function.</p>
<p><strong>Tripwires make it nice and tidy!</strong></p>
<pre><code>return: ~&lt;RETURN used when no function generator is providing it&gt;~

continue: ~&lt;CONTINUE used when no loop is providing it&gt;~

throw: ~&lt;THROW used when no catch is providing it&gt;~

...
</code></pre>
<p>You get the "blame" of the callsite for free, because tripwires aren't function instantiations.</p>
<p>And if you say <strong><code>return/</code></strong> then that's an error, because it's not a function.</p>
<p><em>This is quite an improvement!</em></p> ]]></description>
        <link>https://forum.rebol.info/t/tripwire-in-the-wild/2278#post_3</link>
        <pubDate>Sun, 10 Nov 2024 13:44:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7883</guid>
      </item>
      <item>
        <title>Implicit Capture In PARSE - How To Get It?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1718">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I kind of find myself wishing for another lexical type that means "capture" that has the word "in it". I'd thought about this as being the meaning of <code>@xxx</code> before the current interpretation, and also <code>$xxx</code>:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">parse isodate [$year "-" $month "-" $day "T" ...]
</code></pre>
<p>But almost certainly, $ is going to be binding-related in the default combinator set.</p>
</blockquote>
</aside>
<p>Given that there are more parts in the box, I thought of a possibility for this:</p>
<pre><code>parse isodate [:year: "-" :month: "-" :day: "T" ...]
</code></pre>
<p>It still has a colon on the end, which can help hint that it's an assignment.  But the colon on the front gives it a visual sense of balance, pulling it left to where you might imagine it doesn't take any arguments.  And it suggests perhaps connecting the left and right in a way that would capture between it.</p>
<p>It's generalized to where you can put tuples inside it:</p>
<pre><code>parse isodate [:date.year: "-" :date.month: "-" :date.day: "T" ...]
</code></pre>
<p>It's certainly <em>weird</em>, but it's the best idea I've had so far.  Beyond just "<code>$year</code> and <code>@year</code> are taken", I actually think it's superior.</p> ]]></description>
        <link>https://forum.rebol.info/t/implicit-capture-in-parse-how-to-get-it/1718#post_3</link>
        <pubDate>Sat, 09 Nov 2024 22:47:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7882</guid>
      </item>
      <item>
        <title>Intrinsics: Functions without Frames</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2050">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>All of the native function implementations were assumed to have the same type signature, taking a frame as an argument. I took away that assumption and added an /INTRINSIC refinement to the NATIVE function generator. If it was an intrinsic, then the C function in the native table would take a single value argument and an output slot to write to.</p>
<p>So it's still one C function per native. But if it's an intrinsic, then the function is not a dispatcher... the Intrinsic_Dispatcher() is used, and the C function is poked into the properties of the function.</p>
</blockquote>
</aside>
<p>I realized that I could use a normal native dispatcher.  But simply have the parent level that's calling the intrinsic put a flag on its own level (LEVEL_FLAG_DISPATCHING_INTRINSIC).  If the native sees this flag is set, then it knows the <code>Level*</code> it is receiving is not its own Level (with its own arguments in a frame)... but the parent Level.</p>
<p>Then--by convention--there are two cells worth of data in the parent.  One is the SPARE cell (used for intermediate GC safe calculations).  At the moment of calling an intrinsic, the parent commits the SPARE cell for the single argument to the intrinsic.</p>
<p>The second cell is called the SCRATCH.  This has a specific purpose in the evaluator--to hold the currently evaluating value.  So that's a good place for the Intrinsic native to look for its own function--so it can pick out any instance data <em>(e.g. a typechecker which has only one C function to implement checking for all types can look at that ACTION! instance to get the per-typechecker information of what type is intended to check)</em>.</p>
<p>Because all Levels have SPARE and SCRATCH, this means any of them can call an Intrinsic and pass their own Level* to the native dispatcher function.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2050">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Typically these functions are very simple:</p>
<ul>
<li>They take one argument.</li>
<li>They can't fail.</li>
<li>They don't require recursive invocations of the evaluator.</li>
</ul>
</blockquote>
</aside>
<p>So I realized that not being able to fail was a bad constraint.</p>
<p>In particular, <em>because intrinsics need to implement their own typechecking on their single argument</em>.  Having to call into the generalized typechecking system as a sub-step in calling a fundamental typechecker is not good... especially when that call can't be made intrinsically (because you're in the middle of an intrinsic call that's already using the SPARE and SCRATCH!)</p>
<p>So failing is allowed, simply by making the functions that need to be aware for stack purposes know about LEVEL_FLAG_DISPATCHING_INTRINSIC.  There aren't very many such functions... just putting a stack trace on failures, really.  (Needs to be able to peek in the SCRATCH cell for the action and label to report, vs. the usual place... and not skip the contribution of the parent Level that is being reused).</p>
<p>Anyway--it's snappier.  While I generally push back against doing optimizations, intrinsics are pretty much required for the type-constraints-as-functions to be tolerable at all.</p> ]]></description>
        <link>https://forum.rebol.info/t/intrinsics-functions-without-frames/2050#post_2</link>
        <pubDate>Sat, 09 Nov 2024 17:59:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7881</guid>
      </item>
      <item>
        <title>Exact Matching of Variables with the @ Types In UPARSE</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I think I've finally decided to declare <strong><code>@</code></strong> to be a shorthand for "match any item at this position", and not take an argument.</p>
<p>This combinator's "long" form is called ONE <em>(a replacement for historical SKIP, because reading <strong><code>[x: skip]</code></strong> and expecting that to store an item in a variable sounds like the opposite of skipping... and also, SKIP being arity-0 doesn't fit with the rest of the system... UPARSE instead has a SKIP combinator that takes how much to skip)</em>:</p>
<pre><code>&gt;&gt; parse [#foo &lt;bar&gt;] [issue! one]
== &lt;bar&gt;
</code></pre>
<p>So now, it simply has a shorthand:</p>
<pre><code>&gt;&gt; parse [#foo &lt;bar&gt;] [issue! @]
== &lt;bar&gt;
</code></pre>
<p>To justify why this isn't a fully arbitrary choice: when we see something like <code>@var</code> that's matching at the current position under the constraint of the provided variable:</p>
<pre><code>&gt;&gt; block: [some "a"]

&gt;&gt; parse [[some "a"] [some "a"]] [some @block]
== [some "a"]
</code></pre>
<p>So it doesn't seem too crazy that when you take away the variable name that's being looked up for the constraint, you'd get a combinator that matches <em>anything</em>.</p>
<h2><a name="p-7879-this-frees-blank-up-for-literal-match-blank-or-space-1" class="anchor" href="https://forum.rebol.info#p-7879-this-frees-blank-up-for-literal-match-blank-or-space-1"></a>This Frees BLANK! Up For Literal Match Blank, Or Space</h2>
<p>Since the dawn of the BLANK! datatype, I have wanted to use it for space in string PARSE (among other places), and literal match of blanks in blocks:</p>
<pre><code>&gt;&gt; parse "a b" ["a" _ "b"]
== "b"

&gt;&gt; parse [a _ b] ['a _ 'b]
== b
</code></pre>
<p>But the idea of blank being either "match anything at current position" or "no-op" have been competing intents.</p>
<p>Even the question of being an underscore in strings comes up, but now that's done with quoting (which mold-matches any type)</p>
<pre><code>&gt;&gt; parse "a_&lt;b&gt;" ['a '_ '&lt;b&gt;]
== &lt;b&gt;
</code></pre>
<p>The @ symbol is a bit bulkier for match any item here, but I think its bulk is to scale of its intent...and as I point out, puts it in the family of the other <code>@xxx</code> combinators.</p>
<p>We now have a pretty good answer for people who want a way to opt out of rules without using an empty block... use a void:</p>
<pre><code>&gt;&gt; rule: if 1 = 2 [[some "b"]]
== ~void~  ; anti

&gt;&gt; parse "aaa" [rule some "a"]
== "a"
</code></pre>
<p>So I don't think it's necessary to dabble in the idea of having a fetched blank mean something different.  I'm happy enough saying that the BLANK! combinator only applies in the rule as source, and gives you an error if you try to fetch it via word.</p>
<p>Though I will point out that <strong><code>@var</code></strong> has quoting semantics--as if the fetched <strong>var</strong> were in the rule block with one quote level added.  Hence you would get the underscore behavior:</p>
<pre><code>&gt;&gt; parse "a_&lt;b&gt;" ['a @blank '&lt;b&gt;]
== &lt;b&gt;
</code></pre>
<p>...but if fetching BLANK! from a WORD! did anything (though I think it shouldn't), it should be a no-op:</p>
<pre><code> &gt;&gt; parse "ab" ['a blank 'b]
 == b  ; not that I think it should do this, but if it DID do something...
</code></pre>
<p>If some amazingly compelling case for that shows up, then perhaps it should be enabled.</p>
<h2><a name="p-7879-for-quoting-theres-just-and-literal-2" class="anchor" href="https://forum.rebol.info#p-7879-for-quoting-theres-just-and-literal-2"></a>For Quoting, There's JUST and LITERAL</h2>
<p>This means @ doesn't behave like it does in the main evaluator as an arity-1 operator for literalizing the subsequent argument.</p>
<p>But you have other options.  <a href="https://forum.rebol.info/t/synthesizing-parse-values-from-thin-air-just/2328">JUST will "just" synthesize the value (don't match it)</a>, while LITERAL will match it (and synthesize if matched).</p>
<pre><code>&gt;&gt; parse [] [just x]
== x

&gt;&gt; parse [''x] [literal ''x]
== ''x
</code></pre>
<p>LITERAL is nice when the thing you are matching has more than one quote level, because otherwise it can feel a little confusing:</p>
<pre><code>&gt;&gt; parse [''x] ['''x]
== ''x
</code></pre>
<p>It's also nice if something has a quote mark in the name:</p>
<pre><code> &gt;&gt; foo': "foo prime"

 &gt;&gt; parse [foo'] ['foo']  ; hrrrm
 == foo'

 &gt;&gt; parse [foo'] [literal foo']
 == foo'
</code></pre>
<p>As a shorthand, there's LIT.</p>
<pre><code> &gt;&gt; parse [foo'] [lit foo']
 == foo'
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/exact-matching-of-variables-with-the-types-in-uparse/1643#post_7</link>
        <pubDate>Fri, 08 Nov 2024 20:06:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7879</guid>
      </item>
      <item>
        <title>Trailing Slash Is A Winner For Defused Actions</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I <em>really</em> like this trailing slash thing, meaning "get me the action as is and don't run it AND guarantee it's an action".</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] word?/ &lt;ice&gt;
== [&lt;ice&gt; 1 &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>That's to me just about perfect:</p>
<ul>
<li>
<p>You're passing the parameter of what to replace as being an antiform action, so it will be called on the elements.</p>
</li>
<li>
<p>It does NOT take a parameter (notice the slash dividing it from what comes after it?  that's a strong semiotic hint that <code>&lt;ice&gt;</code> is not a parameter to <code>word?</code>)</p>
</li>
<li>
<p>...and it's an antiform, so you know it doesn't occur literally in the block.</p>
</li>
</ul>
<p>Before this form existed, I was using MATCHES which made an antiform action for a datatype:</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] matches word! &lt;ice&gt;
== [&lt;ice&gt; 1 &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>That's slower, wordier, and more opaque about the mechanics.</p>
<p>It's useful if you have a datatype in your hand and need to convert it to a function, or if you have a more complex type construction:</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] matches [word! integer!] &lt;ice&gt;
== [&lt;ice&gt; &lt;ice&gt; &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>Maybe it should be called MATCHER, since it's actually a function generator.  MATCHES looks a little too much like MATCH, so it seems like it might take <code>&lt;ice&gt;</code> as an argument.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>If you make such a call often, you wouldn't want to regenerate the function each time:</p>
<pre><code>&gt;&gt; word-or-int?: matcher [word! integer!]

&gt;&gt; replace [a 1 a &lt;baby&gt;] word-or-int?/ &lt;ice&gt;
== [&lt;ice&gt; &lt;ice&gt; &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>MATCHES would seems like it's providing an answer in the moment, whereas MATCHER works better for when you're not using immediately.  So it's probably the better choice.</p>
<p>Anyway, I'll also say that the <a href="https://forum.rebol.info/t/make-replace-all-default-semantics-of-replace/2269">REPLACE "ALL" semantic being the default</a> is a big improvement.</p> ]]></description>
        <link>https://forum.rebol.info/t/trailing-slash-is-a-winner-for-defused-actions/2327#post_1</link>
        <pubDate>Fri, 08 Nov 2024 19:05:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7878</guid>
      </item>
      <item>
        <title>TAG!s Angle Brackets: *They Aren&#39;t There!*</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Implementation-wise, the delimiters of tag have been quite the thorn.</p>
<p>Are they there or not?</p>
<p>In Rebol2, Red, R3-Alpha...</p>
<pre><code>&gt;&gt; find &lt;abcd&gt; "c"
== &lt;cd&gt;

&gt;&gt; find &lt;abcd&gt; "&gt;"
== none
</code></pre>
<p>Not there!</p>
<p>Or are they?  Reverse the arguments, and in Rebol2 and Red, they seem to magically appear:</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "&lt;c&gt;d"
</code></pre>
<p>But... this was not the case in R3-Alpha...</p>
<pre><code>r3-alpha&gt;&gt; find "abcd" &lt;c&gt;
== "cd"

r3-alpha&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"
</code></pre>
<p>I know things have gone back and forth with people believing deeply in their little hearts that they are happier when routines act like the delimiters are there...</p>
<p>But for the baseline behavior: <em>I have come to believe R3-Alpha is right.</em>  They're string delimiters, and incidental to the default purpose, just as quotes are.</p>
<p>If you start looking at TAG! as it truly is--just another string class with different delimiters--it simplifies the mental model and the implementation model.  You can truly just use it like another string, and it suddenly becomes consistent.</p>
<p>Of course, it's still nice to be able to match the molded form of a tag.</p>
<p>But... why stop at tags? <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> Why not have a syntax to match the molded form of anything?</p>
<p>In strings, where you can't match list elements literally anyway:</p>
<pre><code>&gt;&gt; parse "&lt;a&gt; 100 (b c)" ['&lt;a&gt; space '100 space '(b c)]
== (b c)
</code></pre>
<p>(The synthesized product may be more interesting, too.  As a reminder, Ren-C has taken words that might be better as variable names like END and uses plain tag as  instead, or  to synthesize the parse input, etc.)</p>
<pre><code>&gt;&gt; parse "&lt;end&gt; asdf" ['&lt;end&gt; to &lt;end&gt; &lt;input&gt;]
== "&lt;end&gt; asdf"
</code></pre>
<p>I don't know whether that is best done as just a PARSE feature, or if quoted things need to be searched for literally by FIND.</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"

&gt;&gt; quote &lt;c&gt;
== '&lt;c&gt;

&gt;&gt; find "ab&lt;c&gt;d" quote &lt;c&gt;
== "&lt;c&gt;d"

&gt;&gt; find "ab&lt;c&gt;d" mold &lt;c&gt;  ; one fewer character
== "&lt;c&gt;d"
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326#post_1</link>
        <pubDate>Fri, 08 Nov 2024 18:12:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7877</guid>
      </item>
      <item>
        <title>Embracing A &quot;Useless&quot; Definition of TO</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Many years ago, I thought about <strong><a href="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649">trying to untangle of the TO and MAKE matrix</a></strong>.  These operations are notoriously unpredictable in historical Redbol.</p>
<p>I tried putting some stakes in the ground about what I believed <em>had</em> to be true.  It was difficult because I could not think of too many.</p>
<p>One thing I said was that TO should always create a "new" value (if the value was not immediate).  And I felt like this should be true:</p>
<pre><code>to (type of value) value
; ...same as...
copy value
</code></pre>
<p>Grasping for any stake in the ground I could find, I was pretty sure that TO of a string representation of an integer to an integer should give you the integer:</p>
<pre><code>&gt;&gt; to integer! "1020"
== 1020  ; we know this, at least? (one hopes...)
</code></pre>
<p>And the reverse, one would think, as well:</p>
<pre><code>&gt;&gt; to text! 1020
== "1020"  ; what else *could* it be?  codepoint 1020? -&gt; "ϼ"
</code></pre>
<p>But beyond that it was hard to think of the pattern.</p>
<h2><a name="p-7876-coming-back-to-an-old-idea-reversibility-1" class="anchor" href="https://forum.rebol.info#p-7876-coming-back-to-an-old-idea-reversibility-1"></a>Coming Back To An Old Idea: Reversibility</h2>
<p>When I first encountered Rebol and was made aware of these problems, I suggested TO should be reversible:</p>
<pre><code>value1 = to (type of value1) to type2 value1
</code></pre>
<p>However, this gave what <em>appeared</em> to be very "unexciting" options for behavior:</p>
<pre><code>&gt;&gt; to block! 1
== [1]

&gt;&gt; to integer! [1]
== 1

&gt;&gt; to integer! [...anything else in a block that's not integer...]
** Error.  Always.
</code></pre>
<p>That particular idea was was so long ago that I don't have direct quotes on hand of people saying "nah, that sucks, TO could barely do anything."  But I'm pretty sure it was panned by basically everyone I suggested it to.  I guess I agreed, because I dropped it.</p>
<p><strong>Coming back to it now, and seeing it in a new light, I see this as much more useful than I used to.</strong>  Especially when compared to the historical mess that makes TO nigh-unusable.</p>
<p>And in fact, it fits in with several Rebol2/Red behaviors that I'd thought were kind of pointless before:</p>
<pre><code>&gt;&gt; to integer! &lt;1&gt;
== 1

&gt;&gt; to tag! 1
== &lt;1&gt;
</code></pre>
<p>The use I didn't see at the time was the frequent need when dialecting to push values out of band, into some other type, without losing their meaning.  If you have a dialect in which integers already mean something, but you want a way of pushing some integer-oriented instruction in there...you can use these kinds of operations.</p>
<p>Definitional errors in Ren-C make this convenient, since checking if something fits the pattern is quick, you just throw in a TRY and the antiform error that's the return result of the TO will be suppressed, giving you a "falsey" null:</p>
<pre><code>&gt;&gt; thing: &lt;a b&gt;

&gt;&gt; to integer! thing
** Error: Cannot TO convert &lt;a b&gt; to integer

&gt;&gt; try to integer! thing
== ~null~  ; anti
</code></pre>
<p>The more I look at it the more useful it appears.  And it helps give clarity to the MAKE vs. TO division.  If you have something that isn't shaped like this, then <em>maybe</em> MAKE is the right place to put it.  For example:</p>
<pre><code>&gt;&gt; to percent! 1
== 1%

&gt;&gt; to integer! 1%
== 1

&gt;&gt; make percent! 1
== 100%
</code></pre>
<p><em>(Note: I think ENCODE + DECODE is a better place for binary conversions, e.g. ENCODE 'IEEE-754 is better than MAKE BINARY! of a decimal because that could mean many things, and ENCODE can have more parameterization for single vs. double precision, etc.  I don't know<br>
if TO BINARY! should work at all, but if it does, I'd probably agree with the Rebol2 choice to give the binary representation of the UTF-8 string... e.g. (to binary! 1020) as #{31303230} ... and use more explicit future-proof routines to encode with specified byte size and endianness.)</em></p>
<h2><a name="p-7876-reversibility-rules-out-rounding-2" class="anchor" href="https://forum.rebol.info#p-7876-reversibility-rules-out-rounding-2"></a>Reversibility Rules Out Rounding</h2>
<p>In order to get losslessness in the representation, you can't throw out information.</p>
<p>So this works:</p>
<pre><code>&gt;&gt; to integer! 1.0
== 1

&gt;&gt; to decimal! 1
== 1.0
</code></pre>
<p>But this does not:</p>
<pre><code> &gt;&gt; to integer! 1.5
 ** Error: Can't TO INTEGER! a DECIMAL! w/digits after decimal point
</code></pre>
<p>I don't think that's a problem, because that seems like a job for ROUND.  Unfortunately, R3-Alpha and Red do something dumb:</p>
<pre><code>rebol2&gt;&gt; round 1.5
== 2

red&gt;&gt; round 1.5
== 2.0

r3-alpha&gt;&gt; round 1.5
== 2.0
</code></pre>
<p>It seems this was part of a shift to try and preserve the input type, to facilitate things like rounding MONEY!:</p>
<pre><code>r3-alpha&gt;&gt; round $1.50
== $2
</code></pre>
<p>So I guess the way the thinking went was that if you want to keep MONEY! as MONEY! when you round it, all types should act that way.</p>
<p>I think the relationship between INTEGER! and DECIMAL!, which lack decoration, suggests something more intimate where the type can be lost.  If you don't want to lose it, ROUND:TO 1.0</p>
<pre><code>&gt;&gt; round 1.5
== 2

&gt;&gt; round:to 1.5 1
== 2

&gt;&gt; round:to 1.5 1.0
== 2.0
</code></pre>
<h2><a name="p-7876-blank-pretty-much-has-to-mean-empty-3" class="anchor" href="https://forum.rebol.info#p-7876-blank-pretty-much-has-to-mean-empty-3"></a>BLANK! Pretty Much Has To Mean Empty</h2>
<p>If we're talking about equivalencies, we now know this:</p>
<pre><code>&gt;&gt; for-each 'x _ [print "Doesn't run"]
== ~void~  ; anti

&gt;&gt; empty? _
== ~okay~  ; anti
</code></pre>
<p>And so really, it seems that the TO conversion of BLANK! has only one set of answers to fit into the family of reversibility:</p>
<pre><code>&gt;&gt; to block! _
== []

&gt;&gt; to text! _
== ""

&gt;&gt; to blank! &lt;&gt;
== _

&gt;&gt; to blank! #{}
== _
</code></pre>
<p>And if you try to TO BLANK! anything that's not conceptually empty, you'd get an error.</p>
<pre><code>&gt;&gt; to blank! &lt;a&gt;
** Error: ...
</code></pre>
<p>I don't know if there's a motivating case for saying <strong>to integer! _</strong> should pick something like 0 as an answer, though Rebol2 did something of that sort:</p>
<pre><code>rebol2&gt;&gt; to integer! none
== 0
</code></pre>
<p>Neither Red nor R3-Alpha carried that forward, <a href="https://github.com/metaeducation/rebol-issues/issues/1018">though it was discussed</a></p>
<h2><a name="p-7876-can-be-checked-in-the-implementation-4" class="anchor" href="https://forum.rebol.info#p-7876-can-be-checked-in-the-implementation-4"></a>Can Be Checked In The Implementation</h2>
<p>I've started hacking this through, and it's gone relatively well.  TO dispatches <em><strong>to the type it's converting from</strong></em>, with the type being converted to as the argument.</p>
<p>And it's nice in the sense that the TO native driving the process can also check the reversibility constraint in the debug build, to give it some teeth.</p>
<p><em>(I've rigged up some interesting frame mechanics to enable doing this reversal efficiently, that have sped up other parts of the system (like CASCADE) with "downlevel shifting", that can bypass a trampoline bounce...)</em></p>
<p>Anyway, things are a mess right now with a couple hundred broken tests to painfully sift through.  But I think the reversibility rule is good... biggest questions are whether that relaxes in terms of spacing...</p>
<pre><code>&gt;&gt; to block! "  1    2  "
== [1 2]  ; legal?
</code></pre>
<p>This would suggest you would have to compare with the trimmed/canonized version of your input.</p>
<p>Also, issues of string representations.</p>
<pre><code>&gt;&gt; b: to block! "--{1}--"
== ["1"]  ; legal?
</code></pre>
<p>So there are some pain points, but chipping away at them.</p> ]]></description>
        <link>https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325#post_1</link>
        <pubDate>Fri, 08 Nov 2024 17:57:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7876</guid>
      </item>
      <item>
        <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I've been suffering through an attempt to bring sanity to bear upon the MAKE and TO matrix.</p>
<p>While doing so, I noticed that there are a lot of MAKE instructions that do "joining".</p>
<p>In R3-Alpha and Red:</p>
<pre><code>&gt;&gt; make binary! [1 2 #{DECAFBAD} 3 4]   
== #{0102DECAFBAD0304}
</code></pre>
<p>Historical MAKE is so arbitrary in how it interprets its arguments that it made me feel that it would be better if JOIN allowed a datatype as its first argument...</p>
<p>JOIN typically makes a new series out of what you give it:</p>
<pre><code>&gt;&gt; bin: #{AABB}

&gt;&gt; join bin #{CCDD}
== #{AABBCCDD}  ; made new series, didn't impact BIN

&gt;&gt; bin
== #{AABB}
</code></pre>
<p>But if you could pass a datatype as the first argument, you could relieve MAKE of the behavior...and make it clearer in the source what's actually happening:</p>
<pre><code>&gt;&gt; join binary! [1 2 #{DECAFBAD} 3 4]
== #{0102DECAFBAD0304}
</code></pre>
<p>Since that seemed nice, I started to map it out, and ran into a bit of a problem:</p>
<p><strong>If "datatypes" are an ANY-WORD! or ANY-LIST! or anything like that, how do you know you're not trying to JOIN with it?</strong></p>
<p>A WORD! should be able to join:</p>
<pre><code>&gt;&gt; join 'var 10
== var10
</code></pre>
<p>A BLOCK! should be able to join...</p>
<pre><code>&gt;&gt; join [a b] 10
== [a b 10]
</code></pre>
<p>Okay, but when you say <strong>join binary!</strong> what is BINARY!?  Well right now, it's:</p>
<pre><code>&gt;&gt; binary!
== &amp;[binary]
</code></pre>
<p>Well that looks like it's in-band for the kinds of things JOIN operates on:</p>
<pre><code>&gt;&gt; join &amp;[binary] 10
== &amp;[binary 10]
</code></pre>
<h2><a name="p-7875-an-antiform-would-push-datatype-out-of-band-1" class="anchor" href="https://forum.rebol.info#p-7875-an-antiform-would-push-datatype-out-of-band-1"></a>An Antiform Would Push DATATYPE? Out-Of-Band...</h2>
<p>It's possible that we could come up with a new non-antiform for types.  But the lexical space is extremely saturated.</p>
<p>If we were just reaching for something on the basis of looks, antiform FENCE! is nice:</p>
<pre><code>&gt;&gt; binary!
== ~{binary}~  ; anti
</code></pre>
<h2><a name="p-7875-this-has-come-up-before-2" class="anchor" href="https://forum.rebol.info#p-7875-this-has-come-up-before-2"></a>This Has Come Up Before...</h2>
<p>Historical Rebol let you use datatypes in FIND:</p>
<pre><code>rebol2&gt;&gt; find [a b c 10 20] integer! 
== [10 20]
</code></pre>
<p>But then this conflates with when you actually literally have the INTEGER! datatype in the block.</p>
<pre><code>&gt;&gt; find compose [a (integer!) b c 10 20] integer!
== [integer! b c 10 20]
</code></pre>
<p>So in the early days of antiforms, I proposed antiform datatypes as a solution... but at that time I was thinking that there'd be non-antiform DATATYPE!, and it's just that when it was an antiform it would be a "MATCHER".</p>
<p>The proposal I'm thinking of now is different, in saying that DATATYPE? only exists as a (stable) antiform state.</p>
<p>There are tradeoffs, in that datatypes can't be put in blocks directly.  But the mechanics of working with quasiforms and antiforms via things like REIFY and DEGRADE are much smoother now.  And really, putting datatypes in blocks doesn't happen that often (I've had to put splices in blocks but really never datatypes).</p>
<p>Being completely out of band with things you can find in a block has advantages.  JOIN isn't unique in reaping benefits from being able to say that datatypes aren't things.</p>
<p>And it unifies datatypes with typecheckers being antiforms, because typecheckers are frame antiforms, e.g. actions:</p>
<pre><code>&gt;&gt; find [1 3 5 8 10] even?/
; first in pack of length 2
== [8 10]
</code></pre>
<p>So I don't think it's a crazy idea.</p>
<p>I'm hesitant to surrender FENCE! antiforms to the purpose so soon after their invention.  But there isn't anything undecorated left.</p>
<p>Not that "no decorated antiforms" is some unbreakable rule, it was a guideline.</p>
<p>Using &amp; would put it in the family of TYPE-XXX! and be cheaper than FENCE! if you made new instances:</p>
<pre><code>&gt;&gt; binary!
== ~&amp;binary~  ; anti
</code></pre>
<p>A random bad idea would be to make them keywords, and just have DATATYPE? be smart enough to filter out ~null~ or ~void~ or ~okay~ or whatever else (the symbol could carry a flag)</p>
<pre><code>&gt;&gt; binary!
== ~binary~  ; anti

&gt;&gt; null
== ~null~  ; anti

&gt;&gt; datatype? binary!
== ~okay~  ; anti

&gt;&gt; datatype? null
== ~null~  ; anti
</code></pre>
<p>I can pretty clearly say that's bad.</p>
<h2><a name="p-7875-or-pick-some-non-antiform-notation-3" class="anchor" href="https://forum.rebol.info#p-7875-or-pick-some-non-antiform-notation-3"></a>Or, Pick Some Non-Antiform Notation</h2>
<p>Status quo might look like:</p>
<pre><code>&gt;&gt; binary!
== #[binary]
</code></pre>
<p>Despite it looking sort of like a block, it wouldn't be.  But we're squandering some of our notational space no matter what.  The <strong><code>~&amp;type~</code></strong> is the discount route.</p>
<h2><a name="p-7875-either-way-datatype-cant-be-any-word-or-any-list-4" class="anchor" href="https://forum.rebol.info#p-7875-either-way-datatype-cant-be-any-word-or-any-list-4"></a>Either Way, DATATYPE? Can't be ANY-WORD! or ANY-LIST!</h2>
<p>It needs to be out of band one way or another.  I'll have to think about it.</p> ]]></description>
        <link>https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324#post_1</link>
        <pubDate>Fri, 08 Nov 2024 17:05:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7875</guid>
      </item>
  </channel>
</rss>

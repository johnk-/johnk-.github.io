<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>What Should BLANK! in UPARSE Do?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>It's always good to look at history first.  So let's compare and contrast #[none] vs. empty block in old Redbols.</p>
<p><strong>In Rebol2 and R3-Alpha, both are no-ops.</strong>  The input type doesn't matter.</p>
<pre><code>r2/r3&gt;&gt; parse {ab} [[] "a" [] "b" []]
== true

r2/r3&gt;&gt; parse {ab} [#[none] "a" #[none] "b" #[none]]
== true

r2/r3&gt;&gt; parse [a b] [[] 'a [] 'b []]
== true

r2/r3&gt;&gt; parse [a b] [#[none] 'a #[none] 'b #[none]]
== true
</code></pre>
<p><strong>In Red, #[none]s are expected to be literal.</strong>  However, you don't get an error on string inputs...just a failure.</p>
<pre><code>red&gt;&gt; parse {ab} [[] "a" [] "b" []]
== true

red&gt;&gt; parse {ab} [#[none] "a" #[none] "b" #[none]]
== false

red&gt;&gt; parse [a b] [[] 'a [] 'b []]
== true

red&gt;&gt; parse [a b] [#[none] 'a #[none] 'b #[none]]
== false

red&gt;&gt; parse [#[none] a #[none] b #[none]] [#[none] 'a #[none] 'b #[none]]
== true
</code></pre>
<h2>I Think No-Op Is the Superior Choice for BLANK! (NONE!)</h2>
<p>Ren-C's philosophy surrounding blank as "reified nothing" is that it is there to signal opting-out.</p>
<p>It's raison d'etre is being falsey, and easy to test for its nothing-ish state...easily convertible to and from NULL.  (NULL rules are errors, as they should be).</p>
<p>The idea of being able to look for literal values is being explored other ways, the @ was one proposal (though this is going back and forth).</p>
<pre><code>  &gt;&gt; var: _

  &gt;&gt; uparse [_ _ _] [some @var]
  == #[true]
</code></pre>
<p>But a blank rule is more effectively a no-op, IMO.</p>
<p>(For a time it had been considered that it could be a way of matching ANY-VALUE!, but that is now done more clearly with the <strong><code>&lt;any&gt;</code></strong> tag combinator, which is working out splendidly.)</p>
<h2>What Should a BLANK! Rule's Synthesized Product Be?</h2>
<p>When it comes to empty blocks, I'm pretty solidly sold that the answer is a ~none~ isotope:</p>
<pre><code>&gt;&gt; rule: []

&gt;&gt; did uparse {ab} ["a" x: rule "b"]
== #[true]

&gt;&gt; x
** Script Error: x is ~none~ isotope
</code></pre>
<p>There's a deeply interlocked set of justifications for that, which (I hope) aren't going to need rethinking.</p>
<p>But with BLANK! rules it's not so obvious:</p>
<pre><code>&gt;&gt; rule: _

&gt;&gt; did uparse {ab} ["a" x: rule "b"]
== #[true]

&gt;&gt; x
== ???
</code></pre>
<p>I'm skeptical of vaporization, e.g. <strong><code>(x = "b")</code></strong>  It seems that would be useful only in the most rare of situations, and 99% of the time it would surprise the caller.</p>
<p>The philosophy of "blank in, null out" suggests NULL.  That seems useful.  (Implementation of this would actually return a <em>null isotope</em>, such that the rule could still look successful while handing back that result!)</p>
<p>I think that gives a pretty interesting shape to things.  Because this is new, I'll have to look for applications of it...but I'm pretty sure they will show up.  If I see any, I'll make a note of them here.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821/1</link>
        <pubDate>Sun, 15 May 2022 22:35:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5844</guid>
      </item>
      <item>
        <title>Introducing UPARSE: The Hackable Usermode PARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>2 posts were split to a new topic: <a href="/t/what-were-apropos-and-parsing-at-about/1820">What Were APROPOS and PARSING-AT About?</a></p> ]]></description>
        <link>https://forum.rebol.info/t/introducing-uparse-the-hackable-usermode-parse/1529/8</link>
        <pubDate>Sun, 15 May 2022 19:50:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5843</guid>
      </item>
      <item>
        <title>Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1799">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>So What To Do About MATCH and its bretheren?</strong></p>
<p>Seems the options are:</p>
<ol>
<li>
<em>Don't worry about it.</em> If you write <strong>match [logic!] 1 = 2</strong> you get back <strong>#[false]</strong> and should you write an expression like <strong>if (match [logic!] 1 = 2) [print "Match!]</strong> you get what you deserve.</li>
<li>
<em>Use a different isotope.</em> Let's say that <strong><code>match [&lt;opt&gt;] null</code></strong> is simply <strong>~matched~ (isotope)</strong>. It wouldn't have the decaying property, but would have the invalidness property.</li>
<li>
<em>Have a MATCH/FALSEY variant.</em> Let plain <strong>match</strong> on a falsey thing trigger an error and if you write <strong>if match/falsey ...</strong> then you clearly do know what you're doing so it becomes like case (1).</li>
<li>
<em>Make all conditional arguments take ^META arguments for their conditions.</em> This would put the responsibility for checking for isotopes on them, and they'd uniquely disallow them before UNMETA'ing them and then testing for truth/falsehood.</li>
</ol>
</blockquote>
</aside>
<p>Or as we learned from many a multiple choice test, the correct answer is: <strong>None of the above.</strong></p>
<h2>Option 5. <a href="https://forum.rebol.info/t/dropping-find-while-if-unless-select-etc/498/2">Adjust <code>(DID ...)</code> as isotope-tolerant <code>(NOT NULL? ...)</code></a>
</h2>
<p>If you find yourself in a situation where isotopes are giving you a problem, switch to <strong>did match</strong> (or decay match, if you're trying to get the value and not test it as a condition)</p>
<p><em>I wouldn't reach for this by default.</em>  You're fine most of the time... if your MATCH doesn't contain <code>[&lt;opt&gt; logic! blank!]</code>.  It's only these quirky edge cases where it's better to let the isotopes give you a localized and clear error than wind up on a wild goose chase for why the program is acting strangely.</p>
<p>Beginners might be cautious and write things like <strong>did match</strong> or <strong>did parse</strong> all over the place, if they're scared of missing a case.  But there's no need to write <strong>if did match integer! value</strong>, because you're testing for a value that can't possibly be false...it's an integer! or null.  Experts would use it sparingly, in cases like <strong>if match typeset value</strong>, in case the typeset gets expanded into things including falsey values, when you're not fully cognizant of that happening.</p>
<p>This broadens the service of DID across the board, to do what it was originally intended to do: transform functions that return non-LOGIC! values and NULL as soft failure to give logic results.  It can handle historical edge cases with an elegant touch, without burdening code that knows itself well enough to not hit those cases.  I'm quite pleased with it!  <img src="https://forum.rebol.info/images/emoji/twitter/man_dancing.png?v=9" title=":man_dancing:" class="emoji" alt=":man_dancing:"></p>
<h2>This Means Auto-Decay Will Be Limited (sorry, Chris)</h2>
<p>There's still some room for compromise.  But the compromise won't be that ~null~ isotopes are interchangeable with NULL to plain function parameters.</p>
<p>Decaying variables seems acceptable, and hopefully it's learnable that DID is testing something transient...and does not obey substitution rules:</p>
<pre><code>if did x: (match [&lt;opt&gt; integer!] null) [
    print "This will print (the ~null~ isotope denotes non-soft-failure)"
]

if did :x [
    print "This won't print, because X decayed to NULL in assignment"
]
</code></pre>
<p>I think that's learnable, if people can realize that DID is supposed to be paired with an evaluation and not a variable fetch.  (*"did x what?  did x be a variable?")</p> ]]></description>
        <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799/3</link>
        <pubDate>Sun, 15 May 2022 08:44:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5842</guid>
      </item>
      <item>
        <title>Name for prefix forms of ELSE and THEN... EITHER-TEST-XXX?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="216">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Combining with IF feels like a satisfying enough answer for prefix then and prefix else</strong>.</p>
<pre><code>(expression) then [code] =&gt; if then? (expression) [code]
(expression) else [code] =&gt; if else? (expression) [code]
</code></pre>
</blockquote>
</aside>
<p>New plan: <strong><a href="https://forum.rebol.info/t/dropping-find-while-if-unless-select-etc/498/2">These are the true meanings of DID and DIDN'T</a></strong></p>
<pre><code>(expression) then [code] =&gt; if did (expression) [code]
(expression) else [code] =&gt; if didn't (expression) [code]
</code></pre>
<p>The old meaning of DID was very rarely what was actually intended...but if you really wanted to convert something (non-isotopic) to its logical equivalent then use TO-LOGIC as the complement to NOT.</p> ]]></description>
        <link>https://forum.rebol.info/t/name-for-prefix-forms-of-else-and-then-either-test-xxx/216/7</link>
        <pubDate>Sun, 15 May 2022 04:01:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5841</guid>
      </item>
      <item>
        <title>Dropping find?, while?, if?, unless? select?, etc</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="498">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>For the cases where you actually do need a LOGIC!, besides TO-LOGIC we now have a sort of interesting word <a href="https://forum.rebol.info/t/the-misleading-names-of-true-and-false/191/8">in the form of DID</a>, as the positive analogue to NOT. Maybe it isn't perfect for all cases, but <strong>did select ...</strong> or <strong>did find ...</strong> or even <strong>did any [...]</strong> are all superior to SELECT?, FIND?, ANY?.</p>
</blockquote>
</aside>
<p>Four years ago, I introduced DID as a way to avoid having a bunch of logic-bearing variants of functions.</p>
<p>The functions in question you would use DID with typically would not return falsey values...although SELECT would be an exception here:</p>
<pre><code>&gt;&gt; select [a #[true] b #[false]] 'b
== #[false]

&gt;&gt; did select [a #[true] b #[false]] 'b
== #[false]  ; but... but it did select!
</code></pre>
<p>What this suggests is that DID shouldn't really be an opposite to NOT, but a synonym for NOT NULL?</p>
<p><strong>A further iteration of this problem has arisen...again leading to question marks...</strong></p>
<p>With UPARSE growing up, it introduces the notion that you can actually return <em>any</em> result on a successful parse.  This includes things like false, blank, and even null.</p>
<p>But if it returns something falsey, it returns the isotope form...to avoid the habit of people writing things like:</p>
<pre><code>if uparse [#[true] #[false]] [some logic!] [  ; #[false] is final rule result
    print "This code errors, IF won't test a ~false~ isotope"
]
</code></pre>
<p>If you use THEN or ELSE, then all is fine...because they are isotope-tolerant and only react to true null.</p>
<pre><code>uparse [#[true] #[false]] [some logic!] then [
    print "The successful return result here would be #[false]"
]
</code></pre>
<p>But not everyone likes writing code this way.  Hence I fell back on the idea of a UPARSE? variant.</p>
<p><strong>But what if DID was the isotopic tolerant form of NOT NULL?, and DIDN'T was the isotopic tolerant form of NULL?</strong></p>
<p>This sounds like a big win to me.  Now we can get rid of the prefix forms THEN? and ELSE? with much clearer answers.</p>
<p><strong>As an interim measure, I'm making DID error if it gets a logic or a blank.</strong>  This will help catch cases where DID was actually being used as a synonym for TO-LOGIC.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/sunglasses.png?v=9" title=":sunglasses:" class="emoji only-emoji" alt=":sunglasses:"></p> ]]></description>
        <link>https://forum.rebol.info/t/dropping-find-while-if-unless-select-etc/498/2</link>
        <pubDate>Sun, 15 May 2022 03:56:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5840</guid>
      </item>
      <item>
        <title>Name for rule to count how many times a PARSE rule matches?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1581">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>There are cases where you want to know how many of a certain match there are.<br>
...<br>
For now, it's checked in as TALLY for UPARSE</p>
</blockquote>
</aside>
<p>So oddly enough, TALLY without paying attention to the result can be used as the replacement for historical instances of ANY or WHILE.</p>
<pre><code>&gt;&gt; uparse "aaaccc" [some "a" tally "b" tally "c"]
== 3

&gt;&gt; uparse "aaaccc" [some "a" tally "b" some "c" tally "d"]
== 0
</code></pre>
<p><em>"Count the number of times this matches"</em> along with ignoring the count is pretty lightweight, and perhaps some would consider it idiomatic for <strong>opt some</strong></p>
<pre><code>opt some
tally    ; three fewer characters, same as WHILE
</code></pre>
<p>I don't care for the tradeoff myself...but...it's worth pointing out that many result-bearing constructs have their results ignored.</p>
<p>But I certainly would prefer seeing people embracing this idiom to having a single-arity WHILE in PARSE!</p> ]]></description>
        <link>https://forum.rebol.info/t/name-for-rule-to-count-how-many-times-a-parse-rule-matches/1581/2</link>
        <pubDate>Sun, 15 May 2022 00:24:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5839</guid>
      </item>
      <item>
        <title>WHILE [Cold Feet]</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1772">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I want to emphasize that there's a lot of thinking points you see from this.</p>
</blockquote>
</aside>
<p>Waitaminute.</p>
<h2>What if PARSE has WHILE <em>and it's arity-2</em>?</h2>
<p>So these two things would be synonyms:</p>
<pre><code> while rule1 rule2   &lt;=&gt;  opt some [rule1 rule2]
</code></pre>
<p>I'm sure I've had the idea before (?) but I don't remember writing up why you would actually want that.  It's actually quite neat.</p>
<p><strong>It would make it cleaner to pair up code in a GROUP! with a rule:</strong></p>
<p>GROUP! rules always run their side effect and succeed.  So:</p>
<pre><code>opt some [rule (code to run on each match)]
</code></pre>
<p>Could instead be written as:</p>
<pre><code>while rule (code to run on each match)
</code></pre>
<p>I would use this frequently!</p>
<p><strong>It helps pscyhologically divide a process into two parts: trigger and response</strong></p>
<p>You can of course write things as:</p>
<pre><code>opt some [
     thing1 thing2 [
        thing3 thing4
     |  thing5 thing6
     ]
]
</code></pre>
<p>Or:</p>
<pre><code>opt some [thing1 thing2 [
    thing3 thing4
        |
   thing5 thing6
]]
</code></pre>
<p>But I think the WHILE structuring into a control half and response half helps you see this better:</p>
<pre><code>while [thing1 thing2] [
    thing3 thing4
        |
    thing5 thing6
]
</code></pre>
<h2>This Pushes My Vote Over The Edge <img src="https://forum.rebol.info/images/emoji/twitter/ballot_box_with_check.png?v=9" title=":ballot_box_with_check:" class="emoji" alt=":ballot_box_with_check:">
</h2>
<p><strong>The existing WHILE will be deprecated in PARSE, and the non-PARSE construct LOOP will be changed back to WHILE when that deprecation has propagated.</strong>  (Sorry for the churn, but this is how improvements are made!)</p>
<p>Because OPT SOME is a full synonym in PARSE3, I'm going to remove WHILE from PARSE3 now...just to help along with the transition to UPARSE...</p>
<p>When all the WHILEs are likely gone, I'll add the new instruction to UPARSE.  Perhaps it will exist as UWHILE just so it can be tried out.</p>
<p>We can keep looking for a good single word that matches the intent of <strong>opt some</strong>.  But this thread lays out my reasoning for why we don't have a word that means "zero or more".  "optionally some" is a pretty good capture of the intent, and there are better ways to focus energy than on micro-optimizing it.</p>
<p><em>(Certainly people who are interested in character micro-optimization will think the entirety of parse is too verbose...)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/while-cold-feet/1772/6</link>
        <pubDate>Sat, 14 May 2022 23:34:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5838</guid>
      </item>
      <item>
        <title>The Rebellion Against Style Guides</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>While driving from Huntsville to Florida, I listened to a talk given by a guy who oversees the general style guide for all of Google's multi-millions of lines of C++.</p>
<p>He spoke very positively about a formatting tool called <code>clang-format</code>, and how if he had his way at Google...there would be no arguing over code formatting.  He felt the robot did a better job on average than even the best developers...and being willing to delegate formatting to the tool gave them time to work on more important things.</p>
<p><strong>My well-known opinion for code like C++ or Rust or Java is that it is best represented as a graph data structure that captures the relationships and identities.</strong>  How you render that is up to the program you use to view and edit the projection of that essential code.  It doesn't matter if code is in braces or has a box drawn around it.  You could make expressions feed into an actual logical circuit AND gate instead of using <code>&amp;&amp;</code> or the word <code>and</code> or what-have-you.</p>
<p><strong>But Rebol is different (and almost absurdist) in the software world.</strong>  If anything, it has an <em>anti</em>-style guide, in <a href="http://www.rebol.com/article/0103.html">The Deep Lake / (Swamp)</a>, where Carl says:</p>
<blockquote>
<p>Suppose I write:</p>
<pre><code>if time &gt; 10:00 [
    wakeup user
]
</code></pre>
<p>which some users may choose to rewrite it this way:</p>
<pre><code>if time &gt; 10:00
[
    wakeup user
    alert "Time to work"
 ]
</code></pre>
<p>But, what if the "then block" is a variable itself, defined as:</p>
<pre><code> action: [
     wakeup user
     alert "Time to work"
  ]
</code></pre>
<p>Would you write this:</p>
<pre><code>  if time &gt; 10:00
      action
</code></pre>
<p>or this:</p>
<pre><code>   if time &gt; 10:00 action
</code></pre>
</blockquote>
<p>The conclusion is:</p>
<blockquote>
<p>...<strong>how you write code is ultimately your choice alone</strong>. REBOL, as a context dependent language, is perhaps the most freeform computing language ever invented.</p>
</blockquote>
<p>I'm bringing this up because I'm mothballing an old Trello and looking for any links or information worth preserving.  It had a card requesting a style guide, pointing out a limited bit that had been written in the Rebol2 manual:</p>
<p><a href="http://www.rebol.com/docs/core23/rebolcore-5.html#section-5">http://www.rebol.com/docs/core23/rebolcore-5.html#section-5</a></p>
<p>I'm really only interested in the bits that reduce complexity (like just-say-no-to-CRLF files, or tabs, etc.)  As for the code itself, this is kind of an ASCII-art medium.</p>
<p>So a good "style guide" for Rebol would be one that showed examples of how to take advantage of the degrees of freedom to be bent to your purposes.  I think a good one was the <strong><a href="https://forum.rebol.info/t/testing-generic-tuple-and-path-structuring/1353">tuple and path test dialect</a></strong>.  But there are certainly more!</p> ]]></description>
        <link>https://forum.rebol.info/t/the-rebellion-against-style-guides/1819/1</link>
        <pubDate>Sat, 14 May 2022 05:39:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5837</guid>
      </item>
      <item>
        <title>`greb` : Grep Using PARSE?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>There was a Trello card with a remark from <a class="mention" href="/u/johnk">@johnk</a> about an idea from Pekr:</p>
<blockquote>
<p>Not sure how this would work, but it is an interesting excercise to think about.  Something that bridges between unix and rebol syntax like:</p>
<pre><code>ls | greb 'some alpha ".reb"'
</code></pre>
<p>(assuming a few more built in rules/charsets)</p>
<p>May need a collect/keep kind of wrapper to retrieve data cleanly.</p>
</blockquote>
<p>This would be a very small subset of what <a class="mention" href="/u/blackattr">@BlackATTR</a>'s QUERY could do...but it seems like it wouldn't hurt if we went ahead and made this program as a test and put it in the <a href="https://github.com/metaeducation/ren-c-stdio">ren-c-stdio</a> repository.</p>
<p>I've already made things like TAC (backwards unix CAT), where the goal is to see how essential and correct we can make things:</p>
<aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/metaeducation/ren-c-stdio/blob/7fc17e5bb36ceeb7f688516ba57db5ad84a923c9/tests/tac.r#L19-L21" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/metaeducation/ren-c-stdio/blob/7fc17e5bb36ceeb7f688516ba57db5ad84a923c9/tests/tac.r#L19-L21" target="_blank" rel="noopener">metaeducation/ren-c-stdio/blob/7fc17e5bb36ceeb7f688516ba57db5ad84a923c9/tests/tac.r#L19-L21</a></h4>
<pre class="onebox"><code class="lang-r"><ol class="start lines" start="19" style="counter-reset: li-counter 18 ;">
<li>write-stdout try delimit/tail newline reverse collect [</li>
<li>    until [not keep line: try read-line]</li>
<li>]</li>
</ol></code></pre>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p><strong>I like the idea of making GREB similarly essential, and part of the samples.</strong>  Worth doing.</p>
<p>(Note that <code>grep</code> was itself originally framed as a one-line <code>awk</code> program.)</p>
<p>I'll also throw in a little ping that it would be nice to have a simple web app that exposed PARSE functionality with some highlighting, like <a href="http://regexpal.com/">http://regexpal.com/</a>.  Seems sometimes we get such big ideas in our head we forget to do the small ones (!)</p> ]]></description>
        <link>https://forum.rebol.info/t/greb-grep-using-parse/1818/1</link>
        <pubDate>Sat, 14 May 2022 05:09:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5836</guid>
      </item>
      <item>
        <title>Mustache Templates vs RSP</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>On an old Trello I found a link to this renderer for "Mustache":</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="16" height="16">
      <a href="https://github.com/kronwiz/r3-mustache" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://opengraph.githubassets.com/1e73d9d2c54389cdd35bded29734b54c3d25b8293c427a9df0cc11db00084d73/kronwiz/r3-mustache" class="thumbnail onebox-full-image" width="60" height="60">

<h3><a href="https://github.com/kronwiz/r3-mustache" target="_blank" rel="noopener">GitHub - kronwiz/r3-mustache: Mustache templates renderer for Rebol 3</a></h3>


  <p><span class="label1">Mustache templates renderer for Rebol 3. Contribute to kronwiz/r3-mustache development by creating an account on GitHub.</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>It may or may not be interesting.  <a class="mention" href="/u/rgchris">@rgchris</a> said:</p>
<blockquote>
<p>"I'd suggest looking at my <a href="http://reb4.me/r3/rsp">RSP engine</a> for handling string templates, local values, sanitization. LOAD-RSP loads a template and returns a function. That function can be applied to a block of local words and returns a completed string. The template need only be loaded once."*</p>
</blockquote> ]]></description>
        <link>https://forum.rebol.info/t/mustache-templates-vs-rsp/1817/1</link>
        <pubDate>Sat, 14 May 2022 04:56:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5835</guid>
      </item>
      <item>
        <title>(U)PARSE + CALL: Controlling Of Interactive CLI Apps</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A long time ago (e.g. college), I used something in Tcl called EXPECT...which was a great way of driving interactive console applications.</p>
<p>You'd specify the patterns you wanted to wait on (that came from the app's stdout), and script the responses to be fed to stdin, in an interactive fashion.</p>
<p>Today people think a lot more about exposing functionality through APIs (with whatever Java or XML and such).  So it's more rare that you have to resort to writing "stdio robots".</p>
<p>But it's a pretty easy-to-absorb test case, and could be a real showcase for UPARSE...as well as a good challenge for a renewed PORT! model.</p>
<p>I found this code from <a class="mention" href="/u/brett">@Brett</a> on Trello, where the need for an R3 version of CALL was being articulated.  It gives some EXPECT-like functionality:</p>
<aside class="onebox githubblob">
  <header class="source">
      <a href="https://github.com/codebybrett/r3-scripts/blob/master/call-server.r" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <h4><a href="https://github.com/codebybrett/r3-scripts/blob/master/call-server.r" target="_blank" rel="noopener">codebybrett/r3-scripts/blob/master/call-server.r</a></h4>
<pre><code class="lang-r">REBOL [
	Title: "call-server"
	File: %call-server.r
	Author: "Brett Handley"
	Date: 22-Jun-2013
	Purpose: "Provides a way to capture output from console program and send input to interactive console programs."
	License: {

		Copyright 2013 Brett Handley

		Licensed under the Apache License, Version 2.0 (the "License");
		you may not use this file except in compliance with the License.
		You may obtain a copy of the License at

			http://www.apache.org/licenses/LICENSE-2.0

		Unless required by applicable law or agreed to in writing, software
		distributed under the License is distributed on an "AS IS" BASIS,
		WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
		See the License for the specific language governing permissions and
</code></pre>

  This file has been truncated. <a href="https://github.com/codebybrett/r3-scripts/blob/master/call-server.r" target="_blank" rel="noopener">show original</a>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>This seems like a good domain to build some simple-but-impressive demos for... in the "layperson could have built this robot" sense (if we can push it to that point).</p> ]]></description>
        <link>https://forum.rebol.info/t/u-parse-call-controlling-of-interactive-cli-apps/1816/1</link>
        <pubDate>Sat, 14 May 2022 04:52:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5834</guid>
      </item>
      <item>
        <title>Beginnings of the &quot;Redbol&quot; Module</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>As an interesting note... I found that when I first pitched Redbol it had the funny name of <strong>R3/Backward</strong>:</p>
<blockquote>
<p>R2/Forward is a project created by <span class="mention">@BrianH</span> which helps the R2 interpreter run R3 codebases.  It works by patching up a few inconsistencies and adding missing features.  It ships now in the downloadable R2 executables and is executed by default.</p>
<p>R3/Backward is an analogue which would be run to help R2 code run in an R3 interpreter.  The main intention is to serve as a stopgap measure for those trying to run R2 modules under R3 when no R3 equivalent is ready for that functionality...as well as to serve as documentation of the changes that will need to be made if a porting process is being done.</p>
</blockquote> ]]></description>
        <link>https://forum.rebol.info/t/beginnings-of-the-redbol-module/755/2</link>
        <pubDate>Sat, 14 May 2022 04:41:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5833</guid>
      </item>
      <item>
        <title>Hex-Valued Integer Literals: Likely Not In Ren-C</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>On an old Trello there was a card about standardizing the differences between R3-Alpha and Red...and a checklist with only one item:</p>
<blockquote>
<p>Hex-valued literal notation (Rebol has none, Red used to use FFh, FFFFh, FFFFFFFFh), now using 0#FF</p>
</blockquote>
<p>The motivation was for purposes of Red/System, mostly.</p>
<p>In Ren-C this doesn't seem like a priority.  It has ISSUE! (TOKEN!) as a read-only data type that fits in a cell.  Hence a systems-oriented dialect already has an efficient way to represent these values.</p>
<p>For instance: it's not a big deal if your assembler says <strong>[mov ax, <span class="hashtag">#FE</span>]</strong> in its source... if it's generating machine code.</p>
<p>Of course, an ISSUE! in it isn't the same from a metaprogramming sense as a slot with an INTEGER! in it.  So you don't get the automatic advantage of <em>every</em> dialect that has INTEGER! support for a given slot working with a hex notation.  But isn't that what COMPOSE is for...?</p>
<pre><code>my-dialect [something-or-another 255]

my-dialect compose [whatever (debin [BE +] #FF)]
</code></pre>
<p><strong>Having more than one representation for the same type is generally bad, anyway.</strong>  Let's look at what Red does here:</p>
<pre><code>red&gt;&gt; FFh
== 255

red&gt;&gt; F0h + 0Fh
== 255
</code></pre>
<p>If it was so important that it had to be encoded in source, why is it thrown away immediately?</p>
<p>It's something about Red worth knowing exists, but off the radar for implementing, methinks.</p> ]]></description>
        <link>https://forum.rebol.info/t/hex-valued-integer-literals-likely-not-in-ren-c/1815/1</link>
        <pubDate>Sat, 14 May 2022 04:35:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5832</guid>
      </item>
      <item>
        <title>Old Idea from DocKimbel For Rebol2 =&gt; Rebol3/Red</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>This is something I just ran across from a long time ago, which I thought would be interesting to look at with modern eyes.</p>
<p>It's a Gist: <a href="https://gist.github.com/dockimbel/5083375">https://gist.github.com/dockimbel/5083375</a> of a proposal of actually making a DO variant that would rewrite the source of a script.</p>
<p>He is quoted as having said: <em>"A JIT-migration tool would be more accurate. It would run just after LOAD and before DO to rewrite part of the R2 sources in a R3 compatible format."</em></p>
<p>Static analysis of Turing-Complete programs is notoriously on the difficult-if-not-impossible scale, even for simple languages.  So JIT-rewriting even something like PARSE rules is only going to be feasible if those rules were not built by code.</p>
<p>His example just looks for one source pattern (negative literal indexing, so like translating between <strong><code>data/0</code></strong> and <strong><code>data/-1</code></strong>).  But determining what is "code" and what is "data" is deliberately more complex in Rebol than other language.</p>
<p>In Ren-C we have code like <code>enbin [BE +/- 32]</code> and that path is never meant to execute, it's just there to convey the notion of wanting to encode a signed number.  Going around and randomly turning all paths with 0 in them to be -1 misses the whole point of "relative expressions"; you don't know what they're relative to.</p>
<p>So the ironic point of preserving this is just to say "nothing to see, here".  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">  <code>%redbol.reb</code> is a saner track.  But I do think it's going to wind up requiring DO itself being different... a DO2 (like UPARSE2).  It won't rewriting the code block given, but hook the evaluator with different rules.</p>
<pre><code>REBOL [
    Author:  "Nenad Rakocevic"
    Date:      04/03/2013
    Purpose: {
        Show how to achieve R2 source rewriting suitable for evaluation
        using R3 interpreter.
    }
        Note: "Use it from %Red/ folder"
]

context [
    do*: s: none
    
    path-rewrite: [
        some [
            s: integer! (if negative? s/1 [s/1: s/1 + 1])
            ;| handle other indexed-access cases here
            | skip
        ]
    ]

    patched-do: func [value /arg /local saved rule mark path file][
        unless file? :value [return do* value]

        saved: system/script/path
        set [path file] split-path :value
        change-dir path
        value: load file

        parse value rule: [
            any [
                mark: [path! | set-path! | lit-path!] :mark into path-rewrite
                ;; | mark: string! :mark into string-rewrite 
                ;; add more rewritting rules here
                | mark: any-block! :mark into rule
                | skip
            ]
        ]
        also 
            do* value
            system/script/path: saved
    ]
    
    set 'do-r2 func [blk [block!]][
        do*: :do
        set 'do :patched-do
        do blk
        set 'do :do*
    ]
]

do-r2 [
    do %red/compiler.r
]
save %red.new red  ;-- inspect the file to see the changes
halt</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/old-idea-from-dockimbel-for-rebol2-rebol3-red/1814/1</link>
        <pubDate>Sat, 14 May 2022 04:12:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5831</guid>
      </item>
      <item>
        <title>Is GROUP! in PATH! for function invocations worth it?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I wrote a short hack of a compatibility-APPLY for bootstrap, and changed all the GROUP!-in-PATH! cases for refinements to use APPLY.</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/commit/c37440ddf9ae034a14cfbb5ef22cb046145f8f2b">It's just better, in most of these cases.</a></strong></p>
<h2>But...An Argument For Keeping It</h2>
<p>When you think about dialects like UPARSE, they don't have an APPLY operator out of the box.</p>
<p>Being able to leverage the evaluative tool could be helpful, to someone who is running a GET on the PATH! and wanting a function back with the proper specialization.  :-/</p>
<p><strong>I'll let it stick around for now, for that reason.  But let's try to avoid using it, and give APPLY some exercise.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/is-group-in-path-for-function-invocations-worth-it/1813/2</link>
        <pubDate>Fri, 13 May 2022 07:07:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5830</guid>
      </item>
      <item>
        <title>Is GROUP! in PATH! for function invocations worth it?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Back in the day, I thought it would be neat to allow you to put GROUP!s in paths.  So you could do things like this:</p>
<pre><code>append/(if condition ['only]) [a b c] [d e]
</code></pre>
<p>It turned out to be of fairly limited use.  Really you could only use it with refinements that didn't take parameters, because it changes the "shape" of the execution stream.  Consider how you would make the following sensible:</p>
<pre><code>append/(if condition ['dup]) [a b c] [d e] ???
</code></pre>
<p>When the condition is true you want something in the ??? spot.  When it's false you don't.  How can your code cover both cases?</p>
<p><em>We actually have some tools these days</em> that could use opportunistic invisibility to solve this.  But then you're testing the condition twice, and getting involved in some pretty wild mechanics for something trivial.</p>
<p>It also raised a lot of annoying questions about NULL/blank tolerance.  I didn't like NULL being allowed in the generic pathing, but it was ugly to require BLANK! for this task:</p>
<pre><code>append/(try if condition ['only]) [a b c] [d e]

append/(if condition ['only] else [_]) [a b c] [d e]
</code></pre>
<h2><strong><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1406/3">Now we have a modern APPLY</a></strong></h2>
<p>It bends some of the raw frame rules, and lets you use LOGIC! for parameterless refinements:</p>
<pre><code>apply :append [[a b c] [d e] /only condition]
</code></pre>
<p>It's a bit longer.  And we haven't really firmed up questions like whether you need the GET-WORD! or if it's soft quoted by default.  Or if there might be some clever shorthand:</p>
<pre><code>($ append [a b c] [d e] /only condition)
</code></pre>
<h2>I'm In A Mood To Kill Off Lesser-Loved Features <img src="https://forum.rebol.info/images/emoji/twitter/hocho.png?v=9" title=":hocho:" class="emoji" alt=":hocho:">
</h2>
<p>All things being equal, it might seem nice to support.  But every feature has a cost!</p>
<p><strong>You'd still be able to put GROUP!s in paths for your own purposes, but refinement dispatch in functions wouldn't use it.</strong></p>
<p>You could also use DO of COMPOSE'd code if you really wanted to:</p>
<pre><code>do compose/deep [
    append/(if condition ['only]) [a b c] [d e]
]
</code></pre>
<p>So if anyone has a good argument for keeping the function dispatch behavior, speak up now!</p> ]]></description>
        <link>https://forum.rebol.info/t/is-group-in-path-for-function-invocations-worth-it/1813/1</link>
        <pubDate>Fri, 13 May 2022 04:35:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5829</guid>
      </item>
      <item>
        <title>Asymmetric Encryption/Decryption in Ren-C</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The most easily recognized form of encryption is symmetric, where the same password is used to encrypt something as to decrypt it.</p>
<p>But a weirder form is <strong>asymmetric encryption</strong>, <em>where the key used to encrypt is different from the one used to decrypt</em>.</p>
<h2>Ren-C Supports RSA Public/Private Encryption</h2>
<p>You generate your keys in a pair, which come back via multiple return results.  You must specify a size for the public key (in <em>bits</em>, not <em>bytes</em>...<a href="https://crypto.stackexchange.com/questions/58124/">because that's the convention</a>)</p>
<p>We'll start using [raw] RSA encryption:</p>
<pre><code>; use /INSECURE to override errors that tell you the key is too small
; (makes examples more readable)

&gt;&gt; [public-key private-key]: rsa-generate-keypair/padding/insecure 128 [raw]
== make object! [
    padding: [raw]
    n: #{C097238C34E7191561DD7D30BBB77C65}
    e: #{010001}
]

&gt;&gt; length of public-key.n
== 16  ; 16 bytes is 128 bits
</code></pre>
<p>When you use raw mode encryption, the data you encrypt must be <em>exactly the same size</em> as the key you made.  We'll show how to work around this later, but for now let's just deal with it.</p>
<pre><code>&gt;&gt; data: #{0123456789ABCDEFFEDCBA9876543210}

&gt;&gt; length of data
== 16  ; same size as our key

&gt;&gt; encrypted: rsa-encrypt data public-key
== #{3F7E8ACD2DEE61D09B7A6FC914E22295}

&gt;&gt; length of encrypted
== 16  ; also same length as key
</code></pre>
<p>Now, decryption is done with the private key:</p>
<pre><code>&gt;&gt; rsa-decrypt encrypted private-key
== #{0123456789ABCDEFFEDCBA9876543210}
</code></pre>
<h2>But <code>[raw]</code> Makes The Same Message Every Time...</h2>
<p>Raw RSA doesn't waste any space (e.g. 4096 bytes in means 4096 bytes out).  <strong>But a given output always produces the same output with raw RSA</strong>:</p>
<pre><code>&gt;&gt; rsa-encrypt data public-key
== #{3F7E8ACD2DEE61D09B7A6FC914E22295}

&gt;&gt; rsa-encrypt data public-key
== #{3F7E8ACD2DEE61D09B7A6FC914E22295}
</code></pre>
<p>This can make it easy (or at least, easier) for someone who doesn't have the private key to do some factoring with the public key, and see if they can generate input that produces that output...effectively defeating the encryption.</p>
<p>Also since it requires exactly the keysize of data coming in, you're likely going to have a lot of cases where you have to throw in some padding.  But naive answers to padding also create security problems:</p>
<ul>
<li>
<p><strong>It would be bad to pad the data block with zeros (or whatever)</strong>, because such predictable behavior generally makes it easier to guess what the encrypted information might be.</p>
</li>
<li>
<p><strong>It would be bad to just put random data in the padding</strong>, because the person doing the decryption wouldn't know if the gibberish they got when decrypting was the same gibberish you put in.</p>
<ul>
<li>Attackers could leverage this random tolerance to forge data in the non-padded portions, then forging the padding in a way that compensated.</li>
</ul>
</li>
</ul>
<p><strong><a href="https://security.stackexchange.com/a/183330">Real-World problems motivated the tricks that are used to resist attacks.</a></strong>  You can read about them if you want...or just don't use <code>[raw]</code> and you'll get a sensible default.</p>
<pre><code>&gt;&gt; [public-a private-a]: rsa-generate-keypair/insecure 128
== make object! [
    padding: [pkcs1-v15]
    n: #{A9EE9282744CC0FC6765824EB2B87539}
    e: #{010001}
]

&gt;&gt; one: rsa-encrypt #{DECAFBAD} public-a  ; Note: shorter input than key
== #{13C14811A3B1CD95100BA4F3273F0962}

&gt;&gt; two: rsa-encrypt #{DECAFBAD} public-a
== #{3245179A18C6B488FD39CDE7B4F5E3EC}  ; different!

&gt;&gt; rsa-decrypt one private-a
== #{DECAFBAD}

&gt;&gt; rsa-decrypt two private-a
== #{DECAFBAD}
</code></pre>
<h2>That Encrypts Smaller Than The Key...But What About Bigger?</h2>
<p>A fundamental issue with RSA encryption/decryption is it is relatively S-L-O-W.  And if you want to futureproof a key to use with big file sizes, those keys would also be B-I-G!</p>
<p><strong>But you can use a smaller asymmetric key as a stepping stone to providing a symmetric key.</strong></p>
<p>It's easy!  Let's say someone has published their 4096-bit public key and you want to send them a 100 megabyte file that only they will know how to open.  Follow these steps:</p>
<ol>
<li>
<p>Generate a random string that's less than 4096 bits, and encrypt <em>that</em> with their public key</p>
</li>
<li>
<p>Encrypt the file using a faster symmetric algorithm, with that random string as the password</p>
</li>
<li>
<p>Send the recipient both the asymmetrically-encrypted random string and the symmetrically-encrypted 100mb file</p>
</li>
<li>
<p>Your recipient uses their private key to decrypt the one-off password you randomly generated, and decrypts the symmetrically encrypted file with it.</p>
</li>
</ol>
<h2>It's All New, So Help Design the Interface...</h2>
<p>The original motivation to research mbedTLS was so that <a class="mention" href="/u/gchiu">@gchiu</a> didn't have to call out to external utilities to generate RSA keys.</p>
<p>But the generation abilities weren't actually written until now.  And honestly, I'm not sure the RSA stuff was even working at all.  :-/  <strong><a href="https://github.com/metaeducation/ren-c/blob/master/extensions/crypt/tests/rsa.test.reb">Now there's at least a minimal amount of testing.</a></strong></p>
<p>I think the multiple return values are a good start on making it clear, but it's certainly a good time for feedback if anyone has any.</p> ]]></description>
        <link>https://forum.rebol.info/t/asymmetric-encryption-decryption-in-ren-c/1812/1</link>
        <pubDate>Fri, 13 May 2022 01:17:30 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5828</guid>
      </item>
      <item>
        <title>Transitioning from mbedTLS 2 to mbedTLS 3: Promise and Peril</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Historically R3-Alpha had its few pieces of crypto math cobbled together from generally unknown sources on the Internet...</p>
<ul>
<li>
<p>My understanding is that Rebol2's support for talking to a limited set of HTTPS sites was written entirely in C.  It's never been open-sourced, so we don't know much about it--such as whether it was original code or done with some early TLS library of the time.</p>
</li>
<li>
<p>Saphirion chose to split out the code for the Transport-Layer-Security protocol and make it usermode Rebol.  Only the foundational cryptographic primitives like <a href="https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808">Secure Hashes</a> or <a href="https://forum.rebol.info/t/key-exchange-methods-in-ren-c/1809">Key Exchange</a> were written in C.</p>
<ul>
<li>
<p><strong>Many of R3-Alpha's C cryptography bits seemed to come from the (one-man?) effort known as <a href="http://axtls.sourceforge.net/">Axolotl TLS (AxTLS)</a></strong></p>
</li>
<li>
<p>The Rebol parts were written by Cyphre (Richard Smolak)</p>
</li>
</ul>
</li>
</ul>
<h2>I Was Initially Very Skeptical of Continuing Saphirion's Strategy...</h2>
<p>If a change ever rippled into affecting the TLS file, it was a voodoo nightmare to figure out how to fix it.  I didn't understand why limited efforts should be stretched into involvement with "something the language wasn't really good for".</p>
<p><em>My impression was also that the %prot-tls.r implementation was bad.</em>  But when I got to looking at the details, the most insidious problems weren't so much the fault of the protocol code.  It more-or-less followed the spec, in a pretty literate way (that I <a href="https://forum.rebol.info/t/dissecting-the-tls-emit-dialect/1498">improved with some dialecting</a>).</p>
<p>The main frustrations regarding prot-tls came from the fact that <a href="https://forum.rebol.info/t/the-weirdness-of-wait/1703">R3-Alpha's asynchronous port model made no sense</a>.  When I rewrote it to use the "seemingly-synchronous" model (which aims to parallel the Go language), it became more clear.</p>
<p><strong>Through the process of implementing TLS 1.2, I began to get the impression that such protocols may actually be a fitting domain for a language like Rebol.</strong></p>
<p>Today's %prot-tls.r is an aggressive and practical test of dialecting.  If it continues to be enhanced may be a case of exposing the workings of an important protocol to the layperson.</p>
<h2>We Needed More Cryptography, and mbedTLS Fit the Bill</h2>
<p>Adding TLS 1.2 wasn't going to do any good without also providing some of the newer exotic cipher suites that are demanded these days.  That meant getting things like elliptic curve key exchange, or SHA512, or anything else the future may demand.</p>
<p>When I found mbedTLS it was much "cleaner" than OpenSSL, and seemed perfect:</p>
<ul>
<li>
<p>It was targeting embedded processors, with <a href="https://github.com/Mbed-TLS/mbedtls/blob/42650260a9109f53d2058f82e1133205545fd65b/include/mbedtls/mbedtls_config.h">incredibly granular controls</a> for doing things like using smaller/slower algorithms vs. bigger/faster ones.</p>
<ul>
<li>
<p>Pure C code, that could be compiled even by TCC.</p>
</li>
<li>
<p>This meant the conference demo of bootstrap could still work, with a TCC-built R3-WITH-TCC having enough cryptography in it to download its own source from an HTTPS GitHub link.</p>
</li>
</ul>
</li>
<li>
<p>The cryptography primitives could be lifted out "a la carte" from the C-based TLS protocol code; the files seemed completely separate:</p>
<ul>
<li>
<p>If we wanted to, we could have a C-based mbedTLS extension option instead of using %prot-tls.r, and it could reuse the same cryptography.</p>
</li>
<li>
<p>(We may at some point have to resort to this, if keeping %prot-tls.r up to date with the times proves impractical.)</p>
</li>
</ul>
</li>
<li>
<p>The interfaces for every cipher and hash supported streaming, so we'd have the ability to incrementally do cryptography on large files or network connections (assuming we figured out how to expose that).</p>
</li>
</ul>
<p><strong>And critically, all of it was under the umbrella of a working group at ARM which would hopefully ensure that it was kept up to date, and being vetted for problems.</strong></p>
<p>All of it made this seem like a no-brainer to build on, which <a href="https://github.com/metaeducation/ren-c/commit/06e110235efb68500700fead3478a3216899d780">I did in April of 2020</a>:</p>
<blockquote>
<p>The mbedTLS library is an embedded-focused set of cryptography hashes,<br>
key exchanges, block ciphers, and other tools.  Its components range<br>
from lower-level facilities like BigNum arithmetic, to higher-level<br>
services like TLS negotiation and certificate validation.  Its<br>
facilities are well-factored such that each piece can be used with only<br>
its dependencies:</p>
<p><a href="https://tls.mbed.org/">https://tls.mbed.org/</a></p>
<p>Because of its fine-grained control, it's possible to use its basic<br>
tools while still keeping higher-level negotiations as spec-driven<br>
usermode Rebol (e.g. the TLS protocol itself) to facilitate more<br>
hooking and understanding.  And because it offers a consistent set of<br>
vetted and active code, it can replace the "hodgepodge" of cut-and-paste<br>
snippets for cryptography (originating from axTLS, internet sources,<br>
custom code, edited OpenSSL, etc.) where there are problems like not<br>
being written to a common BigNum implementation.</p>
<p>Additionally--due to the factoring, it is hoped that this code could be<br>
used as the basis for implementing BigNum arithmetic in the interpreter<br>
core itself...which would be naturally reused in the implementation<br>
of these C algorithms when cryptographic extensions are loaded.</p>
</blockquote>
<p>Possibly inspired by this--or just his own coming to the same conclusions--<a href="https://github.com/Oldes/Rebol3/commit/77515519655a579fbef99f7e185a27a4451718d7">Oldes changed his hashes to use mbedTLS in January 2021</a></p>
<h2>...and Then, Version 3.0 Came... <img src="https://forum.rebol.info/images/emoji/twitter/dragon.png?v=9" title=":dragon:" class="emoji" alt=":dragon:">
</h2>
<p><em>I probably should have been paying more attention to what mbedTLS was planning in their future branches.</em></p>
<p>What I've gathered is that ARM (or someone) was pointing out that mbedTLS not only needed to implement TLS 1.3, but that it wasn't sufficiently fast vs. the competition.</p>
<p>A somewhat-sensible approach to optimization is to first tighten the control over your data structures, making them more opaque to clients.  By limiting the APIs you can use to access those structures, you can know more about the states they are in...and take more for granted.  Your functions can then make optimizations which leverage these rules--adding or rearranging fields in more clever ways.</p>
<p><strong>But I didn't want cleverness, I just wanted the math.</strong>  I liked that our objects for things like Diffie-Hellman showed you the true cryptographic parameters, and wasn't some kind of "black box".  If we were closed off from that, everything would be a HANDLE! and you would have limited ways of extracting parameters from it.</p>
<p>Not only did they close off access to the structure members, many APIs they offered were TLS-specific!</p>
<ul>
<li>
<p>If a cryptographic primitive depended on parameters X and Y and produced Z, they'd offer a function that takes in a blob of data representing X and Y <em>in the specific format that TLS messages encode them</em>.</p>
</li>
<li>
<p>If you were building some protocol that <em>wasn't</em> TLS using that basic crypto primitive, the only way offered to load the parameters was to make a TLS-format message buffer and pass it.</p>
</li>
<li>
<p>The TLS-specific functions were creeping into what were supposed to be the "a la carte" cryptography files, adding bloat at compile time (if not also runtime) if you weren't using them.</p>
</li>
</ul>
<p>One can imagine that this seems good from the point of view of speeding up their C TLS protocol, but bad for anyone trying to use the underlying cryptography.</p>
<p>There was an announcement I missed that it would be split into two libraries: "mbed crypto" and "mbedTLS", to serve the two different audiences for the code.  But that seemed to be short-lived, and "mbed crypto" was reabsorbed into the mbedTLS codebase.  Not before the damage had been done to the layering and generality.</p>
<p>So now mbedTLS seems to be playing catch-up on serving the audience that wanted the crypto primitives.  But functionality that had an endorsed method to do in mbedTLS 2 now requires hacking beneath the approved API to accomplish.</p>
<h2>On the bright side...</h2>
<p>Since the re-absorption of "mbed crypto", mbedTLS seems amenable to having answers for the a-la-carte crypto crowd.  <a href="https://github.com/Mbed-TLS/mbedtls/issues/5818">A request I made is at least marked medium importance</a>.</p>
<p>Also, the API becoming more formalized is pointing out some weird mistakes that were made before in the code...filling structure parameters that were unused, for instance.  Having to call each of these things into question is a good vetting of the code.</p>
<p>And although I had to use hacks to do it, we now can run https on top of mbedTLS 3.  I've been a little on the fence of whether to stick with mbedTLS 2 (support ending in 2024) or find some other library.  But writing about cryptography has made me realize it's a bit of a red herring on the importance scale, and I think we're better off rolling with the punches of mbedTLS 3 than going it some other route.</p> ]]></description>
        <link>https://forum.rebol.info/t/transitioning-from-mbedtls-2-to-mbedtls-3-promise-and-peril/1810/1</link>
        <pubDate>Tue, 10 May 2022 14:47:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5826</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision </title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1786">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>(Makes me think of the <a href="https://en.wikipedia.org/wiki/Conservation_status">species extinction risk scale</a>. Sure, the source code is on GitHub, and the topic list of this forum seems to be on the Internet Archive...but if you click through to individual pages there's nothing about the post contents. Should we do a scrape of the data here and put it elsewhere?)</p>
</blockquote>
</aside>
<p>I couldn't find something here and so I did a google site search to see if it was better and found...</p>
<p>no hits!</p>
<p><strong><a href="https://www.google.com/search?q=site%3Aforum.rebol.info"><code>Google results for site:forum.rebol.info</code></a></strong></p>
<p>I don't think this is all bad, as the plan is re-launching the content under a new domain "when it's ready".  I'm okay with being under the radar until then.  And hey--it keeps one from worrying too much about keeping old <code>forum.rebol.info</code> links working.</p>
<p><em>--nevertheless--</em> it is a little bit unsettling in the sense that there are plenty of inbound links.  <em>Zero</em> Google indexing is surprising.  I think the quality of content is better than many other places (personally).</p>
<p>Not necessarily a particular action item--not trying to get found yet.  But definitely a call to arms, and praise for <a class="mention" href="/u/johnk">@johnk</a> making the valiant preservation effort!</p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/8</link>
        <pubDate>Mon, 09 May 2022 22:43:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5825</guid>
      </item>
      <item>
        <title>Key Exchange Methods in Ren-C</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Having given a summary of <a href="https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808/">Checksums and Secure Hashes</a>, I thought I'd follow up with a quick description of something you're likely not as familiar with: <strong>Key Exchanges</strong>.</p>
<p>There's old quote I like (but can't find a source for):</p>
<blockquote>
<p>"The shared secret is capital.  We may spend it or squander it."</p>
</blockquote>
<p>An example of taking advantage of a shared secret is when people want to share an encrypted .ZIP file.  If you and your friend both know the encryption password that no one else knows...then you could put the file on a public server for your friend to download.  If you trust the encryption, the fact it was public would not matter.</p>
<p><strong>But what if the situation is that your friend has a password that only they know... and you have a password that only you know?</strong>  That wouldn't seem to help with the .ZIP file scenario, because it expects the same password to decrypt as was used to encrypt it.</p>
<p>Key Exchange is a way of taking your individual "passwords" and coming to an agreement on a third "password" that only the two of you know.  Amazingly enough, you can carry out the conversation where you establish the shared password in public.</p>
<h2>Creating one Shared Secret from two Non-Shared Secrets</h2>
<p>For educational purposes, people use paint-mixing as an analogy for key exchange.  It's really "multiplying big prime numbers" instead of mixing paint, but it's visual and easy to see.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png" data-download-href="https://forum.rebol.info/uploads/default/184fa9035c24ffa1250e324b61acaa3915f7757e" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_345x500.png" alt="image" data-base62-sha1="3t485Do7kYfAw6HMsMv5klePtsq" width="345" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_345x500.png, https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png 1.5x, https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">480695 28 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>This assumes everyone in the world has some kind of weird "common paint".  This paint isn't white (because if you mixed it with something that would be too easy to guess at the precise shade you had mixed it with).  And it isn't black (because mixing might just get you something too dark to measure well).</p>
<p>But the key point to absorb is what the diagram says: <strong>we assume that mixture separation is expensive</strong>.  Once you've mixed the common paint with your secret color, it produces a new shade that no one else knows how to make exactly.</p>
<p>When you and your friend exchange your mixtures you cleverly go to your private lairs and each add your secret color to the other's mixture.  <strong>Now both of you have the same weird color, and this is a secret you share.</strong></p>
<h2>Ren-C Supports Diffie-Hellman Key Exchange</h2>
<p>I oversimplified this by saying you each start with a "password"...because that made it sound like you could just pick a phrase out of your head.  In reality, choosing your secret involves some tricky math...to make sure your secret paint color is a <em>good</em> secret paint color.  You don't pick these--you ask the computer to generate it.</p>
<p>To get the ball rolling, you need to specify what kind of "common paint" to use.  You make that by picking two suitable prime numbers, a modulus and a base.  Then you can ask for a unique random secret to be generated.</p>
<p>For the sake of education, I've made it possible to use <em>relatively bad</em> paint mixes with the /INSECURE refinement.  It won't allow numbers that are so broken the process won't work (for instance: non-primes, or primes that don't meet the basic requirements of the algorithm).  This lets you work with small enough numbers that you can see for yourself what's going on more easily.</p>
<p>So let's use a modulus of 9 and a base of 3:</p>
<pre><code>&gt;&gt; mine: dh-generate-keypair/insecure #{09} #{05}
== make object! [
    modulus: #{09}
    generator: #{05}
    private-key: #{07}
    public-key: #{05}
]

&gt;&gt; theirs: dh-generate-keypair/insecure #{09} #{05}
== make object! [
    modulus: #{09}
    generator: #{05}
    private-key: #{05}
    public-key: #{02}
]
</code></pre>
<p>So privately, my secret is 7... and their secret is 5.  But we want to come to an agreement on a new number while only sharing with the public my "mixture" of 5 and their mixture of 2.</p>
<pre><code>&gt;&gt; my-shared: dh-compute-secret mine theirs.public-key
== #{02}

&gt;&gt; their-shared: dh-compute-secret theirs mine.public-key
== #{02}
</code></pre>
<p>So here you see each of us could come to a common agreement of 2.  You can follow through the math on the <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Wikipedia page</a> if you want...but it's enough to know that it works.</p>
<p>What makes for a good (big!) modulus and base to use?  You don't really need to come up with them yourself, although <a href="https://security.stackexchange.com/a/103924">there are algorithms for it</a>.  There are papers that publish some good choices--and we should probably provide a way to default to well-known ones, like maybe accept either an object or an ISSUE!</p>
<pre><code>&gt;&gt; dh-generate-keypair #RFC-3526
; ...or...
&gt;&gt; dh-generate-keypair make object [base: ..., modulus: ...]
</code></pre>
<p>But the main thing to know is that <strong>both sides have to agree on the "common paint" to use</strong>, in order to come to the same conclusion.  So <code>dh-compute-secret</code> won't work unless the same numbers were used here.</p>
<h2>We Also Support Elliptic Curve Key Exchange (ECHDE)</h2>
<p>Modern Internet Transport Security has moved on from traditional Diffie Hellman to trickier math.  But the premise is the same.</p>
<p>In the interface, we only support two "common paints" for this method: "secp256r1" and "curve25519".  There's no option for small answers here:</p>
<pre><code>&gt;&gt; mine: ecc-generate-keypair 'curve25519
== make object! [
    public-key: make object! [
        x: #{121413C34DC265025F24CBEBBA6065B9
             75F1BFA6E493D07A0F4776FAE03DC245}
        y: #{00000000000000000000000000000000
             00000000000000000000000000000000}
    ]
    private-key: #{610A8D99A72500B3A2E8A1FD714FA412
                   17F0A0EA5EDFC9CFBDAE0425E199DC70}
]

&gt;&gt; theirs: ecc-generate-keypair 'curve25519
== make object! [
    public-key: make object! [
        x: #{10D65366D8C9229591C99903D3B5EB0F
             57709AD27E37989E4782050D2B9B2B93}
        y: #{00000000000000000000000000000000
             00000000000000000000000000000000}
    ]
    private-key: #{7C3262BF6028B049EEDC6C37E37A8261
                   EA4DF31F16E4D534D92A7EF11D974618}
]
</code></pre>
<p>But it works the same way; you come to the same conclusion when combining your partner's public portion with your private portion:</p>
<pre><code>&gt;&gt; my-secret: (
    ecdh-shared-secret 'curve25519 mine.private-key theirs.public-key
)
== #{E27891074A60250580B8F2C7CB2448A9AA491C97161D7C8D381348D90E438025}

&gt;&gt; their-secret: (
    ecdh-shared-secret 'curve25519 mine.private-key theirs.public-key
)
== #{E27891074A60250580B8F2C7CB2448A9AA491C97161D7C8D381348D90E438025}

&gt;&gt; my-secret = their-secret
== #[true]
</code></pre>
<h2>Would Average Users Ever Need Key Exchange Functions?</h2>
<p>Right now, the main reason most people would care whether the language has these key exchanges is because without them you can't do TLS.  So no reading or writing over HTTPS.</p>
<p>You really only need key exchanges when protocols are trying to establish private channels of communication.  So notably, some cryptographic protocols (like Bitcoin) don't need key exchanges...because they're carrying out their work in public.</p>
<ul>
<li>
<p><strong>It would be neat if we could democratize the creation of cryptographic protocols</strong>.  I think giving people easier and more transparent access to these kinds of things could foster some grassroots innovation, where people would build <em>exactly the security they needed</em> into a program's design...no more and no less.</p>
<ul>
<li>This would stand in contrast to today's methods, where "security" is accomplished by standing on top of a mountain of protocols (using a literal zoo of cryptographic algorithms) to tunnel and log in somewhere that they are "safe"...and putting more data than they need to in that place.</li>
</ul>
</li>
<li>
<p><strong>But even "simple" cryptography is tricky to reason about, and people are lazy.</strong>  I myself am pretty guilty of doing things like falling back on my GitHub password and resetting my keys instead of doing a good job of filing them in safe places.</p>
<ul>
<li>Convincing people their programs should be "organic and locally sourced"... by tailor-making the protocols and asking their users to keep track of files, is going to be a hard sell to those who are happy to use OAuth and leave this all up to Google.</li>
</ul>
</li>
</ul>
<p>So pessimistically speaking, I don't know that we're going to be able to market easy-to-use key exchange to anyone as a killer feature.  It's a nice thought, and I certainly like having it available to tinker with.  But I'd be surprised if anyone reading this has an idea how to use it in something they're working on.</p> ]]></description>
        <link>https://forum.rebol.info/t/key-exchange-methods-in-ren-c/1809/1</link>
        <pubDate>Mon, 09 May 2022 18:20:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5824</guid>
      </item>
      <item>
        <title>LOGIN Magazine Historical Covers</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>As good a place as any to put a link to <a href="https://amr.abime.net/issue_274">Amiga Format #118</a>, the first I saw mention of 'Rebol'. I may even have that issue kicking around.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/5d5986d4d49ca5cc5d18a80949398c485c826554.jpeg" data-download-href="https://forum.rebol.info/uploads/default/5d5986d4d49ca5cc5d18a80949398c485c826554" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/5d5986d4d49ca5cc5d18a80949398c485c826554_2_363x500.jpeg" alt="image" data-base62-sha1="djOdjEqK07dQ6176v0vFIMJYXsM" width="363" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/5d5986d4d49ca5cc5d18a80949398c485c826554_2_363x500.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/5d5986d4d49ca5cc5d18a80949398c485c826554_2_544x750.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/5d5986d4d49ca5cc5d18a80949398c485c826554_2_726x1000.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/5d5986d4d49ca5cc5d18a80949398c485c826554_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">8421158 325 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p> ]]></description>
        <link>https://forum.rebol.info/t/login-magazine-historical-covers/1803/2</link>
        <pubDate>Mon, 09 May 2022 17:35:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5823</guid>
      </item>
      <item>
        <title>JS testing with Cypress.io</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Looking at <a href="https://www.lambdatest.com/blog/cypress-test-automation-framework/">how Cypress works</a>, it is essentially a proxy server.</p>
<p>So when you ask for <code>http://hostilefork.com/media/shared/replpad-js</code>, it fires up a browser that is actually directed at <code>http://localhost:8000/cypress/media/shared/replpad-js</code> (or whatever).</p>
<p>What the proxy does is add code related to testing.  So by definition, it doesn't do anything we couldn't do ourselves by adding JavaScript into the page.</p>
<p>This means it can't be used to test any "meta" things--like how the page reacts to opening a new browser tab, or interacting across IFRAMEs.</p>
<p>But presumably (?) their injected JavaScript is tricky and tailored, for transmitting keydowns and keyups in a somewhat "realistic" way to mimic what actually happens in browsers...and it may wind up being faster and simpler to use.</p>
<p>My current technique talks to the Firefox webdriver directly (without using the Selenium layer, that abstracts all the webdrivers for all the browsers).  When I made it I figured it was better than nothing, and it has been so...but it is certainly slower than we'd like.</p>
<p>It's certainly worth a shot to see if this is a better answer that covers the cases we'd be interested in.</p> ]]></description>
        <link>https://forum.rebol.info/t/js-testing-with-cypress-io/1778/2</link>
        <pubDate>Mon, 09 May 2022 14:14:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5822</guid>
      </item>
      <item>
        <title>Checksums and Secure Hashes in Ren-C</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I thought I'd write up a quick post about algorithms that take in a bunch of bytes--like a BINARY!--and produce a (usually) shorter "fingerprint" of that data.</p>
<ul>
<li>
<p>It's not hard to make an <em>insecure</em> hash...like taking the first couple of letters of a string: <code>"DICKENS" =&gt; DI</code>.  That might be useful if you're trying to divide book authors into drawers of an old-fashioned library card catalog.</p>
</li>
<li>
<p>But it's easy to find another string that would make the same "DI" fingerprint, like "DIABOLICAL" or "DIR^/FORMAT C:"</p>
</li>
<li>
<p>If you were using a fingerprint to trust something was what it was supposed to be, the easiness of generating these "collisions" is a liability!! <img src="https://forum.rebol.info/images/emoji/twitter/skull_and_crossbones.png?v=9" title=":skull_and_crossbones:" class="emoji" alt=":skull_and_crossbones:"></p>
</li>
<li>
<p>Secure hashes do complicated "one-way functions" in math to make it <em>really hard</em> on today's computers to fabricate any binary sequence--even garbage--that will give you the same fingerprint as any other input.</p>
</li>
</ul>
<p>You've certainly seen web pages that redirect you off to download a file, but beforehand give you some bytes of what the file should securely hash to.  <sub>(And you've probably never checked to make sure they match.)</sub></p>
<h2>If the Fingerprint is Shorter than the data, <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">COLLISIONS EXIST!</a>
</h2>
<p>You obviously can't give every 500mb file in the universe a unique fingerprint that's 32-bits, 128-bits, 512-bits, 2048-bits etc.</p>
<p>So the concept behind a secure hash is just supposed to be you can't find a collision until we're all dead and no one cares.  Less grimly: we might pair a hash with an expiration date to say not to trust a hash after a very conservative guess at how long it would take for computers to advance enough to break it.</p>
<p>When this hope falls apart (e.g. if any researcher can show two inputs that generate the same fingerprint) it's generally considered that the "secure" part of that hash is broken...for the purposes of whatever time-bubble you're living in.</p>
<h2>We Have Four Secure Hashes in the Box Right Now...</h2>
<p>It shouldn't be surprising that longer fingerprints correlate with being harder to find collisions:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'md5
== #{3717A787E2F16310EA51DC0308E88803}  ; considered vulnerable

&gt;&gt; checksum/method {DICKENS} 'sha1
== #{DFE5DD61B2B19C319DBC4F44328CDF8D24366F88}  ; considered vulnerable

&gt;&gt; checksum/method {DICKENS} 'sha256
== #{52A095CF1F0319EF44FF9134AAD2EF5E2BFE1A48307DCB0AD0408F1CE393C950}

&gt;&gt; checksum/method {DICKENS} 'sha512
== #{
E8DBC26DE28FAA1BC2A6A3E1BC6DD22C1ECB3FD0D5FCBBFB69BC63C6AAC6A9CE
FB76294EFFB0522D4C90A5E5829233FC5BC5B811AE6684A6EA632ECB3FF88DA1
}

&gt;&gt; checksum/method {DICKENS} 'ripemd160         ; bitcoin uses this one
== #{ADC86945BE4CEF31F0CFCAF66775E1DA5160F877}  ; ...no one knows why
</code></pre>
<p>But longer isn't <em>intrinsically</em> better...there might be a weakness to exploit in the method used by a longer hash which isn't present in shorter ones.  However, a bunch of mathematicians look at this stuff and we would generally hope that we'd be getting what we pay for--more bytes meaning more security (unless they're from the NSA and trying to punk us).</p>
<h2>We Also Have Three <em>Insecure</em> Hashes...</h2>
<p>These are fine when you're doing something that is not supposed to be protecting against adversarial attacks.  They're smaller to store and much cheaper to calculate...but it's trivial to find other input data that would produces the same 32-bit result:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'crc32
== #{FB05F0BC}  ; used to very gzip files (among other places)

&gt;&gt; checksum/method {DICKENS} 'adler32
== #{0202D207}  ; used by zlib deflate and inflate
</code></pre>
<p>If you want a <em>really</em> cheapskate insecure checksum, we include the one that is in TCP packets on the internet:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'tcp
== #{CA32}
</code></pre>
<hr>
<blockquote>
<p><strong>Fun Corner</strong>: Let's find a collision!</p>
<pre><code>&gt;&gt; until [
    string: copy {}
    repeat (random 10) [append string make char! 64 + random 26]
    #{CA32} = checksum/method string 'tcp
]
== #[true]

&gt;&gt; print string
AOGTDDN

&gt;&gt; checksum/method {AOGTDDN} 'tcp
== #{CA32}
</code></pre>
<p>That wasn't so hard, but... if you can find collisions for any of the <em>secure</em> hashes above (even the relatively-weak MD5 or SHA1) <em>you will be famous!</em></p>
</blockquote>
<h2>We're Primed To Make <strong>STREAMING</strong> Secure (or Insecure) Hashes !</h2>
<p>R3-Alpha did not have fancy modern hashes like SHA256 or SHA512.  But also the code it used was copy-pasted out of a library that required you to have all the data at once.</p>
<p>Hence if you have a multi-gigabyte DVD .iso file that you want to checksum, you have to read that into a multi-gigabyte BINARY! to process it.</p>
<p>But since Ren-C is leveraging the cryptography of the <a href="https://github.com/Mbed-TLS/mbedtls">pure C library known as mbedTLS</a>, the foundations are there to stream in little blobs at a time...and it is generalized so we can just flip on or off any hashes we care about.  <a href="https://forum.rebol.info/t/what-is-a-port/617/5">If we only knew how to express streaming with PORT!s (or whatever)</a>.</p>
<p>And also, the CRC32 and ADLER32 algorithms we have "for free" by including Zlib are now set up in a way that the insecure hashes can be streamed too.</p>
<h2>
<img src="https://forum.rebol.info/images/emoji/twitter/globe_with_meridians.png?v=9" title=":globe_with_meridians:" class="emoji" alt=":globe_with_meridians:"> <em>"How Does This Tie Into The Web Repl Story"?</em> <img src="https://forum.rebol.info/images/emoji/twitter/globe_with_meridians.png?v=9" title=":globe_with_meridians:" class="emoji" alt=":globe_with_meridians:">
</h2>
<p>I really want to have a laser focus on whether investing effort into something is going to be something that pays off or not, and to me a part of that payoff question is "will people using the web build care".</p>
<p><strong>Right now the web build does not include the CHECKSUM function at all.</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>That is too bad, because I do believe that putting secure hashes into the hands of users at the Web Repl prompt (as well as other basic crypto parts) would be a great playground.</p>
<p>But it would be rather heavyweight to push secure hashing into the default .wasm being pulled down on every site if it didn't use it.  This is why I really want to get "Wasm extensions" working, that can be dynamically loaded.  There's something called "side modules" that I have meant to explore but haven't.</p>
<p>Anyway, I hope this summary gives a little insight into where this is at, and perhaps educational for those who don't have experience with the difference between secure/insecure hashing.</p> ]]></description>
        <link>https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808/1</link>
        <pubDate>Mon, 09 May 2022 04:04:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5821</guid>
      </item>
      <item>
        <title>Dropping RC4 Support from the Crypto Extension</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I pretty sure no one out there is using it, but the RC4 cipher has been deprecated for a pretty long time now.  Per Wikipedia:</p>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Cryptography">cryptography</a>, <strong>RC4</strong> (Rivest Cipher 4 also known as <strong>ARC4</strong> or <strong>ARCFOUR</strong> meaning Alleged RC4, see below) is a <a href="https://en.wikipedia.org/wiki/Stream_cipher">stream cipher</a>. While it is remarkable for its simplicity and speed in software, multiple vulnerabilities have been discovered in RC4, rendering it insecure.</p>
</blockquote>
<p>The insecurity of RC4 led the IETF to <a href="https://tools.ietf.org/html/rfc7465">prohibit RC4 for TLS use in 2015</a></p>
<p>However, the original cryptography code (mostly from AxTLS) had an RC4 function, and it was in mbedTLS 2.  So I went ahead and kept it working.</p>
<p>It is now dropped from mbedTLS 3.  So in the scheme of things, time to let it go.</p>
<h2>Code Being Dropped</h2>
<p>The files arc4.h and arc4.c from mbedTLS are now gone, and this was the crypt module code for supporting it:</p>
<pre><code>static void cleanup_rc4_ctx(const REBVAL *v)
{
    struct mbedtls_arc4_context *ctx
        = VAL_HANDLE_POINTER(struct mbedtls_arc4_context, v);
    mbedtls_arc4_free(ctx);
    FREE(struct mbedtls_arc4_context, ctx);
}


//
//  export rc4-key: native [
//
//  "Encrypt/decrypt data (modifies) using RC4 algorithm."
//
//      return: [handle!]
//      key [binary!]
//  ]
//
REBNATIVE(rc4_key)
//
// !!! RC4 was originally included for use with TLS.  However, the insecurity
// of RC4 led the IETF to prohibit RC4 for TLS use in 2015:
//
// https://tools.ietf.org/html/rfc7465
//
// So it is not in use at the moment.  It isn't much code, but could probably
// be moved to its own extension so it could be selected to build in or not,
// which is how cryptography methods should probably be done.
{
    CRYPT_INCLUDE_PARAMS_OF_RC4_KEY;

    struct mbedtls_arc4_context *ctx = TRY_ALLOC(struct mbedtls_arc4_context);
    mbedtls_arc4_init(ctx);

    REBSIZ key_len;
    const REBYTE *key = VAL_BINARY_SIZE_AT(&amp;key_len, ARG(key));
    mbedtls_arc4_setup(ctx, key, key_len);

    return Init_Handle_Cdata_Managed(
        D_OUT,
        ctx,
        sizeof(struct mbedtls_arc4_context),
        &amp;cleanup_rc4_ctx
    );
}


//
//  export rc4-stream: native [
//
//  "Encrypt/decrypt data (modifies) using RC4 algorithm."
//
//      return: &lt;none&gt;
//      ctx "Stream cipher context"
//          [handle!]
//      data "Data to encrypt/decrypt (modified)"
//          [binary!]
//  ]
//
REBNATIVE(rc4_stream)
{
    CRYPT_INCLUDE_PARAMS_OF_RC4_STREAM;

    REBVAL *data = ARG(data);

    if (VAL_HANDLE_CLEANER(ARG(ctx)) != cleanup_rc4_ctx)
        rebJumps ("fail [{Not a RC4 Context:}", ARG(ctx), "]");

    struct mbedtls_arc4_context *ctx
        = VAL_HANDLE_POINTER(struct mbedtls_arc4_context, ARG(ctx));

    REBVAL *error = nullptr;

    REBSIZ length;
    REBYTE *output = VAL_BINARY_SIZE_AT_ENSURE_MUTABLE(&amp;length, data);
    const REBYTE *input = output;
    IF_NOT_0(cleanup, error, mbedtls_arc4_crypt(
        ctx,
        length,
        input,  // input "message"
        output  // output (same, since it modifies)
    ));

  cleanup:
     if (error)
        rebJumps ("fail", error);

    return rebNone();
}
</code></pre>
<p>...and here is the very basic test, also being removed...</p>
<pre><code>ctx: rc4-key as binary! "Deprecated Algorithm"
data: as binary! "But Implemented Anyway"
rc4-stream ctx data
data = #{0C4E2F3BD157EA7214C33F280BE4D9DF1DFB580563A6}</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/dropping-rc4-support-from-the-crypto-extension/1807/1</link>
        <pubDate>Mon, 09 May 2022 01:32:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5820</guid>
      </item>
      <item>
        <title>About the Cryptography category</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Discussion of things related to cryptography, which includes low level primitives (ciphers, hashes, and key exchange) as well as higher-level protocols such as TLS.</p> ]]></description>
        <link>https://forum.rebol.info/t/about-the-cryptography-category/1806/1</link>
        <pubDate>Mon, 09 May 2022 01:11:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5819</guid>
      </item>
      <item>
        <title>REPL Querying</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>It might be worthwhile to take some inspiration from this:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/ellie/atuin" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://opengraph.githubassets.com/dca1958aebeb424b5526f3fa3c903c51716ab4f22eb7cd64a50259c3d4288398/ellie/atuin" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/ellie/atuin" target="_blank" rel="noopener">GitHub - ellie/atuin:  Magical shell history</a></h3>


  <p><span class="label1"> Magical shell history. Contribute to ellie/atuin development by creating an account on GitHub.</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>I'd like us to start using the <a href="https://github.com/hostilefork/replpad-js/blob/master/storage.md">persistence features</a> to remember previous sessions, and perhaps make it easier to <strong>curate past Repl interactions into scripts</strong>.</p> ]]></description>
        <link>https://forum.rebol.info/t/repl-querying/1804/1</link>
        <pubDate>Sat, 07 May 2022 19:11:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5814</guid>
      </item>
      <item>
        <title>LOGIN Magazine Historical Covers</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Those who are interested in Rebol history might be interested in these magazine covers.  I am trying to delete files off a computer and had them, and if they have any relevance they are better backed up as part of the forum backups:</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4.jpeg" data-download-href="https://forum.rebol.info/uploads/default/5385218e7af6c5e52f7dee3c114207f08668bbe4" title="rebol-login-nov-2001"><img src="https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_353x500.jpeg" alt="rebol-login-nov-2001" data-base62-sha1="bUQRrNKBWgwSAqtWhtOVp1zs0ks" width="353" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_353x500.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_529x750.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_706x1000.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">rebol-login-nov-2001</span><span class="informations">14482048 534 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/19d65a0ef0878828180a88f3257fae3cc465db94.jpeg" data-download-href="https://forum.rebol.info/uploads/default/19d65a0ef0878828180a88f3257fae3cc465db94" title="rebol-login-sep-2002"><img src="https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_353x500.jpeg" alt="rebol-login-sep-2002" data-base62-sha1="3GzbmOscS1RVPpGqNNJcrWd2PY0" width="353" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_353x500.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_529x750.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_706x1000.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">rebol-login-sep-2002</span><span class="informations">14482048 488 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p> ]]></description>
        <link>https://forum.rebol.info/t/login-magazine-historical-covers/1803/1</link>
        <pubDate>Fri, 06 May 2022 19:45:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5813</guid>
      </item>
      <item>
        <title>DO vs. IMPORT and &quot;Console-Extending Applications&quot;</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>During the module reworking, I roughly embraced the R3-Alpha distinction made in the header between two categories:</p>
<hr>
<pre><code>Rebol [Type: Script ...]  ; first category
</code></pre>
<ul>
<li>
<p>You would run these "Scripts" with DO</p>
</li>
<li>
<p>Performing a DO could have side effects, but should be isolated...not allowed to leak changes into the caller's environment</p>
<ul>
<li>This was a new rule I imposed as a default (because "Isolate" was made more economical, and I wanted to see how much we could get away with)</li>
</ul>
</li>
</ul>
<hr>
<pre><code>Rebol [Type: Module ...]  ; second category
</code></pre>
<ul>
<li>
<p>An "ideal" module would not have any "side-effects"...because the concept was that no matter how many times you run IMPORT you will only get one copy of that module in memory.</p>
<ul>
<li>Notably, if you run an IMPORT on a module that has already been loaded before...that will not run any code in the module body...it will just give you the MODULE! object that it already made.</li>
</ul>
</li>
</ul>
<hr>
<p><strong>We probably shouldn't be surprised that there are things that don't fit neatly into these categories!</strong></p>
<hr>
<h2>"Console-Extending Applications"</h2>
<p>So these add some functions to your environment, but also tend to have some side effects.  Like:</p>
<ul>
<li>
<p><strong><a class="mention" href="/u/gchiu">@gchiu</a>'s chess program</strong> - It wants to display a board, show you some help, and add various chess-related behaviors to the console.  But to add those commands which "contaminate" the calling environment, you have to say <strong>import</strong>.  On the other hand, by displaying a board and showing help, it sort of violates that "no side-effects" rule.</p>
<ul>
<li>He is working on another prescription-generating application that lets you automate a pop-up window that works in a similar way.</li>
</ul>
</li>
<li>
<p><strong>The ReplPad interactivity test</strong> - This test adds OKAY and NOPE to the vocabulary... where it's actually the typing of those words that runs commands which advance the console through steps in some way and instructs you on what to look for.</p>
<ul>
<li>
<p>If you don't use IMPORT, you don't get the commands added as commands to the context...</p>
</li>
<li>
<p>...but if you DO use IMPORT, you can only run through the test once... because doing it again will not load the code that prints out the instructions and launches it...</p>
</li>
</ul>
</li>
</ul>
<h2>Should DO allow you to EXPORT ?</h2>
<p>The nice thing about the word DO is it sounds pretty unambiguous, that you want to run something that has side effects.</p>
<p>But I do like the default of not leaking into the enclosing environment.</p>
<p>It seems like allowing scripts to export symbols could be a lazy compromise...which would let you ask to run something (vs. just bringing in a cached copy if previously loaded).</p>
<p>Yet this raises the question of what sort of behavior you'd expect from something that extends the console if you DO it multiple times.</p>
<p>There's also some things to think about regarding how modules will only load once, with respect to debugging.  If you have a complex multi-module project running and want to tweak something--reload it and retry without losing your current interpreter state, that's rather complicated semantically.</p>
<p>We might also consider the idea that there's a new script type.  Something like <strong><code>Rebol [Type: Commands ...]</code></strong> for lack of a better name.  Maybe this would by default give you a new console session separate from the one you were in?</p>
<p>Much more work is needed on binding and modules, to try and figure out how to deliver a good experience.  So hopefully if I don't die in a tornado here in Tennessee, I will work on that soon.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p> ]]></description>
        <link>https://forum.rebol.info/t/do-vs-import-and-console-extending-applications/1802/1</link>
        <pubDate>Fri, 06 May 2022 19:42:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5812</guid>
      </item>
      <item>
        <title>Suppressing verbosity in the replpad</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="gchiu" data-post="1" data-topic="1801">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/gchiu/40/22_2.png" class="avatar"> gchiu:</div>
<blockquote>
<p>Maybe <code>http://hostilefork.com/media/shared/replpad-js/@rx</code> would be better</p>
</blockquote>
</aside>
<p>This notation seems nice, but the way browsers work this can't be dispatched to a single script living at <code>http://hostilefork.com/media/shared/replpad-js/</code>.</p>
<p>When serving the ReplPad statically, the only way to do that is with the URI "query" and "fragment"  portions...so it has to be done with things that follow a question mark or a hash mark.  Such as <code>http://hostilefork.com/media/shared/replpad-js/?import=@rx</code> or similar.</p>
<p>In order to do better, there has to be actual server-side code before the page is fetched as part of the "dispatch", which somehow routes the information to the page.  That would be worth it for a hosted service that's trying to be as slick as possible...but the ReplPad is not being prescriptive about the server-side hosting at this time.</p>
<p>It's something we should keep in mind for <code>https://example.com/@rx</code> when things are streamlined.</p> ]]></description>
        <link>https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801/3</link>
        <pubDate>Mon, 02 May 2022 17:40:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5811</guid>
      </item>
      <item>
        <title>Suppressing verbosity in the replpad</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p>if a module is provided then verbose mode is automatically suppressed.</p>
</blockquote>
<p><strong>My main thought about verbosity is that we should think about options beyond just "on" and "off".</strong></p>
<p>Verbose output is something that is helpful when debugging, but you don't always know in advance if you're going to end up in a situation that needs debugging or not.  So having a log running regardless is the best default option--then you can choose to view it after the fact.</p>
<p>This is demonstrated fairly well by the JavaScript console in browsers.  Users aren't troubled by it if all goes well...but if something goes wrong you can bring it up.  Errors are highlighted distinctly from just basic logging.</p>
<p>In the case of the ReplPad, we can actually leverage this by sending the information about module loads and such to the browser console--as opposed to the ReplPad console.  That seems like a reasonable default, and then maybe have a way to send it to the standard output.</p>
<p>When you're running in a desktop console, there could be options:</p>
<ul>
<li>Write informational logging output to a file</li>
<li>Mix it in with the console output</li>
<li>Just keep the last N lines of it in memory and be able to ask for it on an as-needed basis</li>
</ul>
<p><strong>One thing I worry about is superfluous logging that <em>isn't</em> visible getting out of hand and taking up memory and time...</strong> so there should be some way of knowing a lot of logging output is being made.  Not sure when these notices would be given, but perhaps something it says when it prints out a prompt.</p> ]]></description>
        <link>https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801/2</link>
        <pubDate>Mon, 02 May 2022 15:17:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5810</guid>
      </item>
      <item>
        <title>Suppressing verbosity in the replpad</title>
        <dc:creator><![CDATA[@gchiu]]></dc:creator>
        <description><![CDATA[ <p>I am developing a replpad app but I want the users to go straight to a URL and start the app.  I'd rather that they didn't have to type</p>
<pre><code>import @rx
</code></pre>
<p>when a lot of module stuff is sent to the console interrupting the interface, eg</p>
<pre><code>`== make module! [
    alpha: make bitset! #{00000000000000007FFFFFE07FFFFFE0}  
    rx: '#[action! {rx} [drug]]  
    ...  
</code></pre>
<p>`</p>
<p>Maybe <code>http://hostilefork.com/media/shared/replpad-js/@rx</code> would be better and if a module is provided then verbose mode is automatically suppressed.</p>
<p>Anyway, suggestions for a standardised way to run our apps?</p> ]]></description>
        <link>https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801/1</link>
        <pubDate>Thu, 28 Apr 2022 09:49:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5809</guid>
      </item>
      <item>
        <title>Getting data into replpad-js</title>
        <dc:creator><![CDATA[@gchiu]]></dc:creator>
        <description><![CDATA[ <p>I think at least Chrome that local storage is limited to 5Mb.  Other browsers you can set this value.</p>
<p>I'd want a way to also take the local storage data and transfer it to another browser on a different machine.</p> ]]></description>
        <link>https://forum.rebol.info/t/getting-data-into-replpad-js/1742/4</link>
        <pubDate>Thu, 28 Apr 2022 09:38:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5808</guid>
      </item>
      <item>
        <title>Danny, dRebol, Inetw3 (Daniel Murrill)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Hi Danny,</p>
<aside class="quote no-group quote-modified" data-username="Danny" data-post="21" data-topic="1503">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/848f3c/40.png" class="avatar"><a href="https://forum.rebol.info/t/pack-sequence-type/1503/21">PACK! Sequence Type</a>
</div>
<blockquote>
<p>I would like to start coding the Rebol-Dom.r script in Ren-C, but im not sure if it needs to be written as (Redbol) compatible or R3 syntax. Any heads up would be nice.</p>
</blockquote>
</aside>
<p>Last year, Ren-C underwent some necessary but painful transitions... as I try to reason about a working module system, and what the future of binding might look like.  It means the already-not-well-documented variations from historical Rebol are even more of a minefield--I'll do what I can to improve it, but it will be slow.</p>
<p>But likely relevant to what you want is that I think it's going to be crucial that binding be able to let you access "binding environments" for strings.  If you haven't got a chance to read this, I talk some about that:</p>
<p><strong><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">Rebol and Scopes: Well, why Not?</a></strong></p>
<p><strong>So that's one heads-up I'd give you: that the best way to embed "JavaScript-like intents" inside of Ren-C may be something that is done with strings, vs. the kinds of syntax tricks you were trying.</strong></p>
<p>This isn't to say that we couldn't use some experimentation in the area of Ren-C/web interoperability.  <a class="mention" href="/u/rgchris">@rgchris</a> made "StyleTalk" which <a href="https://www.youtube.com/watch?v=sM7uGKCZMl0">he explains in a video</a>.  I'd like to see us to see where things can go with that kind of thinking before bending ourselves too far into pretzels and asking if <strong><code>a[b]c</code></strong> should be its own lexical type.</p>
<p><strong>Another heads up I'll give is that I've been traveling since December, and not programming much at all.</strong>  Hence I'm a bit behind on the mountain of design (as well as my own pet projects...)  I likely won't have the bandwidth to support anyone's new experiments that I'm not already supporting.</p>
<p>Though much of the current efforts are on things in the browser.  If you are interested in HTML interoperability then I'd definitely encourage you to look at the ReplPad and where that is going.  I'm effectively "doubling-down" on the approach of using the browser for GUI <em>(vs. Red's strategy of writing their own code)</em></p>
<p><strong>So if you want to be experimental in Ren-C land, the place where you'll be more likely to find support (though not promising...) is if you're trying things in the web build.</strong>  It may lead you to different ideas about how to attack your problems, specifically as a mixture of JavaScript strings with Ren-C.</p>
<p>I'd suggest looking at <a href="https://forum.rebol.info/t/js-eval-and-js-do/1504">JS-EVAL and JS-DO</a> for instance, things like what <a class="mention" href="/u/gchiu">@gchiu</a> wrote just the other day:</p>
<pre><code>add-content: func [
    txt [text!]
][
    txt: append copy txt newline
    js-do ["document.getElementById('script').innerHTML +=" spell @txt]
]
</code></pre>
<p>That's pretty smooth language interoperability... and I'm sure it can be better!  (If you read the JS-EVAL post I explain why this winds up being smarter than gluing strings together, and avoids various escaping problems.)</p> ]]></description>
        <link>https://forum.rebol.info/t/danny-drebol-inetw3-daniel-murrill/1502/4</link>
        <pubDate>Sun, 17 Apr 2022 00:37:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5807</guid>
      </item>
      <item>
        <title>PACK! Sequence Type</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was merged into an existing topic: <a href="/t/danny-drebol-inetw3-daniel-murrill/1502/3">Danny, dRebol, Inetw3 (Daniel Murrill)</a></p> ]]></description>
        <link>https://forum.rebol.info/t/pack-sequence-type/1503/21</link>
        <pubDate>Sat, 16 Apr 2022 23:04:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5806</guid>
      </item>
      <item>
        <title>Danny, dRebol, Inetw3 (Daniel Murrill)</title>
        <dc:creator><![CDATA[@Danny daniel murrill]]></dc:creator>
        <description><![CDATA[ <p>I would like to start coding the Rebol-Dom.r script in Ren-C, but im not sure if it needs to be written as Rebdol compatible or R3 syntax. Any heads up would be nice.</p>
<p>I also would like to see its node sequence type coded as Red/sys or Ren-C if its possible.</p>
<p>I really like Uparse, but for me to focus on its intricacies would take up more free time that i really don't have right now.</p>
<p>Although i like Rebol, my coding style may not do it much justice, but that's ok. Rebol is still somewhat an unknown. So if anyone have any criticism, good or bad, i welcome it.</p> ]]></description>
        <link>https://forum.rebol.info/t/danny-drebol-inetw3-daniel-murrill/1502/3</link>
        <pubDate>Thu, 14 Apr 2022 02:33:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5803</guid>
      </item>
      <item>
        <title>Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</title>
        <dc:creator><![CDATA[@BlackATTR Black Attr]]></dc:creator>
        <description><![CDATA[ <p>Great refresher and summary of the issues.</p> ]]></description>
        <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799/2</link>
        <pubDate>Thu, 07 Apr 2022 11:58:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5802</guid>
      </item>
      <item>
        <title>Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><code>~null~</code> isotopes are a novel solution shaped to solve a specific problem.  As a reminder of what the goal is...</p>
<h1>The Goal is to Please <a class="mention" href="/u/rgchris">@rgchris</a> <em>AND</em> Please me</h1>
<p>NULL is the signal of "soft failure".  It's a unique result reserved for when a branch fails, or when a loop is halted by a BREAK, when PARSE fails...etc.</p>
<p>Its property of not being storable in blocks makes it critical to disambiguating this historical problem:</p>
<pre><code>redbol&gt;&gt; third [a b #[none]]
== #[none]

redbol&gt;&gt; third [a b]
== #[none]
</code></pre>
<p>In a language that prides itself on letting you work with code structure, <em>this is the tip of the iceberg of the problems that null solves</em>, and you will find the distinction's utility across the board (obviously, in tools like COMPOSE).  It facilitates rigorous analysis and rearrangements...without needing to drop to C or write convoluted code:</p>
<pre><code>&gt;&gt; third [a b _]
== _

&gt;&gt; third [a b]
; null
</code></pre>
<p>Hence NULL has taken the place of blank ("none!") in many places, one of which is the unique result of failed conditionals.</p>
<p>But unlike the elements in a block, a branch that evaluates isn't required to be non-NULL.  Which leads us to the long running question of what to bend NULL branches to so they don't conflate with the branch-not-taken result.</p>
<h2>Chris has (rightly) expressed concern</h2>
<p>At times I've said that it's not that big a deal that branches can't evaluate to NULL and get distorted.  "You didn't have a NULL before, so why get so worked up about control constructs not returning it?"</p>
<p>But the now-pervasive nature of NULL means it can't be avoided.  So:</p>
<p><em>"How do you express branching code which wants to do some work but also produce NULL as an evaluative product?"</em></p>
<p>Conflation was not a problem, e.g. in Rebol2:</p>
<pre><code>rebol2&gt;&gt; exampler: func [x] [
     print "returning sample or none if not found"
     case [
         x = &lt;string&gt; [print "sample string" {hello}]
         x = &lt;integer&gt; [print "sample integer" 3]
         x = &lt;none&gt; [print "sample none" none]
     ]
  ]

rebol2&gt;&gt; exampler &lt;string&gt;
returning sample or none if not found
sample string
== "hello"

rebol2&gt;&gt; exampler &lt;blatz&gt;
returning sample or none if not found
== #[none]

rebol2&gt;&gt; exampler &lt;none&gt;
returning sample or none if not found
sample none
== #[none]
</code></pre>
<p>However NULL is now the basic currency of "soft failure".  As such it would not be uncommon to be in the situation where a branching decision process would want to intentionally return NULL as part of the work it does.</p>
<p>Without something like the isotope decay mechanism, unpleasant convolutions would be needed, for instance surrounding anything that wanted to tunnel a NULL with a CATCH and THROW'ing it:</p>
<pre><code>x: catch [
    throw switch 1 + 2 [
        1 [print "one" 1]
        2 [print "two", &lt;two&gt;]
        3 [print "three", throw null]
     ]
]
</code></pre>
<p>Definitely not good.  But regarding the pleasing-me-part, remember I am trying to avoid this situation:</p>
<pre><code>&gt;&gt; case [
     true [
          print "case branch"
          if 1 &gt; 2 [print "failed inner"]
     ]
   ] else [
     print "else branch"
   ]

case branch
else branch  ; ugh
</code></pre>
<p>I don't want the CASE branch to evaluate to NULL just because the failed IF inside the branch was NULL.  That would mean the ELSE tied to the CASE runs even though the code for the branch ran.</p>
<h2>Enter Isotopes</h2>
<p>One thing null isotopes have in common with NULL (like all BAD-WORD! isotopes) is that they can't be put in blocks.  But they have been automatically "decaying" into regular NULL when stored into variables.</p>
<pre><code>&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; x: ~null~
== ~null~  ; isotope  &lt;-- note the overall expression is still an isotope

&gt;&gt; x
; null
</code></pre>
<p>The twist is that they are <em>different enough</em> from true NULL such that a THEN or an ELSE can consider them a situation where the branch did not run:</p>
<pre><code>&gt;&gt; if false [&lt;ignored&gt;]
; null

&gt;&gt; if true [null]
== ~null~  ; isotope

&gt;&gt; if true [null] else [print "This won't run"]
== ~null~  ; isotope
</code></pre>
<p>The reason functions like ELSE can "see" the isotope is that they don't take an ordinary parameter on their left.  They take a ^META argument.  These can see the distinction between a ~null~ isotope and a "true" NULL.</p>
<p><strong>I'd largely say this has been working well...certainly better than its conceptual predecessors.</strong>  It makes piping NULL out of branches trivially easy, when the fear of conflation is not a problem.</p>
<pre><code>&gt;&gt; x: switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
== ~null~

&gt;&gt; x
; null
</code></pre>
<p>The automatic decay in variable storage prevents you from needing an explicit operation to turn ~null~ isotopes into pure nulls:</p>
<pre><code>&gt;&gt; x: decay switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
; null
</code></pre>
<h1>But <a class="mention" href="/u/rgchris">@rgchris</a> Would Likely Want any <em>NORMAL</em> arg decay</h1>
<p>At the very moment I am writing this, ~null~ isotopes are like all other BAD-WORD! isotopes and not accepted as normal parameters.</p>
<p><strong>They <em>could</em> decay to pure NULL for all normal args.</strong>  But let me explain a bummer of what we lose in that bargain.</p>
<p>It takes away a safety idea I had with functions like MATCH.</p>
<pre><code>&gt;&gt; match [&lt;opt&gt; integer!] 3
== 3

&gt;&gt; match [&lt;opt&gt; integer!] "notaninteger"
; null

&gt;&gt; match [&lt;opt&gt; integer!] null
== ~null~  ; isotope
</code></pre>
<p>The idea was that it could say "yes, this matched" but if ~null~ isotopes were tested, they'd give an error:</p>
<pre><code>&gt;&gt; if (match [&lt;opt&gt; integer!] null) [print "Yes it matched!"]
** Error: IF does not accept ~null~ isotopes without a ^META condition
</code></pre>
<p>Were MATCH to have passed through a plain NULL it would have succeeded in the match but not run the branch.  So it's nice to get the warning on the isotope.</p>
<p><strong>Or it could just return a ~matched~ isotope</strong>.  But this loses the following nice isotopic property:</p>
<pre><code>&gt;&gt; x: match [&lt;opt&gt; integer!] null else [fail "NO MATCH"]
== ~null~  ; isotope

&gt;&gt; x
; null
</code></pre>
<p>In fact I instituted other decaying variants for ~blank~ and ~false~</p>
<pre><code>&gt;&gt; y: match [blank!] _ else [fail "NO MATCH!"]
== ~blank~  ; isotope

&gt;&gt; y
== _

&gt;&gt; z: match [logic!] 1 = 2 else [fail "NO MATCH!"]
== ~false~  ; isotope

&gt;&gt; z
== #[false]
</code></pre>
<h1>So What To Do About MATCH and its bretheren?</h1>
<p>Seems the options are:</p>
<ol>
<li>
<p><em>Don't worry about it.</em>  If you write <strong>match [logic!] 1 = 2</strong> you get back <strong>#[false]</strong> and should you write an expression like <strong>if (match [logic!] 1 = 2) [print "Match!]</strong> you get what you deserve.</p>
</li>
<li>
<p><em>Use a different isotope.</em>  Let's say that <strong><code>match [&lt;opt&gt;] null</code></strong> is simply <strong>~matched~ (isotope)</strong>.  It wouldn't have the decaying property, but would have the invalidness property.</p>
</li>
<li>
<p><em>Have a MATCH/FALSEY variant.</em>  Let plain <strong>match</strong> on a falsey thing trigger an error and if you write <strong>if match/falsey ...</strong> then you clearly do know what you're doing so it becomes like case (1).</p>
</li>
<li>
<p><em>Make all conditional arguments take ^META arguments for their conditions.</em>  This would put the responsibility for checking for isotopes on them, and they'd uniquely disallow them before UNMETA'ing them and then testing for truth/falsehood.</p>
</li>
</ol>
<p>Option (4) is too taxing...impacting not just the interface to IF but the implementation of CASE and any conditional construct.</p>
<p><strong>I think I like (3) because it punts the ball down the road a bit.</strong></p>
<p>But this might still not suit Chris.</p>
<h1>Should Non-Meta Arguments Decay Null isotopes?</h1>
<p>The "auto-decay" of ~null~ isotopes means no variable can ever hold a NULL isotope.  And there's also a rule that no <em>normal</em> parameter can ever be passed an isotope, only ^META parameters.</p>
<p>In the beginning, it seemed useful if normal arguments would automatically decay null isotopes:</p>
<pre><code>&gt;&gt; foo: func [x] [if null? x [print "Yup, it's null"]]

&gt;&gt; foo if true [null]
Yup it's null

&gt;&gt; metafoo: func [^x] [
    case [
        null? x [print "regular null"]
        x = '~null~ [print "null isotope"]
        true [print "something else"]
     ]
   ]

&gt;&gt; metafoo if false [null]
regular null

&gt;&gt; metafoo if true [null]
null isotope
</code></pre>
<p>There is a manual DECAY operator which could be used, but would not meet that wish:</p>
<pre><code>&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; decay ~null~
; null

&gt;&gt; ~blank~
== ~blank~  ; isotope

&gt;&gt; decay ~blank~
== _

&gt;&gt; ~false~
== ~false~  ; isotope

&gt;&gt; decay ~false~
== #[false]
</code></pre>
<h1>Should DECAY Conflation Be A Customization?</h1>
<p>Another avenue of satisfaction could be to say that you simply customize your environment with some definitions to make auto-decaying constructs:</p>
<pre><code>switch: chain [:switch | :decay]
case: chain [:case | :decay]
...

&gt;&gt; case [true [null]]
; null

&gt;&gt; case [false [10]]
; null
</code></pre>
<p>I don't like it, but if someone isn't going to use ELSE (or is willing to accept this very easily unintentional conflation if they do) it could be an option.</p>
<p><strong>I really do believe the ability to tell from outside the construct if a branch has been taken is an interesting property, which even those who think they won't use ELSE or THEN can leverage, especially when building constructs atop each other.</strong>  But this isn't something that can be appreciated without usage, or trying to write something like UPARSE generically in usermode.</p>
<h1>Should function RETURN decay by default?</h1>
<p>Continuing along these lines, this has to do with the pattern of:</p>
<pre><code>foo: func [x] [
    return switch x [
         1 [print "one", #one]
         2 [print "two", null]
         3 [print "three", &lt;three&gt;]
    ]
]

&gt;&gt; foo 1 + 2
two
== ???   ; should this be ~null~ isotope or just NULL
</code></pre>
<p>Also, should it matter whether there's a RETURN there or not?  Is this something the type spec should distinguish?</p>
<p>Right now there's a refinement called /ISOTOPE on RETURN which asks it not to decay.</p>
<p><strong>If all non-^META parameters decay by default, then it seems isotopic decay is the right default for RETURN even though it takes a ^META parameter and returns non-decaying isotopes.</strong></p>
<h2>As Always, A Lot To Think About</h2>
<p>Want to get this posted because it's preventing me from making new drafts (Discourse won't let you have multiple top-level post drafts in-flight for some reason).</p>
<p>Will keep mulling it all over.</p>
<p><em>"A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away."</em></p> ]]></description>
        <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799/1</link>
        <pubDate>Thu, 07 Apr 2022 04:14:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5801</guid>
      </item>
      <item>
        <title>Improving the ASK Dialect (and replacing INPUT)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="onebox githubissue">
  <header class="source">
      <a href="https://github.com/hostilefork/replpad-js/issues/97" target="_blank" rel="noopener">github.com/hostilefork/replpad-js</a>
  </header>
  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Issue">
	  <svg width="60" height="60" class="github-icon" viewbox="0 0 14 16" aria-hidden="true"><path d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/hostilefork/replpad-js/issues/97" target="_blank" rel="noopener">Paste of Multi-Line Text should enter multiline editing mode</a>
    </h4>

    <div class="github-info">
      <div class="date">
        opened <span class="discourse-local-date" data-format="ll" data-date="2022-04-01" data-time="12:28:02" data-timezone="UTC">12:28PM - 01 Apr 22 UTC</span>
      </div>


      <div class="user">
        <a href="https://github.com/hostilefork" target="_blank" rel="noopener">
          <img alt="hostilefork" src="https://avatars.githubusercontent.com/u/20440?v=4" class="onebox-avatar-inline" width="20" height="20">
          hostilefork
        </a>
      </div>
    </div>
  </div>
</div>

<div class="github-row">
  <p class="github-content">Typically hitting enter in the REPL will trigger an evaluation. But if you hit Ctrl-Enter, this goes into a multi-line editing...</p>
</div>

<div class="labels">
</div>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
 ]]></description>
        <link>https://forum.rebol.info/t/improving-the-ask-dialect-and-replacing-input/1124/15</link>
        <pubDate>Fri, 01 Apr 2022 12:28:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5800</guid>
      </item>
      <item>
        <title>Improving the ASK Dialect (and replacing INPUT)</title>
        <dc:creator><![CDATA[@gchiu]]></dc:creator>
        <description><![CDATA[ <p>I'm trying to parse multi line text in the clipboard so control enter doesn't help.</p> ]]></description>
        <link>https://forum.rebol.info/t/improving-the-ask-dialect-and-replacing-input/1124/14</link>
        <pubDate>Fri, 01 Apr 2022 05:47:13 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5799</guid>
      </item>
      <item>
        <title>Improving the ASK Dialect (and replacing INPUT)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><em><a class="mention" href="/u/gchiu">@gchiu</a> has raised an additional question about how to get multiline input, where we can do a reasonably good job in a browser with a textarea of that in the browser.  I moved the discussion here so I could keep the GitHub issue focused on the technical issue it was about.</em></p>
<hr>
<p>Already multi-line input is in the ReplPad when you hit Ctrl-Enter.  I've always intended to make that feature available to ASK...somehow.  But if the caller of ASK can only handle one line, they don't want to have to check it.</p>
<p>So it's a question of intent...whether you want one line or many.  So would it be READ-LINE vs. READ-LINE/MULTI, or READ-TEXT/LINE, or...what?  Then the question of whether ASK TEXT! assumes one or the other.</p>
<p>I kind of feel like ASK TEXT! strikes me as unconstrained.  It's like "as much as you want to say" and if you really just want one line that should be a different request.  But if you want to read only one line it shouldn't be any worse than:</p>
<pre><code>ask ["Enter a single line:" text! /lines 1]
</code></pre>
<p>Maybe worth it to have a "macro":</p>
<pre><code>ask ["Enter a single line:" #line]
</code></pre>
<h2>I will advocate for <em>modelessness</em>
</h2>
<p><em>I'm generally a fan of modeless editing</em>.  So even if you only intend to accept one line, don't constrain me while I'm typing or copy/pasting.  Give me a chance to edit it down to fit what you'll accept.  If we can lean in that direction that would be nice.</p>
<h2>Might we leverage PARSE rules?</h2>
<p>Could we find a way to blend in parsing as part of the asking?  Could there be a way to even guide people to why their input wasn't satisfactory?</p>
<pre><code>ask [text! constraint [thru newline]]
</code></pre>
<p>Would be nice to be creative here, but also to study prior art.</p> ]]></description>
        <link>https://forum.rebol.info/t/improving-the-ask-dialect-and-replacing-input/1124/13</link>
        <pubDate>Fri, 01 Apr 2022 00:46:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5798</guid>
      </item>
  </channel>
</rss>

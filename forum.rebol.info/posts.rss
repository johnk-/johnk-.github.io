<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>What Should TYPE OF an Isotope Be?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1983">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One might ask why you can't avoid naming the type constraint entirely, and always speak in terms of functions. This means you would always have to write <strong>match [any-series?] value</strong> instead of <strong>match any-series! value</strong>. The reasoning is that we want to be able to write things like:</p>
<pre><code>&gt;&gt; parse ["abc" [d e f]] [some any-series!]
== [d e f]
</code></pre>
</blockquote>
</aside>
<p>It may be worth pointing out that in PARSE, we <em>could</em> always encode type matching intent via a MATCH instruction, and then have it quote a block argument:</p>
<pre><code>&gt;&gt; parse ["abc" [d e f]] [some match [any-series?]]
== [d e f]
</code></pre>
<p>But then, people would probably do something like:</p>
<pre><code>any-series!: [match [any-series?]]
</code></pre>
<p>This would be usable in PARSE but not elsewhere, e.g. SWITCH/TYPE wouldn't understand it.  :-/</p>
<p>So it seems that having a "type-flavored block" to encode these sets is the better answer.  Inside that block you can use function references like ANY-SERIES? and other type flavored blocks like ANY-SERIES! interchangeably.  As written, using the function form is slightly faster.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983#post_6</link>
        <pubDate>Sat, 22 Apr 2023 22:28:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6604</guid>
      </item>
      <item>
        <title>Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Hi vnzio,<br>
If I weren't as busy as I am currently in daytime <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"><br>
Well I can tell you in a nutshell why REN-C is awesome. While there are a few R3 clones in development, this is the most active of them all. But REN-C is not R3 anymore. Many things R3 was troubled by were solved by Ren-C. REN-C is also even more a way to put R3 in a C project (or was it the other way around).<br>
REN-C also makes a lot of new constructs possible. <a href="https://forum.rebol.info/t/ren-cs-eloquence-in-the-face-of-fizzbuzz/904" class="inline-onebox">Ren-C's eloquence in the face of FizzBuzz</a> I used it to solve the 8 queens problem in a more Rebol way <a href="https://arnoldvanhofwegen.com/blog/eight-queens-problem-solved-with-ren-c/" class="inline-onebox">Eight queens problem solved with Ren-C | Arnold's Blog</a> And I got a MySQL module working (not in the mainline) for REN-C.<br>
As you can see on the forum, Brian, Hostilefork is the main development force, the other members on the forum are more critical followers and aiding in their own power, try to keep making sense <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"> . There are lots of neat ideas that are implemented in REN-C and when these do not work out as planned, plans change and changes are made accordingly. This makes REN-C a dynamic project to follow. So not directly suitable for using in your day to day work, yet rather constant if you do not do very crazy stuff.<br>
And what makes it even better... it is a small community, you can work on anything you feel and that is okay and no large number of Nay-sayers (maintainers) telling you around. Mny things have not been done for REN-C like for name any (semi) large open source project.</p> ]]></description>
        <link>https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028#post_2</link>
        <pubDate>Tue, 18 Apr 2023 20:23:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6603</guid>
      </item>
      <item>
        <title>&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</title>
        <dc:creator><![CDATA[@vnzio Vnzio]]></dc:creator>
        <description><![CDATA[ <p>Yes<br>
I will try to present my interest, experiences, history and current wishes.<br>
It might take me a couple of days to put this in lucid form.<br>
A bient√¥t</p> ]]></description>
        <link>https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029#post_3</link>
        <pubDate>Tue, 18 Apr 2023 14:41:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6602</guid>
      </item>
      <item>
        <title>&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Hi vnzio,<br>
Welcome. Could you tell us more? Who you are in the Introductions category ( <a href="https://forum.rebol.info/t/about-the-introductions-category/1286" class="inline-onebox">About the Introductions category</a> ) why you consider Factor to be a good Foreign inspiration source for us to take notice?<br>
Best,<br>
Arnold</p> ]]></description>
        <link>https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029#post_2</link>
        <pubDate>Tue, 18 Apr 2023 13:52:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6601</guid>
      </item>
      <item>
        <title>&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</title>
        <dc:creator><![CDATA[@vnzio Vnzio]]></dc:creator>
        <description><![CDATA[ <p><a href="https://factorcode.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://factorcode.org/</a></p>
<aside class="onebox wikipedia" data-onebox-src="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1">
  <header class="source">

      <a href="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">en.wikipedia.org</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:200/124;"><img src="//upload.wikimedia.org/wikipedia/en/thumb/f/ff/NewFactorLogo.png/200px-NewFactorLogo.png" class="thumbnail" width="200" height="124"></div>

<h3><a href="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">Factor (programming language)</a></h3>

<p>Factor is a stack-oriented programming language created by Slava Pestov. Factor is dynamically typed and has automatic memory management, as well as powerful metaprogramming features. The language has a single implementation featuring a self-hosted optimizing compiler and an interactive development environment. The Factor distribution includes a large standard library.
 Slava Pestov created Factor in 2003 as a scripting language for a video game. The initial implementation, now referred to as JFa...</p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Google Tech Talk 2008</p><p><a href="https://www.youtube.com/watch?v=f_0QlhYlS8g">Factor: an extensible interactive language</a></p>

<p>Silicon Valley Forth Interest Group<br>
2022<br>
"Factor in 2022"</p><p><a href="https://www.youtube.com/watch?v=OLh61q4c4XE">2022-03-26 --- Factor in 2022 --- John Benediktsson &amp; Doug Coleman</a></p>
 ]]></description>
        <link>https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029#post_1</link>
        <pubDate>Mon, 17 Apr 2023 23:10:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6600</guid>
      </item>
      <item>
        <title>Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</title>
        <dc:creator><![CDATA[@vnzio Vnzio]]></dc:creator>
        <description><![CDATA[ <p>Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</p>
<p>???</p> ]]></description>
        <link>https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028#post_1</link>
        <pubDate>Mon, 17 Apr 2023 22:47:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6599</guid>
      </item>
      <item>
        <title>What Should TYPE OF an Isotope Be?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1983">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So I propose making <em>none</em> of the ending-in-exclamation forms work, by defining:</p>
<pre><code>integer!: &amp;(integer?)
block!: &amp;(block?)
</code></pre>
<p>They'll be type constraints that can work with <strong>match</strong> or in a function spec block. But then anything that operates mechanically on fundamental types would use the <strong>&amp;integer</strong> form.</p>
</blockquote>
</aside>
<h2>This would be a really far reaching change...</h2>
<p>One kind of ugly-looking consequence would be that you won't be able to write things like <strong>to integer!</strong> anymore, because it will expect <strong>to &amp;integer</strong>.  Same with <strong>make &amp;object</strong> etc.</p>
<p>It's a bit jarring to look at.  Not as jarring as <strong>to #[datatype! integer!]</strong> of course, and I'd imagine one would get used to it.</p>
<p>But it has another downside... <strong>&amp;integer</strong> is a datatype literal, and this literalness makes it something that can't be as easily redefined as if it was a WORD! that was looked up to a datatype.  :-/</p>
<p>One might ask why you can't avoid naming the type constraint entirely, and always speak in terms of functions.  This means you would always have to write <strong>match [any-series?] value</strong> instead of <strong>match any-series! value</strong>.  The reasoning is that we want to be able to write things like:</p>
<pre><code>&gt;&gt; parse ["abc" [d e f]] [some any-series!]
== [d e f]
</code></pre>
<p>Since the point is to help people distinguish between actual cell types and type constraints, perhaps that could be done with another naming convention nuance?  Like two exclamation points on type constraints vs. one on fundamental types...  <strong>any-value!!</strong> and <strong>logic!!</strong> vs. <strong>integer!</strong>  ?  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<pre><code>&gt;&gt; parse ["abc" [d e f]] [some any-series!!]
== [d e f]
</code></pre>
<p>Maybe the ANY is enough to give the hint, and then other type constraints could be named things like <strong>is-even!</strong> or <strong>is-splice!</strong>.  This would clue people to not write things like <strong>make is-logic! [...]</strong> or <strong>is-logic! = kind of value</strong>.</p>
<p>That might be a semi-reasonable solution to the problem: name your type constraints with a leading <strong>IS-</strong> or <strong>ANY-</strong>.  Anything without such a prefix should be left to fundamental types.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983#post_5</link>
        <pubDate>Sun, 16 Apr 2023 20:59:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6597</guid>
      </item>
      <item>
        <title>Should ANY-VALUE! Include Isotopes?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So if you don't put any type restrictions on a parameter, it will allow isotopes:</p>
<pre><code> &gt;&gt; foo: func [x] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p>And right now, that is a synonym for ANY-VALUE!.</p>
<pre><code> &gt;&gt; foo: func [x [any-value!]] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p><strong>But what if you want to exclude isotopes?</strong>  We could have a name for the typeset excluding isotopes (perhaps ANY-CELL!).  Or we could say that ANY-VALUE! doesn't include isotopes by default, and so you have to write <strong>[any-value! isotope!]</strong> if you want them... or just include the specific ones you intend (like <strong>[null! any-value!]</strong>.</p>
<p>Right now I'm going the route of saying ANY-CELL! is the narrower set of values that do not include isotopes.  Is there a better term for saying something can be put into an array vs. not?</p>
<p><em>"10 is an integer! which is legal to use as a cell, while ~null~ isotopes are not legal as cells, but can be variable values"</em></p>
<p>It seems shorter and cleaner than ANY-REIFIED!  or something like that.  I don't know any better options.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-any-value-include-isotopes/2026#post_1</link>
        <pubDate>Fri, 14 Apr 2023 21:37:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6595</guid>
      </item>
      <item>
        <title>TRY... *again* :roll_eyes:</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I have proposed a concept for TRY as trapping definitional errors and turning them into nulls, like this:</p>
<pre><code>&gt;&gt; take []
** Error: you can't take from an empty block (stopping further code)

&gt;&gt; try take []
== ~null~  ; isotope
</code></pre>
<p>And I'll just give a reminder that as this is trapping <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">definitional errors</a>.  So failures from deeper inside code would not be caught... only errors that are returned by contract from the function being called.</p>
<pre><code>&gt;&gt; try compose [(1 / 0)]
** Error: division by zero (e.g. COMPOSE itself didn't raise the error)
</code></pre>
<p><em>I'll remind everyone that it's a very slippery slope to trap "deep errors", and this is why the deep error trapping concept is <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871/3">hidden away as <code>sys.util.rescue</code></a>)</em></p>
<h2>Why Return NULL From TRY (vs. void) ?</h2>
<p>The decision to return null is to make the result falsey so it can be acted on:</p>
<pre><code>while [item: try take block] [
    ...
]

all [
    try take block  ; if this fails we don't want to keep going
    ...
]
</code></pre>
<p>In the vernacular I use, I call NULL "soft failure".  So TRY "converts a definitional failure into soft failure", passing through all other results as-is.</p>
<h2>Comparison with similar word MAYBE</h2>
<p>The MAYBE operation was defined as something that converts nulls to voids, and passes through everything else.  If you didn't know that, it's easy to see not intuiting what the difference between <strong>try take block</strong> and <strong>maybe take block</strong> would be.</p>
<p>You can get some odd-looking combinations with this, e.g.</p>
<pre><code> &gt;&gt; block1: [a b c]
 &gt;&gt; block2: []

 &gt;&gt; append block1 maybe try take block2
 == [a b c]
</code></pre>
<p>Which makes one wonder if MAYBE could be used to trap definitional errors as well as nulls and turn them into voids, so you could just write <strong>append block1 maybe take block2</strong>.</p>
<p>So it raises the question: are there null-returning operations that also return definitional errors, where one would want to suppress the null but not the error?  There's not enough experience for me to say yet.</p>
<h2>Usage in PARSE as opposed to OPT?</h2>
<p>I've wondered if TRY and MAYBE could have parallel meanings in PARSE, where you use TRY to continue but get NULL and MAYBE to skip things:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" maybe some "b"]
== "a"

&gt;&gt; parse "aaa" [some "a" var: try some "b"]
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; var
== ~null~  ; isotope
</code></pre>
<p>Seeing the two operations as being very similar--only one voids while the other one nulls--feels interesting.  I just hadn't thought of MAYBE as a definitional-error-suppressor before.</p> ]]></description>
        <link>https://forum.rebol.info/t/try-again/2025#post_1</link>
        <pubDate>Fri, 14 Apr 2023 21:22:46 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6594</guid>
      </item>
      <item>
        <title>What Should TYPE OF an Isotope Be?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1983">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I suspect I'm missing something here. But as with most things, I guess I just have to kind of try things and feel them out.</p>
</blockquote>
</aside>
<p>I believe what I was missing is that really, <strong>switch type of x [...]</strong> is broken because it goes through a middle-man... some concept of "type".  You have to get a good answer for TYPE OF for everything, which you are then switching on.</p>
<p>Better is something like <strong>switch/type x [...]</strong> where <em>type constraints</em> (compositions of arbitrary functions) can power the process with access to the full value.</p>
<p>There is no special "type" for a block that contains a single word... it's just <em>"a block"</em>.  Similarly I'd say there is there is no special "type" for an isotope of a group... it's just <em>"an isotope"</em>.</p>
<p>Now we have TYPE-WORDs to capture this idea:</p>
<pre><code>&gt;&gt; type of 10
== &amp;integer

&gt;&gt; type of [a]
== &amp;block

&gt;&gt; type of first ['a]
== &amp;quoted

&gt;&gt; type of true  ; it's an isotope of the word TRUE
== &amp;isotope

&gt;&gt; type of null  ; it's an isotope of the word NULL
== &amp;isotope
</code></pre>
<p>Saying that the TYPE OF VOID is ~null~ instead of &amp;void creates a little bit of a speedbump, but would honor the void-in-null-out convention.  I can't say offhand whether it's great or not.</p>
<h2>Things like INTEGER! should probably not be TYPE-WORDs</h2>
<p>Right now in my prototype, <strong>integer!</strong> is defined as <strong>&amp;integer</strong> so you can use it in a switch statement as was done classically.  But this is likely to lead to problems, when people try to write things like:</p>
<pre><code>switch type of x [
    logic! [...]  ; can't work, logic! is &amp;(logic?), not &amp;isotope
    null! [...]  ; can't work, null! is &amp;(null?), not &amp;isotope
    even-integer! [...]  ; more obviously couldn't work
 ]
</code></pre>
<p>So I propose making <em>none</em> of the ending-in-exclamation forms work, by defining:</p>
<pre><code>integer!: &amp;(integer?)
block!: &amp;(block?)
</code></pre>
<p>They'll be type constraints that can work with <strong>match</strong> or in a function spec block.  But then anything that operates mechanically on fundamental types would use the <strong>&amp;integer</strong> form.</p>
<p>This can be made backwards compatible in bootstrap Ren-C, because it let you use ampersands in word names.  So the workaround for bootstrap would be:</p>
<pre><code>&gt;&gt; &amp;integer: integer!
== #[datatype! integer!]
</code></pre>
<p>While the &amp; forms may be a bit uglier and less familiar, the goal would be to convince people to change from <strong>switch</strong> to using <strong>match</strong> so they could use the exclamation forms...which is probably what they wanted if they wanted to test for <strong>logic!</strong> or <strong>null!</strong> etc.</p>
<h2>We May Want to Call This KIND OF vs. TYPE OF</h2>
<p>Over the long term I'm not sure what sort of type system a Redbol-type language could have.  We could imagine TYPE OF being a rich answer that came back from an &amp;object to describe its heritage.</p>
<p><strong>kind of</strong> is a little narrower than implying some elaborate type system.  It would leave TYPE OF for future use.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983#post_4</link>
        <pubDate>Fri, 14 Apr 2023 00:02:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6593</guid>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="1300">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I've made the suggestion that ANY-VALUE! might need to just be a "typecheck-flavored function". So some form of function where you know the implicit meaning is to use it to match types.</p>
<p>Hand-waving what that sort of thing might look like:</p>
<pre><code>any-even!: &amp;(even?)

parse [2 4 6] [some any-even!]
</code></pre>
</blockquote>
</aside>
<p><em>"MORE Time Has Passed, And I Haven't Had Any Better Ideas"</em>.  Pushing forward with isotopes made an already bad situation with the 64-bit TYPESET! worse.  Isotopes bring in a new isotopic form of every datatype, necessitating things like <strong>splice!</strong>, <strong>activation!</strong>, and <strong>matcher!</strong>.  But my verdict is that isotopes (and the reimagining of void) are the undeniable direction of solution to classic problems with the language...so...</p>
<p><strong>I have implemented the strategy, and it is limping along...actually running.</strong></p>
<h2>New Types: &amp;word, &amp;tu.p.le, &amp;pa/th, &amp;[...], &amp;(...)</h2>
<p>I decided to take the ampersand to make TYPE-WORD!, TYPE-BLOCK!, TYPE-GROUP!, etc.</p>
<p>A basis of this replacement for typesets is that <strong>&amp;(...)</strong> are "type AND groups" and <strong>&amp;[...]</strong> are "type OR groups".</p>
<p>Spec blocks convert regular blocks to these implicitly, and you can combine them there without the ampersand:</p>
<pre><code>foo: func [arg [(integer! negative?) block!]] [
    ... you know arg is either a negative integer or a block ...
]
</code></pre>
<p>If the argument wouldn't pass the type checking of a function referenced in one of the type containers, then that counts the same as a failure.  Hence NEGATIVE? would imply a test for DECIMAL! or INTEGER!.</p>
<h2>Exempting ANY-VALUE? from taking ANY-VALUE!</h2>
<p>In order to solve the recursive nature of this, the ANY-VALUE? function has no type on its argument...which means don't type check it.  Hence ANY-VALUE! can indeed be expressed as &amp;(any-value?) without causing an infinite loop.</p>
<p>Of course, opening typechecking to arbitrary computation does introduce a lot of potential for problems...including but not limited to infinite loops.  But we can get infinite loops a lot of ways.</p>
<h2>Speeding Up Checks for Common Types</h2>
<p>When you express something like the type constraint for ANY-SERIES! as &amp;(any-series?) that might make it seem that each call to a function like APPEND would always be calling a type checking function--possibly several.  This seems to add significant overhead.</p>
<p><em>But I added an optimization.</em>  The type checking machinery can make exceptions for these built-in cases and just skip the function call...doing a fast test based on something like the historical bitset-based typesets...so long as ANY-SERIES? points to the definition it thinks it does.</p>
<h2>LOGIC! is a type constraint</h2>
<p>With this, we see LOGIC! ceases to be a foundational type, but a type constraint...it's actually an isotopic word which passes the test for logic by being either isotopic ~false~ or ~true~:</p>
<pre><code>logic!: &amp;(logic?)
</code></pre>
<p>And this ushers in a new era of thinking about the usage of types.  It means moving away from:</p>
<pre><code> switch type of x [  ; old way
     logic! [...]  ; would never happen, since TYPE OF TRUE is &amp;isotope
     block! [...]
 ]
</code></pre>
<p>So this should be replaced with something new where the type constraint function or matching is called.  We're running out of words, so I propose a refinement as <strong>switch/type</strong></p>
<pre><code>switch/type x [
    logic! [...]
    block! [...]
]
</code></pre>
<p>The question of what concrete type something is will matter in a few cases, but we'll just have a limited number of concrete types, which will include <strong>&amp;isotope</strong> and <strong>&amp;quoted</strong>.  So you won't be able to say <strong>type of</strong> and get back a logic! (for instance)</p>
<h2>Hence, TYPESET! No Longer Exists</h2>
<p>This solves the typeset representation problem because they just don't exist anymore.  They are functions, some of which are native and can be recognized and tested for without going through function calling machinery.</p>
<p>You need to use MATCH functions with them.  Because if you try to FIND on what you think of as a typeset, you will just be interacting with it as a block or group...nothing special.</p>
<pre><code>&gt;&gt; positive-integer!
== &amp;(integer! positive?)

&gt;&gt; find positive-integer! 'positive?
== &amp;(positive?)
</code></pre>
<p>So instead, use <strong>match</strong> function is how to do type tests... not FIND.</p>
<pre><code>&gt;&gt; match positive-integer! 10
== 10

&gt;&gt; match positive-integer! -10
== ~null~  ; isotope

&gt;&gt; match positive-integer! "hello"
== ~null~  ; isotope
</code></pre>
<h2>Amazingly I Have This Working, But It's Far From Good</h2>
<p>The code is a wreck, held together only by the fact that it's got so many asserts in it that I can make it limp along.  It will take time to hammer it into shape good enough to push out.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300#post_12</link>
        <pubDate>Wed, 12 Apr 2023 18:53:13 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6592</guid>
      </item>
      <item>
        <title>The Handling of NULL in UPARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>By design, nulls are handled noisily--right at the moment of fetching the word!--in UPARSE (and PARSE3):</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [prefix, some "a", suffix]
** Error: (prefix is null, and we raise errors for that in parse)
</code></pre>
<p>If we didn't raise an error it seems there are only two other options:</p>
<ol>
<li>
<p>Make <strong><code>null</code></strong> always succeed, keeping the parse position where it is (synonym for <strong><code>[]</code></strong>)</p>
</li>
<li>
<p>Make <strong><code>null</code></strong> always be an unsuccessful combinator match, but not cause a failure (synonym for <strong><code>false</code></strong>)</p>
</li>
</ol>
<p>I think (1) feels like a pretty obvious bad idea, because null is supposed to represent a soft failure.  I've suggested that this is a better behavior for void, e.g. <strong><code>parse "ab" ["a" void "b"]</code></strong> would work.</p>
<p>I'm not too pleased with the idea of (2), and prefer the error as the default.</p>
<p><em>...that said...</em> it seems there should be some operators or combinators that let you get the other behaviors.</p>
<h2>What About a "MAYBE" Combinator To Use With Null?</h2>
<p>In standard code, the policy of "void-in-null-out" has worked well, with MAYBE transforming soft-failure nulls to voids:</p>
<pre><code> ; non-PARSE handling of NULL via MAYBE

 &gt;&gt; append [a b c] null
 ** Error: cannot append ~null~ isotope to a block

 &gt;&gt; append [a b c] maybe null
 == [a b c]

 &gt;&gt; block: null

 &gt;&gt; append maybe block [d e]
 == ~null~  ; isotope
</code></pre>
<p>So if we imagine applying this to the parse example, it would presumably do this:</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [maybe prefix, some "a", maybe suffix]
== ")"
</code></pre>
<p>For the above parse to succeed, the combinator made by <strong>maybe prefix</strong> would have to succeed and not advance the input.</p>
<h2>But It Doesn't Combine Well In Larger Rules</h2>
<p>What if what you intended was <em>"if there's a prefix, match some non-zero number of instances, but if prefix is null then don't worry about matching"</em>:</p>
<p>You might try doing that by COMPOSE'ing your rules.  But UPARSE actually lets us write that out literally using GET-GROUP! rule synthesis:</p>
<pre><code>&gt;&gt; parse "aaa)))" [:(if prefix '[some prefix]), some "a", :(if suffix '[some suffix])]
== ")"
</code></pre>
<p>But what if we tried to do that with MAYBE...could it work?</p>
<pre><code>&gt;&gt; parse "aaa)))" [some maybe prefix, some "a", some maybe suffix]
; infinite loop!
</code></pre>
<p>No dice.  We've said <strong>maybe prefix</strong> just succeeds and doesn't advance the input when prefix was null.  But if you combine that with <code>some</code> the null case will just match nothing in perpetuity, causing an infinite loop.</p>
<p>This may look familiar, because if you write <strong>some opt [...anything...]</strong> you'll always get an infinite loop.  But in that case it's just wrong thinking: you know that the repetitive nature of <code>some</code> looking for an eventual non-match meant you must have intended <strong>some [...anything...]</strong> (at least one) or <strong>opt some [...anything...]</strong> (zero or more).</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji only-emoji" alt=":thinking:"></p>
<blockquote>
<h3>NOTE THAT HISTORICAL PARSE HAS NO GOOD ANSWER FOR THIS</h3>
<p>Rebol2 treats NONE! as a no-op which just succeeds but doesn't advance the input.  So the following gives you an infinite loop:</p>
<pre><code>rebol2&gt;&gt; prefix: none suffix: ")"

rebol2&gt;&gt; parse "aaa)))" [some prefix some "a" some suffix]   
; infinite loop
</code></pre>
<p>The hackish "must make progress" rules in R3-Alpha actually make the above "work as intended", because the SOME will bail out after one non-advancing match.  I don't consider that a "good" answer--more a random effect.</p>
</blockquote>
<h2>Another Problem: MAYBE is a very similar word to OPT</h2>
<p>Imagine looking at this code:</p>
<pre><code>&gt;&gt; prefix: "(", suffix: ")"

&gt;&gt; parse "aaa)" [maybe prefix, some "a", maybe suffix]
== ~null~  ; isotope
</code></pre>
<p><em>"But wait"</em>... I can imagine someone saying... <em>"doesn't that mean that if it's not there, you skip the rule"</em>?</p>
<blockquote>
<p>I've had some mental back-and-forth about the words <strong><code>try</code></strong>, <strong><code>opt</code></strong>, and <strong><code>maybe</code></strong>...with a general dislike of the word OPT.  The current idea is that TRY was intended to defuse harder definitional errors:</p>
<pre><code>&gt;&gt; take []
** Error: you can't take from an empty block (stopping further code)

&gt;&gt; try take []
== ~null~  ; isotope
</code></pre>
</blockquote>
<h2>An extra barrier to creating MAYBE is mechanical</h2>
<p>... <em>because the error that NULL generates is the "null combinator" itself</em>.  It is <em>not</em> a definitional error, because those just represent things like "type didn't match".</p>
<p>The only way I can see a null-disabling MAYBE parse combinator working would be by quoting its argument, doing the rule fetch itself, and turning into a failing combinator if it fetched null.  This breaks the model somewhat.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<h2>Maybe <strong>/prefix</strong> could Mean Optionally-Null variable?</h2>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [/prefix, some "a", /suffix]
== ")"
</code></pre>
<p>It's already the case that paths have to be quoted to match in blocks, but a leading slash could be used to deal with the rules.</p>
<p>It's a lot to think about on my first day of thinking about Rebol stuff for a while!  But there you go.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-handling-of-null-in-uparse/2023#post_1</link>
        <pubDate>Fri, 07 Apr 2023 00:14:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6590</guid>
      </item>
      <item>
        <title>Should REDUCE Heed SPREAD?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1917">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>When <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">suggesting the term SPREAD </a>, <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> gave this example for REDUCE behavior, which hadn't occurred to me previously:</p>
<pre><code>&gt;&gt; reduce [spread [a b c] [a b c]]
== [a b c [a b c]]
</code></pre>
</blockquote>
</aside>
<p>I think I've mentioned before that this raises some questions about how casual we should be about variables holding isotopes.</p>
<p>We already know that true and false isotopes, as well as null isotopes, have to be able to be accessed casually.  How about splices?</p>
<p>For instance, should you be able to write this:</p>
<pre><code>&gt;&gt; x: spread [a b c]

&gt;&gt; reduce [x x]
== [a b c a b c]
</code></pre>
<p>Should the assignment itself create an error without a SET/ANY?</p>
<pre><code>&gt;&gt; x: spread [a b c]
** Error: Can't assign isotopes without SET/ANY

&gt;&gt; set/any 'x spread [a b c]
== ~(a b c)~
</code></pre>
<p>Or should you need to use a special form of access, like GET-WORD!?</p>
<pre><code>&gt;&gt; reduce [x x]
** Error: X contains a splice isotope, access with GET-WORD!

&gt;&gt; reduce [:x :x]
== [a b c a b c]
</code></pre>
<p><strong>At this point I think I'm leaning to saying the plain access works.</strong>  Remember this old behavor:</p>
<pre><code>rebol2&gt;&gt; x: [a b c]

rebol2&gt;&gt; append [a b c] x
== [a b c a b c]
</code></pre>
<p>Looked at that way, it's kind of like you were "appending a splicing isotope through a plain reference".</p> ]]></description>
        <link>https://forum.rebol.info/t/should-reduce-heed-spread/1917#post_4</link>
        <pubDate>Fri, 17 Mar 2023 16:07:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6588</guid>
      </item>
      <item>
        <title>Naming void&#39;s isotopic, quoted, and quasi forms</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I've called the state of unset variables "nihil"... <strong>this is the isotopic state of void</strong>.  I don't know if it's the best name but I definitely know I don't like calling it "unset" (I always say "variables are unset, not values").</p>
<p>The meta state of void is just a single apostrophe.  Evaluating it produces void:</p>
<pre><code>&gt;&gt; '
; void
</code></pre>
<p>The quasi state of void is a single tilde, and it evaluates to nihil:</p>
<pre><code>&gt;&gt; ~
== ~  ; isotope  &lt;-- a.k.a. nihil
</code></pre>
<p>I mentioned that I prefer this to be the default for making an ARRAY if you don't specify an /INITIAL value because it is the reified stand-in for uninitialized-ness.  Unlike blanks, it would error if you try to SPREAD it:</p>
<pre><code>&gt;&gt; block: array 10
== [~ ~ ~ ~ ~ ~ ~ ~ ~ ~]

&gt;&gt; spread block.2
** Error...
</code></pre>
<p>This seems to me a better default than blank for any slots that you miss filling in for your arrays.</p>
<p><strong>So what do we call <code>[']</code> and <code>[~]</code></strong>?  Metavoid and Quasivoid?  Tick and tilde?  Is tilde a Metanihil?</p>
<p>I've also wondered if there's any better name for nihil.</p> ]]></description>
        <link>https://forum.rebol.info/t/naming-voids-isotopic-quoted-and-quasi-forms/2021#post_1</link>
        <pubDate>Fri, 03 Mar 2023 21:55:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6587</guid>
      </item>
      <item>
        <title>Correct Formulation of ME and MY</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The ME function is used with enfix to allow you to avoid repeating the name of a variable:</p>
<pre><code>&gt;&gt; variable: 10

&gt;&gt; variable: me + 1
== 11

&gt;&gt; variable
== 11
</code></pre>
<p>So that's the same as if you'd written <strong>variable: variable + 1</strong>.</p>
<p>There's an analogous operation for non-enfix functions called MY.</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; block: my next
== [b c]

&gt;&gt; block
== [b c]
</code></pre>
<p>So the same if you had written <strong>block: next block</strong>.</p>
<h2>Here Is The "Naive" Macro Implementation of ME</h2>
<pre><code>me: enfixed macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
][
    reduce [left, plain left, right]
]
</code></pre>
<p>So the macro is looking for a SET-WORD! or SET-TUPLE! on the left, and then something indicating the action to run on the right.  It replaces the whole sequence with what was on the left, then a plain WORD! or TUPLE! version of what was on the left, and then what's on the right.</p>
<p>MY is done similarly, just with <strong>reduce [left, right, plain left]</strong> to put the repeated term after the call.</p>
<p>This is naive for two reasons:</p>
<ul>
<li>
<p>It doesn't check that what the RIGHT parameter looks up to is an action</p>
</li>
<li>
<p>If the SET-TUPLE! in LEFT has a GROUP! in it, then it will be executed twice.</p>
</li>
</ul>
<h2>Here is A "Non-Naive" Implementation of ME</h2>
<pre><code>macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
    &lt;local&gt; value
][
    [left value]: resolve left  ; avoid double-evaluation
    :['set left meta value ensure action! get right]
]
</code></pre>
<p>The RESOLVE function is used to turn a TUPLE! or PATH! with groups in it into an inert representation:</p>
<pre><code> &gt;&gt; blk: [a b [c d]]

 &gt;&gt; resolve 'blk.(print "hi", 1 + 2).2
 hi
 == @[blk 3 2]
</code></pre>
<p>GET and SET accept these blocks as an alternative to words/tuples to be used to describe what to set or get.</p>
<p>It has to use a BLOCK! representation because not all things can be represented in paths that can be used with picking (note this implies you cannot pick with isotopes, otherwise not all blocks would be resolvable).</p>
<p>So long as RESOLVE is walking the path, you can ask it to give you back the value of what's there.</p>
<h2>But the non-naive version triggers a binding bug...</h2>
<p>It's also rather slow.  In trying to prioritize, it may be better to just document the right answer, as I've done here... :-/</p> ]]></description>
        <link>https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020#post_1</link>
        <pubDate>Fri, 03 Mar 2023 21:23:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6586</guid>
      </item>
      <item>
        <title>ChatGPT Speaking About Rebol</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p><strong>Do you know REN-C?</strong></p>
<p>Yes, I am familiar with REN-C. REN-C is a fork of the Rebol 3 language that is maintained by the community after the original Rebol 3 project was abandoned. The goal of REN-C is to continue the development of the Rebol language and improve its performance, stability, and compatibility with other systems.</p>
<p>REN-C includes many improvements and new features over the original Rebol 3, such as enhanced garbage collection, better error handling, improved performance, and support for new platforms. REN-C also aims to maintain compatibility with existing Rebol 3 code and libraries.</p>
<p>REN-C is developed by a community of volunteers who are passionate about the Rebol language and its potential. The project is open-source and welcomes contributions from anyone who wants to help improve the language.</p>
<p>Overall, REN-C is a promising project that seeks to continue the development of the Rebol language and keep it relevant and useful for modern computing.</p>
<p>And chatGPT tells us how amazing REN-C is, but does REN-C get too much honor here?<br>
<strong>Can you tell me about some amazing REN-C programs</strong></p>
<p>There are many interesting and impressive programs that have been developed using REN-C. Here are a few examples:</p>
<pre><code>Red language: Red is a programming language and development environment that is built on top of REN-C. Red is a high-level language that is designed to be fast, expressive, and portable. It includes many advanced features, such as automatic memory management, data serialization, and network protocols. Red is used for a wide range of applications, including desktop applications, games, and web development.

Rebmu: Rebmu is a minimalist programming language that is designed to be concise and expressive. Rebmu is implemented in REN-C and includes a small set of operators and functions that can be combined to create complex programs. Rebmu is used for scripting, automation, and code generation.

RebolView: RebolView is a GUI toolkit that is built on top of REN-C and provides a set of reusable GUI components and tools for building desktop applications. RebolView includes support for a wide range of widgets, including buttons, text fields, and menus. It also includes support for advanced features, such as drag-and-drop and clipboard management.

RebolBot: RebolBot is a chatbot that is built on top of REN-C and provides a simple interface for interacting with Rebol code and libraries. RebolBot can be used for testing, debugging, and learning the Rebol language.

Rebol Database: Rebol Database is a database management system that is implemented in REN-C and provides a simple and lightweight way to store and retrieve data. Rebol Database includes support for multiple storage engines, including memory-based and file-based storage. It also includes support for advanced features, such as indexing and transactions.
</code></pre>
<p>These are just a few examples of the many interesting and innovative programs that have been developed using REN-C. The flexibility and expressiveness of the Rebol language, combined with the performance and stability of REN-C, make it a powerful platform for a wide range of applications.</p> ]]></description>
        <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997#post_4</link>
        <pubDate>Thu, 02 Mar 2023 19:59:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6583</guid>
      </item>
      <item>
        <title>Compiling ren-c with zig?</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>. I just hoped it might be an easy way for cross compiling. If it isn't it's not worth the time.</p> ]]></description>
        <link>https://forum.rebol.info/t/compiling-ren-c-with-zig/2017#post_3</link>
        <pubDate>Wed, 01 Mar 2023 13:20:30 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6581</guid>
      </item>
      <item>
        <title>Pikchr Drawing Dialect</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>This is an interesting dialect-looking thing that's a Unix utility someone showed me for diagrams.  It might interest <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>, or others.  It's called PIKCHR.</p>
<p>You can try it online at <a href="https://pikchr.org/home/pikchrshow">https://pikchr.org/home/pikchrshow</a> ... there are a few examples.</p>
<p>It's a textual set of instructions that lets you lay things out... but differently from something like PDF, it captures intents in a pretty interesting way for aligments and duplication.</p>
<p>Look how it lays out this "swim lanes" example graphic:</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/babd46454d69ba774a09050d20d26dc3e2e9e326.png" alt="image" data-base62-sha1="qDYklKuijn94kAkO07RmNG9E6YS" width="520" height="449"></p>
<pre><code>$laneh = 0.75
# Draw the lanes
down
box width 3.5in height $laneh fill 0xacc9e3
box same fill 0xc5d8ef
box same as first box
box same as 2nd box
line from 1st box.sw+(0.2,0) up until even with 1st box.n "Alan" above aligned
line from 2nd box.sw+(0.2,0) up until even with 2nd box.n "Betty" above aligned
line from 3rd box.sw+(0.2,0) up until even with 3rd box.n "Charlie" above aligned
line from 4th box.sw+(0.2,0) up until even with 4th box.n "Darlene" above aligned
# fill in content for the Alice lane
right
A1: circle rad 0.1in at end of first line + (0.2,-0.2) fill white thickness 1.5px "1"
arrow right 50%
circle same "2"
arrow right until even with first box.e - (0.65,0.0)
ellipse "future" fit fill white height 0.2 width 0.5 thickness 1.5px
A3: circle same at A1+(0.8,-0.3) "3" fill 0xc0c0c0
arrow from A1 to last circle chop "fork!" below aligned
# content for the Betty lane
B1: circle same as A1 at A1-(0,$laneh) "1"
arrow right 50%
circle same "2"
arrow right until even with first ellipse.w
ellipse same "future"
B3: circle same at A3-(0,$laneh) "3"
arrow right 50%
circle same as A3 "4"
arrow from B1 to 2nd last circle chop
# content for the Charlie lane
C1: circle same as A1 at B1-(0,$laneh) "1"
arrow 50%
circle same "2"
arrow right 0.8in "goes" "offline"
C5: circle same as A3 "5"
arrow right until even with first ellipse.w "back online" above "pushes 5" below "pulls 3 &amp; 4" below
ellipse same "future"
# content for the Darlene lane
D1: circle same as A1 at C1-(0,$laneh) "1"
arrow 50%
circle same "2"
arrow right until even with C5.w
circle same "5"
arrow 50%
circle same as A3 "6"
arrow right until even with first ellipse.w
ellipse same "future"
D3: circle same as B3 at B3-(0,2*$laneh) "3"
arrow 50%
circle same "4"
arrow from D1 to D3 chop</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/pikchr-drawing-dialect/2018#post_1</link>
        <pubDate>Tue, 28 Feb 2023 22:17:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6579</guid>
      </item>
      <item>
        <title>Compiling ren-c with zig?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I gave it a shot tonight just to see if it was easy.  Doesn't look like a "it just works" situation.</p>
<p>I couldn't figure out how to get it to act like a C99 compiler.  It defines <code>__cplusplus</code> but then doesn't provide the headers for C++ (like <code>&lt;string&gt;</code> or <code>&lt;type_traits&gt;</code>).</p>
<p>If you can research or ask to see how to get it to not define __cplusplus then I can take another crack at it.  But right now I'm mostly worrying about existential questions of Ren-C... so not a lot of time for detours.</p> ]]></description>
        <link>https://forum.rebol.info/t/compiling-ren-c-with-zig/2017#post_2</link>
        <pubDate>Tue, 28 Feb 2023 02:49:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6578</guid>
      </item>
      <item>
        <title>Compiling ren-c with zig?</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>Has anyone tried to compile ren-c with zig? ( <a href="https://www.ziglang.org">https://www.ziglang.org</a> ).</p>
<p>They claim to be able to compile c-code using zig cc , and have an impressive list of cross compilation targets, wasm among them.</p>
<p><a href="https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler">https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler</a></p>
<p><a href="https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case">https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case</a></p> ]]></description>
        <link>https://forum.rebol.info/t/compiling-ren-c-with-zig/2017#post_1</link>
        <pubDate>Wed, 22 Feb 2023 21:31:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6577</guid>
      </item>
      <item>
        <title>Kaitai Struct Declarative Language for Binary Formats</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>This is an interesting declarative language in YAML designed to generate classes for binary formats.  There are many formats defined:</p>
<p><a href="https://formats.kaitai.io/">https://formats.kaitai.io/</a></p>
<p>That's a lot of cases...but as one instructive example, you can look at how it describes a ZIP file--with little snippets of code in it for extracting the values:</p>
<p><a href="https://formats.kaitai.io/zip/" class="inline-onebox">ZIP archive file format spec for Kaitai Struct</a></p>
<p>The C++ code generated is like this:</p>
<p><a href="https://formats.kaitai.io/zip/cpp_stl_11.html" class="inline-onebox">ZIP archive file: C++11/STL parsing library</a></p>
<p>But it also can also be used to make code for C#, JavaScript, Python, Ruby, Nim, PHP, Lua, Perl... <em>(though we'd assume that if you escape code in, that part will only work be available for that language)</em></p>
<p>The regimentation of YAML provides the typical repetition in the "dialect".  This is the same as the Rebol complaint about JSON--not really leveraging "parts of speech", but repeating tags over and over like <code>id:</code> and <code>type:</code></p>
<pre><code>  - id: version
    type: u2
  - id: flags
    type: gp_flags
    size: 2
  - id: compression_method
    type: u2
    enum: compression
</code></pre>
<p>But it's still pretty hard to compete with, especially when you consider this is giving a compilable specification...so the performance is going to be much better.</p>
<p>I always thought BINARY! parse was something that Rebol would have a unique story for, and Ren-C's UPARSE makes that a stronger story (by allowing rules to synthesize arbitrary results via extraction)... but seeing this kind of stuff reminds me that there are diminishing returns.</p> ]]></description>
        <link>https://forum.rebol.info/t/kaitai-struct-declarative-language-for-binary-formats/2016#post_1</link>
        <pubDate>Tue, 21 Feb 2023 22:36:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6576</guid>
      </item>
      <item>
        <title>Line Continuation and Arity Bugs: Thoughts?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1965">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<h2>I Just Got Bit By a Variadic QUIT Bug</h2>
<p>Without thinking about it, I tried to end some code prematurely by injecting a quit:</p>
<pre><code>some stuff I wanted to run

quit  ; added this

some stuff I wanted to avoid running
</code></pre>
<p>And that QUIT ran the stuff I didn't want to run anyway, because it was variadic (and acted as QUIT/WITH SOME STUFF I WANTED TO AVOID RUNNING).</p>
</blockquote>
</aside>
<p>I realized this issue is very similar to problems that come up in JavaScript with "automatic semicolon insertion":</p>
<p><a href="https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion" class="inline-onebox">JavaScript/Automatic semicolon insertion - Wikibooks, open books for an open world</a></p>
<p>JavaScript doesn't require semicolons at the ends of lines.  There's some debate on whether to take advantage of this--but I'm one of the people who believes it makes the code cleaner.  But cases like RETURN have a parallel problem in JavaScript.</p>
<p>So JavaScript's <code>return</code> is variadic, but the automatic semicolon would bias it so that if you have some stuff on a line after a return it gets ignored.</p>
<p><em>The complexity of the situation makes me feel like erring on the side of fixed arity.</em>  If you want to return nothing, say <strong><code>return none</code></strong>.  And if you want to return void, say <strong><code>return void</code></strong>.  It's more explicit, and I think the "naked" returns probably do more harm than good.</p>
<p>I don't think people will use passing arguments to continue too often, but <strong><code>continue/with value</code></strong> isn't terrible</p> ]]></description>
        <link>https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965#post_2</link>
        <pubDate>Fri, 10 Feb 2023 17:08:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6575</guid>
      </item>
      <item>
        <title>Should SET-WORD!s Have &quot;Raised Error Interception&quot;?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Division by zero is a simple example of something that produces a "definitional error".  <em>It's considered to be "emitted" by the division</em>, and if you try to "move on" without handling it, the raised error becomes a failure that <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871">you can only catch at some top level by SYS.UTIL.RESCUE</a>.</p>
<p>For instance:</p>
<pre><code>&gt;&gt; 1 / 0, 2 + 0
** Math Error: attempt to divide by zero
** Where: / console
** Near: [1 / 0 **, 2 + ***]
</code></pre>
<p>What happened was that <strong>1 / 0</strong> evaluated, but rather than forcing a "hard failure" (e.g. running FAIL) it instead <em>returned a raised error</em>.  There's an opportunity if that raised error were to be intercepted, but in this case it just moseyed along to the next expression... so the raised error was promoted to a failure.</p>
<p>However a ^META oriented function can trap that, and react to it, allowing you to continue.  EXCEPT is such a function:</p>
<pre><code>&gt;&gt; 1 / 0 except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p>One thing that pretty obviously shouldn't count as "moving on" would be parentheses.  Adding parentheses shouldn't change the situation, they just pass any raised errors through:</p>
<pre><code>&gt;&gt; (1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2

&gt;&gt; ((((1 / 0)))) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p><strong>But what about things like SET-WORD!s?</strong>  Right now, it does not raise an error and just skips the assignment, and lets the code continue:</p>
<pre><code>&gt;&gt; num: &lt;before&gt;

&gt;&gt; (num: 1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2

&gt;&gt; num
== &lt;before&gt;
</code></pre>
<p><strong>This is a useful pattern, but if we do it for SET-WORD!s then we have to ask whether it should be done for SET the function as well...</strong></p>
<pre><code>&gt;&gt; (set 'num 1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p>If we do this then the SET function has to take its argument of the value to assign as a ^META argument.  Because raised errors can't be stored in variables, and function parameters are communicated via variables.</p>
<p>This does make SET a more complicated function, and any functions like it might also become complicated.  It's a hard decision to condemn all SET-like functions to take their arguments as ^META so they can proxy any errors and not perform the assignment.</p>
<p>I'll probably have more to say about this, but for the moment both SET and SET-WORD! react to definitional failures by <em>not performing the assignment</em> and <em>propagating the raised error</em>.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-set-word-s-have-raised-error-interception/2015#post_1</link>
        <pubDate>Tue, 07 Feb 2023 02:52:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6574</guid>
      </item>
      <item>
        <title>Difficult Decision: Not Renewing (unlaunched!) Domain Names</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>You are so right in not spending your hard earned money on domain names. Always another option around later.</p> ]]></description>
        <link>https://forum.rebol.info/t/difficult-decision-not-renewing-unlaunched-domain-names/2014#post_2</link>
        <pubDate>Sun, 05 Feb 2023 09:35:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6573</guid>
      </item>
      <item>
        <title>Difficult Decision: Not Renewing (unlaunched!) Domain Names</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A couple of years ago--at <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>'s urging--I had reserved a <code>.com</code>, <code>.org</code>, and <code>.net</code> for launching Ren-C to the public.</p>
<p>But in the intervening years, I put nothing on these domains.  They've been vacant lots, doing little but transferring money from me to the "Namecheap" registrar.  <img src="https://forum.rebol.info/images/emoji/twitter/angry.png?v=9" title=":angry:" class="emoji" alt=":angry:"></p>
<p>Feb 3rd was this year's renewal date, and I disabled auto-renew, and didn't pay.</p>
<h2>If I "Owned" Them, Why Didn't I Use Them?</h2>
<p>I put "owned" in quotes because you don't own domain names, you just rent them.</p>
<p>There are good reasons for not wanting to impart value to these domains prematurely--e.g. not even transferring the forum there.  My worries were:</p>
<ol>
<li>
<p>You don't get a second chance to announce a project.</p>
<ul>
<li>If you need a case study, Red has certainly worn out their welcome on hackernews.</li>
</ul>
</li>
<li>
<p>Once you start using a domain, the content becomes an issue of identity.</p>
<ul>
<li>
<p>You have imparted a value to URLs which is easily stolen by spammers.</p>
</li>
<li>
<p>You become obligated to pay recurring charges to protect your material and identity.</p>
</li>
</ul>
</li>
</ol>
<h2>Why I'm Not Renewing Them, Despite Believing in Ren-C...</h2>
<p><strong>While Ren-C is in my eyes, successful in many areas... given the (long!) timescale we are looking at... I don't think it is necessary to pay for specialized domain names for the project.</strong></p>
<p>The DNS system itself may be obsolete--and AI may be writing all the code--before I get around to finishing this myself. <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:">  Though perhaps I have helped set the goalposts.</p>
<p>I'm basically saying that I'm okay coupling the Ren-C work to the domain names I already have established, or their subdomains, rather than making a separate entity that others would manage.  Those identities (like hostilefork or metaeducation) are a sunk cost, and I can just use those.</p>
<h2>I Put Up Money For A Couple Of Years, Is Not Doing So "Giving Up"?</h2>
<p>Not really.  This is just an epicycle of my firm belief that DNS is not to be trusted any further than you can throw it.  It says more about how I feel about the domain name ecosystem than it says about how I feel about Ren-C.</p>
<p>...and if I hadn't mentioned it, you wouldn't have noticed any difference at all.  Things would seem the same.</p>
<p><em>But in my mind with the huge new design space opening up with isotopes,</em> I will admit that I'm moving closer to the idea that the final product of Ren-C is just more like "demos and papers and code golf gaming".  Not "download the solution to all your problems here".</p>
<p>After all, there are worse things than being the <a href="https://en.wikipedia.org/wiki/Antikythera_mechanism">Antikythera mechanism</a>.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>So I'm not quitting, but I certainly am trying to do a lot more other things in my life these days.  I'll keep hacking on it as time permits, and hopefully we won't be taking too many steps backwards... and the WebAssembly stuff will remain the user-facing focus.</p> ]]></description>
        <link>https://forum.rebol.info/t/difficult-decision-not-renewing-unlaunched-domain-names/2014#post_1</link>
        <pubDate>Sat, 04 Feb 2023 17:56:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6572</guid>
      </item>
      <item>
        <title>Should TRAP and CATCH return null if no fails/throws?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="940">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Looks like we may get the best of both worlds now, with <a href="https://forum.rebol.info/t/forward-to-multiple-return-values-and-return-value-forwarding/1271/2">multiple returns</a>! The TRAP and CATCH could offer a second output which is the value that "falls out" of the evaluation.</p>
</blockquote>
</aside>
<p>So there's a competing application for multi-returns, which is the ability to throw a multi-return... which is more useful:</p>
<pre><code>&gt;&gt; [x fallthrough?]: catch [
       if false [throw pack [1 false]]
       throw pack [2 true]
   ]
== 2

&gt;&gt; x
== 2

&gt;&gt; fallthrough?
== ~true~  ; isotope
</code></pre>
<p>This seems like a much better use of the multi-return ability.  And to my mind, that tips the scales to where you should do a THROW as the last line if you want "the block's result".</p>
<p>Then if you want to detect whether a result came from the end of the block or somewhere inside it, you can do as I did above and encode that as an extra parameter.</p>
<h3>So... should CATCH return NULL or NONE if there's no throw?</h3>
<p><em>Hmmm.</em></p>
<p>Right now functions that lack a RETURN statement return NONE.  As a reminder, this is a multi-return pack of length zero, that has the special console behavior of printing nothing.</p>
<pre><code>&gt;&gt; foo: func [] []
== ~#[action! {foo} []]~  ; isotope

&gt;&gt; foo

&gt;&gt;
</code></pre>
<p>If you really want NULL to come back from a CATCH, you can just say that with THROW NULL.  It's more explicit.</p>
<pre><code>catch [...] else [...]  ; default w/no throw is NONE, would not run ELSE

catch [..., throw null] else [...]  ; would run ELSE
</code></pre>
<p><em>Although...we could say that THROW always throws a "heavy null"...and then ELSE really would mean "didn't catch anything".</em>  That does seem kind of cool, that ELSE really would react to nothing being caught.</p>
<h3>What About Named Throws... How to Know The Name?</h3>
<p><em>Hmmm.</em></p>
<p>I'll start by saying I've personally felt a bit skeptical of named throws, compared with "definitional throws".  :-/</p>
<p>But in any case, if you catch a named throw you might want to know its name.  Though I notice that Red does not tell you:</p>
<pre><code>red&gt;&gt; catch/name [throw/name 304 'red] [red blue]
== 304  ; no indication of if blue or red was caught
</code></pre>
<p>If we imagine you did want to know which name you caught, then here we have another competing interest for the multi-return ability... the /NAME of the throw.</p>
<p>In systems like C++ that support throwing, you can actually say what <em>types</em> of throws you want to receive.  Then you receive an object, potentially re-throwing it.</p>
<p><strong>Maybe this is another opportunity for isotopic objects!</strong>  Recall that isotopic objects can't be stored in variables... they need to have a DECAY method to produce normal values (including potentially a multi-return), or other methods like ELSE and THEN which coerce them.  But they could have a CATCH field which might just be some name or structure.  Then there could be a CATCH/FILTER which would be able to pick over these isotopic objects and decide if the CATCH wanted it or not.</p>
<p>That sounds pretty interesting... there'd be no THROW/NAME, it would be more like:</p>
<pre><code>[x y name]: catch/filter [
    throw isotopic make object! [
        catch: 'orange
        decay: does [pack [1 2 'orange]]
    ]
] obj -&gt; [  ; only filter on isotopic objects, pass plain object here?
    did find [orange green] obj.catch
]
</code></pre>
<p>So something like that would wind up giving you <strong>x</strong> as 1 and <strong>y</strong> as 2 and <strong>name</strong> as orange, so I'm showing a way to get the name handed back to you.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji only-emoji" alt=":thinking:"></p>
<p>This would mean isotopic objects with CATCH methods would be special.  It wouldn't be <em>all</em> isotopic objects that got filtered... e.g. you might want to throw a PARSE result which I'm theorizing has special THEN and ELSE methods.</p>
<p><strong>I like this direction more than I like baking in some particular /NAME mechanism.</strong>  And I really like the concept of being able to THROW and CATCH multi-return packs.  I'm going to fiddle around with this.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-trap-and-catch-return-null-if-no-fails-throws/940#post_8</link>
        <pubDate>Wed, 01 Feb 2023 11:01:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6571</guid>
      </item>
      <item>
        <title>Future of the MATH Dialect</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2013">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One key difficulty which <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a> and I fretted over at some point was that since Rebol isn't "psychic" regarding arity,</p>
</blockquote>
</aside>
<p>Note: if you want to ask "why isn't Rebol psychic?" consider cases like:</p>
<pre><code>mystery: func [a b] [return a * b]
tricky-negate: func [a] [mystery: :tricky-negate, return negate a]

1 + add tricky-negate 2 mystery 3 * 4
</code></pre>
<p>If a pre-pass tried to assume MYSTERY's arity and make decisions, those decisions might become invalid.  Ren-C features like variadics make this worse, but the problem is all tied in with Rebol being as dynamic as it is.</p>
<p>Explicit grouping is not a <em>terrible</em> thing, when you consider that most languages require parentheses to delimit function calls.  But it's certainly swimming upstream to be trying to ship MATH in the core.</p>
<p><em>Maybe this will change in the future, but Ren-C has bigger and more interesting issues to work on than trying to twist Rebol into a language that people who don't like Rebol would not want to use anyway.</em></p> ]]></description>
        <link>https://forum.rebol.info/t/future-of-the-math-dialect/2013#post_2</link>
        <pubDate>Tue, 31 Jan 2023 19:40:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6570</guid>
      </item>
      <item>
        <title>Future of the MATH Dialect</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>It is basically inevitable that people coming to Rebol will ask about its mathematical evaluation being left-to-right, instead of obeying the precedence order that they are used to.  Red just had a new user try to file it as a bug... 3 days ago:</p>
<p><a href="https://github.com/red/red/issues/5276">https://github.com/red/red/issues/5276</a></p>
<p><strong>What seemed to make sense to people like me and BrianH was that the core ship with a dialect called MATH.</strong>  The concept was that <strong>math [1 + 2 * 3]</strong> would give <strong>7</strong> and not <strong>9</strong>.  Having something in the box seemed better than having the first line of argument being <em>"you don't want the precedence you think you do"</em>.</p>
<p>But it turned out to be kind of hard to make pleasing.  One key difficulty which <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a> and I fretted over at some point was that since Rebol isn't "psychic" regarding arity, does not know a-priori how much code an expression will consume:</p>
<pre><code>math [1 + 2 * foo baz bar + 3]

; should it be...
[1 + (2 * (foo baz bar)) + 3]

; or perhaps...
[(1 + (2 * foo)) ((baz bar) + 3)]

; maybe...
[(1 + (2 * foo)) baz (bar + 3)]
</code></pre>
<p><strong>It started to appear that the user would have to put anything that wasn't a number or a math operator in groups.</strong>  There may be some heuristics which tolerate words that look up to numbers vs. functions, but it feels very slippery.</p>
<p>As I've said I hate to be dropping things, but MATH is something that Rebol programmers don't really want in the first place--and I don't think non-Rebol programmers would be satisfied by it.  If it's included in the core that suggests support for it, and there are just too many things in play.</p>
<p>Here is an implementation that was previously included, by Gabriele:</p>
<pre><code>; This MATH implementation is from Gabrielle Santilli circa 2001, found
; via http://www.rebol.org/ml-display-thread.r?m=rmlXJHS. It implements the
; much-requested (by new users) idea of * and / running before + and - in
; math expressions. Expanded to include functions.
;
math: func [
    {Process expression taking "usual" operator precedence into account.}

    expr [block!]
        {Block to evaluate}
    /only
        {Translate operators to their prefix calls, but don't execute}

    ; !!! This creation of static rules helps avoid creating those rules
    ; every time, but has the problem that the references to what should
    ; be locals are bound to statics as well (e.g. everything below which
    ; is assigned with BLANK! really should be relatively bound to the
    ; function, so that it will refer to the specific call.)  It's not
    ; technically obvious how to do that, not the least of the problem is
    ; that statics are currently a usermode feature...and injecting relative
    ; binding information into something that's not the function body itself
    ; isn't implemented.

    &lt;static&gt;

    slash (the /)

    expr-val (_)

    expr-op (_)

    expression  ([
        term (expr-val: term-val)
        opt some [
            ['+ (expr-op: 'add) | '- (expr-op: 'subtract)]
            term (expr-val: compose [(expr-op) (expr-val) (term-val)])
        ]
        &lt;end&gt;
    ])

    term-val (_)

    term-op (_)

    term ([
        pow (term-val: power-val)
        opt some [
            ['* (term-op: 'multiply) | slash (term-op: 'divide)]
            pow (term-val: compose [(term-op) (term-val) (power-val)])
        ]
    ])

    power-val (_)

    pow ([
        unary (power-val: unary-val)
        opt ['** unary (power-val: compose [power (power-val) (unary-val)])]
    ])

    unary-val (_)

    pre-uop (_)

    post-uop (_)

    unary ([
        (post-uop: pre-uop: [])
        opt ['- (pre-uop: 'negate)]
        primary
        opt ['! (post-uop: 'factorial)]
        (unary-val: compose [(post-uop) (pre-uop) (prim-val)])
    ])

    prim-val (_)

    primary ([
        set prim-val any-number!
        | set prim-val [word! | path!] (prim-val: reduce [prim-val])
            ; might be a funtion call, looking for arguments
            opt some [
                nested-expression (append prim-val take nested-expr-val)
            ]
        | ahead group! into nested-expression (prim-val: take nested-expr-val)
    ])

    p-recursion (_)

    nested-expr-val ([])

    save-vars (func [][
            p-recursion: reduce [
                :p-recursion :expr-val :expr-op :term-val :term-op :power-val :unary-val
                :pre-uop :post-uop :prim-val
            ]
        ])

    restore-vars (func [][
            set [
                p-recursion expr-val expr-op term-val term-op power-val unary-val
                pre-uop post-uop prim-val
            ] p-recursion
        ])

    nested-expression ([
            ;all of the static variables have to be saved
            (save-vars)
            expression
            (
                ; This rule can be recursively called as well,
                ; so result has to be passed via a stack
                insert nested-expr-val expr-val
                restore-vars
            )
            ; vars could be changed even it failed, so restore them and fail
            | (restore-vars) fail

    ])
][
    clear nested-expr-val
    let res: either parse3 expr expression [expr-val] [blank]

    either only [
        return res
    ][
        ret: reduce res
        all [
            1 = length of ret
            any-number? ret.1
        ] else [
            fail [
                unspaced ["Cannot be REDUCED to a number (" mold ret ")"]
                ":" mold res
            ]
        ]
        return ret.1
    ]
]</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/future-of-the-math-dialect/2013#post_1</link>
        <pubDate>Tue, 31 Jan 2023 19:08:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6569</guid>
      </item>
      <item>
        <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If we were "more honest" and just META'd the isotopic blank, we'd get renders like:</p>
<pre><code>make object! [
    alpha: ~_~
    beta: ~_~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~_~
    omega: 'now
]
</code></pre>
<p>But I might actually like that less than seeing <strong><code>~null~</code></strong> there.</p>
</blockquote>
</aside>
<p>You don't always know how you're going to feel until you've tried something a while.  But I have to say I'm starting to like <strong><code>~null~</code></strong> a lot more than I expected.</p>
<p>In fact, I was just reading some code:</p>
<pre><code>let meta: meta-of action
let notes: null
let description: null
</code></pre>
<p>And I thought to myself... hey.  That doesn't feel like it's "calling out" the nulls as much as I might like (!)  I almost felt like changing it:</p>
<pre><code>let meta: meta-of action
let notes: ~null~
let description: ~null~
</code></pre>
<p>Add oddly enough, that's faster...because it doesn't need to fetch the definition of the WORD! <strong><code>null</code></strong>.</p>
<p>I'm not <em>actually</em> going to change it.  But the fact that I thought about it makes me comfortable with the decision to go this route.  It feels more natural than I expected.</p> ]]></description>
        <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989#post_4</link>
        <pubDate>Fri, 27 Jan 2023 21:03:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6568</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2001">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their plain forms:</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; something true
== true

&gt;&gt; something 10
== 10
</code></pre>
</blockquote>
</aside>
<p>After pushing various problems around: <strong><em>I think it has turned out that this operation is more useful in practice</em> ...and likely deserves the coveted term "REIFY".</strong></p>
<p>In particular, I think it may be the answer to passing isotopic actions as parameters in a way that conflates with plain actions, yet canonizes it to plain.  e.g. the <strong><code>&lt;reify&gt;</code></strong> tag could indicate a desire to turn isotopic actions into non-isotopic ones if passed.  But it would be generic.  If you use it you mean you want anything passed to arrive in its reified form.</p>
<pre><code> func [arg [block!] /predicate [&lt;reify&gt; action!]] [...]
</code></pre>
<p>That feels like a pretty intelligent solution to the problem, while being generic enough to be useful for other purposes.</p>
<p>The other operation (which I called REIFY above) would be what needed a name.  Maybe it's a parameter to META, something like a META/ISOTOPE or similar.  I'll keep thinking, but I don't think it's going to be needed very often...whereas the sense of REIFY I'm talking about here is actually showing up a lot of places.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001#post_5</link>
        <pubDate>Fri, 27 Jan 2023 20:49:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6567</guid>
      </item>
      <item>
        <title>ChatGPT Speaking About Rebol</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/ef46f6ed21a760ee729f697f3ce5f5e776e97206.png" data-download-href="https://forum.rebol.info/uploads/default/ef46f6ed21a760ee729f697f3ce5f5e776e97206" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/ef46f6ed21a760ee729f697f3ce5f5e776e97206.png" alt="image" data-base62-sha1="y8K9GNX2z0xyXt4Nt9YaGfNuODc" width="468" height="499" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/ef46f6ed21a760ee729f697f3ce5f5e776e97206_2_10x10.png"></a></div><p></p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8.png" data-download-href="https://forum.rebol.info/uploads/default/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8.png" alt="image" data-base62-sha1="wA8R2o1Qk1ewNbNaJOGrW3dzqha" width="659" height="500" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8_2_10x10.png"></a></div><p></p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/5ccd13ead198bb971401d36c7b73cd7cc33052c5.png" alt="image" data-base62-sha1="deXiShPN2xO1ngpAGH0Gmt20keh" width="647" height="487"></p>
<p>ChatGPT can grasp some pretty abstract stuff.  If they ever give it access to dev tools (so it can test-compile code) or other real-time information, it's going to be pretty darn good, I'd say.</p> ]]></description>
        <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997#post_3</link>
        <pubDate>Fri, 27 Jan 2023 05:22:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6566</guid>
      </item>
      <item>
        <title>Should Quasiform Parameters Accept as the Plain Form?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><strong><a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">I'm very confident of the goodness of "isotopic actions"</a></strong>.</p>
<p>Not being able to put them in blocks gives us the <a href="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244/9">nice, mechanical invariant</a> of being able to manipulate blocks without inadvertently running functions in the process.  It opens the doors to other guardrails against isotopes being in variables when it might surprise you.</p>
<p>But what happens when you write something like SPECIALIZE, with a spec that looks something like:</p>
<pre><code>//
//  specialize: native [
//
//  {Create a new action through partial or full specialization of another}
//
//      return: [~action!~]  ; ~ notation since an isotopic action is returned
//      action "Function whose parameters will be set to fixed values"
//          [action!]
//      def "Definition for FRAME! fields for args and refinements"
//          [block!]
//  ]
//
</code></pre>
<p>Should SPECIALIZE tolerate being passed an isotopic action, maybe with a spec that looks like:</p>
<pre><code>return: [~action!~]
action "Function whose parameters will be set to fixed values"
    [action! ~action!~]
def "Definition for FRAME! fields for args and refinements"
    [block!]
</code></pre>
<p>This would lead to complexity inside most function, because now if it references the <strong>action</strong> variable it might run.  And this lack of automatic canonization to the inert form creates hassles for both usermode and native code alike.</p>
<p>Another thing is that the meaning of isotopic actions is potentially <em>very</em> different from that of a plain action.  For instance: <strong><code>find block :even?</code></strong> might know that since blocks cannot contain isotopes, it should interpret it as a function to call to test the items in the block for evenness.</p>
<p>So this led me to a bit of a thought...</p>
<h2>What if QUASI!-forms typechecked as the plain form?</h2>
<p>The idea is that there's an initial type check done.  If that check fails and it's a quasiform, it is tested again as its plain form.  If that passes, the plain form is received.</p>
<p>Producing a quasiform of an action from an isotope is easy, just use a meta operation.  So <strong><code>^append</code></strong> instead of <strong><code>:append</code></strong>.  All meta forms are inert, so code using the meta is less likely to do wild things.</p>
<p><em>To me, this feels like a safer exception than letting isotopes pass for plain forms.</em>  Due to their alien-ness, an isotopic form could intend something quite far from a mechanical brick in a block.  But what a quasiform has in common with a plain form is that both are inert.</p>
<p>Also, even the name "quasi" suggests a possibly loose relationship.  It carries the same payload as the plain form.  What if this were legal:</p>
<pre><code>&gt;&gt; add first [~1~] first [~2~]
== 3
</code></pre>
<p>I'm suggesting a general-enough mechanism that would work... so long as ADD didn't widen its net to taking actual ANY-VALUE! (which would indicate it had an actual meaning that applied to quasiforms).</p>
<p>This may not be the most brilliant thought to ever be thunk.  But in this more complex world there need to be succinct answers.  We don't want to have to write things like <strong><code>apply concretize :append [...]</code></strong>, and I feel like glossing over the fact that something is an isotope is a worse move than glossing over that something is a quasiform.</p>
<p>I even may like <strong><code>apply ^append [...]</code></strong> a bit more than <strong><code>apply :append [...]</code></strong> for looks, too.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012#post_1</link>
        <pubDate>Thu, 26 Jan 2023 18:42:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6565</guid>
      </item>
      <item>
        <title>Looking into a *usermode* POINTFREE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1236">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>POINTFREE is pretty awesome and I find it comes in handy a lot.</p>
</blockquote>
</aside>
<p>POINTFREE is very cool, but I'm removing its usage from bootstrap...because changes I want to make break it.  And it's hard to fix and redesign such things when the system won't boot.</p>
<p>While I <em>could</em> remove its bootstrap usage... and then make my next task after the changes be to work through it and put it back in the bootstrap, I'm actually not going to.  I'm just going to leave in a file on the side, as part of the test scripts--<em>for now</em>.  I'm going to leave it broken until such time as it's a priority to fix it.</p>
<p><em>I can't make everything a focus, and am mentioning this just to talk out loud about the need to become more mercenary.</em></p>
<p><strong><a href="https://forum.rebol.info/t/introducing-the-hackable-usermode-parse-uparse/1529">The big "what's possible in usermode" showcase is UPARSE.</a></strong>  And it stands on the shoulders of all the efforts like POINTFREE that came before it.  But the demand to keep all of these experiments working -and- try using them in the boot process is too much.</p> ]]></description>
        <link>https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236#post_8</link>
        <pubDate>Thu, 26 Jan 2023 18:05:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6564</guid>
      </item>
      <item>
        <title>Axing --breakpoint switch, C-DEBUG-BREAK-AT</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><strong>I'm killing off features for whom their maintenance is not paying off.</strong></p>
<p>One is the "tick" based usermode <code>--breakpoint</code> feature, implemented on the command line as:</p>
<pre><code>        "--breakpoint" end (
            c-debug-break-at to-integer param-or-die "BREAKPOINT"
        )
</code></pre>
<p>The complex problem of taking a "tick" count to break on via a command line switch is that since command line processing is in usermode, you have a kind of observer-affects-the-experiment situation.  The code for adding in the breakpoint messes with the tick count you're trying to reproduce.</p>
<p>I had ideas to work around this.  So there's the /COMPENSATE feature of C-DEBUG-BREAK, which I don't even know if it works or if my idea is fundamentally flawed:</p>
<pre><code>; Taking a command-line `--breakpoint NNN` parameter is helpful if a
; problem is reproducible, and you have a tick count in hand from a
; panic(), REBSER.tick, Frame.tick, REBVAL.extra.tick, etc.  But there's
; an entanglement issue, as any otherwise-deterministic tick from a prior
; run would be thrown off by the **ticks added by the userspace parameter
; processing of the command-line for `--breakpoint`**!  :-/
;
; The /COMPENSATE option addresses this problem.  Pass it a reasonable
; upper bound for how many ticks you think could have been added to the
; parse, if `--breakpoint` was processed (even though it might not have
; been processed).  Regardless of whether the switch was present or not,
; the tick count rounds up to a reproducible value, using this method:
;
; https://math.stackexchange.com/q/2521219/
;
; At time of writing, 1000 ticks should be *way* more than enough for both
; the PARSE steps and the evaluation steps `--breakpoint` adds.  Yet some
; things could affect this, e.g. a complex userspace TRACE which was
; run during boot.
;
attempt [c-debug-break-at/compensate 1000]  ; fails in release build
</code></pre>
<p>Here was more of it:</p>
<pre><code>  #if !defined(NDEBUG) &amp;&amp; DEBUG_COUNT_TICKS
    if (REF(compensate)) {
        //
        // Imagine two runs of Rebol console initialization.  In the first,
        // the tick count is 304 when C-DEBUG-BREAK/COMPENSATE is called,
        // right after command line parsing.  Later on a panic() is hit and
        // reports tick count 1020 in the crash log.
        //
        // Wishing to pick apart the bug before it happens, the Rebol Core
        // Developer then re-runs the program with `--breakpoint=1020`, hoping
        // to break at that tick, to catch the downstream appearance of the
        // tick in the panic().  But since command-line processing is in
        // usermode, the addition of the parameter throws off the ticks!
        //
        // https://en.wikipedia.org/wiki/Observer_effect_(physics)
        //
        // Let's say that after the command line processing, it still runs
        // C-DEBUG-BREAK/COMPENSATE, this time at tick 403.  Imagine our goal
        // is to make the parameter to /COMPENSATE something that can be used
        // to conservatively guess the same value to set the tick to, and
        // that /COMPENSATE ARG(bound) that gives a maximum of how far off we
        // could possibly be from the "real" tick. (e.g. "argument processing
        // took no more than 200 additional ticks", which this is consistent
        // with...since 403-304 = 99).
        //
        // The reasoning for why the formula below works for this rounding is
        // given in this StackExchange question and answer:
        //
        // https://math.stackexchange.com/q/2521219/
        //
        Tick one = 1; // MSVC gives misguided warning for cast(Tick, 1)
        TG_tick =
            (one &lt;&lt; (ceil_log2(TG_tick) + 1))
            + VAL_INT64(ARG(tick))
            - 1;
        return nullptr;
    }
</code></pre>
<p>Also, I've never used the /RELATIVE tick feature, killing that too:</p>
<pre><code>  if (REF(relative))
      TG_break_at_tick = frame_-&gt;tick + 1 + VAL_INT64(ARG(tick));
</code></pre>
<p><strong>I'm going to be deleting a lot of things, I think, in the pursuit of simplification--now that isotopes are showing the way.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/axing-breakpoint-switch-c-debug-break-at/2009#post_1</link>
        <pubDate>Tue, 24 Jan 2023 21:57:46 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6561</guid>
      </item>
      <item>
        <title>Getting Output From Rebol2 on Windows GitHub Actions</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>If you run Rebol 2 with the CGI flag (<code>-c</code>) you should be able to get basic interaction.</p> ]]></description>
        <link>https://forum.rebol.info/t/getting-output-from-rebol2-on-windows-github-actions/1966#post_2</link>
        <pubDate>Tue, 24 Jan 2023 16:14:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6560</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Same here, that is when I go for one of my help lines in these kinds of cases: The wordhippo</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://www.wordhippo.com/favicon.ico" class="site-icon" width="16" height="16">
      <a href="https://www.wordhippo.com/what-is/another-word-for/reify.html" target="_blank" rel="noopener">WordHippo</a>
  </header>
  <article class="onebox-body">
    <img src="https://wordhippo.s3.amazonaws.com/what-is/img/logo-200x200.png" class="thumbnail onebox-avatar" width="60" height="60">

<h3><a href="https://www.wordhippo.com/what-is/another-word-for/reify.html" target="_blank" rel="noopener">What is another word for reify? | Reify Synonyms - WordHippo Thesaurus</a></h3>

<p>Synonyms for reify include concretize, objectify, picture, thingify, embody, incarnate, manifest, externalize, substantiate and materialize. Find more similar words at wordhippo.com!</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<p>
There is a tab for antonyms as well. That would lead me to suggestions NEGLECT, OBSCURE or IGNORE.<br>
But with some creativity I came up with the word DEIFY.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001#post_4</link>
        <pubDate>Sun, 15 Jan 2023 12:30:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6557</guid>
      </item>
  </channel>
</rss>

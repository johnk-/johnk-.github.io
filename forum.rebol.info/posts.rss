<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>Compiling ren-c with zig?</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>Hi,</p>
<p>has anyone tried to compile ren-c with zig? ( <a href="https://www.ziglang.org">https://www.ziglang.org</a> ).</p>
<p>They claim to be able to compile c-code using zig cc , and have an impressive list of cross compilation targets, wasm among them.</p>
<p><a href="https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler" class="onebox" target="_blank" rel="noopener">https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler</a><br>
<a href="https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case" class="onebox" target="_blank" rel="noopener">https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case</a></p>
<p>Kind regards,<br>
Ingo</p> ]]></description>
        <link>https://forum.rebol.info/t/compiling-ren-c-with-zig/2017/1</link>
        <pubDate>Wed, 22 Feb 2023 21:31:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6577</guid>
      </item>
      <item>
        <title>Kaitai Struct Declarative Language for Binary Formats</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>This is an interesting declarative language in YAML designed to generate classes for binary formats.  There are many formats defined:</p>
<p><a href="https://formats.kaitai.io/">https://formats.kaitai.io/</a></p>
<p>That's a lot of cases...but as one instructive example, you can look at how it describes a ZIP file--with little snippets of code in it for extracting the values:</p>
<p><a href="https://formats.kaitai.io/zip/" class="inline-onebox">ZIP archive file format spec for Kaitai Struct</a></p>
<p>The C++ code generated is like this:</p>
<p><a href="https://formats.kaitai.io/zip/cpp_stl_11.html" class="inline-onebox">ZIP archive file: C++11/STL parsing library</a></p>
<p>But it also can also be used to make code for C#, JavaScript, Python, Ruby, Nim, PHP, Lua, Perl... <em>(though we'd assume that if you escape code in, that part will only work be available for that language)</em></p>
<p>The regimentation of YAML provides the typical repetition in the "dialect".  This is the same as the Rebol complaint about JSON--not really leveraging "parts of speech", but repeating tags over and over like <code>id:</code> and <code>type:</code></p>
<pre><code>  - id: version
    type: u2
  - id: flags
    type: gp_flags
    size: 2
  - id: compression_method
    type: u2
    enum: compression
</code></pre>
<p>But it's still pretty hard to compete with, especially when you consider this is giving a compilable specification...so the performance is going to be much better.</p>
<p>I always thought BINARY! parse was something that Rebol would have a unique story for, and Ren-C's UPARSE makes that a stronger story (by allowing rules to synthesize arbitrary results via extraction)... but seeing this kind of stuff reminds me that there are diminishing returns.</p> ]]></description>
        <link>https://forum.rebol.info/t/kaitai-struct-declarative-language-for-binary-formats/2016/1</link>
        <pubDate>Tue, 21 Feb 2023 22:36:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6576</guid>
      </item>
      <item>
        <title>Line Continuation and Arity Bugs: Thoughts?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1965">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<h2>I Just Got Bit By a Variadic QUIT Bug</h2>
<p>Without thinking about it, I tried to end some code prematurely by injecting a quit:</p>
<pre><code>some stuff I wanted to run

quit  ; added this

some stuff I wanted to avoid running
</code></pre>
<p>And that QUIT ran the stuff I didn't want to run anyway, because it was variadic (and acted as QUIT/WITH SOME STUFF I WANTED TO AVOID RUNNING).</p>
</blockquote>
</aside>
<p>I realized this issue is very similar to problems that come up in JavaScript with "automatic semicolon insertion":</p>
<p><a href="https://en.wikibooks.org/wiki/JavaScript/Automatic_semicolon_insertion" class="inline-onebox">JavaScript/Automatic semicolon insertion - Wikibooks, open books for an open world</a></p>
<p>JavaScript doesn't require semicolons at the ends of lines.  There's some debate on whether to take advantage of this--but I'm one of the people who believes it makes the code cleaner.  But cases like RETURN have a parallel problem in JavaScript.</p>
<p>So JavaScript's <code>return</code> is variadic, but the automatic semicolon would bias it so that if you have some stuff on a line after a return it gets ignored.</p>
<p><em>The complexity of the situation makes me feel like erring on the side of fixed arity.</em>  If you want to return nothing, say <strong><code>return none</code></strong>.  And if you want to return void, say <strong><code>return void</code></strong>.  It's more explicit, and I think the "naked" returns probably do more harm than good.</p>
<p>I don't think people will use passing arguments to continue too often, but <strong><code>continue/with value</code></strong> isn't terrible</p> ]]></description>
        <link>https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965/2</link>
        <pubDate>Fri, 10 Feb 2023 17:08:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6575</guid>
      </item>
      <item>
        <title>Should SET-WORD!s Have &quot;Raised Error Interception&quot;?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Division by zero is a simple example of something that produces a "definitional error".  <em>It's considered to be "emitted" by the division</em>, and if you try to "move on" without handling it, the raised error becomes a failure that <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871">you can only catch at some top level by SYS.UTIL.RESCUE</a>.</p>
<p>For instance:</p>
<pre><code>&gt;&gt; 1 / 0, 2 + 0
** Math Error: attempt to divide by zero
** Where: / console
** Near: [1 / 0 **, 2 + ***]
</code></pre>
<p>What happened was that <strong>1 / 0</strong> evaluated, but rather than forcing a "hard failure" (e.g. running FAIL) it instead <em>returned a raised error</em>.  There's an opportunity if that raised error were to be intercepted, but in this case it just moseyed along to the next expression... so the raised error was promoted to a failure.</p>
<p>However a ^META oriented function can trap that, and react to it, allowing you to continue.  EXCEPT is such a function:</p>
<pre><code>&gt;&gt; 1 / 0 except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p>One thing that pretty obviously shouldn't count as "moving on" would be parentheses.  Adding parentheses shouldn't change the situation, they just pass any raised errors through:</p>
<pre><code>&gt;&gt; (1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2

&gt;&gt; ((((1 / 0)))) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p><strong>But what about things like SET-WORD!s?</strong>  Right now, it does not raise an error and just skips the assignment, and lets the code continue:</p>
<pre><code>&gt;&gt; num: &lt;before&gt;

&gt;&gt; (num: 1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2

&gt;&gt; num
== &lt;before&gt;
</code></pre>
<p><strong>This is a useful pattern, but if we do it for SET-WORD!s then we have to ask whether it should be done for SET the function as well...</strong></p>
<pre><code>&gt;&gt; (set 'num 1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p>If we do this then the SET function has to take its argument of the value to assign as a ^META argument.  Because raised errors can't be stored in variables, and function parameters are communicated via variables.</p>
<p>This does make SET a more complicated function, and any functions like it might also become complicated.  It's a hard decision to condemn all SET-like functions to take their arguments as ^META so they can proxy any errors and not perform the assignment.</p>
<p>I'll probably have more to say about this, but for the moment both SET and SET-WORD! react to definitional failures by <em>not performing the assignment</em> and <em>propagating the raised error</em>.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-set-word-s-have-raised-error-interception/2015/1</link>
        <pubDate>Tue, 07 Feb 2023 02:52:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6574</guid>
      </item>
      <item>
        <title>Difficult Decision: Not Renewing (unlaunched!) Domain Names</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>You are so right in not spending your hard earned money on domain names. Always another option around later.</p> ]]></description>
        <link>https://forum.rebol.info/t/difficult-decision-not-renewing-unlaunched-domain-names/2014/2</link>
        <pubDate>Sun, 05 Feb 2023 09:35:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6573</guid>
      </item>
      <item>
        <title>Difficult Decision: Not Renewing (unlaunched!) Domain Names</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A couple of years ago--at <a class="mention" href="/u/gchiu">@gchiu</a>'s urging--I had reserved a <code>.com</code>, <code>.org</code>, and <code>.net</code> for launching Ren-C to the public.</p>
<p>But in the intervening years, I put nothing on these domains.  They've been vacant lots, doing little but transferring money from me to the "Namecheap" registrar.  <img src="https://forum.rebol.info/images/emoji/twitter/angry.png?v=9" title=":angry:" class="emoji" alt=":angry:"></p>
<p>Feb 3rd was this year's renewal date, and I disabled auto-renew, and didn't pay.</p>
<h2>If I "Owned" Them, Why Didn't I Use Them?</h2>
<p>I put "owned" in quotes because you don't own domain names, you just rent them.</p>
<p>There are good reasons for not wanting to impart value to these domains prematurely--e.g. not even transferring the forum there.  My worries were:</p>
<ol>
<li>
<p>You don't get a second chance to announce a project.</p>
<ul>
<li>If you need a case study, Red has certainly worn out their welcome on hackernews.</li>
</ul>
</li>
<li>
<p>Once you start using a domain, the content becomes an issue of identity.</p>
<ul>
<li>
<p>You have imparted a value to URLs which is easily stolen by spammers.</p>
</li>
<li>
<p>You become obligated to pay recurring charges to protect your material and identity.</p>
</li>
</ul>
</li>
</ol>
<h2>Why I'm Not Renewing Them, Despite Believing in Ren-C...</h2>
<p><strong>While Ren-C is in my eyes, successful in many areas... given the (long!) timescale we are looking at... I don't think it is necessary to pay for specialized domain names for the project.</strong></p>
<p>The DNS system itself may be obsolete--and AI may be writing all the code--before I get around to finishing this myself. <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:">  Though perhaps I have helped set the goalposts.</p>
<p>I'm basically saying that I'm okay coupling the Ren-C work to the domain names I already have established, or their subdomains, rather than making a separate entity that others would manage.  Those identities (like hostilefork or metaeducation) are a sunk cost, and I can just use those.</p>
<h2>I Put Up Money For A Couple Of Years, Is Not Doing So "Giving Up"?</h2>
<p>Not really.  This is just an epicycle of my firm belief that DNS is not to be trusted any further than you can throw it.  It says more about how I feel about the domain name ecosystem than it says about how I feel about Ren-C.</p>
<p>...and if I hadn't mentioned it, you wouldn't have noticed any difference at all.  Things would seem the same.</p>
<p><em>But in my mind with the huge new design space opening up with isotopes,</em> I will admit that I'm moving closer to the idea that the final product of Ren-C is just more like "demos and papers and code golf gaming".  Not "download the solution to all your problems here".</p>
<p>After all, there are worse things than being the <a href="https://en.wikipedia.org/wiki/Antikythera_mechanism">Antikythera mechanism</a>.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>So I'm not quitting, but I certainly am trying to do a lot more other things in my life these days.  I'll keep hacking on it as time permits, and hopefully we won't be taking too many steps backwards... and the WebAssembly stuff will remain the user-facing focus.</p> ]]></description>
        <link>https://forum.rebol.info/t/difficult-decision-not-renewing-unlaunched-domain-names/2014/1</link>
        <pubDate>Sat, 04 Feb 2023 17:56:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6572</guid>
      </item>
      <item>
        <title>Should TRAP and CATCH return null if no fails/throws?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="940">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Looks like we may get the best of both worlds now, with <a href="https://forum.rebol.info/t/forward-to-multiple-return-values-and-return-value-forwarding/1271/2">multiple returns</a>! The TRAP and CATCH could offer a second output which is the value that "falls out" of the evaluation.</p>
</blockquote>
</aside>
<p>So there's a competing application for multi-returns, which is the ability to throw a multi-return... which is more useful:</p>
<pre><code>&gt;&gt; [x fallthrough?]: catch [
       if false [throw pack [1 false]]
       throw pack [2 true]
   ]
== 2

&gt;&gt; x
== 2

&gt;&gt; fallthrough?
== ~true~  ; isotope
</code></pre>
<p>This seems like a much better use of the multi-return ability.  And to my mind, that tips the scales to where you should do a THROW as the last line if you want "the block's result".</p>
<p>Then if you want to detect whether a result came from the end of the block or somewhere inside it, you can do as I did above and encode that as an extra parameter.</p>
<h3>So... should CATCH return NULL or NONE if there's no throw?</h3>
<p><em>Hmmm.</em></p>
<p>Right now functions that lack a RETURN statement return NONE.  As a reminder, this is a multi-return pack of length zero, that has the special console behavior of printing nothing.</p>
<pre><code>&gt;&gt; foo: func [] []
== ~#[action! {foo} []]~  ; isotope

&gt;&gt; foo

&gt;&gt;
</code></pre>
<p>If you really want NULL to come back from a CATCH, you can just say that with THROW NULL.  It's more explicit.</p>
<pre><code>catch [...] else [...]  ; default w/no throw is NONE, would not run ELSE

catch [..., throw null] else [...]  ; would run ELSE
</code></pre>
<p><em>Although...we could say that THROW always throws a "heavy null"...and then ELSE really would mean "didn't catch anything".</em>  That does seem kind of cool, that ELSE really would react to nothing being caught.</p>
<h3>What About Named Throws... How to Know The Name?</h3>
<p><em>Hmmm.</em></p>
<p>I'll start by saying I've personally felt a bit skeptical of named throws, compared with "definitional throws".  :-/</p>
<p>But in any case, if you catch a named throw you might want to know its name.  Though I notice that Red does not tell you:</p>
<pre><code>red&gt;&gt; catch/name [throw/name 304 'red] [red blue]
== 304  ; no indication of if blue or red was caught
</code></pre>
<p>If we imagine you did want to know which name you caught, then here we have another competing interest for the multi-return ability... the /NAME of the throw.</p>
<p>In systems like C++ that support throwing, you can actually say what <em>types</em> of throws you want to receive.  Then you receive an object, potentially re-throwing it.</p>
<p><strong>Maybe this is another opportunity for isotopic objects!</strong>  Recall that isotopic objects can't be stored in variables... they need to have a DECAY method to produce normal values (including potentially a multi-return), or other methods like ELSE and THEN which coerce them.  But they could have a CATCH field which might just be some name or structure.  Then there could be a CATCH/FILTER which would be able to pick over these isotopic objects and decide if the CATCH wanted it or not.</p>
<p>That sounds pretty interesting... there'd be no THROW/NAME, it would be more like:</p>
<pre><code>[x y name]: catch/filter [
    throw isotopic make object! [
        catch: 'orange
        decay: does [pack [1 2 'orange]]
    ]
] obj -&gt; [  ; only filter on isotopic objects, pass plain object here?
    did find [orange green] obj.catch
]
</code></pre>
<p>So something like that would wind up giving you <strong>x</strong> as 1 and <strong>y</strong> as 2 and <strong>name</strong> as orange, so I'm showing a way to get the name handed back to you.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji only-emoji" alt=":thinking:"></p>
<p>This would mean isotopic objects with CATCH methods would be special.  It wouldn't be <em>all</em> isotopic objects that got filtered... e.g. you might want to throw a PARSE result which I'm theorizing has special THEN and ELSE methods.</p>
<p><strong>I like this direction more than I like baking in some particular /NAME mechanism.</strong>  And I really like the concept of being able to THROW and CATCH multi-return packs.  I'm going to fiddle around with this.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-trap-and-catch-return-null-if-no-fails-throws/940/8</link>
        <pubDate>Wed, 01 Feb 2023 11:01:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6571</guid>
      </item>
      <item>
        <title>Future of the MATH Dialect</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2013">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One key difficulty which <a class="mention" href="/u/brett">@Brett</a> and I fretted over at some point was that since Rebol isn't "psychic" regarding arity,</p>
</blockquote>
</aside>
<p>Note: if you want to ask "why isn't Rebol psychic?" consider cases like:</p>
<pre><code>mystery: func [a b] [return a * b]
tricky-negate: func [a] [mystery: :tricky-negate, return negate a]

1 + add tricky-negate 2 mystery 3 * 4
</code></pre>
<p>If a pre-pass tried to assume MYSTERY's arity and make decisions, those decisions might become invalid.  Ren-C features like variadics make this worse, but the problem is all tied in with Rebol being as dynamic as it is.</p>
<p>Explicit grouping is not a <em>terrible</em> thing, when you consider that most languages require parentheses to delimit function calls.  But it's certainly swimming upstream to be trying to ship MATH in the core.</p>
<p><em>Maybe this will change in the future, but Ren-C has bigger and more interesting issues to work on than trying to twist Rebol into a language that people who don't like Rebol would not want to use anyway.</em></p> ]]></description>
        <link>https://forum.rebol.info/t/future-of-the-math-dialect/2013/2</link>
        <pubDate>Tue, 31 Jan 2023 19:40:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6570</guid>
      </item>
      <item>
        <title>Future of the MATH Dialect</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>It is basically inevitable that people coming to Rebol will ask about its mathematical evaluation being left-to-right, instead of obeying the precedence order that they are used to.  Red just had a new user try to file it as a bug... 3 days ago:</p>
<p><a href="https://github.com/red/red/issues/5276">https://github.com/red/red/issues/5276</a></p>
<p><strong>What seemed to make sense to people like me and BrianH was that the core ship with a dialect called MATH.</strong>  The concept was that <strong>math [1 + 2 * 3]</strong> would give <strong>7</strong> and not <strong>9</strong>.  Having something in the box seemed better than having the first line of argument being <em>"you don't want the precedence you think you do"</em>.</p>
<p>But it turned out to be kind of hard to make pleasing.  One key difficulty which <a class="mention" href="/u/brett">@Brett</a> and I fretted over at some point was that since Rebol isn't "psychic" regarding arity, does not know a-priori how much code an expression will consume:</p>
<pre><code>math [1 + 2 * foo baz bar + 3]

; should it be...
[1 + (2 * (foo baz bar)) + 3]

; or perhaps...
[(1 + (2 * foo)) ((baz bar) + 3)]

; maybe...
[(1 + (2 * foo)) baz (bar + 3)]
</code></pre>
<p><strong>It started to appear that the user would have to put anything that wasn't a number or a math operator in groups.</strong>  There may be some heuristics which tolerate words that look up to numbers vs. functions, but it feels very slippery.</p>
<p>As I've said I hate to be dropping things, but MATH is something that Rebol programmers don't really want in the first place--and I don't think non-Rebol programmers would be satisfied by it.  If it's included in the core that suggests support for it, and there are just too many things in play.</p>
<p>Here is an implementation that was previously included, by Gabriele:</p>
<pre><code>; This MATH implementation is from Gabrielle Santilli circa 2001, found
; via http://www.rebol.org/ml-display-thread.r?m=rmlXJHS. It implements the
; much-requested (by new users) idea of * and / running before + and - in
; math expressions. Expanded to include functions.
;
math: func [
    {Process expression taking "usual" operator precedence into account.}

    expr [block!]
        {Block to evaluate}
    /only
        {Translate operators to their prefix calls, but don't execute}

    ; !!! This creation of static rules helps avoid creating those rules
    ; every time, but has the problem that the references to what should
    ; be locals are bound to statics as well (e.g. everything below which
    ; is assigned with BLANK! really should be relatively bound to the
    ; function, so that it will refer to the specific call.)  It's not
    ; technically obvious how to do that, not the least of the problem is
    ; that statics are currently a usermode feature...and injecting relative
    ; binding information into something that's not the function body itself
    ; isn't implemented.

    &lt;static&gt;

    slash (the /)

    expr-val (_)

    expr-op (_)

    expression  ([
        term (expr-val: term-val)
        opt some [
            ['+ (expr-op: 'add) | '- (expr-op: 'subtract)]
            term (expr-val: compose [(expr-op) (expr-val) (term-val)])
        ]
        &lt;end&gt;
    ])

    term-val (_)

    term-op (_)

    term ([
        pow (term-val: power-val)
        opt some [
            ['* (term-op: 'multiply) | slash (term-op: 'divide)]
            pow (term-val: compose [(term-op) (term-val) (power-val)])
        ]
    ])

    power-val (_)

    pow ([
        unary (power-val: unary-val)
        opt ['** unary (power-val: compose [power (power-val) (unary-val)])]
    ])

    unary-val (_)

    pre-uop (_)

    post-uop (_)

    unary ([
        (post-uop: pre-uop: [])
        opt ['- (pre-uop: 'negate)]
        primary
        opt ['! (post-uop: 'factorial)]
        (unary-val: compose [(post-uop) (pre-uop) (prim-val)])
    ])

    prim-val (_)

    primary ([
        set prim-val any-number!
        | set prim-val [word! | path!] (prim-val: reduce [prim-val])
            ; might be a funtion call, looking for arguments
            opt some [
                nested-expression (append prim-val take nested-expr-val)
            ]
        | ahead group! into nested-expression (prim-val: take nested-expr-val)
    ])

    p-recursion (_)

    nested-expr-val ([])

    save-vars (func [][
            p-recursion: reduce [
                :p-recursion :expr-val :expr-op :term-val :term-op :power-val :unary-val
                :pre-uop :post-uop :prim-val
            ]
        ])

    restore-vars (func [][
            set [
                p-recursion expr-val expr-op term-val term-op power-val unary-val
                pre-uop post-uop prim-val
            ] p-recursion
        ])

    nested-expression ([
            ;all of the static variables have to be saved
            (save-vars)
            expression
            (
                ; This rule can be recursively called as well,
                ; so result has to be passed via a stack
                insert nested-expr-val expr-val
                restore-vars
            )
            ; vars could be changed even it failed, so restore them and fail
            | (restore-vars) fail

    ])
][
    clear nested-expr-val
    let res: either parse3 expr expression [expr-val] [blank]

    either only [
        return res
    ][
        ret: reduce res
        all [
            1 = length of ret
            any-number? ret.1
        ] else [
            fail [
                unspaced ["Cannot be REDUCED to a number (" mold ret ")"]
                ":" mold res
            ]
        ]
        return ret.1
    ]
]</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/future-of-the-math-dialect/2013/1</link>
        <pubDate>Tue, 31 Jan 2023 19:08:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6569</guid>
      </item>
      <item>
        <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If we were "more honest" and just META'd the isotopic blank, we'd get renders like:</p>
<pre><code>make object! [
    alpha: ~_~
    beta: ~_~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~_~
    omega: 'now
]
</code></pre>
<p>But I might actually like that less than seeing <strong><code>~null~</code></strong> there.</p>
</blockquote>
</aside>
<p>You don't always know how you're going to feel until you've tried something a while.  But I have to say I'm starting to like <strong><code>~null~</code></strong> a lot more than I expected.</p>
<p>In fact, I was just reading some code:</p>
<pre><code>let meta: meta-of action
let notes: null
let description: null
</code></pre>
<p>And I thought to myself... hey.  That doesn't feel like it's "calling out" the nulls as much as I might like (!)  I almost felt like changing it:</p>
<pre><code>let meta: meta-of action
let notes: ~null~
let description: ~null~
</code></pre>
<p>Add oddly enough, that's faster...because it doesn't need to fetch the definition of the WORD! <strong><code>null</code></strong>.</p>
<p>I'm not <em>actually</em> going to change it.  But the fact that I thought about it makes me comfortable with the decision to go this route.  It feels more natural than I expected.</p> ]]></description>
        <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/4</link>
        <pubDate>Fri, 27 Jan 2023 21:03:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6568</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2001">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their plain forms:</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; something true
== true

&gt;&gt; something 10
== 10
</code></pre>
</blockquote>
</aside>
<p>After pushing various problems around: <strong><em>I think it has turned out that this operation is more useful in practice</em> ...and likely deserves the coveted term "REIFY".</strong></p>
<p>In particular, I think it may be the answer to passing isotopic actions as parameters in a way that conflates with plain actions, yet canonizes it to plain.  e.g. the <strong><code>&lt;reify&gt;</code></strong> tag could indicate a desire to turn isotopic actions into non-isotopic ones if passed.  But it would be generic.  If you use it you mean you want anything passed to arrive in its reified form.</p>
<pre><code> func [arg [block!] /predicate [&lt;reify&gt; action!]] [...]
</code></pre>
<p>That feels like a pretty intelligent solution to the problem, while being generic enough to be useful for other purposes.</p>
<p>The other operation (which I called REIFY above) would be what needed a name.  Maybe it's a parameter to META, something like a META/ISOTOPE or similar.  I'll keep thinking, but I don't think it's going to be needed very often...whereas the sense of REIFY I'm talking about here is actually showing up a lot of places.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001/5</link>
        <pubDate>Fri, 27 Jan 2023 20:49:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6567</guid>
      </item>
      <item>
        <title>ChatGPT Speaking About Rebol</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/ef46f6ed21a760ee729f697f3ce5f5e776e97206.png" data-download-href="https://forum.rebol.info/uploads/default/ef46f6ed21a760ee729f697f3ce5f5e776e97206" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/ef46f6ed21a760ee729f697f3ce5f5e776e97206.png" alt="image" data-base62-sha1="y8K9GNX2z0xyXt4Nt9YaGfNuODc" width="468" height="499" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/ef46f6ed21a760ee729f697f3ce5f5e776e97206_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">652×696 13.6 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8.png" data-download-href="https://forum.rebol.info/uploads/default/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8.png" alt="image" data-base62-sha1="wA8R2o1Qk1ewNbNaJOGrW3dzqha" width="659" height="500" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">685×519 16 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/5ccd13ead198bb971401d36c7b73cd7cc33052c5.png" alt="image" data-base62-sha1="deXiShPN2xO1ngpAGH0Gmt20keh" width="647" height="487"></p>
<p>ChatGPT can grasp some pretty abstract stuff.  If they ever give it access to dev tools (so it can test-compile code) or other real-time information, it's going to be pretty darn good, I'd say.</p> ]]></description>
        <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997/3</link>
        <pubDate>Fri, 27 Jan 2023 05:22:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6566</guid>
      </item>
      <item>
        <title>Should Quasiform Parameters Accept as the Plain Form?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><strong><a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">I'm very confident of the goodness of "isotopic actions"</a></strong>.</p>
<p>Not being able to put them in blocks gives us the <a href="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244/9">nice, mechanical invariant</a> of being able to manipulate blocks without inadvertently running functions in the process.  It opens the doors to other guardrails against isotopes being in variables when it might surprise you.</p>
<p>But what happens when you write something like SPECIALIZE, with a spec that looks something like:</p>
<pre><code>//
//  specialize: native [
//
//  {Create a new action through partial or full specialization of another}
//
//      return: [~action!~]  ; ~ notation since an isotopic action is returned
//      action "Function whose parameters will be set to fixed values"
//          [action!]
//      def "Definition for FRAME! fields for args and refinements"
//          [block!]
//  ]
//
</code></pre>
<p>Should SPECIALIZE tolerate being passed an isotopic action, maybe with a spec that looks like:</p>
<pre><code>return: [~action!~]
action "Function whose parameters will be set to fixed values"
    [action! ~action!~]
def "Definition for FRAME! fields for args and refinements"
    [block!]
</code></pre>
<p>This would lead to complexity inside most function, because now if it references the <strong>action</strong> variable it might run.  And this lack of automatic canonization to the inert form creates hassles for both usermode and native code alike.</p>
<p>Another thing is that the meaning of isotopic actions is potentially <em>very</em> different from that of a plain action.  For instance: <strong><code>find block :even?</code></strong> might know that since blocks cannot contain isotopes, it should interpret it as a function to call to test the items in the block for evenness.</p>
<p>So this led me to a bit of a thought...</p>
<h2>What if QUASI!-forms typechecked as the plain form?</h2>
<p>The idea is that there's an initial type check done.  If that check fails and it's a quasiform, it is tested again as its plain form.  If that passes, the plain form is received.</p>
<p>Producing a quasiform of an action from an isotope is easy, just use a meta operation.  So <strong><code>^append</code></strong> instead of <strong><code>:append</code></strong>.  All meta forms are inert, so code using the meta is less likely to do wild things.</p>
<p><em>To me, this feels like a safer exception than letting isotopes pass for plain forms.</em>  Due to their alien-ness, an isotopic form could intend something quite far from a mechanical brick in a block.  But what a quasiform has in common with a plain form is that both are inert.</p>
<p>Also, even the name "quasi" suggests a possibly loose relationship.  It carries the same payload as the plain form.  What if this were legal:</p>
<pre><code>&gt;&gt; add first [~1~] first [~2~]
== 3
</code></pre>
<p>I'm suggesting a general-enough mechanism that would work... so long as ADD didn't widen its net to taking actual ANY-VALUE! (which would indicate it had an actual meaning that applied to quasiforms).</p>
<p>This may not be the most brilliant thought to ever be thunk.  But in this more complex world there need to be succinct answers.  We don't want to have to write things like <strong><code>apply concretize :append [...]</code></strong>, and I feel like glossing over the fact that something is an isotope is a worse move than glossing over that something is a quasiform.</p>
<p>I even may like <strong><code>apply ^append [...]</code></strong> a bit more than <strong><code>apply :append [...]</code></strong> for looks, too.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012/1</link>
        <pubDate>Thu, 26 Jan 2023 18:42:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6565</guid>
      </item>
      <item>
        <title>Looking into a *usermode* POINTFREE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1236">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>POINTFREE is pretty awesome and I find it comes in handy a lot.</p>
</blockquote>
</aside>
<p>POINTFREE is very cool, but I'm removing its usage from bootstrap...because changes I want to make break it.  And it's hard to fix and redesign such things when the system won't boot.</p>
<p>While I <em>could</em> remove its bootstrap usage... and then make my next task after the changes be to work through it and put it back in the bootstrap, I'm actually not going to.  I'm just going to leave in a file on the side, as part of the test scripts--<em>for now</em>.  I'm going to leave it broken until such time as it's a priority to fix it.</p>
<p><em>I can't make everything a focus, and am mentioning this just to talk out loud about the need to become more mercenary.</em></p>
<p><strong><a href="https://forum.rebol.info/t/introducing-the-hackable-usermode-parse-uparse/1529">The big "what's possible in usermode" showcase is UPARSE.</a></strong>  And it stands on the shoulders of all the efforts like POINTFREE that came before it.  But the demand to keep all of these experiments working -and- try using them in the boot process is too much.</p> ]]></description>
        <link>https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236/8</link>
        <pubDate>Thu, 26 Jan 2023 18:05:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6564</guid>
      </item>
      <item>
        <title>Axing --breakpoint switch, C-DEBUG-BREAK-AT</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><strong>I'm killing off features for whom their maintenance is not paying off.</strong></p>
<p>One is the "tick" based usermode <code>--breakpoint</code> feature, implemented on the command line as:</p>
<pre><code>        "--breakpoint" end (
            c-debug-break-at to-integer param-or-die "BREAKPOINT"
        )
</code></pre>
<p>The complex problem of taking a "tick" count to break on via a command line switch is that since command line processing is in usermode, you have a kind of observer-affects-the-experiment situation.  The code for adding in the breakpoint messes with the tick count you're trying to reproduce.</p>
<p>I had ideas to work around this.  So there's the /COMPENSATE feature of C-DEBUG-BREAK, which I don't even know if it works or if my idea is fundamentally flawed:</p>
<pre><code>; Taking a command-line `--breakpoint NNN` parameter is helpful if a
; problem is reproducible, and you have a tick count in hand from a
; panic(), REBSER.tick, Frame.tick, REBVAL.extra.tick, etc.  But there's
; an entanglement issue, as any otherwise-deterministic tick from a prior
; run would be thrown off by the **ticks added by the userspace parameter
; processing of the command-line for `--breakpoint`**!  :-/
;
; The /COMPENSATE option addresses this problem.  Pass it a reasonable
; upper bound for how many ticks you think could have been added to the
; parse, if `--breakpoint` was processed (even though it might not have
; been processed).  Regardless of whether the switch was present or not,
; the tick count rounds up to a reproducible value, using this method:
;
; https://math.stackexchange.com/q/2521219/
;
; At time of writing, 1000 ticks should be *way* more than enough for both
; the PARSE steps and the evaluation steps `--breakpoint` adds.  Yet some
; things could affect this, e.g. a complex userspace TRACE which was
; run during boot.
;
attempt [c-debug-break-at/compensate 1000]  ; fails in release build
</code></pre>
<p>Here was more of it:</p>
<pre><code>  #if !defined(NDEBUG) &amp;&amp; DEBUG_COUNT_TICKS
    if (REF(compensate)) {
        //
        // Imagine two runs of Rebol console initialization.  In the first,
        // the tick count is 304 when C-DEBUG-BREAK/COMPENSATE is called,
        // right after command line parsing.  Later on a panic() is hit and
        // reports tick count 1020 in the crash log.
        //
        // Wishing to pick apart the bug before it happens, the Rebol Core
        // Developer then re-runs the program with `--breakpoint=1020`, hoping
        // to break at that tick, to catch the downstream appearance of the
        // tick in the panic().  But since command-line processing is in
        // usermode, the addition of the parameter throws off the ticks!
        //
        // https://en.wikipedia.org/wiki/Observer_effect_(physics)
        //
        // Let's say that after the command line processing, it still runs
        // C-DEBUG-BREAK/COMPENSATE, this time at tick 403.  Imagine our goal
        // is to make the parameter to /COMPENSATE something that can be used
        // to conservatively guess the same value to set the tick to, and
        // that /COMPENSATE ARG(bound) that gives a maximum of how far off we
        // could possibly be from the "real" tick. (e.g. "argument processing
        // took no more than 200 additional ticks", which this is consistent
        // with...since 403-304 = 99).
        //
        // The reasoning for why the formula below works for this rounding is
        // given in this StackExchange question and answer:
        //
        // https://math.stackexchange.com/q/2521219/
        //
        Tick one = 1; // MSVC gives misguided warning for cast(Tick, 1)
        TG_tick =
            (one &lt;&lt; (ceil_log2(TG_tick) + 1))
            + VAL_INT64(ARG(tick))
            - 1;
        return nullptr;
    }
</code></pre>
<p>Also, I've never used the /RELATIVE tick feature, killing that too:</p>
<pre><code>  if (REF(relative))
      TG_break_at_tick = frame_-&gt;tick + 1 + VAL_INT64(ARG(tick));
</code></pre>
<p><strong>I'm going to be deleting a lot of things, I think, in the pursuit of simplification--now that isotopes are showing the way.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/axing-breakpoint-switch-c-debug-break-at/2009/1</link>
        <pubDate>Tue, 24 Jan 2023 21:57:46 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6561</guid>
      </item>
      <item>
        <title>Getting Output From Rebol2 on Windows GitHub Actions</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>If you run Rebol 2 with the CGI flag (<code>-c</code>) you should be able to get basic interaction.</p> ]]></description>
        <link>https://forum.rebol.info/t/getting-output-from-rebol2-on-windows-github-actions/1966/2</link>
        <pubDate>Tue, 24 Jan 2023 16:14:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6560</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Same here, that is when I go for one of my help lines in these kinds of cases: The wordhippo</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://www.wordhippo.com/favicon.ico" class="site-icon" width="16" height="16">
      <a href="https://www.wordhippo.com/what-is/another-word-for/reify.html" target="_blank" rel="noopener">WordHippo</a>
  </header>
  <article class="onebox-body">
    <img src="https://wordhippo.s3.amazonaws.com/what-is/img/logo-200x200.png" class="thumbnail onebox-avatar" width="60" height="60">

<h3><a href="https://www.wordhippo.com/what-is/another-word-for/reify.html" target="_blank" rel="noopener">What is another word for reify? | Reify Synonyms - WordHippo Thesaurus</a></h3>

<p>Synonyms for reify include concretize, objectify, picture, thingify, embody, incarnate, manifest, externalize, substantiate and materialize. Find more similar words at wordhippo.com!</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<p>
There is a tab for antonyms as well. That would lead me to suggestions NEGLECT, OBSCURE or IGNORE.<br>
But with some creativity I came up with the word DEIFY.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001/4</link>
        <pubDate>Sun, 15 Jan 2023 12:30:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6557</guid>
      </item>
      <item>
        <title>Working With Truthy BLANK!</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The current re-imagining of the concept of truthy/falsey involves the idea that <em>anything you can put into a block is truthy</em>.  That includes BLANK!.</p>
<p>~null~ isotopes are falsey, and will REIFY to be <strong><code>~null~</code></strong> which can be somewhat clumsy-looking.</p>
<p>But consider some test cases for seeing how SPLIT-PATH works, looking a bit like this:</p>
<pre><code>split-path-tests:  [
    %foo                            [_ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%/ %/]
    %.                              [%./ _]
    %./                             [%./ _]
    %./.                            [%./ %./]
    &lt;...etc...&gt;
]
</code></pre>
<p>SPLIT-PATH is a multi-return routine, which gives back two values: the path and the filename.  But if one or the other is missing then that component will be null, which is useful for testing with IF (or using DEFAULT with).</p>
<p>But if we just blindly changed the tests to reify, it would become less legible:</p>
<pre><code>split-path-tests:  [
    %foo                            [~null~ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%/ %/]
    %.                              [%./ ~null~]
    %./                             [%./ ~null~]
    %./.                            [%./ %./]
    &lt;...etc...&gt;
]
</code></pre>
<p>However...with blanks being truthy, this means you that you can take a variable which may be null and turn it into a blank, like this:</p>
<pre><code>reduce [any [path _] any [file _]]
</code></pre>
<p>That's rather succinct!  Probably so succinct that it doesn't need its own native to express.</p>
<p>(I thought it was neat.)</p> ]]></description>
        <link>https://forum.rebol.info/t/working-with-truthy-blank/2007/1</link>
        <pubDate>Sat, 14 Jan 2023 15:21:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6556</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>Not being an English native speaker I'll have 5o trust you on this.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001/3</link>
        <pubDate>Thu, 12 Jan 2023 21:24:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6555</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2001">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Maybe... CONCRETIZE? That sounds like it might do a bit more work than what REIFY does :-/</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concretize true
== true

&gt;&gt; concretize 10
== 10
</code></pre>
<p>It's not awful</p>
</blockquote>
</aside>
<p>A shorter word would be CONCRETE.</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concrete true
== true

&gt;&gt; concrete 10
== 10
</code></pre>
<p>We do mess a bit with wording, but here it would be more of an adjective.</p>
<p><strong>Another big question is what the antonym of REIFY would be.</strong>  That is to say something that leaves all input values alone except for quasi forms, and gives you back an isotope.</p>
<pre><code>&gt;&gt; unreify first [~alpha~ 1020]
== ~alpha~  ; isotope

&gt;&gt; unreify second [~alpha~ 1020]
== 1020
</code></pre>
<p>Unfortunately, there's not a good opposite word for REIFY.  Maybe DEGRADE?</p>
<pre><code>&gt;&gt; degrade first [~alpha~ 1020]
== ~alpha~  ; isotope

&gt;&gt; degrade second [~alpha~ 1020]
== 1020
</code></pre>
<p>The pairing of CONCRETE/ABSTRACT might be a possibility here.  I'm not sure.</p>
<p>I think I'll go with DEGRADE a while and see how I like it.  The names can be juggled around once all the necessary behaviors are assembled.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001/2</link>
        <pubDate>Mon, 09 Jan 2023 13:15:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6552</guid>
      </item>
      <item>
        <title>&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>It's no secret that I'm proud of the way the <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">design for generalized isotopes</a> is tearing through classic problems in Rebol.</p>
<p>At the same time, people's eyes can glaze over when you find yourself writing sentences like:</p>
<blockquote>
<p><em>"All quasiforms become isotopic forms when evaluated, and when going the other way through a meta operation on an isotope, you'll get a quasiform back."</em></p>
</blockquote>
<p>It all makes sense to me.  But I don't want to overlook better terms, if they exist.</p>
<h2>How Did "Isotopes" Come To Be Called That?</h2>
<p>The term isotope originated from the "decaying" behavior, where a special form of null would run a THEN branch.  But this special form would not be something you could store in a variable...it would become an ordinary null at that point.  So getting stored in a variable would cause "decay".</p>
<pre><code>&gt;&gt; null
; null

&gt;&gt; if true [null]
; null isotope

&gt;&gt; x: if true [null]
; null isotope

&gt;&gt; x
; null
</code></pre>
<p>The decay means variables captured from expressions would have a different behavior when substituted for the expressions.  That was deemed to be an acceptable cost.</p>
<pre><code>&gt;&gt; if true [print "then", null] else [print "else"]
then

&gt;&gt; temp: if true [print "then", null]
then

&gt;&gt; temp else [print "else"]
else
</code></pre>
<p>The parallel with decay of atomic isotopes seemed pretty clear, at least to me.  Many places would see it as a normal null, but a few special sites could use a "sensor" to detect the difference.  ELSE was an example of something that could detect.</p>
<p>As things moved forward, and when logic variables became ~true~ and ~false~ isotopes, it became clear these isotopic states would need to be able to stored in variables.  That meant there were "unstable isotopes" and "stable isotopes"... e.g. WORD! isotopes were stable, ERROR! isotopes were not.</p>
<p><em><strong>Having these stable isotopes actually strengthened the analogy.</strong></em>  Because some atomic isotopes are stable, while others are not.</p>
<h2>How Did "QUASI" Become Called That?</h2>
<p>Originally, things like <code>~foo~</code> were called "bad words", designed to cause errors when accessed through a variable by default.  They were like an old-school UNSET! where you could give it a custom label.  But eventually everything was generalized so that everything had an isotopic form.</p>
<p>The fact that these forms stopped conveying an error condition meant considering them "bad" wasn't sensible.  I kind of latched onto "quasi" in part because of the tilde's use in approximation, e.g. (3.0001 ~= 3).</p>
<p>(It also sounds a little like "queasy" and the squigglies look wavy and maybe a bit uncomfortable.  <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">)</p>
<h2>So... Speak Now Or Hold Your Peace?</h2>
<p>Bad naming can have an impact.  I think calling complex numbers "imaginary" is a good example of a bad name that probably caused a few problems.</p>
<p>But I think the names here are good.  It's just going to be a matter of figuring out how to teach people to not be afraid of them.</p> ]]></description>
        <link>https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005/1</link>
        <pubDate>Sun, 08 Jan 2023 21:18:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6550</guid>
      </item>
      <item>
        <title>The Canonical List of Non-Negotiables</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h2>ATOMICITY OF ELEMENTS IN BLOCK!s AND GROUP!s</h2>
<p>A new non-negotiable for Ren-C is that for <em>any</em> BLOCK! (or blocklike thing) the following property holds:</p>
<pre><code>block2: copy []

for-each item block1 [append block2 item]

assert [block1 = block2]
</code></pre>
<p>Prior to isotopes, <em>it wasn't conceivable that such rules could hold.</em>  But after years scaling a mountain of design... I concluded this could be achieved, if all the tricky behaviors came from values "at quoting level -1" that could not be put into blocks.</p>
<ul>
<li>
<p>There are no isotopic actions to implicitly execute; you'd get an error trying to put them in the block.</p>
</li>
<li>
<p>There are no blocks/groups/paths that will splice into the target, because splicing requires an explicit conversion to an isotope.</p>
</li>
<li>
<p>There are no "unsets" to trip on that you can find in a block, because the state conveying "unsetness" (nihil) is an isotope.</p>
</li>
</ul> ]]></description>
        <link>https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244/9</link>
        <pubDate>Sat, 07 Jan 2023 23:35:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6548</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>FYI<br>
For Altme the important bit was setting up a lightweight headless display.<br>
We were using X virtual frame buffer then running jwm as a super light window manager.</p>
<pre><code class="lang-auto">Xvfb :0 -ac -screen 0 1024x768x24 &amp;
sleep 2
nohup /usr/bin/jwm -display :0 &amp; 
export DISPLAY=:0
./altme &amp;
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/5</link>
        <pubDate>Sat, 07 Jan 2023 23:31:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6547</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>I don't think there is much more to save from the server. I will take a backup of the code and make sure that what is in <a href="https://github.com/rebolbot/rebolbot">https://github.com/rebolbot/rebolbot</a> is correct. I will also upload the headless scripts to get altme working as well, if anyone is still using it?<br>
I have to say that Digital Ocean have been absolutely rock solid. I do not remember the box being rebooted once, other than following updates that I initiated. As an example, the current uptime is 87 days. These LTS Ubuntu variants do seem to do exactly what they say on the box - if we wanted to keep this running it would still be supported and patched until 2026 (<a href="https://wiki.ubuntu.com/Releases" class="inline-onebox">Releases - Ubuntu Wiki</a>).</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/4</link>
        <pubDate>Sat, 07 Jan 2023 23:19:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6546</guid>
      </item>
      <item>
        <title>Websocket Support in Oldes Rebol3</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Looking to see what Oldes has been up to, he added some kind of minimal websocket support to the HTTP scheme:</p>
<p><a href="https://github.com/Oldes/Rebol3/commit/bae6cffe97e662ec9a727a01cdcc1fdd61455ea6#diff-490ba807ac4a5ee57e7a587ca0936d36e4c0ff2798b0652fdf791e758ce079c2R718" class="inline-onebox">FEAT: Minimalistic WebSocket support in the `httpd` scheme · Oldes/Rebol3@bae6cff · GitHub</a></p>
<p>Websockets isn't something I'm looking into at this time, but I wanted to bookmark it here in case it comes up later.</p>
<p>He also updated zlib to a new version released in 2022... and <a href="https://github.com/Oldes/Rebol3/commit/15fcc00b84f6d0e386f2ba2f4fc7bdc32ebff75d">used Ren-C's %make-zlib.r to do it!</a>.  But he edited it so he'd be able to run it under his Rebol3.  It's not a huge priority to do that update, but seems like since his ported script still worked, it might not be too hard.  (And a good reminder that script exists, and should be part of a CI test...)</p> ]]></description>
        <link>https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003/1</link>
        <pubDate>Fri, 06 Jan 2023 03:56:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6544</guid>
      </item>
      <item>
        <title>Picking ACTION!s from BLOCK!s In The Age of Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>In <strong><a href="https://forum.rebol.info/t/reds-design-issues-wiki/1282">Red's Design Questions wiki</a></strong>, they bring up the issue of why picking functions out of blocks runs them:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block
Evaluated.  ; d'oh
== false
</code></pre>
<p><a href="https://gitter.im/red/red?at=5c782ca0c1cab53d6f53dd6d">In the Gitter conversation</a>, Boris calls it a "shady area" that they can't get out of "under the current semantic model".  He suggests it is clear that <strong><code>block/1</code></strong> should not run an action, but possible that <strong>block/word</strong> would mean to.</p>
<p>They contemplate the idea that <strong>block/1</strong> would not run the action, but pick it:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block  ; hypothetical behavior
== false
</code></pre>
<p><strong>I will argue this doesn't really help you much, the problem just becomes one step removed.</strong>  Quite often people are picking things out of blocks to put them in variables, and you'll just get bit there instead:</p>
<pre><code>red&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block/1
== func [][print "Evaluated."]

red&gt;&gt; append otherblock temp
Evaluated.  ; d'oh
== [unset]  ; double d'oh
</code></pre>
<h2>Isotopes Bring The Better Semantic Model!</h2>
<p>In Ren-C's concept (as I'm working on it), the only actions that will run from a word reference are those that are isotopic actions.  And FUNC or DOES creates an isotopic action.</p>
<p>So you would be stopped from making an illegal block up front:</p>
<pre><code>&gt;&gt; block: reduce [does [print "Evaluated."]]
** Script Error: Invalid use of ~#[action! []]~ isotope
</code></pre>
<p>You can put quasi-ACTION!s, plain ACTION!s, and quoted actions in blocks.  Just not isotopic ones.</p>
<p>Whichever you choose, the equality test will work... and picking out a value into a variable will give you an inert variable to work with, that can be used with things like append!</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; equal? block.1 first block
== ~true~  ; isotope  &lt;-- didn't run and print "Evaluated", yay!

&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block.1
== ~#[action! []]~

red&gt;&gt; append otherblock temp
== [~#[action! []]~]   ; &lt;-- didn't run and gave sensible block out
</code></pre>
<p>I used REIFY there and got a quasi-action.  BUT which would you rather put in the block: a quasi-action or a plain one?  This depends on what you plan to do with the block.  A plain action will execute when encountered by the evaluator, while a quasi-action will evaluate to an isotopic action--suitable for assigning via SET-WORD! when you meant to make that word dispatch the function when referenced.</p>
<p>My leaning is to say that either form can be used with APPLY, RUN, or the terminal path form:</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; run block.1
Evaluated.

&gt;&gt; block: reduce [concretize does [print "Evaluated."]] 
== [#[action! []]]

&gt;&gt; apply block.1 []
Evaluated.
</code></pre>
<p><em>(See post on <a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">difference between REIFY and CONCRETIZE</a>, and the search for a better term...)</em></p>
<p>If you want to pick an action out of a block and put it into a variable, where it will execute from that variable, there is the RUNS transformer.  It will turn a quasi or plain ACTION! into an action isotope:</p>
<pre><code> &gt;&gt; active-var: runs block.1
 == ~#[action! {active-var} []]~  ; isotope  &lt;-- note: also cached name, neat!

 &gt;&gt; active-var
 Evaluated.
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=9" title=":clap:" class="emoji only-emoji" alt=":clap:"></p>
<p>You can use UNMETA more generically to get an isotope back from any quasi-form (not just actions), or ISOTOPIC to get an isotope from a plain form.</p>
<h2>The Invariant Is What Counts, Here!</h2>
<p>The mountain that has been climbed is that we can now say that for any block, this is true:</p>
<pre><code>block2: collect [
    for-each item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<ul>
<li>
<p>I've just covered that there are no isotopic actions to implicitly execute; you'd get an error trying to put them in the block.</p>
</li>
<li>
<p>There are no blocks/groups/paths that will splice into the target, because splicing requires an explicit conversion to an isotope.</p>
</li>
<li>
<p>There are no "unsets" to trip on that you can find in a block, because the state conveying "unsetness" (nihil) is an isotope.</p>
</li>
</ul>
<p>Of course with objects, it's going to be a different story.  I think we'll still want some safeguards:</p>
<pre><code>for-each [key value] object [...]  ; will error when value is action

for-each [key :value] object [...]  ; will allow action isotopes as-is

for-each [key ^value] object [...]  ; will give a meta value
</code></pre>
<p>A key problem here is I'm wondering how much to cross purposes of GET-WORD! between action disarming and the other isotopic states.  But, it just takes time to work through.</p> ]]></description>
        <link>https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002/1</link>
        <pubDate>Fri, 06 Jan 2023 03:16:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6543</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Originally I suggested that REIFY of an isotope would give its plain form, and you would META it if you wanted a quasiform:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/1">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</a>
</div>
<blockquote>
<ul>
<li>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</li>
<li>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</li>
</ul>
</blockquote>
</aside>
<p><em>But that's not a full coverage answer.</em></p>
<ul>
<li>
<p>An operator that takes everything "one level up", where isotopes become quasiforms and everything else gets a quote level added.</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; meta true
== ~true~

&gt;&gt; meta 10
== '10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their quasiforms (and I think this probably is best called REIFY):</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; reify true
== ~true~

&gt;&gt; reify 10
== 10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their plain forms:</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; something true
== true

&gt;&gt; something 10
== 10
</code></pre>
</li>
</ul>
<p>Specifically for ACTION! isotopes being turned into plain actions, I used an interim term UNRUN, but that's pretty awful.</p>
<p>Making things into isotopes is done with ISOTOPIC:</p>
<pre><code>&gt;&gt; isotopic 10
== ~10~  ; isotope
</code></pre>
<p>It could be a refinement to REIFY, like REIFY/PLAIN.  But at that point it could be two steps that might be clearer: NOQUASI REIFY, where NOQUASI would be like NOQUOTE and not complain if the thing you passed it was not a quasiform.</p>
<p>Maybe... CONCRETIZE?  That sounds like it might do a bit more work than what REIFY does :-/</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concretize true
== true

&gt;&gt; concretize 10
== 10
</code></pre>
<p>It's not awful.  Main thing is just to have <em>a</em> name for it while the gears turn.  But as usual, throw out suggestions if you have them...</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001/1</link>
        <pubDate>Thu, 05 Jan 2023 21:26:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6542</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm curious about this distinction... why wouldn't a filter that takes in UTF-8 and produces a block of transcoded data be covered here? What's the missing capability?</p>
</blockquote>
</aside>
<p>I think it's ultimately scope creep. In my proposal in the other thread, I'd conceived as such a mechanism as tokenizing as well, but in hashing out many of the data points I've been considering, it just became too convoluted. I feel in isolating binary/text it's really a clean separation that lends well to optimization and doesn't fall into the Codec black box that I think is ultimately problematic.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The umbrella term I tend to myself use above "Filter"/"Codecs"/"Ports" is "Streaming".</p>
</blockquote>
</aside>
<p><em>'Filter'</em> is the term used in PDF and I think lends itself to this specific isolation. <em>'Streaming'</em> would apply, but could also be saved for more appropriate use, such as the mechanism for moving data in from external sources. And one can apply <em>filters</em> to a <em>stream</em>...</p>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Maybe we could get examples worked up and see some contrast with how those would be done e.g. in C++ (with <a href="https://think-async.com/Asio/">Boost.Asio</a>) or in Conduit/Pipes/Machines/Streams of Haskell? I feel that really helped with UPARSE to drive the design from ideas that had already been worked out.</p>
</blockquote>
</aside>
<p>I'm still following through on my line of inquiry here and see if I can get some success in streamlining some of the <em>'Codec'</em> work I've been exploring. Certainly some of this thinking comes, again, from working a bit with Iterators in Javascript. I still think tokenization can be done in an iterative fashion as well, but that's a bit down the line.</p>
<hr>
<p>I'm inclined to think this concept offers something new and quite compelling that I don't see in these alternatives (or at least, <em>Pipes</em> would seem similar but I find the examples quite opaque). The ability to work through layered encoding in an incremental manner that would only place in memory the essential parts of a stream, and in a way that is really quite minimal in terms of its impact on the language. The mechanics for obtaining the stream are where they should be and it encourages a style of handling incoming data in a way that is incremental, precise and relatively non-blocking—180º from the traditional Rebol family model if nothing else.</p>
<p>Of course, it's easy to say so. Need to actually flex it a bit to back that up. And I haven't got to PostScript yet...</p> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/5</link>
        <pubDate>Thu, 05 Jan 2023 20:33:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6541</guid>
      </item>
      <item>
        <title>Happy 2023, and 2022 General Status &amp; Reflection</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I mention up top that I have been busy for all of November and December, so I didn't do anything worth adding to the October status post in terms of <em>code progress</em>.</p>
<p>But putting some space between yourself and the code can offer other insights.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1988">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm still "finding the cool" in new behaviors, so that's motivating. But maybe with the basics sorted out, it's getting closer to time to start ripping out some unnecessary parts, so that a committed subset can be pushed out to people on the web.</p>
</blockquote>
</aside>
<p><em>Definitely this:</em> <em><strong>I want to put the system into people's hands.</strong></em></p>
<p>We've reached a point where for once, we know how APPEND works.  That is no small feat... and the solution was a decade in the making.</p>
<p>I believe we now know how true and false work, with <code>~true~</code> and <code>~false~</code> being their meta state that evaluates to an isotopic state which can't be put into blocks.</p>
<p>There are so many neat solutions to old questions... like what is <strong><code>any []</code></strong> or <strong><code>all []</code></strong>, and having coherent answers to basic questions is something to stand on the shoulders of for the next tough question.  It all interlocks.</p>
<p><strong>I'm hard-pressed to say exactly what's going to happen with binding, but I'm wondering if there's any way to make a system that's useful even if we don't know how that will work.</strong></p>
<p>But I'm going to keep going at it, and start posting again here now that I'm getting more settled.  Again: Happy New Year!</p> ]]></description>
        <link>https://forum.rebol.info/t/happy-2023-and-2022-general-status-reflection/1988/3</link>
        <pubDate>Thu, 05 Jan 2023 19:43:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6540</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Related threads:</p>
<ul>
<li><a href="https://forum.rebol.info/t/streaming-mental-blocks-and-some-haskell-streaming-research/1325" class="inline-onebox">Streaming Mental Blocks, and some Haskell Streaming Research</a></li>
<li><a href="https://forum.rebol.info/t/streaming-survey-from-other-languages/1739" class="inline-onebox">"Streaming" Survey from Other Languages</a></li>
<li><a href="https://forum.rebol.info/t/parsing-giant-streams-without-consuming-tons-of-memory-how/1698" class="inline-onebox">Parsing Giant Streams Without Consuming Tons of Memory: How?</a></li>
</ul>
<hr>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="1" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>this concept is more focused on transcoding one series of numbers/characters to another. Filters are NOT scanners/tokenizers/lexers.</p>
</blockquote>
</aside>
<p>I'm curious about this distinction... why wouldn't a filter that takes in UTF-8 and produces a block of transcoded data be covered here?  What's the missing capability?</p>
<aside class="quote no-group" data-username="rgchris" data-post="1" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>A filter could conceivably be implemented as a distinct type that has object-like properties (as the PORT! type does) and could thus be acted upon by the appropriate Rebol actors (COPY/SKIP/NEXT/TAIL, etc.).</p>
</blockquote>
</aside>
<p>The umbrella term I tend to myself use above "Filter"/"Codecs"/"Ports" is "Streaming".  This is because of the use of the term in C++ and in Haskell in the cases I find interesting.  But even in Haskell it branches off into different models, such as <strong><a href="https://www.schoolofhaskell.com/school/advanced-haskell/conduit-overview">Conduit</a></strong>, <strong><a href="https://www.schoolofhaskell.com/user/Gabriel439/Pipes%20tutorial">Pipes</a></strong> and <strong><a href="https://statusfailed.com/blog/2014/09/02/practical-machines-in-60-seconds.html">Machines</a></strong></p>
<p>I'm glad you're putting down some concrete examples and experimenting with them.  Because if one stays fully general it gets hard to know what the limits are that would inform a useful design.</p>
<p>Maybe we could get examples worked up and see some contrast with how those would be done e.g. in C++ (with <a href="https://think-async.com/Asio/">Boost.Asio</a>) or in Conduit/Pipes/Machines/Streams of Haskell?  I feel that really helped with UPARSE to drive the design from ideas that had already been worked out.</p> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/4</link>
        <pubDate>Thu, 05 Jan 2023 18:16:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6539</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>One interesting file format is that of <a href="http://site.xara.com/support/docs/webformat/spec/">Xara (XAR) vector images</a>. They consist of an eight-byte header followed by a collection of records. Records consist of two little-endian 32-bit integers denoting the record type and size followed by the record content. Presumably easy to traverse—however: the wrinkle here is that there is one record type that indicates that subsequent records are encoded in a single Deflate stream that terminates with both the end of the Deflate stream and a record type that indicates the end of the compressed section.</p>
<p>This is a simplified way of looking at it (each tag representing a whole record):</p>
<pre><code class="lang-nohighlight">---- regular byte stream ----
&lt;8-byte header&gt;
&lt;title&gt;
&lt;metadata&gt;
&lt;start-compressed-section&gt;
---- deflate compressed byte stream ----
&lt;thing&gt;
&lt;thing&gt;
...
&lt;end-compressed-section&gt;
---- regular byte stream ----
&lt;thing&gt;
&lt;thing&gt;
---- eof ----
</code></pre>
<p>This type of switch could be handled with filters.</p>
<pre><code class="lang-nohighlight">file-content: make filter! [
    source: open/direct %image.xar
]

content: file-content

consume content #{... magic number ...}

until [
    type: consume content 'unsigned-32-le
    size: consume content 'unsigned-32-le

    switch type [
        types/start-compressed-section [
            content: make filter! [
                type: 'deflate
                source: file-content
            ]
        ]

        types/end-compressed-section [
            assert [
                tail? content
            ]

            content: file-content
        ]
    ]

    ... record dispatcher ...

    type == types/end-of-file
]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/3</link>
        <pubDate>Thu, 05 Jan 2023 15:06:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6538</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>I'll spitball samples/test cases in replies. The example from the ports/streams/iterator posts was a layered encoding where an compressed encoding is in turn encoded as text:</p>
<pre><code class="lang-nohighlight">encoded: make filter! [
    ; implied type: 'text
    source: "start F3DI7!! end"
]

consume encoded "start"

encoded-ascii85: make filter! [
    type: 'ascii85
    source: encoded
]

encoded-deflate: make filter! [
    type: 'deflate
    source: encoded-ascii85
]

result: copy encoded-deflate

consume encoded " end"
=&gt; true
</code></pre>
<h2>Extracting from a large file</h2>
<pre><code class="lang-nohighlight">big-file: open/direct %big-file.txt

file-content: make filter! [
    ; implied type: 'stream
    source: big-file
]

copy/part skip file-content 1'000'000 25
</code></pre>
<p>As mentioned, ideally filter algorithms would have mechanisms to skip content without buffering, so you could do the following as fast as any other way of doing it:</p>
<pre><code class="lang-nohighlight">big-file: open/direct %big-file.txt

file-content-as-utf-8: make filter! [
    type: 'utf-8
    source: make filter! [
        ; implied type: 'stream
        source: big-file
    ]
]

copy/part skip file-content 1'000'000 25
; skips 1'000'000 UTF-8 characters without copying/buffering
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/2</link>
        <pubDate>Thu, 05 Jan 2023 04:01:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6537</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>Filters are a means of incrementally transcoding data from source to brokered output (bytes/binary! or characters/text!). A goal is to provide a standard API for transcoding that can be implemented and used as efficiently as possible (e.g. extracting a portion of encoded data without extracting the whole; native transcoders for Deflate). A filter could conceivably be implemented as a distinct type that has object-like properties (as the PORT! type does) and could thus be acted upon by the appropriate Rebol actors (COPY/SKIP/NEXT/TAIL, etc.).</p>
<p><em>I've alluded to a similar idea in <a href="https://forum.rebol.info/t/semantics-of-port-s-vs-streams-vs-iterators/1689/4">an earlier post</a>, however this concept is more focussed on transcoding one series of numbers/characters to another. Filters are NOT scanners/tokenizers/lexers.</em></p>
<p>A filter source can be:</p>
<ul>
<li>BINARY! or TEXT! values</li>
<li>PORT! values that stream BINARY! or TEXT! (including files/network resources)</li>
<li>filter values (i.e. filters can be layered)</li>
</ul>
<p>Examples of filter types:</p>
<ul>
<li>Retrieves binary contained within a file/network resource</li>
<li>Decodes text encoded as UTF-8, UTF-16, ISO-8859-1, CP-1252, etc. (or even unspecified using something like Chardet)</li>
<li>Decodes binary compressed per Deflate, LZW, etc.</li>
<li>Decodes binary encoded as 'text' per Base64, Ascii85, Hexadecimal, etc.</li>
<li>Decrypts binary encrypted per e.g. Rebol 2 ENCLOAK/DECLOAK (but obviously more)</li>
<li>Decodes text encoded mostly literally but with escape sequences, e.g. JSON strings, Rebol strings, XML/HTML data sequences/attribute values</li>
</ul>
<p>Filters should have at least the following capabilities:</p>
<ul>
<li>Copy all encoded data</li>
<li>Copy part of the encoded data</li>
<li>Skip part of the encoded data (Deflate could potentially iterate faster if it wasn't emitting simultaneously)</li>
</ul>
<p>Filters should possibly have the following capabilities:</p>
<ul>
<li>BACK/HEAD/negative SKIP support</li>
<li>TAKE/REMOVE/CLEAR as a means of clearing buffers</li>
</ul>
<p>Functions that consume data should support filters as a pseudo-series type, e.g.</p>
<ul>
<li>Parse</li>
<li>BINARY/READ (from Oldes/Rebol3)</li>
<li>CONSUME (from <a href="https://forum.rebol.info/t/bincode/1863">rgchris/bincode</a>)</li>
</ul>
<p>Filter values are exhausted when:</p>
<ul>
<li>An end-of-content signal/delimiter has been found e.g. self-terminating formats such as Deflate; quote marks ending a JSON string</li>
<li>A filter cap has been reached e.g. the filter has a specified length</li>
<li>An unrecoverable error occurs (e.g. invalid UTF-8 sequences in strict mode; the 'g' character in a hexadecimal stream)</li>
<li>The source has been exhausted</li>
</ul>
<p>It should be possible to recover the current source at the corresponding index within a filter value though this may require additional state info, e.g. in Deflate or Base64 where a byte within an encoding has information pertaining to more than one decoded byte</p>
<p>Filter algorithms can be native (e.g. Deflate tied to Zlib, UTF-8) or in user-mode (thus extensible).</p> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/1</link>
        <pubDate>Thu, 05 Jan 2023 03:49:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6536</guid>
      </item>
      <item>
        <title>JavaScript object notation shorthand</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>In essence, there's already three BLOCK! constructors in traditional Rebol (REDUCE, COMPOSE and COLLECT) of which COLLECT is perhaps the most versatile. It does require KEEP for most values which is likely why it's not the only one, but gives you access to all of the other language features:</p>
<pre><code class="lang-nohighlight">; alt-ARRAY
;
collect [
    repeat value 4 [
        keep value
    ]
]
</code></pre>
<p>A few variations on KEEP would be similarly useful in OBJECT! and MAP! creation:</p>
<pre><code class="lang-nohighlight">collect-map [
    keep "key" "value"
    spread another-map
]

collect-object [
    keep foo: "Bar"
    keep ["a" 123] "A value"
    spread another-object
]
</code></pre>
<p>I do like the idea of implicit collection though as well. I don't know if it's at all possible to mix implicit/explicit collection in any sane way.</p>
<hr>
<p>This would completely mess with any trivial noodling around with the language, but you could use A in place of CONSTRUCTOR in the previous posting:</p>
<pre><code class="lang-nohighlight">a block! [
    1 2 [3 4] spread [5 6] a map! [
        combine ["a" 123] "A value"
        from another-key
        spread another-map
    ]
]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/javascript-object-notation-shorthand/1836/4</link>
        <pubDate>Mon, 02 Jan 2023 14:06:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6535</guid>
      </item>
      <item>
        <title>JavaScript object notation shorthand</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="rgchris" data-post="2" data-topic="1836">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I had to unlearn the idea that <code>[ ]</code> and <code>{ }</code> notation were <em>literals</em>; rather they are <em>constructors</em>.</p>
</blockquote>
</aside>
<p>I am not completely settled on my ideas about what I have called "fences":</p>
<p><a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727" class="inline-onebox">{ Rethinking Braces }... as an array type?</a></p>
<p>The idea that braces evaluate to unstable fence isotopes and then decay into objects is so strange that I want to try it just to know what that might be like (!)</p> ]]></description>
        <link>https://forum.rebol.info/t/javascript-object-notation-shorthand/1836/3</link>
        <pubDate>Mon, 02 Jan 2023 14:01:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6534</guid>
      </item>
      <item>
        <title>JavaScript object notation shorthand</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>In understanding JavaScript more from a Rebol-brain (or even just with JSON priors), I had to unlearn the idea that <code>[ ]</code> and <code>{ }</code> notation were <em>literals</em>; rather they are <em>constructors</em>. I think this distinction is why JavaScript is at best awkwardly Lispy. Also constructors can't self-reference so e.g. within an object you can't reference a prior key set in the same construction (<code>{'a': 123, 'b': &lt; no way to get 'a' &gt;}</code>), although one 'benefit' to this is you can't inadvertently create a circularly referenced structure.</p>
<p>I do like the constructors in principle, but again in Rebol-land my inclination is to do this with language rather than syntax—the question is given how much heavy lifting syntax does in constructors, how much language/convention would need to be used to get some a degree of parity without being overly verbose:</p>
<pre><code class="lang-nohighlight">[
    1, 2, [3, 4], ...[5, 6], {
        ["a" + 123]: "A value",
        anotherKey,
        ...anotherMap
    }
]

constructor block! [
    1 2 [3 4] spread [5 6] constructor map! [
        combine ["a" 123] "A value"
        from another-key
        spread another-map
    ]
]
</code></pre>
<p>I don't suppose it's a trivial exercise.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1836">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It may be that there should be a less freeform alternative to MAKE OBJECT! which doesn't let you put arbitrary code in the middle of it.</p>
</blockquote>
</aside>
<p>This sounds like CONSTRUCT as was.</p> ]]></description>
        <link>https://forum.rebol.info/t/javascript-object-notation-shorthand/1836/2</link>
        <pubDate>Mon, 02 Jan 2023 13:36:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6533</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>Thanks for keeping this going for so long! I will likely try and recreate bits and pieces from the <strong>rebol.info</strong> site elsewhere. I may need help getting headless <strong>altme</strong> running somehow—I'm not really sure if there's too much point but nice to have the option.</p>
<p>I have the list of <a href="http://rebol.info/bot/links.r">Rebolbot links</a> saved, is there any other Rebolbot data worth holding on to?</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/3</link>
        <pubDate>Sun, 01 Jan 2023 17:53:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6532</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Thanks for keeping it up... I didn't know it was around still!</p>
<p>We don't need an active RebolBot server.  But it might be nice to put it under GitHub CI to prevent the code from rotting (any more than it has), at some point.  Just something that asks it to do a few tasks and makes sure it can do them in a container.</p>
<p>I've been relatively inactive on Rebol the last couple of months, but expect this to change in the New Year.  I'll write up a post shortly...</p>
<p>Thanks again for keeping tabs and your help!</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/2</link>
        <pubDate>Fri, 30 Dec 2022 17:12:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6531</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>Hi guys<br>
I think it is time to turn off the old rebolbot server as I have not been using it for a while. <a class="mention" href="/u/rgchris">@rgchris</a> may still have a few things running on it, so this is a heads up that I plan to turn it off in the next month or so.<br>
All the best,<br>
John</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/1</link>
        <pubDate>Thu, 29 Dec 2022 07:31:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6530</guid>
      </item>
      <item>
        <title>SPLIT Semantics</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><a href="https://gitter.im/red/red?at=63523097f00b697fec501c7a">On Red Gitter</a>, it was discussed "which of the following is 'correct'":</p>
<pre><code>Red&gt; split "" ","
== [""]

R3&gt; split "" ","
== []
</code></pre>
<p>Rebolek thinks R3 is right.  Boris says:</p>
<blockquote>
<p>I don't think there's a correct answer, just choices. I prefer the Red version because:<br>
it strictly follows the rule: `number-of-segments = 1 + number-of-delimiters", no exceptions, so it's easier to reason about</p>
<p>it should be able thus to preserve the type in case one wants to rejoin it later (that it doesn't is a bug, try split %"" ",")</p>
</blockquote>
<p>So there's a couple of ways to look at it.</p>
<p>But I have a philosophy about these things where I want edge cases to be "noisy", because usually they require special handling.  I might even say:</p>
<pre><code>&gt;&gt; split "" ","
== ~null~  ; isotope</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/split-semantics/1998/1</link>
        <pubDate>Thu, 22 Dec 2022 04:04:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6529</guid>
      </item>
      <item>
        <title>ChatGPT Speaking About Rebol</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>I'm going to ask it to create a GUI (replacement using Qt or GTK)</p> ]]></description>
        <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997/2</link>
        <pubDate>Sun, 18 Dec 2022 19:15:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6528</guid>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If we were "more honest" and just META'd the isotopic blank, we'd get renders like:</p>
<pre><code>make object! [
    alpha: ~_~
    beta: ~_~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~_~
    omega: 'now
]
</code></pre>
<p>But I might actually like that less than seeing <strong><code>~null~</code></strong> there.</p>
</blockquote>
</aside>
<p>You don't always know how you're going to feel until you've tried something a while.  But I have to say I'm starting to like <strong><code>~null~</code></strong> a lot more than I expected.</p>
<p>In fact, I was just reading some code:</p>
<pre><code>let meta: meta-of action
let notes: null
let description: null
</code></pre>
<p>And I thought to myself... hey.  That doesn't feel like it's "calling out" the nulls as much as I might like (!)  I almost felt like changing it:</p>
<pre><code>let meta: meta-of action
let notes: ~null~
let description: ~null~
</code></pre>
<p>Add oddly enough, that's faster...because it doesn't need to fetch the definition of the WORD! <strong><code>null</code></strong>.</p>
<p>I'm not <em>actually</em> going to change it.  But the fact that I thought about it makes me comfortable with the decision to go this route.  It feels more natural than I expected.</p> ]]></description>
        <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/4</link>
        <pubDate>Fri, 27 Jan 2023 21:03:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6568</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2001">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their plain forms:</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; something true
== true

&gt;&gt; something 10
== 10
</code></pre>
</blockquote>
</aside>
<p>After pushing various problems around: <strong><em>I think it has turned out that this operation is more useful in practice</em> ...and likely deserves the coveted term "REIFY".</strong></p>
<p>In particular, I think it may be the answer to passing isotopic actions as parameters in a way that conflates with plain actions, yet canonizes it to plain.  e.g. the <strong><code>&lt;reify&gt;</code></strong> tag could indicate a desire to turn isotopic actions into non-isotopic ones if passed.  But it would be generic.  If you use it you mean you want anything passed to arrive in its reified form.</p>
<pre><code> func [arg [block!] /predicate [&lt;reify&gt; action!]] [...]
</code></pre>
<p>That feels like a pretty intelligent solution to the problem, while being generic enough to be useful for other purposes.</p>
<p>The other operation (which I called REIFY above) would be what needed a name.  Maybe it's a parameter to META, something like a META/ISOTOPE or similar.  I'll keep thinking, but I don't think it's going to be needed very often...whereas the sense of REIFY I'm talking about here is actually showing up a lot of places.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001/5</link>
        <pubDate>Fri, 27 Jan 2023 20:49:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6567</guid>
      </item>
      <item>
        <title>ChatGPT Speaking About Rebol</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/ef46f6ed21a760ee729f697f3ce5f5e776e97206.png" data-download-href="https://forum.rebol.info/uploads/default/ef46f6ed21a760ee729f697f3ce5f5e776e97206" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/ef46f6ed21a760ee729f697f3ce5f5e776e97206.png" alt="image" data-base62-sha1="y8K9GNX2z0xyXt4Nt9YaGfNuODc" width="468" height="499" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/ef46f6ed21a760ee729f697f3ce5f5e776e97206_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">652×696 13.6 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8.png" data-download-href="https://forum.rebol.info/uploads/default/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8.png" alt="image" data-base62-sha1="wA8R2o1Qk1ewNbNaJOGrW3dzqha" width="659" height="500" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/e45b7a8bac5d8b812f526eb166ae48da3c7fb1e8_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">685×519 16 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/5ccd13ead198bb971401d36c7b73cd7cc33052c5.png" alt="image" data-base62-sha1="deXiShPN2xO1ngpAGH0Gmt20keh" width="647" height="487"></p>
<p>ChatGPT can grasp some pretty abstract stuff.  If they ever give it access to dev tools (so it can test-compile code) or other real-time information, it's going to be pretty darn good, I'd say.</p> ]]></description>
        <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997/3</link>
        <pubDate>Fri, 27 Jan 2023 05:22:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6566</guid>
      </item>
      <item>
        <title>Should Quasiform Parameters Accept as the Plain Form?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><strong><a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">I'm very confident of the goodness of "isotopic actions"</a></strong>.</p>
<p>Not being able to put them in blocks gives us the <a href="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244/9">nice, mechanical invariant</a> of being able to manipulate blocks without inadvertently running functions in the process.  It opens the doors to other guardrails against isotopes being in variables when it might surprise you.</p>
<p>But what happens when you write something like SPECIALIZE, with a spec that looks something like:</p>
<pre><code>//
//  specialize: native [
//
//  {Create a new action through partial or full specialization of another}
//
//      return: [~action!~]  ; ~ notation since an isotopic action is returned
//      action "Function whose parameters will be set to fixed values"
//          [action!]
//      def "Definition for FRAME! fields for args and refinements"
//          [block!]
//  ]
//
</code></pre>
<p>Should SPECIALIZE tolerate being passed an isotopic action, maybe with a spec that looks like:</p>
<pre><code>return: [~action!~]
action "Function whose parameters will be set to fixed values"
    [action! ~action!~]
def "Definition for FRAME! fields for args and refinements"
    [block!]
</code></pre>
<p>This would lead to complexity inside most function, because now if it references the <strong>action</strong> variable it might run.  And this lack of automatic canonization to the inert form creates hassles for both usermode and native code alike.</p>
<p>Another thing is that the meaning of isotopic actions is potentially <em>very</em> different from that of a plain action.  For instance: <strong><code>find block :even?</code></strong> might know that since blocks cannot contain isotopes, it should interpret it as a function to call to test the items in the block for evenness.</p>
<p>So this led me to a bit of a thought...</p>
<h2>What if QUASI!-forms typechecked as the plain form?</h2>
<p>The idea is that there's an initial type check done.  If that check fails and it's a quasiform, it is tested again as its plain form.  If that passes, the plain form is received.</p>
<p>Producing a quasiform of an action from an isotope is easy, just use a meta operation.  So <strong><code>^append</code></strong> instead of <strong><code>:append</code></strong>.  All meta forms are inert, so code using the meta is less likely to do wild things.</p>
<p><em>To me, this feels like a safer exception than letting isotopes pass for plain forms.</em>  Due to their alien-ness, an isotopic form could intend something quite far from a mechanical brick in a block.  But what a quasiform has in common with a plain form is that both are inert.</p>
<p>Also, even the name "quasi" suggests a possibly loose relationship.  It carries the same payload as the plain form.  What if this were legal:</p>
<pre><code>&gt;&gt; add first [~1~] first [~2~]
== 3
</code></pre>
<p>I'm suggesting a general-enough mechanism that would work... so long as ADD didn't widen its net to taking actual ANY-VALUE! (which would indicate it had an actual meaning that applied to quasiforms).</p>
<p>This may not be the most brilliant thought to ever be thunk.  But in this more complex world there need to be succinct answers.  We don't want to have to write things like <strong><code>apply concretize :append [...]</code></strong>, and I feel like glossing over the fact that something is an isotope is a worse move than glossing over that something is a quasiform.</p>
<p>I even may like <strong><code>apply ^append [...]</code></strong> a bit more than <strong><code>apply :append [...]</code></strong> for looks, too.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012/1</link>
        <pubDate>Thu, 26 Jan 2023 18:42:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6565</guid>
      </item>
      <item>
        <title>Looking into a *usermode* POINTFREE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1236">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>POINTFREE is pretty awesome and I find it comes in handy a lot.</p>
</blockquote>
</aside>
<p>POINTFREE is very cool, but I'm removing its usage from bootstrap...because changes I want to make break it.  And it's hard to fix and redesign such things when the system won't boot.</p>
<p>While I <em>could</em> remove its bootstrap usage... and then make my next task after the changes be to work through it and put it back in the bootstrap, I'm actually not going to.  I'm just going to leave in a file on the side, as part of the test scripts--<em>for now</em>.  I'm going to leave it broken until such time as it's a priority to fix it.</p>
<p><em>I can't make everything a focus, and am mentioning this just to talk out loud about the need to become more mercenary.</em></p>
<p><strong><a href="https://forum.rebol.info/t/introducing-the-hackable-usermode-parse-uparse/1529">The big "what's possible in usermode" showcase is UPARSE.</a></strong>  And it stands on the shoulders of all the efforts like POINTFREE that came before it.  But the demand to keep all of these experiments working -and- try using them in the boot process is too much.</p> ]]></description>
        <link>https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236/8</link>
        <pubDate>Thu, 26 Jan 2023 18:05:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6564</guid>
      </item>
      <item>
        <title>Axing --breakpoint switch, C-DEBUG-BREAK-AT</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><strong>I'm killing off features for whom their maintenance is not paying off.</strong></p>
<p>One is the "tick" based usermode <code>--breakpoint</code> feature, implemented on the command line as:</p>
<pre><code>        "--breakpoint" end (
            c-debug-break-at to-integer param-or-die "BREAKPOINT"
        )
</code></pre>
<p>The complex problem of taking a "tick" count to break on via a command line switch is that since command line processing is in usermode, you have a kind of observer-affects-the-experiment situation.  The code for adding in the breakpoint messes with the tick count you're trying to reproduce.</p>
<p>I had ideas to work around this.  So there's the /COMPENSATE feature of C-DEBUG-BREAK, which I don't even know if it works or if my idea is fundamentally flawed:</p>
<pre><code>; Taking a command-line `--breakpoint NNN` parameter is helpful if a
; problem is reproducible, and you have a tick count in hand from a
; panic(), REBSER.tick, Frame.tick, REBVAL.extra.tick, etc.  But there's
; an entanglement issue, as any otherwise-deterministic tick from a prior
; run would be thrown off by the **ticks added by the userspace parameter
; processing of the command-line for `--breakpoint`**!  :-/
;
; The /COMPENSATE option addresses this problem.  Pass it a reasonable
; upper bound for how many ticks you think could have been added to the
; parse, if `--breakpoint` was processed (even though it might not have
; been processed).  Regardless of whether the switch was present or not,
; the tick count rounds up to a reproducible value, using this method:
;
; https://math.stackexchange.com/q/2521219/
;
; At time of writing, 1000 ticks should be *way* more than enough for both
; the PARSE steps and the evaluation steps `--breakpoint` adds.  Yet some
; things could affect this, e.g. a complex userspace TRACE which was
; run during boot.
;
attempt [c-debug-break-at/compensate 1000]  ; fails in release build
</code></pre>
<p>Here was more of it:</p>
<pre><code>  #if !defined(NDEBUG) &amp;&amp; DEBUG_COUNT_TICKS
    if (REF(compensate)) {
        //
        // Imagine two runs of Rebol console initialization.  In the first,
        // the tick count is 304 when C-DEBUG-BREAK/COMPENSATE is called,
        // right after command line parsing.  Later on a panic() is hit and
        // reports tick count 1020 in the crash log.
        //
        // Wishing to pick apart the bug before it happens, the Rebol Core
        // Developer then re-runs the program with `--breakpoint=1020`, hoping
        // to break at that tick, to catch the downstream appearance of the
        // tick in the panic().  But since command-line processing is in
        // usermode, the addition of the parameter throws off the ticks!
        //
        // https://en.wikipedia.org/wiki/Observer_effect_(physics)
        //
        // Let's say that after the command line processing, it still runs
        // C-DEBUG-BREAK/COMPENSATE, this time at tick 403.  Imagine our goal
        // is to make the parameter to /COMPENSATE something that can be used
        // to conservatively guess the same value to set the tick to, and
        // that /COMPENSATE ARG(bound) that gives a maximum of how far off we
        // could possibly be from the "real" tick. (e.g. "argument processing
        // took no more than 200 additional ticks", which this is consistent
        // with...since 403-304 = 99).
        //
        // The reasoning for why the formula below works for this rounding is
        // given in this StackExchange question and answer:
        //
        // https://math.stackexchange.com/q/2521219/
        //
        Tick one = 1; // MSVC gives misguided warning for cast(Tick, 1)
        TG_tick =
            (one &lt;&lt; (ceil_log2(TG_tick) + 1))
            + VAL_INT64(ARG(tick))
            - 1;
        return nullptr;
    }
</code></pre>
<p>Also, I've never used the /RELATIVE tick feature, killing that too:</p>
<pre><code>  if (REF(relative))
      TG_break_at_tick = frame_-&gt;tick + 1 + VAL_INT64(ARG(tick));
</code></pre>
<p><strong>I'm going to be deleting a lot of things, I think, in the pursuit of simplification--now that isotopes are showing the way.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/axing-breakpoint-switch-c-debug-break-at/2009/1</link>
        <pubDate>Tue, 24 Jan 2023 21:57:46 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6561</guid>
      </item>
      <item>
        <title>Getting Output From Rebol2 on Windows GitHub Actions</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>If you run Rebol 2 with the CGI flag (<code>-c</code>) you should be able to get basic interaction.</p> ]]></description>
        <link>https://forum.rebol.info/t/getting-output-from-rebol2-on-windows-github-actions/1966/2</link>
        <pubDate>Tue, 24 Jan 2023 16:14:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6560</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Same here, that is when I go for one of my help lines in these kinds of cases: The wordhippo</p><aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://www.wordhippo.com/favicon.ico" class="site-icon" width="16" height="16">
      <a href="https://www.wordhippo.com/what-is/another-word-for/reify.html" target="_blank" rel="noopener">WordHippo</a>
  </header>
  <article class="onebox-body">
    <img src="https://wordhippo.s3.amazonaws.com/what-is/img/logo-200x200.png" class="thumbnail onebox-avatar" width="60" height="60">

<h3><a href="https://www.wordhippo.com/what-is/another-word-for/reify.html" target="_blank" rel="noopener">What is another word for reify? | Reify Synonyms - WordHippo Thesaurus</a></h3>

<p>Synonyms for reify include concretize, objectify, picture, thingify, embody, incarnate, manifest, externalize, substantiate and materialize. Find more similar words at wordhippo.com!</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
<p>
There is a tab for antonyms as well. That would lead me to suggestions NEGLECT, OBSCURE or IGNORE.<br>
But with some creativity I came up with the word DEIFY.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001/4</link>
        <pubDate>Sun, 15 Jan 2023 12:30:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6557</guid>
      </item>
      <item>
        <title>Working With Truthy BLANK!</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The current re-imagining of the concept of truthy/falsey involves the idea that <em>anything you can put into a block is truthy</em>.  That includes BLANK!.</p>
<p>~null~ isotopes are falsey, and will REIFY to be <strong><code>~null~</code></strong> which can be somewhat clumsy-looking.</p>
<p>But consider some test cases for seeing how SPLIT-PATH works, looking a bit like this:</p>
<pre><code>split-path-tests:  [
    %foo                            [_ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%/ %/]
    %.                              [%./ _]
    %./                             [%./ _]
    %./.                            [%./ %./]
    &lt;...etc...&gt;
]
</code></pre>
<p>SPLIT-PATH is a multi-return routine, which gives back two values: the path and the filename.  But if one or the other is missing then that component will be null, which is useful for testing with IF (or using DEFAULT with).</p>
<p>But if we just blindly changed the tests to reify, it would become less legible:</p>
<pre><code>split-path-tests:  [
    %foo                            [~null~ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%/ %/]
    %.                              [%./ ~null~]
    %./                             [%./ ~null~]
    %./.                            [%./ %./]
    &lt;...etc...&gt;
]
</code></pre>
<p>However...with blanks being truthy, this means you that you can take a variable which may be null and turn it into a blank, like this:</p>
<pre><code>reduce [any [path _] any [file _]]
</code></pre>
<p>That's rather succinct!  Probably so succinct that it doesn't need its own native to express.</p>
<p>(I thought it was neat.)</p> ]]></description>
        <link>https://forum.rebol.info/t/working-with-truthy-blank/2007/1</link>
        <pubDate>Sat, 14 Jan 2023 15:21:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6556</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>Not being an English native speaker I'll have 5o trust you on this.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001/3</link>
        <pubDate>Thu, 12 Jan 2023 21:24:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6555</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2001">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Maybe... CONCRETIZE? That sounds like it might do a bit more work than what REIFY does :-/</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concretize true
== true

&gt;&gt; concretize 10
== 10
</code></pre>
<p>It's not awful</p>
</blockquote>
</aside>
<p>A shorter word would be CONCRETE.</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concrete true
== true

&gt;&gt; concrete 10
== 10
</code></pre>
<p>We do mess a bit with wording, but here it would be more of an adjective.</p>
<p><strong>Another big question is what the antonym of REIFY would be.</strong>  That is to say something that leaves all input values alone except for quasi forms, and gives you back an isotope.</p>
<pre><code>&gt;&gt; unreify first [~alpha~ 1020]
== ~alpha~  ; isotope

&gt;&gt; unreify second [~alpha~ 1020]
== 1020
</code></pre>
<p>Unfortunately, there's not a good opposite word for REIFY.  Maybe DEGRADE?</p>
<pre><code>&gt;&gt; degrade first [~alpha~ 1020]
== ~alpha~  ; isotope

&gt;&gt; degrade second [~alpha~ 1020]
== 1020
</code></pre>
<p>The pairing of CONCRETE/ABSTRACT might be a possibility here.  I'm not sure.</p>
<p>I think I'll go with DEGRADE a while and see how I like it.  The names can be juggled around once all the necessary behaviors are assembled.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001/2</link>
        <pubDate>Mon, 09 Jan 2023 13:15:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6552</guid>
      </item>
      <item>
        <title>&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>It's no secret that I'm proud of the way the <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">design for generalized isotopes</a> is tearing through classic problems in Rebol.</p>
<p>At the same time, people's eyes can glaze over when you find yourself writing sentences like:</p>
<blockquote>
<p><em>"All quasiforms become isotopic forms when evaluated, and when going the other way through a meta operation on an isotope, you'll get a quasiform back."</em></p>
</blockquote>
<p>It all makes sense to me.  But I don't want to overlook better terms, if they exist.</p>
<h2>How Did "Isotopes" Come To Be Called That?</h2>
<p>The term isotope originated from the "decaying" behavior, where a special form of null would run a THEN branch.  But this special form would not be something you could store in a variable...it would become an ordinary null at that point.  So getting stored in a variable would cause "decay".</p>
<pre><code>&gt;&gt; null
; null

&gt;&gt; if true [null]
; null isotope

&gt;&gt; x: if true [null]
; null isotope

&gt;&gt; x
; null
</code></pre>
<p>The decay means variables captured from expressions would have a different behavior when substituted for the expressions.  That was deemed to be an acceptable cost.</p>
<pre><code>&gt;&gt; if true [print "then", null] else [print "else"]
then

&gt;&gt; temp: if true [print "then", null]
then

&gt;&gt; temp else [print "else"]
else
</code></pre>
<p>The parallel with decay of atomic isotopes seemed pretty clear, at least to me.  Many places would see it as a normal null, but a few special sites could use a "sensor" to detect the difference.  ELSE was an example of something that could detect.</p>
<p>As things moved forward, and when logic variables became ~true~ and ~false~ isotopes, it became clear these isotopic states would need to be able to stored in variables.  That meant there were "unstable isotopes" and "stable isotopes"... e.g. WORD! isotopes were stable, ERROR! isotopes were not.</p>
<p><em><strong>Having these stable isotopes actually strengthened the analogy.</strong></em>  Because some atomic isotopes are stable, while others are not.</p>
<h2>How Did "QUASI" Become Called That?</h2>
<p>Originally, things like <code>~foo~</code> were called "bad words", designed to cause errors when accessed through a variable by default.  They were like an old-school UNSET! where you could give it a custom label.  But eventually everything was generalized so that everything had an isotopic form.</p>
<p>The fact that these forms stopped conveying an error condition meant considering them "bad" wasn't sensible.  I kind of latched onto "quasi" in part because of the tilde's use in approximation, e.g. (3.0001 ~= 3).</p>
<p>(It also sounds a little like "queasy" and the squigglies look wavy and maybe a bit uncomfortable.  <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">)</p>
<h2>So... Speak Now Or Hold Your Peace?</h2>
<p>Bad naming can have an impact.  I think calling complex numbers "imaginary" is a good example of a bad name that probably caused a few problems.</p>
<p>But I think the names here are good.  It's just going to be a matter of figuring out how to teach people to not be afraid of them.</p> ]]></description>
        <link>https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005/1</link>
        <pubDate>Sun, 08 Jan 2023 21:18:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6550</guid>
      </item>
      <item>
        <title>The Canonical List of Non-Negotiables</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h2>ATOMICITY OF ELEMENTS IN BLOCK!s AND GROUP!s</h2>
<p>A new non-negotiable for Ren-C is that for <em>any</em> BLOCK! (or blocklike thing) the following property holds:</p>
<pre><code>block2: copy []

for-each item block1 [append block2 item]

assert [block1 = block2]
</code></pre>
<p>Prior to isotopes, <em>it wasn't conceivable that such rules could hold.</em>  But after years scaling a mountain of design... I concluded this could be achieved, if all the tricky behaviors came from values "at quoting level -1" that could not be put into blocks.</p>
<ul>
<li>
<p>There are no isotopic actions to implicitly execute; you'd get an error trying to put them in the block.</p>
</li>
<li>
<p>There are no blocks/groups/paths that will splice into the target, because splicing requires an explicit conversion to an isotope.</p>
</li>
<li>
<p>There are no "unsets" to trip on that you can find in a block, because the state conveying "unsetness" (nihil) is an isotope.</p>
</li>
</ul> ]]></description>
        <link>https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244/9</link>
        <pubDate>Sat, 07 Jan 2023 23:35:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6548</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>FYI<br>
For Altme the important bit was setting up a lightweight headless display.<br>
We were using X virtual frame buffer then running jwm as a super light window manager.</p>
<pre><code class="lang-auto">Xvfb :0 -ac -screen 0 1024x768x24 &amp;
sleep 2
nohup /usr/bin/jwm -display :0 &amp; 
export DISPLAY=:0
./altme &amp;
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/5</link>
        <pubDate>Sat, 07 Jan 2023 23:31:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6547</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>I don't think there is much more to save from the server. I will take a backup of the code and make sure that what is in <a href="https://github.com/rebolbot/rebolbot">https://github.com/rebolbot/rebolbot</a> is correct. I will also upload the headless scripts to get altme working as well, if anyone is still using it?<br>
I have to say that Digital Ocean have been absolutely rock solid. I do not remember the box being rebooted once, other than following updates that I initiated. As an example, the current uptime is 87 days. These LTS Ubuntu variants do seem to do exactly what they say on the box - if we wanted to keep this running it would still be supported and patched until 2026 (<a href="https://wiki.ubuntu.com/Releases" class="inline-onebox">Releases - Ubuntu Wiki</a>).</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/4</link>
        <pubDate>Sat, 07 Jan 2023 23:19:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6546</guid>
      </item>
      <item>
        <title>Websocket Support in Oldes Rebol3</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Looking to see what Oldes has been up to, he added some kind of minimal websocket support to the HTTP scheme:</p>
<p><a href="https://github.com/Oldes/Rebol3/commit/bae6cffe97e662ec9a727a01cdcc1fdd61455ea6#diff-490ba807ac4a5ee57e7a587ca0936d36e4c0ff2798b0652fdf791e758ce079c2R718" class="inline-onebox">FEAT: Minimalistic WebSocket support in the `httpd` scheme · Oldes/Rebol3@bae6cff · GitHub</a></p>
<p>Websockets isn't something I'm looking into at this time, but I wanted to bookmark it here in case it comes up later.</p>
<p>He also updated zlib to a new version released in 2022... and <a href="https://github.com/Oldes/Rebol3/commit/15fcc00b84f6d0e386f2ba2f4fc7bdc32ebff75d">used Ren-C's %make-zlib.r to do it!</a>.  But he edited it so he'd be able to run it under his Rebol3.  It's not a huge priority to do that update, but seems like since his ported script still worked, it might not be too hard.  (And a good reminder that script exists, and should be part of a CI test...)</p> ]]></description>
        <link>https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003/1</link>
        <pubDate>Fri, 06 Jan 2023 03:56:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6544</guid>
      </item>
      <item>
        <title>Picking ACTION!s from BLOCK!s In The Age of Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>In <strong><a href="https://forum.rebol.info/t/reds-design-issues-wiki/1282">Red's Design Questions wiki</a></strong>, they bring up the issue of why picking functions out of blocks runs them:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block
Evaluated.  ; d'oh
== false
</code></pre>
<p><a href="https://gitter.im/red/red?at=5c782ca0c1cab53d6f53dd6d">In the Gitter conversation</a>, Boris calls it a "shady area" that they can't get out of "under the current semantic model".  He suggests it is clear that <strong><code>block/1</code></strong> should not run an action, but possible that <strong>block/word</strong> would mean to.</p>
<p>They contemplate the idea that <strong>block/1</strong> would not run the action, but pick it:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block  ; hypothetical behavior
== false
</code></pre>
<p><strong>I will argue this doesn't really help you much, the problem just becomes one step removed.</strong>  Quite often people are picking things out of blocks to put them in variables, and you'll just get bit there instead:</p>
<pre><code>red&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block/1
== func [][print "Evaluated."]

red&gt;&gt; append otherblock temp
Evaluated.  ; d'oh
== [unset]  ; double d'oh
</code></pre>
<h2>Isotopes Bring The Better Semantic Model!</h2>
<p>In Ren-C's concept (as I'm working on it), the only actions that will run from a word reference are those that are isotopic actions.  And FUNC or DOES creates an isotopic action.</p>
<p>So you would be stopped from making an illegal block up front:</p>
<pre><code>&gt;&gt; block: reduce [does [print "Evaluated."]]
** Script Error: Invalid use of ~#[action! []]~ isotope
</code></pre>
<p>You can put quasi-ACTION!s, plain ACTION!s, and quoted actions in blocks.  Just not isotopic ones.</p>
<p>Whichever you choose, the equality test will work... and picking out a value into a variable will give you an inert variable to work with, that can be used with things like append!</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; equal? block.1 first block
== ~true~  ; isotope  &lt;-- didn't run and print "Evaluated", yay!

&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block.1
== ~#[action! []]~

red&gt;&gt; append otherblock temp
== [~#[action! []]~]   ; &lt;-- didn't run and gave sensible block out
</code></pre>
<p>I used REIFY there and got a quasi-action.  BUT which would you rather put in the block: a quasi-action or a plain one?  This depends on what you plan to do with the block.  A plain action will execute when encountered by the evaluator, while a quasi-action will evaluate to an isotopic action--suitable for assigning via SET-WORD! when you meant to make that word dispatch the function when referenced.</p>
<p>My leaning is to say that either form can be used with APPLY, RUN, or the terminal path form:</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; run block.1
Evaluated.

&gt;&gt; block: reduce [concretize does [print "Evaluated."]] 
== [#[action! []]]

&gt;&gt; apply block.1 []
Evaluated.
</code></pre>
<p><em>(See post on <a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">difference between REIFY and CONCRETIZE</a>, and the search for a better term...)</em></p>
<p>If you want to pick an action out of a block and put it into a variable, where it will execute from that variable, there is the RUNS transformer.  It will turn a quasi or plain ACTION! into an action isotope:</p>
<pre><code> &gt;&gt; active-var: runs block.1
 == ~#[action! {active-var} []]~  ; isotope  &lt;-- note: also cached name, neat!

 &gt;&gt; active-var
 Evaluated.
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=9" title=":clap:" class="emoji only-emoji" alt=":clap:"></p>
<p>You can use UNMETA more generically to get an isotope back from any quasi-form (not just actions), or ISOTOPIC to get an isotope from a plain form.</p>
<h2>The Invariant Is What Counts, Here!</h2>
<p>The mountain that has been climbed is that we can now say that for any block, this is true:</p>
<pre><code>block2: collect [
    for-each item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<ul>
<li>
<p>I've just covered that there are no isotopic actions to implicitly execute; you'd get an error trying to put them in the block.</p>
</li>
<li>
<p>There are no blocks/groups/paths that will splice into the target, because splicing requires an explicit conversion to an isotope.</p>
</li>
<li>
<p>There are no "unsets" to trip on that you can find in a block, because the state conveying "unsetness" (nihil) is an isotope.</p>
</li>
</ul>
<p>Of course with objects, it's going to be a different story.  I think we'll still want some safeguards:</p>
<pre><code>for-each [key value] object [...]  ; will error when value is action

for-each [key :value] object [...]  ; will allow action isotopes as-is

for-each [key ^value] object [...]  ; will give a meta value
</code></pre>
<p>A key problem here is I'm wondering how much to cross purposes of GET-WORD! between action disarming and the other isotopic states.  But, it just takes time to work through.</p> ]]></description>
        <link>https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002/1</link>
        <pubDate>Fri, 06 Jan 2023 03:16:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6543</guid>
      </item>
      <item>
        <title>REIFY vs. META vs. SOMETHING</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Originally I suggested that REIFY of an isotope would give its plain form, and you would META it if you wanted a quasiform:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/1">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</a>
</div>
<blockquote>
<ul>
<li>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</li>
<li>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</li>
</ul>
</blockquote>
</aside>
<p><em>But that's not a full coverage answer.</em></p>
<ul>
<li>
<p>An operator that takes everything "one level up", where isotopes become quasiforms and everything else gets a quote level added.</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; meta true
== ~true~

&gt;&gt; meta 10
== '10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their quasiforms (and I think this probably is best called REIFY):</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; reify true
== ~true~

&gt;&gt; reify 10
== 10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their plain forms:</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; something true
== true

&gt;&gt; something 10
== 10
</code></pre>
</li>
</ul>
<p>Specifically for ACTION! isotopes being turned into plain actions, I used an interim term UNRUN, but that's pretty awful.</p>
<p>Making things into isotopes is done with ISOTOPIC:</p>
<pre><code>&gt;&gt; isotopic 10
== ~10~  ; isotope
</code></pre>
<p>It could be a refinement to REIFY, like REIFY/PLAIN.  But at that point it could be two steps that might be clearer: NOQUASI REIFY, where NOQUASI would be like NOQUOTE and not complain if the thing you passed it was not a quasiform.</p>
<p>Maybe... CONCRETIZE?  That sounds like it might do a bit more work than what REIFY does :-/</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concretize true
== true

&gt;&gt; concretize 10
== 10
</code></pre>
<p>It's not awful.  Main thing is just to have <em>a</em> name for it while the gears turn.  But as usual, throw out suggestions if you have them...</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001/1</link>
        <pubDate>Thu, 05 Jan 2023 21:26:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6542</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm curious about this distinction... why wouldn't a filter that takes in UTF-8 and produces a block of transcoded data be covered here? What's the missing capability?</p>
</blockquote>
</aside>
<p>I think it's ultimately scope creep. In my proposal in the other thread, I'd conceived as such a mechanism as tokenizing as well, but in hashing out many of the data points I've been considering, it just became too convoluted. I feel in isolating binary/text it's really a clean separation that lends well to optimization and doesn't fall into the Codec black box that I think is ultimately problematic.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The umbrella term I tend to myself use above "Filter"/"Codecs"/"Ports" is "Streaming".</p>
</blockquote>
</aside>
<p><em>'Filter'</em> is the term used in PDF and I think lends itself to this specific isolation. <em>'Streaming'</em> would apply, but could also be saved for more appropriate use, such as the mechanism for moving data in from external sources. And one can apply <em>filters</em> to a <em>stream</em>...</p>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Maybe we could get examples worked up and see some contrast with how those would be done e.g. in C++ (with <a href="https://think-async.com/Asio/">Boost.Asio</a>) or in Conduit/Pipes/Machines/Streams of Haskell? I feel that really helped with UPARSE to drive the design from ideas that had already been worked out.</p>
</blockquote>
</aside>
<p>I'm still following through on my line of inquiry here and see if I can get some success in streamlining some of the <em>'Codec'</em> work I've been exploring. Certainly some of this thinking comes, again, from working a bit with Iterators in Javascript. I still think tokenization can be done in an iterative fashion as well, but that's a bit down the line.</p>
<hr>
<p>I'm inclined to think this concept offers something new and quite compelling that I don't see in these alternatives (or at least, <em>Pipes</em> would seem similar but I find the examples quite opaque). The ability to work through layered encoding in an incremental manner that would only place in memory the essential parts of a stream, and in a way that is really quite minimal in terms of its impact on the language. The mechanics for obtaining the stream are where they should be and it encourages a style of handling incoming data in a way that is incremental, precise and relatively non-blocking—180º from the traditional Rebol family model if nothing else.</p>
<p>Of course, it's easy to say so. Need to actually flex it a bit to back that up. And I haven't got to PostScript yet...</p> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/5</link>
        <pubDate>Thu, 05 Jan 2023 20:33:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6541</guid>
      </item>
      <item>
        <title>Happy 2023, and 2022 General Status &amp; Reflection</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I mention up top that I have been busy for all of November and December, so I didn't do anything worth adding to the October status post in terms of <em>code progress</em>.</p>
<p>But putting some space between yourself and the code can offer other insights.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1988">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm still "finding the cool" in new behaviors, so that's motivating. But maybe with the basics sorted out, it's getting closer to time to start ripping out some unnecessary parts, so that a committed subset can be pushed out to people on the web.</p>
</blockquote>
</aside>
<p><em>Definitely this:</em> <em><strong>I want to put the system into people's hands.</strong></em></p>
<p>We've reached a point where for once, we know how APPEND works.  That is no small feat... and the solution was a decade in the making.</p>
<p>I believe we now know how true and false work, with <code>~true~</code> and <code>~false~</code> being their meta state that evaluates to an isotopic state which can't be put into blocks.</p>
<p>There are so many neat solutions to old questions... like what is <strong><code>any []</code></strong> or <strong><code>all []</code></strong>, and having coherent answers to basic questions is something to stand on the shoulders of for the next tough question.  It all interlocks.</p>
<p><strong>I'm hard-pressed to say exactly what's going to happen with binding, but I'm wondering if there's any way to make a system that's useful even if we don't know how that will work.</strong></p>
<p>But I'm going to keep going at it, and start posting again here now that I'm getting more settled.  Again: Happy New Year!</p> ]]></description>
        <link>https://forum.rebol.info/t/happy-2023-and-2022-general-status-reflection/1988/3</link>
        <pubDate>Thu, 05 Jan 2023 19:43:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6540</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Related threads:</p>
<ul>
<li><a href="https://forum.rebol.info/t/streaming-mental-blocks-and-some-haskell-streaming-research/1325" class="inline-onebox">Streaming Mental Blocks, and some Haskell Streaming Research</a></li>
<li><a href="https://forum.rebol.info/t/streaming-survey-from-other-languages/1739" class="inline-onebox">"Streaming" Survey from Other Languages</a></li>
<li><a href="https://forum.rebol.info/t/parsing-giant-streams-without-consuming-tons-of-memory-how/1698" class="inline-onebox">Parsing Giant Streams Without Consuming Tons of Memory: How?</a></li>
</ul>
<hr>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="1" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>this concept is more focused on transcoding one series of numbers/characters to another. Filters are NOT scanners/tokenizers/lexers.</p>
</blockquote>
</aside>
<p>I'm curious about this distinction... why wouldn't a filter that takes in UTF-8 and produces a block of transcoded data be covered here?  What's the missing capability?</p>
<aside class="quote no-group" data-username="rgchris" data-post="1" data-topic="2000">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>A filter could conceivably be implemented as a distinct type that has object-like properties (as the PORT! type does) and could thus be acted upon by the appropriate Rebol actors (COPY/SKIP/NEXT/TAIL, etc.).</p>
</blockquote>
</aside>
<p>The umbrella term I tend to myself use above "Filter"/"Codecs"/"Ports" is "Streaming".  This is because of the use of the term in C++ and in Haskell in the cases I find interesting.  But even in Haskell it branches off into different models, such as <strong><a href="https://www.schoolofhaskell.com/school/advanced-haskell/conduit-overview">Conduit</a></strong>, <strong><a href="https://www.schoolofhaskell.com/user/Gabriel439/Pipes%20tutorial">Pipes</a></strong> and <strong><a href="https://statusfailed.com/blog/2014/09/02/practical-machines-in-60-seconds.html">Machines</a></strong></p>
<p>I'm glad you're putting down some concrete examples and experimenting with them.  Because if one stays fully general it gets hard to know what the limits are that would inform a useful design.</p>
<p>Maybe we could get examples worked up and see some contrast with how those would be done e.g. in C++ (with <a href="https://think-async.com/Asio/">Boost.Asio</a>) or in Conduit/Pipes/Machines/Streams of Haskell?  I feel that really helped with UPARSE to drive the design from ideas that had already been worked out.</p> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/4</link>
        <pubDate>Thu, 05 Jan 2023 18:16:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6539</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>One interesting file format is that of <a href="http://site.xara.com/support/docs/webformat/spec/">Xara (XAR) vector images</a>. They consist of an eight-byte header followed by a collection of records. Records consist of two little-endian 32-bit integers denoting the record type and size followed by the record content. Presumably easy to traverse—however: the wrinkle here is that there is one record type that indicates that subsequent records are encoded in a single Deflate stream that terminates with both the end of the Deflate stream and a record type that indicates the end of the compressed section.</p>
<p>This is a simplified way of looking at it (each tag representing a whole record):</p>
<pre><code class="lang-nohighlight">---- regular byte stream ----
&lt;8-byte header&gt;
&lt;title&gt;
&lt;metadata&gt;
&lt;start-compressed-section&gt;
---- deflate compressed byte stream ----
&lt;thing&gt;
&lt;thing&gt;
...
&lt;end-compressed-section&gt;
---- regular byte stream ----
&lt;thing&gt;
&lt;thing&gt;
---- eof ----
</code></pre>
<p>This type of switch could be handled with filters.</p>
<pre><code class="lang-nohighlight">file-content: make filter! [
    source: open/direct %image.xar
]

content: file-content

consume content #{... magic number ...}

until [
    type: consume content 'unsigned-32-le
    size: consume content 'unsigned-32-le

    switch type [
        types/start-compressed-section [
            content: make filter! [
                type: 'deflate
                source: file-content
            ]
        ]

        types/end-compressed-section [
            assert [
                tail? content
            ]

            content: file-content
        ]
    ]

    ... record dispatcher ...

    type == types/end-of-file
]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/3</link>
        <pubDate>Thu, 05 Jan 2023 15:06:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6538</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>I'll spitball samples/test cases in replies. The example from the ports/streams/iterator posts was a layered encoding where an compressed encoding is in turn encoded as text:</p>
<pre><code class="lang-nohighlight">encoded: make filter! [
    ; implied type: 'text
    source: "start F3DI7!! end"
]

consume encoded "start"

encoded-ascii85: make filter! [
    type: 'ascii85
    source: encoded
]

encoded-deflate: make filter! [
    type: 'deflate
    source: encoded-ascii85
]

result: copy encoded-deflate

consume encoded " end"
=&gt; true
</code></pre>
<h2>Extracting from a large file</h2>
<pre><code class="lang-nohighlight">big-file: open/direct %big-file.txt

file-content: make filter! [
    ; implied type: 'stream
    source: big-file
]

copy/part skip file-content 1'000'000 25
</code></pre>
<p>As mentioned, ideally filter algorithms would have mechanisms to skip content without buffering, so you could do the following as fast as any other way of doing it:</p>
<pre><code class="lang-nohighlight">big-file: open/direct %big-file.txt

file-content-as-utf-8: make filter! [
    type: 'utf-8
    source: make filter! [
        ; implied type: 'stream
        source: big-file
    ]
]

copy/part skip file-content 1'000'000 25
; skips 1'000'000 UTF-8 characters without copying/buffering
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/2</link>
        <pubDate>Thu, 05 Jan 2023 04:01:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6537</guid>
      </item>
      <item>
        <title>Concept: Filters</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>Filters are a means of incrementally transcoding data from source to brokered output (bytes/binary! or characters/text!). A goal is to provide a standard API for transcoding that can be implemented and used as efficiently as possible (e.g. extracting a portion of encoded data without extracting the whole; native transcoders for Deflate). A filter could conceivably be implemented as a distinct type that has object-like properties (as the PORT! type does) and could thus be acted upon by the appropriate Rebol actors (COPY/SKIP/NEXT/TAIL, etc.).</p>
<p><em>I've alluded to a similar idea in <a href="https://forum.rebol.info/t/semantics-of-port-s-vs-streams-vs-iterators/1689/4">an earlier post</a>, however this concept is more focussed on transcoding one series of numbers/characters to another. Filters are NOT scanners/tokenizers/lexers.</em></p>
<p>A filter source can be:</p>
<ul>
<li>BINARY! or TEXT! values</li>
<li>PORT! values that stream BINARY! or TEXT! (including files/network resources)</li>
<li>filter values (i.e. filters can be layered)</li>
</ul>
<p>Examples of filter types:</p>
<ul>
<li>Retrieves binary contained within a file/network resource</li>
<li>Decodes text encoded as UTF-8, UTF-16, ISO-8859-1, CP-1252, etc. (or even unspecified using something like Chardet)</li>
<li>Decodes binary compressed per Deflate, LZW, etc.</li>
<li>Decodes binary encoded as 'text' per Base64, Ascii85, Hexadecimal, etc.</li>
<li>Decrypts binary encrypted per e.g. Rebol 2 ENCLOAK/DECLOAK (but obviously more)</li>
<li>Decodes text encoded mostly literally but with escape sequences, e.g. JSON strings, Rebol strings, XML/HTML data sequences/attribute values</li>
</ul>
<p>Filters should have at least the following capabilities:</p>
<ul>
<li>Copy all encoded data</li>
<li>Copy part of the encoded data</li>
<li>Skip part of the encoded data (Deflate could potentially iterate faster if it wasn't emitting simultaneously)</li>
</ul>
<p>Filters should possibly have the following capabilities:</p>
<ul>
<li>BACK/HEAD/negative SKIP support</li>
<li>TAKE/REMOVE/CLEAR as a means of clearing buffers</li>
</ul>
<p>Functions that consume data should support filters as a pseudo-series type, e.g.</p>
<ul>
<li>Parse</li>
<li>BINARY/READ (from Oldes/Rebol3)</li>
<li>CONSUME (from <a href="https://forum.rebol.info/t/bincode/1863">rgchris/bincode</a>)</li>
</ul>
<p>Filter values are exhausted when:</p>
<ul>
<li>An end-of-content signal/delimiter has been found e.g. self-terminating formats such as Deflate; quote marks ending a JSON string</li>
<li>A filter cap has been reached e.g. the filter has a specified length</li>
<li>An unrecoverable error occurs (e.g. invalid UTF-8 sequences in strict mode; the 'g' character in a hexadecimal stream)</li>
<li>The source has been exhausted</li>
</ul>
<p>It should be possible to recover the current source at the corresponding index within a filter value though this may require additional state info, e.g. in Deflate or Base64 where a byte within an encoding has information pertaining to more than one decoded byte</p>
<p>Filter algorithms can be native (e.g. Deflate tied to Zlib, UTF-8) or in user-mode (thus extensible).</p> ]]></description>
        <link>https://forum.rebol.info/t/concept-filters/2000/1</link>
        <pubDate>Thu, 05 Jan 2023 03:49:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6536</guid>
      </item>
      <item>
        <title>JavaScript object notation shorthand</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>In essence, there's already three BLOCK! constructors in traditional Rebol (REDUCE, COMPOSE and COLLECT) of which COLLECT is perhaps the most versatile. It does require KEEP for most values which is likely why it's not the only one, but gives you access to all of the other language features:</p>
<pre><code class="lang-nohighlight">; alt-ARRAY
;
collect [
    repeat value 4 [
        keep value
    ]
]
</code></pre>
<p>A few variations on KEEP would be similarly useful in OBJECT! and MAP! creation:</p>
<pre><code class="lang-nohighlight">collect-map [
    keep "key" "value"
    spread another-map
]

collect-object [
    keep foo: "Bar"
    keep ["a" 123] "A value"
    spread another-object
]
</code></pre>
<p>I do like the idea of implicit collection though as well. I don't know if it's at all possible to mix implicit/explicit collection in any sane way.</p>
<hr>
<p>This would completely mess with any trivial noodling around with the language, but you could use A in place of CONSTRUCTOR in the previous posting:</p>
<pre><code class="lang-nohighlight">a block! [
    1 2 [3 4] spread [5 6] a map! [
        combine ["a" 123] "A value"
        from another-key
        spread another-map
    ]
]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/javascript-object-notation-shorthand/1836/4</link>
        <pubDate>Mon, 02 Jan 2023 14:06:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6535</guid>
      </item>
      <item>
        <title>JavaScript object notation shorthand</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="rgchris" data-post="2" data-topic="1836">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I had to unlearn the idea that <code>[ ]</code> and <code>{ }</code> notation were <em>literals</em>; rather they are <em>constructors</em>.</p>
</blockquote>
</aside>
<p>I am not completely settled on my ideas about what I have called "fences":</p>
<p><a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727" class="inline-onebox">{ Rethinking Braces }... as an array type?</a></p>
<p>The idea that braces evaluate to unstable fence isotopes and then decay into objects is so strange that I want to try it just to know what that might be like (!)</p> ]]></description>
        <link>https://forum.rebol.info/t/javascript-object-notation-shorthand/1836/3</link>
        <pubDate>Mon, 02 Jan 2023 14:01:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6534</guid>
      </item>
      <item>
        <title>JavaScript object notation shorthand</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>In understanding JavaScript more from a Rebol-brain (or even just with JSON priors), I had to unlearn the idea that <code>[ ]</code> and <code>{ }</code> notation were <em>literals</em>; rather they are <em>constructors</em>. I think this distinction is why JavaScript is at best awkwardly Lispy. Also constructors can't self-reference so e.g. within an object you can't reference a prior key set in the same construction (<code>{'a': 123, 'b': &lt; no way to get 'a' &gt;}</code>), although one 'benefit' to this is you can't inadvertently create a circularly referenced structure.</p>
<p>I do like the constructors in principle, but again in Rebol-land my inclination is to do this with language rather than syntax—the question is given how much heavy lifting syntax does in constructors, how much language/convention would need to be used to get some a degree of parity without being overly verbose:</p>
<pre><code class="lang-nohighlight">[
    1, 2, [3, 4], ...[5, 6], {
        ["a" + 123]: "A value",
        anotherKey,
        ...anotherMap
    }
]

constructor block! [
    1 2 [3 4] spread [5 6] constructor map! [
        combine ["a" 123] "A value"
        from another-key
        spread another-map
    ]
]
</code></pre>
<p>I don't suppose it's a trivial exercise.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1836">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It may be that there should be a less freeform alternative to MAKE OBJECT! which doesn't let you put arbitrary code in the middle of it.</p>
</blockquote>
</aside>
<p>This sounds like CONSTRUCT as was.</p> ]]></description>
        <link>https://forum.rebol.info/t/javascript-object-notation-shorthand/1836/2</link>
        <pubDate>Mon, 02 Jan 2023 13:36:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6533</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>Thanks for keeping this going for so long! I will likely try and recreate bits and pieces from the <strong>rebol.info</strong> site elsewhere. I may need help getting headless <strong>altme</strong> running somehow—I'm not really sure if there's too much point but nice to have the option.</p>
<p>I have the list of <a href="http://rebol.info/bot/links.r">Rebolbot links</a> saved, is there any other Rebolbot data worth holding on to?</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/3</link>
        <pubDate>Sun, 01 Jan 2023 17:53:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6532</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Thanks for keeping it up... I didn't know it was around still!</p>
<p>We don't need an active RebolBot server.  But it might be nice to put it under GitHub CI to prevent the code from rotting (any more than it has), at some point.  Just something that asks it to do a few tasks and makes sure it can do them in a container.</p>
<p>I've been relatively inactive on Rebol the last couple of months, but expect this to change in the New Year.  I'll write up a post shortly...</p>
<p>Thanks again for keeping tabs and your help!</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/2</link>
        <pubDate>Fri, 30 Dec 2022 17:12:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6531</guid>
      </item>
      <item>
        <title>Rebolbot future</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>Hi guys<br>
I think it is time to turn off the old rebolbot server as I have not been using it for a while. <a class="mention" href="/u/rgchris">@rgchris</a> may still have a few things running on it, so this is a heads up that I plan to turn it off in the next month or so.<br>
All the best,<br>
John</p> ]]></description>
        <link>https://forum.rebol.info/t/rebolbot-future/1999/1</link>
        <pubDate>Thu, 29 Dec 2022 07:31:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6530</guid>
      </item>
      <item>
        <title>SPLIT Semantics</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><a href="https://gitter.im/red/red?at=63523097f00b697fec501c7a">On Red Gitter</a>, it was discussed "which of the following is 'correct'":</p>
<pre><code>Red&gt; split "" ","
== [""]

R3&gt; split "" ","
== []
</code></pre>
<p>Rebolek thinks R3 is right.  Boris says:</p>
<blockquote>
<p>I don't think there's a correct answer, just choices. I prefer the Red version because:<br>
it strictly follows the rule: `number-of-segments = 1 + number-of-delimiters", no exceptions, so it's easier to reason about</p>
<p>it should be able thus to preserve the type in case one wants to rejoin it later (that it doesn't is a bug, try split %"" ",")</p>
</blockquote>
<p>So there's a couple of ways to look at it.</p>
<p>But I have a philosophy about these things where I want edge cases to be "noisy", because usually they require special handling.  I might even say:</p>
<pre><code>&gt;&gt; split "" ","
== ~null~  ; isotope</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/split-semantics/1998/1</link>
        <pubDate>Thu, 22 Dec 2022 04:04:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6529</guid>
      </item>
      <item>
        <title>ChatGPT Speaking About Rebol</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>I'm going to ask it to create a GUI (replacement using Qt or GTK)</p> ]]></description>
        <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997/2</link>
        <pubDate>Sun, 18 Dec 2022 19:15:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6528</guid>
      </item>
      <item>
        <title>ChatGPT Speaking About Rebol</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So ChatGPT actually knows a bit about Rebol (at least Rebol2)</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" data-download-href="https://forum.rebol.info/uploads/default/7b940f01f3801b53d0a1d4d412074bda30517443" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" alt="image" data-base62-sha1="hDdWsU3sEBthVlysVvcHRLWmfWH" width="356" height="500" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/7b940f01f3801b53d0a1d4d412074bda30517443_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">634×890 25 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>This does raise some questions about the future of software, in general.  It's possible that AI models will plateau and maybe they'll never get too much better than this...</p>
<p>...but I don't think so.  I imagine year-over-year, we're going to see them learning.  I don't know exactly when they'd be able to come up with ideas like what I've been doing for Ren-C.</p>
<p>But something I did think about is that if they can write code, then giving them a super-expressive medium in which to do it could be very powerful.  If they can come up with the dialect and then use it, then they might be able to write concise programs that wind up being quite legible...whereas other languages might make them trade off length for clarity.</p>
<p>If you ask ChatGPT an interesting Rebol question, feel free to put it in this thread.</p> ]]></description>
        <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997/1</link>
        <pubDate>Sat, 17 Dec 2022 15:53:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6527</guid>
      </item>
      <item>
        <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="3" data-topic="1991">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>should except react to the whole expression, or just to the branch it is tacked on?</p>
</blockquote>
</aside>
<p>Currently ELSE passes through an isotopic error.</p>
<p>As evidenced by my questioning of if ELSE with a parameter might act as EXCEPT, I'm not totally firm on this, I guess it really just comes down to what shows it works in practice.</p>
<p>But even though it's a bit messy and emergent, I think isotopic errors are a tremendous step up from the more or less untenable prior error situation.</p>
<p><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852" class="inline-onebox">FAIL vs. RETURN RAISE: The New Age of Definitional Failures!</a></p> ]]></description>
        <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991/4</link>
        <pubDate>Mon, 05 Dec 2022 16:12:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6526</guid>
      </item>
      <item>
        <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>I find it much clearer to use 'except for error handling, and it makes this possible:</p>
<pre><code>&gt;&gt; if true [1 / 0] else [ 2 / 0 ] except e -&gt; [print mold e]
    make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: [1 / 0 **]
    where: [/ if console]
    file: _
    line: 1
]
</code></pre>
<p>The remaining question: should except react to the whole expression, or just to the branch it is tacked on?</p> ]]></description>
        <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991/3</link>
        <pubDate>Mon, 05 Dec 2022 11:15:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6525</guid>
      </item>
      <item>
        <title>What Should BLANK! in UPARSE Do?</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>That's how I see Blank as well. As a generic place holder: nothing interesting here (yet), but no need to worry, this is not an error.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821/4</link>
        <pubDate>Mon, 05 Dec 2022 08:50:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6524</guid>
      </item>
      <item>
        <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Another idea that has been simmering in my head: <strong>What if ELSE was ERROR!-isotope reactive, but only if you use it with a function that takes an argument?</strong></p>
<p>Today that requires you use EXCEPT.</p>
<pre><code>&gt;&gt; if true [1 / 0] except e -&gt; [print mold e]
make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: [1 / 0 **]
    where: [/ if _]
    file: ~null~
    line: 1
]
</code></pre>
<p>But what if this happened?</p>
<pre><code>&gt;&gt; if true [1 / 0] else [print "not reached"]
** Math Error: attempt to divide by zero
** Where: / if
** Near: [1 / 0 **]
** Line: 1

&gt;&gt; if true [1 / 0] else e -&gt; [print mold e]
make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: [1 / 0 **]
    where: [/ if _]
    file: ~null~
    line: 1
]
</code></pre>
<p>This would conflate errors with null and void.  But maybe that's all right.</p>
<p>In the case of UPARSE, pure null or pure void is not returned by combinators at this time.  So you'd be able to write combinators using ELSE instead of the uglier EXCEPT.  And I guess if you didn't actually feel like giving a full error explaining why you were failing a parse combinator, null isn't a terrible shorthand for "I am lazy"...but we'd have to allow <code>raise null</code> to work as just returning null.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991/2</link>
        <pubDate>Fri, 02 Dec 2022 12:20:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6522</guid>
      </item>
      <item>
        <title>Thinking About Isotopes Logically: ~true~ and ~false~</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1944">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>All told, it seems simpler to just let a ~true~ isotope be truthy, ~false~ be falsey, all other word isotopes be neither conditional true nor false. And then make isotopic words an unusually friendly sort of isotope.</p>
</blockquote>
</aside>
<p>So I am pretty gung ho on this.  It has the feeling of a <em>right answer</em>.  As I've said, it was always really depressing to start reading the boot from the top and have a big essay on "we have no idea what logic literals are"... and now not only do we know, but there's a whole deep philosophy on the reified realm being truthy vs. the isotopic realm having some falsey things.  It's high-leverage, high-IQ stuff.  <img src="https://forum.rebol.info/images/emoji/twitter/brain.png?v=9" title=":brain:" class="emoji" alt=":brain:"></p>
<p>The question of just how friendly to make these isotopes runs up against some issues.</p>
<p>For instance, what about MOLDing?  In the bootstrap, we have for instance a <code>debug</code> flag which can be set to things like <strong><code>on</code></strong> or <strong><code>normal</code></strong> or <strong><code>symbols</code></strong> etc., but when it's set to ON in the default config it actually becomes a ~true~ isotope.</p>
<p>So that now causes an error, since MOLD refuses to turn an isotope into a word:</p>
<pre><code>print ["debug:" mold app-config/debug]
</code></pre>
<p>Historical Redbol is willing to wordify the logic:</p>
<pre><code>red&gt;&gt; mold on
== "true"
</code></pre>
<p>I think this intermixing of words with logic is flawed, <em>and I actually like how it gets caught here</em>.  The code which is assigning <strong>debug: on</strong> in the configuration is better as <strong>debug: 'normal</strong>.</p>
<p>For other cases, we've got REIFY if you are okay with ~true~ and ~false~... and it passes through non-isotopic things as-is:</p>
<pre><code>&gt;&gt; reify "hello"
== "hello"

&gt;&gt; reify true
== ~true~
</code></pre>
<p>If you want a word from something you know is a logic, there's LOGIC-TO-WORD</p>
<pre><code>&gt;&gt; logic-to-word true
== 'true
</code></pre>
<p>Overall there are a lot of issues like this, but I think that we want to keep MOLD and PRINT unwilling to do isotopes.  It's a little bit of a speedbump, but helps you get involved to make sure the right thing happens.</p> ]]></description>
        <link>https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944/5</link>
        <pubDate>Fri, 02 Dec 2022 11:48:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6521</guid>
      </item>
      <item>
        <title>Should Everything Have an Isotopic Form?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[  ]]></description>
        <link>https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/8</link>
        <pubDate>Fri, 02 Dec 2022 11:15:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6520</guid>
      </item>
      <item>
        <title>Should Isotopes Be Legal in MAP! (Keys, Values?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1995">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>null was the signal of not being in a map. Assigning a key null was a way of removing items from that map.</p>
</blockquote>
</aside>
<p>Now that null is implemented as an isotopic word, this feature is broken by a "no isotopes" rule.  So there would have to be an exception made just for null.</p>
<p><strong>But... what if we <em>didn't</em> make an exception, and used void (which isn't "isotopic") to remove elements?</strong>  We could still have the falsey null come back when items weren't found.  The asymmetry seems consistent in the era of void-in-null out.</p>
<p>This would introduce a little bit of a "hassle", e.g. by forcing you to throw in a MAYBE:</p>
<pre><code>&gt;&gt; m: make map! [key &lt;initial&gt;]
== make map! [key &lt;initial&gt;]

&gt;&gt; m.key
== &lt;initial&gt;

&gt;&gt; m.key: select [a 10 b 20] 'c
** Error: Can't put ~null~ isotopes in maps, use void to remove key

&gt;&gt; m.key: maybe select [a 10 b 20] 'c
; void

&gt;&gt; m.key
== ~null~  ; isotope
</code></pre>
<p>But it's probably a good hassle.  "Did you really mean to unset this key?"</p>
<p>If you're sure, it's not any harder... you just say <strong>m.key: void</strong> instead of <strong>m.key: null</strong>.  And it helps make the "you can't put isotopes in maps" rule universal... null just becomes the answer given back when nothing is there, kind of like how it's used in blocks.  This doesn't get cognitively mixed up with giving the appearance you're actually storing an isotope.</p>
<p>You can also make keys the direct product of a conditional, like <strong><code>m.key: case [... [&lt;whatever&gt;]]</code></strong> and if no cases are taken there won't be an addition done.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995/2</link>
        <pubDate>Fri, 02 Dec 2022 10:08:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6519</guid>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>Raku (Perl 6) Type System</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="19" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/19">Ugly Types: Less Ugly Than History, Can We Do Better?</a>
</div>
<blockquote>
<p>That’s why I think it’s a good idea to keep TYPE OF a direct reflection of the heart-byte, and use other constructions for code which needs other things.</p>
</blockquote>
</aside>
<p>I’ve just discovered a bit of prior art for this, in the form of Raku (i.e., the language formerly known as Perl 6). Its equivalent to TYPE OF, namely <a href="https://docs.raku.org/language/mop#WHAT">WHAT</a>, returns only the ‘type object’ of which the value is an instance. By contrast, type matching (and pattern matching) is done using <a href="https://docs.raku.org/type/Mu#method_ACCEPTS">ACCEPTS</a> with a <a href="https://docs.raku.org/language/signatures">signature literal</a>, which is a much more flexible syntax allowing all kinds of constraints to be expressed.</p>
<p>Actually, now that I think of it, Raku signature literals strike me as quite a nice approach. For Ren-C, they suggest the idea of having a ‘type-matching dialect’… though, then again, I guess that’s something I <a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2">already suggested above</a>.</p> ]]></description>
        <link>https://forum.rebol.info/t/raku-perl-6-type-system/2156#post_1</link>
        <pubDate>Sun, 25 Feb 2024 12:53:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7184</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="18" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But given the choice, people would prefer <strong>switch type of</strong> and being able to think of type as being a value instead of a constraint. And with the TYPE-BLOCK! answer, there's some inkling of a direction of going that way:</p>
<pre><code class="lang-plaintext">switch type of x [
    logic! [...]  ; wouldn't be locked in a 1:1 heart:type ratio
    integer! [...]
    splice! [...]
]
</code></pre>
</blockquote>
</aside>
<p>In a way, I think this just goes to prove my point. Yet again, we see the most common thing to do with types is to <em>match</em> against them. And, in your words, when we’re matching types it’s nice if we’re not ‘locked in a 1:1 heart:type ratio’. To me, that again implies that it should be able to take constraints, like SWITCH/TYPE does… and you can’t do that simply by SWITCHing against TYPE OF.</p>
<p>I suppose the point I’m making is that TYPE OF is limited in a very fundamental sense: it can <strong>only ever return one value</strong>. Perhaps you can try to predict ahead of time what people will want to test, and add things like LOGIC! that to the output of TYPE OF… but then comes someone who wants to test if a number is EVEN?, and TYPE OF just doesn’t give you that information. That’s why I think it’s a good idea to keep TYPE OF a direct reflection of the heart-byte, and use other constructions for code which needs other things.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="18" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>With more complex types, you'd have to use <a href="https://forum.rebol.info/t/destructure-dialect/1877">something like DESTRUCTURE</a> to get at what you were looking for. And maybe that would be interesting.</p>
</blockquote>
</aside>
<p>I’ll put my support strongly behind this. Pattern-matching is inordinately useful.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="18" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm quite glad that you're thinking about it, and that you are able to take initiative and grok these problems well.</p>
</blockquote>
</aside>
<p>This is really where my expertise lies. I’m a Haskeller — I spend a long time thinking about types and type systems. Additionally, over the past year or two I’ve been learning a lot about structural type systems (i.e. ones which allow union and intersection), including making my own. So when I say things like ‘a Haskell-like type system isn’t a great fit for Rebol’, there’s some intuition behind those statements.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="18" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm pleased and terrified that you're reading the source, but... there are some files that have decent organizations and comments to them, which can give you your bearings faster than reading something like a R3-Alpha or a Red.</p>
</blockquote>
</aside>
<p>Sure, but I just wanted to get some statistics quickly, and Ren-C itself is the largest Ren-C codebase that I know of. (Also, sometimes I get curious how things are implemented internally.)</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_19</link>
        <pubDate>Fri, 23 Feb 2024 00:19:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7183</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="17" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>(Apologies, this post has ended up somewhat long and rambly. TL;DR: we should think much more carefully about how useful TYPE OF really is in practice.)</p>
</blockquote>
</aside>
<p>Nothing's too long for me to read here!  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>Feel free to write long things and edit them down later for clarity, or if you just decide parts of it were distractions and aren't relevant anymore (and it doesn't break the continuity of the thread).</p>
<aside class="quote no-group" data-username="bradrn" data-post="17" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>At least to me, this suggests that <strong>TYPE OF is of significantly limited use in actual code</strong></p>
</blockquote>
</aside>
<p>The reason for that is that most uses of TYPE OF had been SWITCH TYPE OF.  Many of those would no longer work, because e.g. TYPE OF TRUE was an antiform and not LOGIC!, etc.</p>
<p>So all the <strong>switch type of</strong> instances (except for two, apparently) were robotically changed to <strong>switch/type</strong> where the values you're switching on are constraints (or types).</p>
<pre><code>switch/type x [
    &amp;logic? [...]
    integer! [...]
    &amp;splice? [...]
]
</code></pre>
<p>But given the choice, people would prefer <strong>switch type of</strong> and being able to think of type as being a value instead of a constraint.  And with the TYPE-BLOCK! answer, there's some inkling of a direction of going that way:</p>
<pre><code>switch type of x [
    logic! [...]  ; wouldn't be locked in a 1:1 heart:type ratio
    integer! [...]
    splice! [...]
]
</code></pre>
<p>With more complex types, you'd have to use <a href="https://forum.rebol.info/t/destructure-dialect/1877">something like DESTRUCTURE</a> to get at what you were looking for.  And maybe that would be interesting.  But of course that's a lot of hand-waving right now.</p>
<aside class="quote no-group" data-username="bradrn" data-post="17" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I take this as a sign that we shouldn’t waste our time thinking up elaborate schemes to encode information in its return value… rather, we should just make it as simple as possible.</p>
</blockquote>
</aside>
<p>In the end, a good "realistic" choice might well need to be about coming to terms with something kind of simple.  That may just be how it is.</p>
<p>64 types wasn't going to cut it for me, so I had to break that barrier for starters.</p>
<p>Now that the barrier is broken, it's a good time to let it simmer a bit.  It's not going to resolve overnight--but I'm quite glad that you're thinking about it, and that you are able to take initiative and grok these problems well.</p>
<p>On the plus side, there's a lot of other fun things to work on right now while this sorts out...empowered by the new types (and some other realizations that are falling into place)...</p>
<aside class="quote no-group" data-username="bradrn" data-post="17" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>As a first step towards answering it, I did a quick search of the Ren-C source code. As far as I can see, it’s not used very It looks often.</p>
</blockquote>
</aside>
<p>I'm pleased and terrified that you're reading the source, but... there are some files that have decent organizations and comments to them, which can give you your bearings faster than reading something like a R3-Alpha or a Red.</p>
<p>This is motivating me to start pushing through some changes that had been on the back burner for a while, e.g. the death of REBVAL:</p>
<p><a href="https://github.com/metaeducation/ren-c/commit/71459d6dc03ca9b0aea5e97ff76c57b0a2405249" class="inline-onebox">REBVAL =&gt; Value renaming · metaeducation/ren-c@71459d6 · GitHub</a></p>
<p>If you do have questions about things you see, feel free to ask them (or send PRs of things that are clearly just wrong or outdated).</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_18</link>
        <pubDate>Thu, 22 Feb 2024 14:01:30 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7182</guid>
      </item>
      <item>
        <title>Variant Of &quot;COLLECT&quot; Without &quot;KEEP&quot;</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2110">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Maybe having a thing and calling it ACCUMULATE would be useful?</p>
<pre><code class="lang-plaintext">&gt;&gt; parse [hello 1 2 3] [let w: word! (print [w]), accumulate integer!]
hello
== [1 2 3]
</code></pre>
</blockquote>
</aside>
<p>I've realized this is actually <em>extremely</em> useful.  Ren-C's ability to vaporize things with ELIDE makes it even more useful, since making the result you want drop out of an expression is even easier without a temporary variable.</p>
<pre><code> &gt;&gt; parse ["a" a &lt;a&gt; "b" b &lt;b&gt;] [accumulate [text! word! elide tag!]]
 == [a b]
</code></pre>
<p>So I've added it!</p>
<pre><code>accumulate: combinator [
    return: "Block of accumulated values"
        [block!]
    parser [action?]
    &lt;local&gt; collected
][
    collected: copy []
    remainder: input
    cycle [
        append collected (
            [@ remainder]: parser remainder except e -&gt; [
                return collected
            ]
        )
    ]
]
</code></pre>
<p>It just loops through calling the "combinated" parser function it receives, until there's a match failure.  Then it returns the block it collected.  (Ultimately I decided that an empty block is probably what you want vs a null if there are no matches, but a variation could be easily done...as you can see.)</p>
<p><strong>UPARSE extensibility for the win yet again.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/variant-of-collect-without-keep/2110#post_6</link>
        <pubDate>Thu, 22 Feb 2024 09:20:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7181</guid>
      </item>
      <item>
        <title>TRY PARSE + PARSE EXCEPT : *FAIL* On Mismatch</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1924">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So this is good when you're writing an expression that's supposed to return a value. But if you're only interested in if the parse reached the end or not, it's not good enough.</p>
<pre><code class="lang-plaintext">&gt;&gt; try parse "aaabbb" [some "a" try some "b"]
== ~null~  ; isotope
</code></pre>
<p>That parse reached the end, but the product of the TRY combinator inside the parse block when it doesn't succeed is NULL. So <strong>if try parse ...</strong> is unfortunately not a general answer to testing if a parse completed.</p>
</blockquote>
</aside>
<h2>
<a name="i-think-i-have-the-answer-1" class="anchor" href="https://forum.rebol.info#i-think-i-have-the-answer-1"></a>I Think I Have The Answer...</h2>
<p>...and that answer is <strong>VALIDATE</strong>.</p>
<pre><code>&gt;&gt; validate "aaa" [some #a]
== "aaa"

&gt;&gt; validate "aaa" [some #b]
== ~null~  ; anti
</code></pre>
<p>If the only thing you're interested in testing for success or failure, then this variant of PARSE which evaluates to either the input series or null will give you a falsey result only if the parse does not succeed.</p>
<p>It's also a combinator, so you can use it from within PARSE (or another VALIDATE).</p>
<p>So don't do <strong>if parse ...</strong> unless you are testing for results of the rules that are logically synthesized based on the idea that's what the rules are outputting.</p>
<pre><code> if parse "ttt" [some "t" (true) | some "f" (false)] [
     ...
 ]
</code></pre>
<p>If you're using arbitrary rules and not controlling the result carefully, you want VALIDATE and not TRY PARSE.</p>
<p>The only uses of TRY PARSE should be if you don't care if the parse reaches the end <strong>and</strong> you don't care if the rules fail.  If you only want to allow for not reaching the end of the input, I've added PARSE/RELAX.</p>
<pre><code>&gt;&gt; parse "aaa" [#a]
== #a
** Error: PARSE partially matched the input, but didn't reach the tail

&gt;&gt; parse/relax "aaa" [#a]
== #a

&gt;&gt; parse "aaa" [#b]
** Error: PARSE BLOCK! combinator did not match input

&gt;&gt; parse/relax "aaa" [#b]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p><strong>It took a long time to get here, but I think this gives pretty complete coverage.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924#post_5</link>
        <pubDate>Thu, 22 Feb 2024 08:50:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7180</guid>
      </item>
      <item>
        <title>Should &quot;Arity-2 INTO&quot; in UPARSE actually just be... PARSE?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1864">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code class="lang-plaintext">parse [x: [$y z] "a" &lt;b&gt; %c] [
    words: accumulate [
        &amp;any-word?
        | spread validate block! [some &amp;any-word?]
    ]
    numbers: accumulate &amp;any-string?
]
</code></pre>
</blockquote>
</aside>
<p>I'll add that it might seem you don't need VALIDATE because you could just write instead:</p>
<pre><code>spread subparse block! [some &amp;any-word? &lt;subinput&gt;]
</code></pre>
<p>But it's worth mentioning a few reasons why VALIDATE as its own primitive is good...</p>
<p>It's not always as simple as adding  to the end:</p>
<pre><code>subparse block! ["foo" "bar" | some &amp;any-word? &lt;subinput&gt;]  ; oops
</code></pre>
<p>You need to make sure all the alternatives have finished:</p>
<pre><code>subparse block! [["foo" "bar" | some &amp;any-word?] &lt;subinput&gt;]
subparse block! ["foo" "bar" | some &amp;any-word? || &lt;subinput&gt;]
</code></pre>
<p>The rule may not be inline, so you could go from not needing a block at all to needing one, so you're adding a tag AND a block:</p>
<pre><code>subparse block! element-rule
subparse block! [element-rule &lt;subinput&gt;]
</code></pre>
<p>But overall, it's generally just very helpful to know ahead of time that you're expecting the input you're giving back out if it matches.  That aids comprehensibility, in particular if your rules are long:</p>
<pre><code>x: subparse block! [[
      ...
      pages of stuff that scroll off the screen
      ...
 ] &lt;subinput&gt;]
</code></pre>
<p>A reader has much more of a clue what's going on with:</p>
<pre><code>x: validate block! [
      ...
      pages of stuff that scroll off the screen
      ...
 ]
</code></pre>
<p>They know X can only be the block you just matched and passed to validate, or the rule fails and it the parse moves on.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864#post_6</link>
        <pubDate>Thu, 22 Feb 2024 03:54:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7179</guid>
      </item>
      <item>
        <title>Should &quot;Arity-2 INTO&quot; in UPARSE actually just be... PARSE?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>There's another nuance here...</p>
<p>PARSE has a variant (currently called MATCH-PARSE) that returns the parse input when the rules match, and null if it does not:</p>
<pre><code>&gt;&gt; parse "aaa" [some #a]
== #a

&gt;&gt; parse "aaa" [some #b]
** Error: PARSE BLOCK! combinator did not match input

&gt;&gt; match-parse "aaa" [some #a]
== "aaa"

&gt;&gt; match-parse "aaa" [some #b]
== ~null~  ; anti
</code></pre>
<p>One concern here is that MATCH-PARSE has its parameters backwards from MATCH</p>
<ul>
<li>
<p>MATCH purposefully takes the "rules" of what to match first, because it expects the expression producing the data to be longer than the match rule in the general case.</p>
</li>
<li>
<p>PARSE purposefully takes the "rules" of what to match second, because it expects the rules to be an entire mini-program</p>
</li>
</ul>
<p>So I'm not sure how good a name it is in the first place.  Then, we'd need MATCH-SUBPARSE if we're going to use it as a combinator to operate on series encountered during the parse.</p>
<p>I was thinking of changing the name to just VALIDATE (it's implicit in other dialects like DESTRUCTURE that they are built on top of parse, so why not make the default meaning of LIB.VALIDATE be parse-oriented as well?)</p>
<p>And it's appealing to be able to just say VALIDATE in the PARSE rules.</p>
<pre><code>parse [x: [$y z] "a" &lt;b&gt; %c] [
    words: accumulate [
        &amp;any-word?
        | spread validate block! [some &amp;any-word?]
    ]
    numbers: accumulate &amp;any-string?
]

&gt;&gt; words
== [x &amp;y z]

&gt;&gt; strings
== ["a" &lt;b&gt; %c]
</code></pre>
<p>Saying SUBVALIDATE doesn't make sense, because we're not in an outer validation.  We're in an outer parse.</p>
<p>The reverse applies if you're in a VALIDATE (or a DESTRUCTURE, etc.)... or anything that doesn't make it completely obvious that it's being driven via PARSE.</p>
<aside class="quote no-group" data-username="IngoHohmann" data-post="2" data-topic="1864">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>We're in a different dialect there, so one has to be aware of that anyway.</p>
<p>Dialects all the way down.</p>
</blockquote>
</aside>
<p>SUBVALIDATE irks me more than SUBPARSE did, and it moves the needle to where I think this is probably the right way to look at it.</p>
<p>But I'll hold off on renaming SUBPARSE just yet, and see what the consequences are with using the name VALIDATE as both combinator-keyword and top-level function.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864#post_5</link>
        <pubDate>Thu, 22 Feb 2024 02:28:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7178</guid>
      </item>
      <item>
        <title>What is the use of typesets?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>More than that, TYPE-BLOCK!s suggest a nice way to match one of several types, just like you can do in function definitions:</p>
<pre><code class="lang-plaintext">&gt;&gt; parse [x: $y z "a" &lt;b&gt; %c] [
     words-or-numbers: collect [some keep &amp;[any-word? any-string?]]
 ]
</code></pre>
</blockquote>
</aside>
<p>So you'll recall that was something that the design passed through at one point.  And in fact, GROUP!s would intersect, while blocks would union.</p>
<pre><code> &gt;&gt; match &amp;[(negative? integer!) (positive? decimal!)] -10.20
 == ~null~  ; anti

 &gt;&gt; match &amp;[(negative? integer!) (positive? decimal!)] -10
 == -10

 &gt;&gt; match &amp;[(negative? integer!) (positive? decimal!)] 3.04
 == 3.04

 &gt;&gt; match &amp;[(negative? integer!) (positive? decimal!)] 3
 == ~null~  ; anti
</code></pre>
<p>You don't technically need two types to do this if you're willing to pay for parentheses inside a group even for one clause.  But all things being equal, having the option to say <strong>&amp;(negative? integer!)</strong> instead of <strong>&amp;[(negative? integer!)]</strong> could be nice.</p>
<p>If the design winds up being able to accommodate this, I'm for it, but it all comes down to what the type system and TYPE OF need etc. as per other threads.</p>
<p>However...</p>
<aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>you can do it just as easily with TYPE-BLOCK! alone:</p>
<pre><code class="lang-plaintext">&gt;&gt; parse [x: $y z "a" &lt;b&gt; %c] [
     words: collect [some keep &amp;[any-word?]]
     numbers: collect [some keep &amp;[any-string?]]
 ]
</code></pre>
</blockquote>
</aside>
<p>The constraints already pushed it away from <strong>[some keep any-word!]</strong> to <strong>[some keep &amp;any-word?]</strong>.  So it carries a wart that many would say has compromised the aesthetic goals of a common case (that already had a "wart" of !, now a ?).  <em>But the &amp; wart at least buys you something rather significant:</em> the generality that you can bring in any function.</p>
<p>Taking that another two steps away with three characters of noise moves this to an even more unpalatable place, without offering a benefit that the single character did not provide (for the common case).</p>
<p>Unlike some of the people who play this game who don't appear that self-aware... I'm quite conscious that this obsession with the economy of every little character and drift away from English can seem ridiculous.  Maybe it's a dumb game.  But if one is going to play it, one has to try and follow the rules.</p>
<p>(If you didn't see my <a href="https://youtu.be/7hgttttaczc?t=240">"timeless bear" story</a>... as stupid as it may sound... the reason I told it is because actually: yeah, that's how obsessive we actually intend to be.)</p> ]]></description>
        <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153#post_8</link>
        <pubDate>Thu, 22 Feb 2024 01:01:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7177</guid>
      </item>
      <item>
        <title>Alternate String Forms if {...} Becomes An Array Type</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="giuliolunati" data-post="16" data-topic="1743">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/giuliolunati/40/203_2.png" class="avatar"> giuliolunati:</div>
<blockquote>
<p>Well, having<br>
"..." as multiline quasi-raw (with "" representing ")</p>
</blockquote>
</aside>
<p>I'm definitely liking the raw-by-default concept.  It makes the most sense.</p>
<p>I'm still leery of <strong>"..."</strong> being multiline (or even <strong>-"..."-</strong>).  With the <strong><code>-{...}-</code></strong> option available I think being able to rein in the frustration of unclosed quotes would be a benefit to having the choice.  Making the jump to the braced form would go hand in hand with having to be more vigilant/tolerant of the potentially mysterious errors that happen when multiline strings aren't correctly terminated and wind up coupling with a later delimiter than expected, making a larger-than-expected string.</p>
<p>Using <strong>""</strong> for escaping a single quote in a raw string vs. being an error is something to ponder ...as keeping from forcing you to a different string choice or the ugly <strong><code>\""\</code></strong> just to get a quote inside a quoted string.  But I still feel it's more logical to say:</p>
<pre><code>&gt;&gt; print """"
""
</code></pre>
<p>Instead of:</p>
<pre><code>&gt;&gt; print """"
== "
</code></pre>
<p>The idea of starting the quotes-look-for-pairs process when a quote is seen followed by a non-closing-delimiter seems novel and useful.</p>
<pre><code>&gt;&gt; print "I think "(this seems cool)" and would be useful."
I think "(this seems cool)" and would be useful.
</code></pre>
<p>So you wouldn't have to jump to the 2-character delimiter format of  <strong><code>-{...}-</code></strong> for common quoted material cases, making the fence transition introduce somewhat less "noise".</p>
<p>This strategy doesn't cut you any breaks if you want lone quotes inside a lone quoted string.  Since it's raw, there's no representation for that.  You have to go to more than one character for your delimiter...to use a different delimiter that doesn't conflict with quote, or to add the ability to escape.  So <strong><code>-{"}-</code></strong> or <strong><code>-"""-</code></strong> would be your only reasonable choices for a lone quote string... given that <strong><code>\"\""\</code></strong> is unreadable.</p>
<p>If doing something in C, the choice would clearly be the braced form, giving you the "about as good as it's going to get" option of:</p>
<pre><code>rebElide("print -{\"}-");  // backslash is for the C literal, not seen by Rebol
</code></pre>
<p>I was going to say it's not as "nice" as it was in the pre-FENCE! era:</p>
<pre><code>rebElide("print {\"}");
</code></pre>
<p>But actually it feels like there's a bit more guidance with that compound delimiter to know what you're looking at, fences or not.</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="27" data-topic="1743">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="26" data-topic="1743">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Regarding quote doubling... given the space-significance of Rebol, I wonder if a rule about nested quotes could be that if a quote isn't followed by a terminating delimiter character (space, <code>)</code> <code>]</code>, <code>}</code>, comma, newline) then it starts a paired quote?</p>
</blockquote>
</aside>
<p>I greatly dislike this approach — I think it’s a bad idea to make this work with some embedded quotes, but not others. That feels like it could get a bit confusing in practice.</p>
</blockquote>
</aside>
<p>If single quoted strings are confined to one line, it helps mitigate how out of hand this could get.  It's something that I think should be given a chance before dismissing it out of hand.</p>
<p>Everything about the practice of escaping strings comes down to tradeoff situations.  This just would be the case that if you are going to deal with putting quotes inside of single quoted strings, you would have to ask yourself <em>"am I doing a simple quote pair that doesn't clearly conflict with what looks like single-quoted string termination"</em>.  If the answer is no, choose another method.</p>
<p>I don't know if the deeper nuance to make closing delimiters legal under some situations but not others is worth it:</p>
<pre><code>"this would ") be illegal"  ; thinks the ) with space after is a closing delimiter 
"this could ")" be legal"  ; looks ahead and sees ), but then looks and sees "
</code></pre>
<p>But again, I wouldn't dismiss that out of hand either.  It may follow a simple-enough-to-articulate implementation rule, that is learnable in practice.</p> ]]></description>
        <link>https://forum.rebol.info/t/alternate-string-forms-if-becomes-an-array-type/1743?page=2#post_29</link>
        <pubDate>Wed, 21 Feb 2024 23:29:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7176</guid>
      </item>
      <item>
        <title>Alternate String Forms if {...} Becomes An Array Type</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="25" data-topic="1743">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Out of those proposed, I don’t hate <code>#{…}</code> as a possible solution. <code>&lt;{…}&gt;</code> isn’t bad either.</p>
</blockquote>
</aside>
<p>With FENCE! existing, I think it's a given that anything that reuses <code>{}</code> needs to have the delimiter on both ends.  Not only is it an important visual cue after a long read to know you're not dealing with a fence, but it gives you the benefit of not having to escape lone <code>}</code>.</p>
<pre><code class="lang-plaintext">Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: #{
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors
    }#
    License: #{
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    }#
    Description: #{
       Note this reclaims the benefit of braces not escaping:
       
            printf("The char is } and it need not be escaped\n");

       So that's good.
   }#
]
</code></pre>
<p>To my eyes, that's rather abrasive to be using for a very common string type.  Definitely more abrasive than <code>&lt;{...}&gt;</code>.  And it leaves us without a representation for BINARY!, e.g. #{DECAFBAD}</p>
<pre><code class="lang-plaintext">Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: &lt;{
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors
    }&gt;
    License: &lt;{
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    }&gt;
    Description: &lt;{
       Note this reclaims the benefit of braces not escaping:
       
            printf("The char is } and it need not be escaped\n");

       So that's good.
   }&gt;
]
</code></pre>
<p>But if the goal is "distinguishibility but slightness", you can't get too much more slight than <strong><code>-</code></strong>.</p>
<pre><code class="lang-plaintext">Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: -{
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors
    }-
    License: -{
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    }-
    Description: -{
       Note this reclaims the benefit of braces not escaping:
       
            printf("The char is } and it need not be escaped\n");

       So that's good.
   }-
]
</code></pre>
<p>If that's <em>too</em> slight to the point of being "too fency", then = is another option whose sleek horizontalness doesn't break the visual flow as much...though it does certainly break the flow.</p>
<pre><code class="lang-plaintext">Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: ={
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors
    }=
    License: ={
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    }=
    Description: ={
       Note this reclaims the benefit of braces not escaping:
       
            printf("The char is } and it need not be escaped\n");

       So that's good.
   }=
]
</code></pre>
<p>My use of <strong>===</strong> as a section divider leads me to not wanting to see something this heavy in such positions.</p>
<p>Red has adopted <code>%{...}% </code> for "raw strings", e.g. those that you don't need to use escaping inside.  Which compromises the FILE! string type <strong>%file.txt</strong>, which would want to use <strong>%{...}%</strong> for spanning spaced filenames I'd imagine.</p>
<p>I believe I agree with <a class="mention" href="https://forum.rebol.info/u/giuliolunati">@giuliolunati</a> that not using escaping makes the best <em>default</em>.  if you wanted escaping, then maybe backslash is the way to go.  Ugly, but it would call attention to the fact that you're using escaping...and you'd be able to notice if you took the escaping out and could drop the backslashes at that point.</p>
<pre><code class="lang-plaintext">Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: -{
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors
    }-
    License: -{
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    }-
    Description: -\{
       Note this reclaims the benefit of braces not escaping:
       
            printf("The char is } and it need not be escaped\n");

       So that's good.  And here we can do \n\n\n for escaped lines.
   }\-
]
</code></pre>
<p>I'm not using just <strong><code>\{...}\</code></strong> because I imagine this as a family of escaped strings <strong><code>%\{...}\%</code></strong>, so you'd need to know which it is.  It also counterintuitively looks better with the <strong>-</strong>.</p>
<pre><code class="lang-plaintext">Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: -{
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors
    }-
    License: -{
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    }-
    Description: \{
       Weirdly this does not look as good, despite dropping a character.
       
            printf("The char is } and it need not be escaped\n");

       So that's good.  And here we can do \n\n\n for escaped lines.
   }\
]
</code></pre>
<p>The slightness argument makes the <strong><code>-{...}-</code></strong> and <strong><code>-\{...}\-</code></strong> idea actually kind of compelling to me.  It wouldn't cause confusion with TAG! (and would leave <code>&lt;{...}&gt;</code> and <code>&lt;\{...}\&gt;</code> as an option for a tag that wouldn't need to escape &gt; inside of it.)</p>
<p>It's a pattern which could be used with quoted strings too.</p>
<pre><code>&gt;&gt; print "I'm a \n not escaped string"
I'm a \n not escaped string

&gt;&gt; print \"I'm an \nescaped string"\
I'm an
escaped string

&gt;&gt; print -"I'm a quote " safe string"-
I'm a quote " safe string

&gt;&gt; print -\"I'm a quote " safe\nescaped string"\-
I'm a quote " safe
escaped string
</code></pre>
<p>Gives you options.  <strong><code>-{"}-</code></strong> isn't a fantastic way to say "single quote" but it's better than <strong><code>-"""-</code></strong> and definitely better than <strong><code>\"\""\</code></strong></p>
<p>The BINARY! representation contention with TOKENISSUECHAR! (whatever that thing is) bothers me.  I'd imagine like <strong><code>#{"}#</code></strong> as a single character for quote, and <strong><code>#"{"#</code></strong> as a single character for brace, with things like <strong><span class="hashtag">#a</span></strong> and <strong><span class="hashtag">#b</span></strong> just standing on their own since there are no spaces or irregular letters.</p>
<p>But we've kind of run out of symbols at this point... what does #{DECAFBAD} become to be a binary?  There'd still be &amp;"..." and $"..."  I guess (not fence forms like &amp;{..} and ${ }).  It's up to you whether to put a closing "&amp; or "$ on that, since $ and &amp; and other escapable things aren't legal inside binaries.</p>
<p>Or angle brackets with a decorator.  <strong><code>$&lt;DECAFBAD&gt;</code></strong> is actually a pretty respectable looking BINARY!.  And it leaves <strong>#&lt;</strong> and <strong>#&gt;</strong> for the characters of less than and greater than (assuming we don't get so saturated that <code>#&lt;&gt;</code> needs to be something, but maybe that's looking like a bad assumption).</p> ]]></description>
        <link>https://forum.rebol.info/t/alternate-string-forms-if-becomes-an-array-type/1743?page=2#post_28</link>
        <pubDate>Wed, 21 Feb 2024 21:08:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7175</guid>
      </item>
      <item>
        <title>What is the use of typesets?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Let me patiently again mention my conviction that not only do I use them (and intend to continue to use them) but I am not budging on being able to do this:</p>
<pre><code class="lang-plaintext">&gt;&gt; parse [x: $y z "a" &lt;b&gt; %c] [
     words: collect [some keep &amp;any-word?]
     numbers: collect [some keep &amp;any-string?]
 ]
</code></pre>
</blockquote>
</aside>
<p>While thinking about types more generally… I came to the conclusion this isn’t as good an argument as I thought it was. Because you can do it just as easily with TYPE-BLOCK! alone:</p>
<pre><code class="lang-plaintext">&gt;&gt; parse [x: $y z "a" &lt;b&gt; %c] [
     words: collect [some keep &amp;[any-word?]]
     numbers: collect [some keep &amp;[any-string?]]
 ]
</code></pre>
<p>More than that, TYPE-BLOCK!s suggest a nice way to match one of several types, just like you can do in function definitions:</p>
<pre><code class="lang-plaintext">&gt;&gt; parse [x: $y z "a" &lt;b&gt; %c] [
     words-or-numbers: collect [some keep &amp;[any-word? any-string?]]
 ]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153#post_7</link>
        <pubDate>Wed, 21 Feb 2024 13:04:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7174</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>(Apologies, this post has ended up somewhat long and rambly. TL;DR: we should think much more carefully about how useful TYPE OF really is in practice.)</p>
<p>In trying to sort out my thoughts on this topic, I’ve come to think that the key question we should be asking is: <em>precisely what do we want to use types for?</em></p>
<p>Starting with the most basic things, one very important use is within the interpreter itself. This is the HEART_BYTE, which (as I understand it) defines how to interpret the bytes making up a Rebol value. (Previously <a class="mention" href="https://forum.rebol.info/u/hostilefork">@hostilefork</a> has called this the ‘kind’.) Obviously, this is vital to making the interpreter work. It’s also fairly limited, albeit less now than it used to be.</p>
<p>A second usecase is if you have some arbitrary value and want to find out what you can do with it — what Rebol calls TYPE OF. In most dynamically-typed programming languages, including historical Rebol, this gives you back the internal interpreter type… but there’s no reason it couldn’t yield something more generic, as we’ve been discussing.</p>
<p>A third usecase is if you want to match a value against some criterion. Rebol highlights this quite prominently: in average Rebol code, types are used most frequently to establish preconditions for function arguments. They’re used similarly <a href="https://forum.rebol.info/t/what-is-the-use-of-typesets/2153/2">in PARSE</a>, amongst other places.</p>
<p>(In other languages, the most prominent use of types is to enable static analysis during compilation. This is an <em>extremely</em> useful capability, and in many modern languages, the type system is explicitly designed to make it tractable to check as many properties as possible before the program is run. But Ren-C isn’t compiled, and Rebol more broadly isn’t hugely amenable to static analysis anyway, so this isn’t a concern for us at all.)</p>
<p>Most dynamically-typed languages cover all three of these usecases with a single notion. Each value is stored alongside some type descriptor, which is returned when the programmer asks for <code>typeof(value)</code> (or whatever it might be). Then, you can check that against another type using an ordinary <code>if</code> expressions, same as checking any other condition.</p>
<p>Historical Rebol took much the same approach. It has a fairly unorthodox implementation of supertyping (using typesets), but otherwise, there’s one notion of ‘type’ which covers all usecases. The main wrinkle is that dialects can use special syntax for matching against types, most notably in function parameters.</p>
<p>Ren-C has already diverged from this approach, by recognising that ‘things you can match against’ is a broader category than ‘things the interpreter needs to know about’. Thus, it’s gradually extended the language to accept functions (a.k.a. ‘type constraints’) in places where it previously only accepted types. We’re now at a point where all type-like things, aside from the primitive ‘kinds’, are consistently represented as functions. <strong>And I think we’ve agreed that this is a good idea.</strong> By separating ‘types the interpreter knows about’ from ‘types we match against’, we free up the interpreter to support a lot more basic types, while giving function definitions a greater ability to express arbitrary preconditions.</p>
<p>But of course, that doesn’t cover all the places types pop up in Rebol. They also appear as the return value of TYPE OF… which, I think, is where our disagreement lies. I’ve been leaning towards unifying it with that idea of ‘types we match against’, meaning that users only have to deal with a single notion of ‘type constraint’. On the other hand, you want to make it a more structured system, focussed around those primitive types known by the interpreter.</p>
<p>However, thinking along these lines has led me to pose a slightly different question: <strong>how does TYPE OF get used in practise?</strong> I think the answer to this question should significantly influence what we choose it to return.</p>
<p>As a first step towards answering it, I did a quick search of the Ren-C source code. As far as I can see, it’s not used very It looks often. Indeed, I can only find three occurrences:</p>
<ul>
<li>Two in UPARSE, where it’s used in <code>type-block! combinator</code> to test a value against a type in an <code>if</code> expression. In my opinion, this should really be replaced with MATCH, allowing it to deal with filter actions as well.</li>
<li>One in <code>test/datatypes/varargs.test.reb</code>, where it’s again used to match a value against a type, albeit in a significantly more convoluted way which I don’t understand.</li>
</ul>
<p>(For comparison, when I search for MATCH, I count &gt;40 occurrences in the mezzanine alone.)</p>
<p>At least to me, this suggests that <strong>TYPE OF is of significantly limited use in actual code</strong>. I take this as a sign that we shouldn’t waste our time thinking up elaborate schemes to encode information in its return value… rather, we should just make it as simple as possible.</p>
<p>Along those lines, maybe TYPE-BLOCK! isn’t such a good choice for its return type after all, and it should be returning a single TYPE-WORD!. On the other hand, that doesn’t work so well with my conviction that we should only have one variety of TYPE-*. I feel sure that there’s some better design waiting to be discovered for this.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_17</link>
        <pubDate>Wed, 21 Feb 2024 12:59:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7173</guid>
      </item>
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><strong>-&gt;</strong> is an infix operator that takes its left hand argument literally.</p>
<p>It is a shorthand for making lambdas.</p>
<pre><code>x -&gt; [...]  ; same as lambda [x] [...]
</code></pre>
<p>So the above is just another way of writing:</p>
<pre><code>all/predicate @[
    [$word $tu.p.le $pa/th $[bl o ck] $(gr o up)]
] lambda [item] [
    '$ = sigil of item
]
</code></pre>
<p>Because the ALL can see the @ on the block it receives, it can use this as a cue to not evaluate.  Hence synonymous with:</p>
<pre><code>all [
    '$ = sigil of '$word
    '$ = sigil of '$tu.p.le
    '$ = sigil of '$pa/th
    '$ = sigil of '$[bl o ck]
    '$ = sigil of '$(gr o up)
]
</code></pre>
<p>I think the <code>@XXX</code> behavior is going to turn out to be far more important than even I thought at first (and that it should not bind, if you need it bound say <strong><code>$ @xxx</code></strong>)... I'll be making a writeup on that.</p>
<p>Of course, now that I look at the repetition in the tests, the fact that I didn't actually factor out the tester means this looks a lot messier than if I'd just written it out. <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Maybe it would be better (and give Chris less of a heart attack) if it said:</p>
<pre><code>for-each [sigil' items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    '::    [  word:  tu.p.le:  pa/th:  [bl o ck]:  (gr o up): ]
    ':     [ :word  :tu.p.le  :pa/th  :[bl o ck]  :(gr o up)  ]
    '^     [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    '&amp;     [ &amp;word  &amp;tu.p.le  &amp;pa/th  &amp;[bl o ck]  &amp;(gr o up)  ]
    '@     [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    '$     [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
 ][
      for-each item items [
          if (unmeta sigil') &lt;&gt; sigil of item [fail [mold item]]
      ]
 ]
</code></pre>
<p>That actually pinpoints which item gave the bad sigil back, if one does...</p>
<p>RE: the UNMETA there, I love how <em>rational</em> the isotopic model is.  I chose NULL for the result of SIGIL OF when there isn't one vs. fabricating.  That makes the most sense (you can test (if sigil of value)), but that means you can't put the null result in blocks...yet there are answers!  Just got to wear your META-hat.  <strong>^</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560#post_12</link>
        <pubDate>Wed, 21 Feb 2024 02:00:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7172</guid>
      </item>
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Speaking of which... note the application of the @[...] block type to tell ALL not to evaluate, just to apply the predicate to the items in the block as-is:</p>
<pre><code class="lang-plaintext">apply :all [
    @[$word $tu.p.le $pa/th $[bl o ck] $(gr o up)]
    /predicate item -&gt; ['$ = sigil of item]
]
</code></pre>
</blockquote>
</aside>
<p>I don’t understand this code… what result would it return?</p> ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560#post_11</link>
        <pubDate>Wed, 21 Feb 2024 01:05:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7171</guid>
      </item>
      <item>
        <title>About the Math category</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Rebol languages aren't a particularly great choice for math.</p>
<ul>
<li>
<p>Operator precedence follows the left-to-right nature of the evaluator, not the precedence many would expect:</p>
<pre><code>&gt;&gt; 1 + 2 * 3
== 9
</code></pre>
</li>
<li>
<p>Its syntax focus on words-separated-by-spaces, so this expands out expressions:</p>
<pre><code>&gt;&gt; length of [x+y*z]
== 1

&gt;&gt; type of first [x+y*z]
== &amp;[word]
</code></pre>
</li>
<li>
<p>The language is interpreted, meaning that even the simplest operation like <strong>add 1 2</strong> will run thousands of times slower than a compiled instruction.</p>
</li>
</ul>
<hr>
<p>But all programming involves math every now and again.  So this category is for discussing any math issues people want to talk about.</p> ]]></description>
        <link>https://forum.rebol.info/t/about-the-math-category/2155#post_1</link>
        <pubDate>Tue, 20 Feb 2024 23:27:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7170</guid>
      </item>
      <item>
        <title>What is the use of typesets?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>What confused me was <code>%types.r</code></p>
</blockquote>
</aside>
<p><a href="https://github.com/metaeducation/ren-c/commit/7523828e5c2e1048bfee834ce3178c1e16527b01" class="inline-onebox">Update %types.r with e.g. ANY-STRING? vs ANY-STRING! · metaeducation/ren-c@7523828 · GitHub</a></p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">&gt;&gt; test: func [x [any-utf8!]] [return x]
Assertion failure: QUOTE_BYTE(v) == ANTIFORM_0
Line 165, File: /home/bradrn/Documents/red/ren-c/src/include/cells/cell-quoted.h
Trace/breakpoint trap (core dumped)
</code></pre>
</blockquote>
</aside>
<p><a href="https://github.com/metaeducation/ren-c/commit/dde4b07d83e3e75f82568fb555127f9680478176">This was a simple incorrect assert in the error delivery.</a></p>
<p>If you hit asserts (or bugs) then please feel free to report them on GitHub Issues.  I don't really use it much right now, as I just keep a little local task list...and most things that don't fit there are open-ended design discussions, where the forum's reorganizability makes it a better medium.</p>
<p>But I do write up an occasional thing if it's something I'm not imminently going to fix and don't feel like it belongs as a long comment inline in the source, or as a forum post.  Did this one recently, for example:</p>
<p><a href="https://github.com/metaeducation/ren-c/issues/1157" class="inline-onebox">Quasi-Void Rendering Ambiguity in Paths · Issue #1157 · metaeducation/ren-c · GitHub</a></p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>On reading the source code, this confused me a bit…</p>
</blockquote>
</aside>
<p>If you're reading source, hopefully you've gathered that there are a lot of "extenuating factors" which mean that what you're reading may not be good or current... so take everything with a grain of salt.</p>
<ul>
<li>
<p>A lot of the code in the building process is more convoluted than it need be because it's trying to run in a 6-year-old Ren-C as well as a current one.</p>
<ul>
<li>As bad as the convolutions are, it's still a bit impressive to see how much emulation and twisting can be done.  The design has been influenced by what was hard or easy to bend, so recent interpreters are even more bendy.</li>
</ul>
</li>
<li>
<p>Rebmake is a catastrophe beyond that, <a href="https://forum.rebol.info/t/new-build-executables-new-build-strategy/1432">I've explained why</a>.</p>
<ul>
<li>Again...as much of a nightmare it is, maintaining that nightmare provides insights.  It's like a large organic test case that demands attention to itself...I can't skip over its needs, because things need to build.</li>
</ul>
</li>
<li>
<p>Large swaths of the system are legacy C if/then/else soup that I wouldn't trust further than I can throw it.  But this is the life support for the moment, that makes the interpreter able to actually do some things... so it's possible to test the ramifications of designs on sort-of-real-world situations.</p>
</li>
<li>
<p>Entire fundamental pieces (like binding and types, as recent examples), have undergone experimental prototyping while trying to juggle all the balls in the air... the carnage is pretty intense.</p>
</li>
<li>
<p>The concerns of isotopes are still very much propagating (in fact, the concerns of generic quoting never quite got a good formalism).  The very existence of "values that decay" raise the question of which routines have to face about who should see decayed or undecayed values.  This is the consequence of innovating in the midst of existing code.</p>
<ul>
<li>Fortunately Ren-C can be built as C++ for extra checks, and I started introducing some amount of type safety <a href="https://github.com/metaeducation/ren-c/blob/10b98c98399db6cab5472c0d8a1d803e520cd631/src/include/structs/struct-cell.h#L646">with Element/Value/Atom distinctions</a>.  You'll see a pattern of me trying to make things that compile as brutish C but get a leg up if a C++ compiler is used.</li>
</ul>
</li>
</ul>
<p>But as I've said before, as despairing as some of it may seem, the defensive programming of asserts and such put Ren-C in a much stronger position than something like R3-Alpha or Red.  If they have a bug they just kind of have to go "oh well, it does that sometimes."  Ren-C is so noisy when something is out of alignment that it usually pinpoints the moment something goes wrong.</p>
<p>And I do think it actually does quite a lot of impressive things, considering the "rules of the game" the implementation is playing.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153#post_6</link>
        <pubDate>Tue, 20 Feb 2024 21:02:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7168</guid>
      </item>
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="9" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>(I don’t have much to say about the rest of the post, other than that it seems reasonable enough.)</p>
</blockquote>
</aside>
<p>This turned out to be a really good-feeling change!  Ugly dark corners got cleaned up.</p>
<p>The test file is the kind of thing that would give <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> nightmares, because it's very symbol-y by its nature <em>(but it's a test file...avoid writing code targeting humans that looks like this)</em>:</p>
<p><a href="https://github.com/metaeducation/ren-c/blob/master/tests/datatypes/sigil.test.reb">https://github.com/metaeducation/ren-c/blob/master/tests/datatypes/sigil.test.reb</a></p>
<p>Hopefully the regularity there has a feeling of completeness, to where you won't be calling for the death of any of the contained types.</p>
<p>Speaking of which... note the application of the @[...] block type to tell ALL not to evaluate, just to apply the predicate to the items in the block as-is:</p>
<pre><code>apply :all [
    @[$word $tu.p.le $pa/th $[bl o ck] $(gr o up)]
    /predicate item -&gt; ['$ = sigil of item]
]
</code></pre>
<p>That could be controlled with a refinement, but I think it's nice to carry it on the value.  Usually it looks better than that, because it's not used with symbol soup.</p>
<p>You can also do this with INERT, that will put the decoration on the block before it's passed to ALL.</p>
<pre><code>&gt;&gt; inert [a b c]
== @[a b c]

apply :all [
    inert [$word $tu.p.le $pa/th $[bl o ck] $(gr o up)]
    /predicate item -&gt; ['$ = sigil of item]
]
</code></pre>
<aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>They could either be their own datatype (as members of the category ANY-SIGIL?), or just use one type and be SIGIL! Probably one type is better.</p>
</blockquote>
</aside>
<p>Yep, one type is better.  I made it just be a variant of the ISSUE! cell, so the UTF-8 for the sigil is in the cell directly, and it falls mostly under the handling of anything that could take UTF-8-bearing types before.</p>
<p>You can use sigils, words, etc. in some places you could otherwise use quoted strings, e.g. string parsing:</p>
<pre><code>&gt;&gt; str: "AT&amp;T"

&gt;&gt; parse str [try some [change '&amp; ("-and-") | skip 1]]

&gt;&gt; str
== "AT-and-T"
</code></pre>
<p>It's not the biggest benefit, but you do save on the visual noise of three teeny vertical lines (and less importantly, you save on creating a string series node).  So I like being able to do it.</p>
<pre><code>parse str [try some [change '&amp; ("-and-") | skip 1]]

parse str [try some [change "&amp;" ("-and-") | skip 1]]
</code></pre>
<p>Of course if you are parsing an array, the meanings have to be different.</p> ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560#post_10</link>
        <pubDate>Tue, 20 Feb 2024 16:26:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7167</guid>
      </item>
      <item>
        <title>What is the use of typesets?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Typesets are now an implementation detail about how some type constraints are implemented quickly.</p>
</blockquote>
</aside>
<p>I’d actually been thinking of approaches like this myself, as a way to implement constraints… so it’s good to know we’re on the same page here!</p> ]]></description>
        <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153#post_5</link>
        <pubDate>Tue, 20 Feb 2024 06:37:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7166</guid>
      </item>
      <item>
        <title>What is the use of typesets?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Ah, OK. What confused me was <code>%types.r</code>, plus a <a href="https://github.com/metaeducation/ren-c/commit/add48c69505320b73199ecaa0d7ab1dba1fee3fb">recent commit message </a> mentioning typesets.</p>
</blockquote>
</aside>
<p>Typesets are now an implementation detail about how some type constraints are implemented quickly.</p>
<p>Some constraints like ANY-ARRAY? can be implemented just by checking the range of the byte in the cell being between a lower and higher value.</p>
<p>Other constraints are sparse, and to check them fast there's just a table... where each entry in the table for each type has bitflags OR'd together for whether the type for that entry in the table has membership in that typeset.</p>
<p>Historically all typesets were implemented one way: as 64 flags in an 64-bit integer.  As the commit message said, this just shifted the internals so that instead of the "fast" technique meaning you're limited to 64 types, you're limited to 64 non-range typesets for this optimization... and the limit of 256 types comes from using a byte in the cell.</p>
<p>(I say the "fast" technique, but there is no "slow" technique to compare with... it just has to have an implementation for things to run, and this is what it is.)</p> ]]></description>
        <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153#post_4</link>
        <pubDate>Tue, 20 Feb 2024 06:31:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7165</guid>
      </item>
      <item>
        <title>What is the use of typesets?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The current Ren-C does not have them.</p>
<p>(The %types.r table still has things like ANY-UTF8! mentioned in it, but that's just because I haven't gotten around to changing it...it's used to make the ANY-UTF8? function.)</p>
</blockquote>
</aside>
<p>Ah, OK. What confused me was <code>%types.r</code>, plus a <a href="https://github.com/metaeducation/ren-c/commit/add48c69505320b73199ecaa0d7ab1dba1fee3fb" rel="noopener nofollow ugc">recent commit message</a> mentioning typesets.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code class="lang-plaintext">&gt;&gt; parse [x: $y z "a" &lt;b&gt; %c] [
     words: collect [some keep &amp;any-word?]
     numbers: collect [some keep &amp;any-string?]
 ]
</code></pre>
</blockquote>
</aside>
<p>Fair enough, I’d forgotten about this. That’s one more thing for me to consider, I guess!</p> ]]></description>
        <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153#post_3</link>
        <pubDate>Tue, 20 Feb 2024 06:23:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7164</guid>
      </item>
      <item>
        <title>What is the use of typesets?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>So… if they can’t be accessed from Ren-C itself, then why does the interpreter have typesets at all?</p>
</blockquote>
</aside>
<p>The current Ren-C does not have them.</p>
<p>(The %types.r table still has things like ANY-UTF8! mentioned in it, but that's just because I haven't gotten around to changing it...it's used to make the ANY-UTF8? function.)</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>[On which note, incidentally, let me yet again mention my conviction that the other TYPE-* datatypes are useless and should be removed.]</p>
</blockquote>
</aside>
<p>Let me patiently again mention my conviction that not only do I use them (and intend to continue to use them) but I am not budging on being able to do this:</p>
<pre><code>&gt;&gt; parse [x: $y z "a" &lt;b&gt; %c] [
     words: collect [some keep &amp;any-word?]
     numbers: collect [some keep &amp;any-string?]
 ]

&gt;&gt; words
== [x: $y z]

&gt;&gt; numbers
== ["a" &lt;b&gt; %c]
</code></pre>
<p>If the functions I wanted to be able to use as constraints were members of objects, I would need <code>&amp;obj.my-constraint?</code></p>
<p>If the function had a refinement I was interested in, I would need <code>&amp;my-constraint?/refinement</code></p>
<p><strong>We do not assume that just any arbitrary function looked up by WORD! reference in a dialect (at least, in PARSE) is meant to be used as a type constraint.</strong></p>
<pre><code>&gt;&gt; parse [x: $y z "a" &lt;b&gt; %c] [
     words: collect [some keep any-word?]
     numbers: collect [some keep any-string?]
 ]
</code></pre>
<p>Even if we could do that (by some categorization system that said a function returned a boolean and took a single value and was a plausible type constraint) I don't know that I'd want to.  Applying a test to the current value of the input is different than what's suggested by <strong>any-value? xxx</strong> inline in the parse...which makes it seem like you're testing the product of the next rule.  I prefer at the source level having this called out, and having the inertness overture let you know that it's not taking the ensuing thing as an argument.</p>
<p>The only undecorated functions that I'd want to dispatch would be those that fit the format of a combinator.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2153">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">&gt;&gt; test: func [x [any-utf8!]] [return x]
Assertion failure: QUOTE_BYTE(v) == ANTIFORM_0
Line 165, File: /home/bradrn/Documents/red/ren-c/src/include/cells/cell-quoted.h
Trace/breakpoint trap (core dumped)
</code></pre>
</blockquote>
</aside>
<p>Due to the large amount of flux right now, I'm focusing on lining up parts more than I am on making sure the error handling is good.  So there's a lot of stuff that asserts vs. errors.</p>
<p>Of course this is clearly something that should just be an error, as putting undefined things in type spec blocks is an ordinary usermode problem.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153#post_2</link>
        <pubDate>Tue, 20 Feb 2024 06:08:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7163</guid>
      </item>
      <item>
        <title>What is the use of typesets?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>Recent discussions have brought the notion of ‘typesets’ to my attention. On reading the source code, this confused me a bit… they don’t seem to be used all that much. Moreover, they seem to be subsumed by the idea of optimised constraint functions.</p>
<p>So I set out to try them myself. Only to find myself thoroughly confused, because typesets don’t actually seem to be accessible from Ren-C itself. Or, at least, none seem to be defined — normal type names evaluate to TYPE-BLOCK!s as expected, but typeset names are unassigned:</p>
<pre><code class="lang-plaintext">&gt;&gt; word!
== &amp;[word]

&gt;&gt; text!
== &amp;[text]

&gt;&gt; any-utf8!
** Script Error: any-utf8! word is attached to a context, but unassigned
** Where: console
** Near: [any-utf8! **]
** Line: 1

&gt;&gt; any-type-value!
** Script Error: any-type-value! word is attached to a context, but unassigned
** Where: console
** Near: [any-type-value! **]
** Line: 1
</code></pre>
<p>[On which note, incidentally, let me yet again mention my conviction that the other TYPE-* datatypes are useless and should be removed.]</p>
<p>I expected to at least be able to use them in function signatures, but I can’t even do that, since it crashes a program:</p>
<pre><code class="lang-plaintext">&gt;&gt; test: func [x [word!]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8?]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8!]] [return x]
Assertion failure: QUOTE_BYTE(v) == ANTIFORM_0
Line 165, File: /home/bradrn/Documents/red/ren-c/src/include/cells/cell-quoted.h
Trace/breakpoint trap (core dumped)
</code></pre>
<p>So… if they can’t be accessed from Ren-C itself, then why does the interpreter have typesets at all?</p> ]]></description>
        <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153#post_1</link>
        <pubDate>Tue, 20 Feb 2024 04:29:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7162</guid>
      </item>
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>as <a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> said (somewhere)</p>
</blockquote>
</aside>
<p>Here: <a href="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146/10" class="inline-onebox">Upcoming Datatype $WORD... What Will It Mean? - #10 by bradrn</a>.</p>
<p>(I don’t have much to say about the rest of the post, other than that it seems reasonable enough.)</p> ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560#post_9</link>
        <pubDate>Tue, 20 Feb 2024 03:59:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7161</guid>
      </item>
      <item>
        <title>SETIFY, PLAINIFY, GETIFY, SYMIFY... or MORPH ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1334">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>There are historical cases where you have to navigate a situation like:</p>
<blockquote>
<p>"I have either a <strong>foo</strong> or a <strong>foo/bar</strong> and I want a <strong>foo:</strong> or a <strong>foo/bar:</strong> as appropriate."</p>
</blockquote>
<p>You can't exactly classify this in the type system. There's no <strong>to set! value</strong> that can do the right thing generically for WORD! and ANY-WORD!</p>
</blockquote>
</aside>
<p>A new proposal is to make <strong><code>:</code></strong> <strong><code>&amp;</code></strong> <strong><code>$</code></strong> <strong><code>^</code></strong> their own sigil datatypes, with special consideration for <strong><code>::</code></strong> as "the sigil of a SET-WORD!".</p>
<p>That offers a kind of clean path toward generalizing this:</p>
<pre><code>&gt;&gt; morph '$ 'var
== $var

 &gt;&gt; morph ':: 'var
 == var:

 &gt;&gt; morph void '$var  ; maybe morph '_
 == var
</code></pre>
<p>If you mention array/sequence types, it would be assumed the thing you were morphing was also an array/sequence.</p>
<pre><code> &gt;&gt; morph '[]: '$(a b c)
 == [a b c]:

 &gt;&gt; morph '$. 'a/b/c
 == $a.b.c

 &gt;&gt; morph ':: 'a/b/c
 == a/b/c:

 &gt;&gt; morph '[]: 'a
 ** Error: a is not an any-array type, can't make it []
</code></pre>
<p>Maybe it would be useful if it recursed if you had nestings of single items:</p>
<pre><code> &gt;&gt; morph '[({})]: '${[(a b c)]}
 == [({a b c})]:
</code></pre>
<p>Or maybe not.  Anyway, the general concept seems nice and orthogonal.</p>
<p>And importantly, it means you can do things like take a sigil off of one thing and put it onto another one.</p>
<pre><code>  morph (sigil of path-or-word-etc) other-path-or-word-etc
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/setify-plainify-getify-symify-or-morph/1334#post_3</link>
        <pubDate>Tue, 20 Feb 2024 03:45:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7160</guid>
      </item>
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So I'm having cold-feet on the idea that sigils should be able to be WORD!, when you can't create decorated forms of them.</p>
<p>In the <a href="http://blog.hostilefork.com/freedom-to-and-freedom-from/">"freedom to" and "freedom from"</a> dynamic, it's nice to have freedom from a WORD! that can't be turned into a SET-WORD!.</p>
<p>But there are big convolutions that come into play if colons are words, with people saying something like:</p>
<pre><code> make object! [
    {:}: does [print "colon as key"]
 ]
</code></pre>
<p>...if they expect that to make a key in the object named ":".  Having a key that can't be made into a SET-WORD! turns everything on its head if you expect things to handle it.</p>
<pre><code>&gt;&gt; setify ':
== {:}:  ; but not an ANY-WORD!... welcome to consequence city, population: me
</code></pre>
<p>It really wrecks the implementation to say that you search not only for SET-WORD!, but also SET-FENCE! (or whatever).  It ripples too far.</p>
<p>Same for @ and $ and &amp; and ^.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This means that instead of <strong><code>[^]: ...</code></strong> assigning a meaning to <strong>^</strong>, it signals you want the nameless result to be meta</p>
</blockquote>
</aside>
<p>So here we see another angle of that freedom-to/freedom-from.  If you're free from the idea that <strong>:</strong> is a word, then it can be a COLON!.  <strong>^</strong> can be a CARET!.    If we have a datatype for COLON!, we can give that colon behavior in the evaluator. Users can give it behavior in dialects.</p>
<p>SET-BLOCK! doesn't have to be concerned about not being able to assign to a variable named <code>"^"</code> because there aren't variables named <code>"^"</code>.</p>
<p>When we were at a 64-datatype limit, <strong><code>^</code></strong> and <strong><code>@</code></strong> had to be words, there wasn't space for them to be datatypes.  But now this is possible, and I think it's the direction to go.</p>
<p>They could either be their own datatype (as members of the category ANY-SIGIL?), or just use one type and be SIGIL!  Probably one type is better.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><code>[::]: does [print "This SET-BLOCK! does the job...visually and mechanically."]</code></p>
</blockquote>
</aside>
<p>I do like the idea of having <strong><code>::</code></strong> as a dialecting part.  But as <a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> said (somewhere), if you're willing to use the justification of "would be nice to have in a dialect" then that could be used to justify practically anything.</p>
<p>Maybe the types are something like COLONS! and CARETS!, and have lengths?</p>
<pre><code>&gt;&gt; type off first [:::]
== &amp;[colons]

&gt;&gt; length of first [:::]
== 3
</code></pre>
<p>Then colon? and &amp;colon? could be the type constraint for a single colon.  That's kind of batty (and disrupts the idea that these are always sigils).</p>
<p><strong>OR MAYBE...</strong> we could argue that <strong><code>::</code></strong> is a unique datatype that's the answer to SIGIL OF for a SET-WORD!</p>
<pre><code>&gt;&gt; sigil of first [:a]
== :

&gt;&gt; sigil of first [a:]
== ::

&gt;&gt; sigil of first [a]  ; void or null, or maybe BLANK! is an ANY-SIGIL?
== ~null~  ; anti
</code></pre>
<p>This gives completeness (one sigil per sigilized form), and adds a kind of nice extra part that I think might be nice in dialecting.  I guess that <code>::</code> would be named COLONS!, or maybe COLON-2! would be easier to see as distinct from COLON! (or COLON-COLON!... kind of a long type name, but whatever).</p>
<p>Anyway, this would remove one axis of second-class citizens from the world, and I would be much relieved about the cases of needing to render out MAKE OBJECT! with sigils as keys.</p> ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560#post_8</link>
        <pubDate>Tue, 20 Feb 2024 02:56:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7159</guid>
      </item>
      <item>
        <title>&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A month into the "antiform" change, I wanted to report that it has gone over quite well, and now feels completely natural.</p>
<p>You can still use phrases like "...is an unstable isotope...", but it's just the case that all unstable isotopes are antiforms.  So you don't need to say "...is an unstable antiform..." if you don't feel like it.</p>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2005">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>From this perspective, calling Ren-C values ‘isotopic’ vs ‘non-isotopic‘ is not just confusing but actually nonsensical. If a value is an isotope… what is it an isotope <em>of</em>, exactly? (Carbon? Hydrogen? Oxygen?) And if a value is <em>not</em> an isotope, then what could it possibly be? Some weird form of non-atomic matter?</p>
</blockquote>
</aside>
<p>There's a little subtlety here in that you can say <em>"packs are <strong>an isotope</strong> of block"</em> or <em>"packs are <strong>isotopes of</strong> block"</em>, but not <em>"packs are <strong>the</strong> isotope of block"</em>.</p>
<p>You can only use THE when saying <em>"packs are <strong>the antiform</strong> of block"</em> or <em>"packs are <strong>the antiform isotope</strong> of block"</em>.</p>
<p>And the term "isotopic" is now meaningless, outside of referring to something like "isotopic theory" or "the isotopic era of Ren-C".</p>
<p>Anyway... I'm not having any misgivings on this, it's been a good change.  Thanks again <a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a>, for putting the pressure on using the "isotope" term correctly!</p>
<p>I'm slowly updating the language used in old posts when I'm already editing them for other reasons.  (This makes those posts rise to the top as "recent", so I don't tend to do such terminology retcons all at once...)</p> ]]></description>
        <link>https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005#post_10</link>
        <pubDate>Tue, 20 Feb 2024 02:05:07 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7158</guid>
      </item>
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="4" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>Another idea might be to have backticked (or something else) braced strings be the notation for weird words.</p>
</blockquote>
</aside>
<p>It may be that with the FENCE! proposal, the "weird" fences could evaluate for the purpose of letting you GET and SET an arbitrary word.  I'm not sure what <strong>:{...}</strong> and <strong>{...}:</strong> would be used for otherwise.</p>
<p>I mention it because one problem with the dialecting of SET-BLOCK! is you can't use it to set <strong>@</strong> or <strong>^</strong> because they are used for nameless variables:</p>
<pre><code> &gt;&gt; [_ @]: pack [1 2]
 == 2

 &gt;&gt; [^ _]: pack [1 2]
 == '1
</code></pre>
<p>This means that instead of <strong><code>[^]: ...</code></strong> assigning a meaning to <strong>^</strong>, it signals you want the nameless result to be meta.  Maybe that's all right, and <strong><code>{^}:</code></strong> can pick up the slack, as well as offer a way to get the weird word with <strong><code>:{^}</code></strong>.</p>
<p>But it would have to stop there I think, because <code>${...}</code> would need to mean "bind the fence" not "give back the word in the fence bound".</p>
<p>Something to think about.</p> ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560#post_7</link>
        <pubDate>Sun, 18 Feb 2024 11:24:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7157</guid>
      </item>
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>My feeling is you should be able to build paths and tuples out of anything that's a valid WORD!. But is it time we had an escaping mode for "weird words"?</p>
</blockquote>
</aside>
<p>Remotivated a bit by my own answers to <a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147">why there's a 1-sigil limit</a>, I've had something of a Come-to-Jesus Moment on this... and I think it's one of these places where saying "no" is actually the right answer.</p>
<pre><code>|::|: does [print "I look all right, but..."]

|\|\|\||: does [print "THAT's |||: ? ... kill it with fire!"]

&gt;&gt; to path! [&lt;| |&gt;]
== |&lt;\||/|\|&gt;|  ; NOOOOO! 🔥🔥☠️☠️🔥🔥
</code></pre>
<p><em>I believe the way to deal with things that have sigils and delimiters/interstitials in them is with a second-class-citizen symbol type.</em>  (It may be too much of a hassle to make it a whole different datatype from WORD!, but the capabilities of some word symbols would be limited in terms of decoratability or putting in paths and tuples.)</p>
<p>The means of applying sigils would be using array types to wrap them, which may not cover all uses (you might need to <strong><code>get inside [] '$</code></strong>, for instance, to defuse it if it's an action) but would get some of the most important ones.</p>
<pre><code>[::]: does [print "This SET-BLOCK! does the job...visually and mechanically."]

&gt;&gt; make tuple! ['map '...]
** Error ; oh well

&gt;&gt; map.[...]: 10

&gt;&gt; map.[...]
== 10

|||: does [print "assigns |||, so back to normalcy for vertical bars"]
</code></pre>
<h2>
<a name="but-my-other-language-lets-me-do-it-1" class="anchor" href="https://forum.rebol.info#but-my-other-language-lets-me-do-it-1"></a>...But My Other Language Lets Me Do It!</h2>
<p><em>Well your other language isn't here now, is it?!</em></p>
<p>As it happens, when first encountering the idea of dialecting I was a pretty staunch believer that system-endorsed escaping was necessary in words.  Because when you've cooked up a dialect that uses types to cue behavior, it sucks if you hit a wall where you need spaces in what was otherwise an ANY-WORD!, or maybe you need something to start with a number.</p>
<p>The scenario one would predict would be that everyone would wind up inventing their own escaping system, and having to retrofit their code once they hit an edge case.</p>
<p>Maybe one person would start using two underscores to mean space, let's say they have ways of sending and receiving, SET-WORD! means send:</p>
<pre><code> dialect: [
     thermocouple_mux__pin: (+/-/16.bit) [11 7 913 -34 81]
     ...
 ]

 form-receiver-word: lambda [w [set-word!]] [
     replace/all (to text! w) "__" space
 ]
</code></pre>
<p>When what they really wanted was just:</p>
<pre><code> dialect: [
     |thermocouple_mux pin|: (+/-/16.bit) [11 7 913 -34 81]
     ...
 ]

&gt;&gt; type of first dialect
== &amp;[set-word]

&gt;&gt; form first dialect
== "thermocouple_mux pin"
</code></pre>
<p>Maybe 99.9% of the time they never need a space in the name, but some external pressure exists to line up the name with something that expects a space.  Or maybe it's something that starts with a number.  But once this comes up, the whole bet the person made on using the type might fall apart...</p>
<p>Couldn't the system have some empathy, vs. generating errors the way Ren-C, Red, and R3-Alpha do?</p>
<pre><code>&gt;&gt; to set-word! "thermocouple_mux pin"
*** Script Error: contains invalid characters
</code></pre>
<h2>
<a name="ren-cs-expanded-array-types-are-your-empathy-2" class="anchor" href="https://forum.rebol.info#ren-cs-expanded-array-types-are-your-empathy-2"></a>Ren-C's Expanded Array Types Are Your Empathy</h2>
<p>You have <strong>["thermocouple_mux pin"]:</strong> and <strong>[thermocouple_mux pin]:</strong> if you need them, and <strong>(...):</strong>, and soon <strong>{...}:</strong></p>
<p>I'm not as bothered by the idea that you have to accommodate another type or use your own FORM routine to produce strings, as I am about the idea of the source being crap because you had to distort it.  If you don't have to distort it, then a little more work in the implementation is a small price to pay.  Let's just work on making sure the implementation is easy to bend--having the language be the best it can.</p>
<p>If you've used all your array variants up for fully unrelated purposes, then what you have is probably verging on undeadable... and maybe you should have considered <strong>/send "thermocouple_mux pin"</strong> to begin with.</p>
<p>Broadly speaking... to be part of the crusade for simplification, you need to be able to push back against ugly requirements.  If you can't push back then you've pretty much already lost the battle for control of complexity.  The complexity is controlling you.</p>
<p>If you can't stand up against something like CR LF line endings--that's just a stepping stone on the path of pain:</p>
<p><a href="https://forum.rebol.info/t/fight-for-the-future-how-deline-will-save-us-from-cr-lf/1264" class="inline-onebox">Fight for the Future: How DELINE will save us from CR LF</a></p>
<p>(By analogy: I'm sure the people who decided filesystems should allow spaces in them meant well.  But the decision was a catastrophic one, creating <em>far</em> more pain than benefit.)</p>
<h2>
<a name="permissiveness-wouldnt-win-over-any-skeptics-3" class="anchor" href="https://forum.rebol.info#permissiveness-wouldnt-win-over-any-skeptics-3"></a>Permissiveness Wouldn't Win Over Any Skeptics</h2>
<p>Anyway, I went down the rabbit hole of escaped weird words... and the resulting chaos was beyond my ability to reason about it.  It turns out to be very not-Amish.</p>
<p>What comes out of the line of thinking ruins the pleasing aspects of working with the parts.  And I don't think giving in to this particular issue would wind up being enough to win over someone who ultimately wants to see the project bent to external constraints.  They'll disagree with the premise and leave when they hit the next speedbump.  Best to stick to principles, if anything notable is to be accomplished.</p> ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560#post_6</link>
        <pubDate>Sun, 18 Feb 2024 05:22:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7156</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="14" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I don't know if it's a good thought or not, but the narrowing could come from the idea that antform is an arity-2 parameterized type... which adds the subtype if applicable:</p>
<pre><code class="lang-plaintext">&gt;&gt; type of spread [a b c]
== &amp;[antiform &amp;[group] #splice]

&gt;&gt; type of true
== &amp;[antiform &amp;[word] #logic]
</code></pre>
</blockquote>
</aside>
<p>This feels quite redundant to me. A group antiform is <em>always</em> a splice. A word antiform is… OK, sometimes it’s a logic, sometimes it’s something else, but I don’t think TYPE OF is the right tool to be testing value-level properties like that.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="15" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm not sure how you'd elaborate objects to get something knowingly distinct.</p>
</blockquote>
</aside>
<p>Do we even have to? Plenty of languages (most notably JavaScript and Lua) use prototype-based objects which are not distinguished at runtime. I see no problem with Rebol taking the same approach.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_16</link>
        <pubDate>Sun, 18 Feb 2024 01:49:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7155</guid>
      </item>
      <item>
        <title>Dropping the ANY-XXX! from (Some) Type Constraints?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>In my <a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2">proposal for a constraints-only world</a>, I suggested keeping ANY-* for constraints which ‘look under’ sigils to match a specific type. So ANY-WORD? would match WORD!, GET-WORD!, QUOTED! of WORD!, ISOTOPE! of WORD!, etc., and similarly for the other ANY-* constraints. The idea would be that these are looking for ‘any’ occurrence of the specified type name. By contrast, a constraint like SERIES? wouldn’t get an ANY in its name, because it’s not looking for any occurrence of a SERIES! type. I think this is a reasonable compromise.</p> ]]></description>
        <link>https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152#post_2</link>
        <pubDate>Sun, 18 Feb 2024 00:11:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7154</guid>
      </item>
      <item>
        <title>What Should TYPE OF an Antiform Be?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1983">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think I like TYPE OF NULL being NULL</p>
<ul>
<li>I like it even if it breaks a pattern in XXX OF where VOID input means NULL out, and NULL input is an error</li>
<li>TYPE feels like a fairly special kind of question, so it's probably okay</li>
</ul>
</blockquote>
</aside>
<p>So I'm a little conflicted here.  Because <em><strong>if</strong> null has an answer to TYPE OF</em>, then I like that answer to be NULL.  But I don't like the idea of casually giving back an answer to TYPE OF for null, because it's supposed to be a kind of failure signal and draw attention to itself.</p>
<p>The idea of having a special "TYPE-BUT-IT-CAN-BE-NULL" question (like <strong><code>type* of</code></strong>) is one possibility for cases when you are sure that you intentionally want to tell if you have a null in your hand.</p>
<p>But I had what is probably a better idea...</p>
<h2>
<a name="what-if-we-used-definitional-errors-and-try-1" class="anchor" href="https://forum.rebol.info#what-if-we-used-definitional-errors-and-try-1"></a>What If We Used Definitional Errors, and TRY?</h2>
<p>Let's say every value gives an answer to TYPE OF, except for the one case of NULL.  But if you ask for it, TYPE OF raises a definitional error.  Then if you TRY it to defuse the error... giving you back a NULL!</p>
<pre><code> &gt;&gt; thing: null

 &gt;&gt; type of thing
 ** Error: TYPE OF NULL not legal (use TRY TYPE OF NULL if intended)

 &gt;&gt; try type of thing
 == ~null~  ; antiform
</code></pre>
<p>So you can write:</p>
<pre><code> switch try type of thing [
     null [... not a type, but you react to null ...]
     void! [...]
     splice! [...]
     logic! [...]
     etc.
 ]
</code></pre>
<p>You'd be guided by the TRY and the fact that NULL! does not exist to use the odd-man-out of NULL here.</p>
<p>That's actually pretty satisfying.  But what if you're trying to get at the FIRST TYPE OF?</p>
<p>Well, that suggests that TYPE OF VOID has to be &amp;[void] so that if you write <strong>first maybe try type of</strong> the TRY turns the error to null, the MAYBE turns the null to a void, and then FIRST gives null based on void-in-null-out.  VOID in gives you the word VOID out in that case, NULL in gives you NULL out in that case.</p>
<p>It's a bit of a mouthful, but nulls are supposed to be "ornery".  If people don't like it, they can test for null independently of the switch, which is probably what a normal person would do.</p>
<p>(There's some little nagging part of me that wants <strong>type of void</strong> to be something like <code>&amp;[]</code>.  I've always had some kind of urge to avoid reifying the types of voids and nulls... as too much of "something from nothing".  But it might be irrational.  Though not wanting to be too casual about allowing TYPE OF NULL is not irrational, I don't think.)</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-type-of-an-antiform-be/1983#post_8</link>
        <pubDate>Sat, 17 Feb 2024 22:23:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7153</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>it’s worth noting that ‘kind’ already has <a href="https://en.wikipedia.org/wiki/Kind_(type_theory)">a well-established meaning</a> in type theory. (Specifically, it’s the type of a type.) So it’s probably a good idea to choose some other word.</p>
</blockquote>
</aside>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>The elements of these series could simply be ordinary words, left unevaluated and unbound: one could test <code>'isotope = first type of spread [a b c]</code>, and so on.</p>
</blockquote>
</aside>
<p>Ok... well maybe I guess that if you want to test the "kind" then maybe the whole thing should be set up so that really is the <strong>first type of</strong> whatever you have.</p>
<p>It feels a bit strange to say that the <strong>type of</strong> whatever object subclasses wind up becoming starts with object... but... well, I guess it makes sense.</p>
<p>Then OBJECT! could mean "just a plain object with no further elaboration".</p>
<pre><code>&gt;&gt; object!
== &amp;[object]
</code></pre>
<p>So if you SWITCH TYPE OF and check against OBJECT! then you wouldn't match against fancier things than the base untyped object.  You'd have to SWITCH FIRST TYPE OF, and then you wouldn't be able to use things like SPLICE! or LOGIC! in what you test against because you'd be dealing with words, not types.</p>
<p>I'm not sure how you'd elaborate objects to get something knowingly distinct.  Could go the Java route and use URLs when you create your classes.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<pre><code> &amp;[object http://hostilefork.com/project1/book]

 &amp;[object http://hostilefork.com/project2/animal]
</code></pre>
<p>As these are runtime concepts, maybe making a new object class would get a runtime ID.</p>
<pre><code> &amp;[object @animal.17]

 &amp;[object @book.32302]
</code></pre>
<p>That's less oppressive-seeming.</p>
<pre><code> &gt;&gt; book!: class @book [...]
 == &amp;[object @book.32302]  ; e.g. class creates a type, not an instance

 &gt;&gt; b: make book! [title: "Ren-C (Ab)user's Guide"]
 == ...{@book title: "Ren-C (Ab)user's Guide"}...

 &gt;&gt; type of b
 == &amp;[object @book.32302] 
</code></pre>
<p>Well, it's a thought.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_15</link>
        <pubDate>Sat, 17 Feb 2024 09:45:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7152</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code class="lang-plaintext">&gt;&gt; type of spread [a b c]
== &amp;[antiform group]  ; or &amp;[splice], if e.g. &amp;[logic] narrows &amp;[antiform word]
</code></pre>
</blockquote>
</aside>
<p>I don't know if it's a good thought or not, but the narrowing could come from the idea that antform is an arity-2 parameterized type... which adds the subtype if applicable:</p>
<pre><code>&gt;&gt; type of spread [a b c]
== &amp;[antiform &amp;[group] #splice]

&gt;&gt; type of true
== &amp;[antiform &amp;[word] #logic]
</code></pre>
<p>And then:</p>
<pre><code>&gt;&gt; logic!
== &amp;[antiform &amp;[word] #logic]

&gt;&gt; logic! = type of true
== ~true~  ; anti
</code></pre>
<p>Maybe messy, but a definite improvement over saying you can't get the type of a logic.  :-/</p>
<p>I'm thinking when types appear as parameters to other types, they should be whole (decorations/block), just so it makes more sense to decompose.</p>
<pre><code>&gt;&gt; t: type of first ['1]
== &amp;[quoted &amp;[integer]]

&gt;&gt; all [t.1 = 'quoted, t.2 = integer!] then [print "quoted integer"]
quoted integer
</code></pre>
<p>Maybe.  I guess I'd have to see in practice how it panned out.</p>
<p>Only have vague ideas about how to practically implement this so it isn't dog slow, but it does seem like a positive direction.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_14</link>
        <pubDate>Sat, 17 Feb 2024 08:59:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7151</guid>
      </item>
      <item>
        <title>TEXT! vs. STRING!</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="612">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<h3>Category as member of Category is bad</h3>
<p>I've never liked the idea of naming categories and members of the category the same thing. Saying "STRING! is an ANY-STRING!" has a loop in it, just as "BLOCK! is an ANY-BLOCK!". Categories are supposed to be ways of talking about common properties, and when you name the member of the set the same as the set...you're sort of prohibiting anything being in the set.</p>
</blockquote>
</aside>
<p>I certainly do prefer Ren-C's choices here...</p>
<p><strong>Rebol2 / Red:</strong></p>
<pre><code> ANY-BLOCK!:
    [block! paren! path! lit-path! set-path! get-path! hash!]

 ANY-STRING!:
    [string! file! url! tag! email! ref!]
</code></pre>
<p><strong>Ren-C</strong></p>
<pre><code>ANY-ARRAY?:
    [block! group! (set-block!, set-group!, etc.)]

ANY-SEQUENCE?:
    [path! tuple! (set-path, set-tuple!, etc.)]

ANY-STRING?:
    [text! file! url! tag! email!]
</code></pre>
<p>But I just noticed that for whatever reason I never got around to changing ANY-WORD! to ANY-SYMBOL!, and I didn't remember the justification for not doing that.</p>
<p>Then I remembered that I'd considered there being a SYMBOL! type, which would be distinct from WORD! because it was only available in the non-sigil form, and could not be used in sequences.  This would be things like <strong><code>/</code></strong> or <strong><code>::</code></strong> or <strong><code>-&gt;</code></strong> or whatever.  You'd have to assign them like:</p>
<pre><code> [::]: func [...] [...]
 ; or
 set inside [] ':: func [...] [...]
 ; or
 set $ ':: func [...] [...]
</code></pre>
<p>I wavered and instead decided to try a generalized way of letting arbitrary words be legal, e.g. with spaces and such, but I think this is a dead end (and I'll write it up).  So that puts the SYMBOL! proposal back on the table.</p>
<p>(What it would actually probably be would be that ANY-SYMBOL? would be the class that included all words as well as this weird outlier, and it would be named something else...GLYPH! or RUNE! or something...)</p>
<p>Something about ANY-WORD isn't as bothersome anyway, because all members of the class have "word" in their name.  I don't hate it the way I hated ANY-BLOCK! describing GROUP! and BLOCK! (in fact, ANY-BLOCK! now describes BLOCK!, SET-BLOCK!, GET-BLOCK!, etc. so there's another instance of "it's okay to say ANY-XXX! if all members of the class are XXX")</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="612">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<h3>Need a name that spans WORD!, TAG!, SET-WORD!, ISSUE!...</h3>
<p>There has been great consternation over questions like "should ISSUE! be an ANY-STRING! or an ANY-WORD!". It changed from Rebol2 to R3-Alpha and chaos ensued. Fights over it raised a question in my mind: why aren't they all unified into one category?</p>
</blockquote>
</aside>
<p>This category exists, and it's now called (perhaps obviously) ANY-UTF8.</p>
<p>But ANY-STRING specifically covers only series types which can be mutable and have an index.  ISSUE! and URL! and EMAIL! do not, and this immutability avoids problems like:</p>
<pre><code> &gt;&gt; x: http://hostilefork.com

 &gt;&gt; type of x
 == &amp;[url]

 &gt;&gt; reverse x
 == moc.krofelitsoh//:ptth

 &gt;&gt; type of x
 == &amp;[url]

 &gt;&gt; clear x
 ==
</code></pre>
<p>So series operations aren't available on them, but you can pass them anywhere that ANY-UTF8 is accepted.</p> ]]></description>
        <link>https://forum.rebol.info/t/text-vs-string/612#post_3</link>
        <pubDate>Sat, 17 Feb 2024 07:50:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7150</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Hmm... I was just reminded that the nature of type predicates is such that they can only check against instances, it can't check for relationships between types described by the predicate.</p>
<p>So if you have a question like <em>"Hey, I have a type T. Is it in the category ANY-WORD?"</em> there's no way to know.</p>
</blockquote>
</aside>
<p>Hmm. Interesting point.</p>
<p>Although it does remind me of one of my suggestions above:</p>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Possibly, these type constraints may need to have their own internal representations, different to that of ordinary Rebol functions.</p>
</blockquote>
</aside>
<p>If that internal representation does something along the lines of storing the set of types directly, it would become easy to test if one predicate is a subset of another.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_13</link>
        <pubDate>Sat, 17 Feb 2024 07:04:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7149</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="9" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>we should focus more heavily on type constraints as the fundamental building blocks for types.</p>
</blockquote>
</aside>
<p>Hmm... I was just reminded that the nature of type predicates is such that they can only check against instances, it can't check for relationships between types described by the predicate.</p>
<p>So if you have a question like <em>"Hey, I have a type T.  Is it in the category ANY-WORD?"</em> there's no way to know.</p>
<p>Things like function specs and PARSE and such always have value instances to operate on, so it's not a problem there.  But it comes up in other code.</p>
<p>Maybe it suggests that functions like ANY-WORD? that can meaningfully be applied to either might need a refinement to help with that:</p>
<pre><code> &gt;&gt; any-word? first [x:]
 == ~true~  ; anti

 &gt;&gt; any-word?/type set-word!
 == ~true~  ; anti
</code></pre>
<p>This would avoid saturating the universe with duplicate functions like ANY-WORD-TYPE?.</p>
<p>It's relatively rare to need to do this, but it comes up sometimes...and it's something typesets could do that we can't do easily at present.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_12</link>
        <pubDate>Sat, 17 Feb 2024 07:00:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7148</guid>
      </item>
      <item>
        <title>Dropping the ANY-XXX! from (Some) Type Constraints?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>There was a slightly confusing aspect of historical Rebol where some typesets were named so that they looked just like a datatype:</p>
<pre><code>red&gt;&gt; help append
USAGE:
    APPEND series value

DESCRIPTION: 
    Inserts value(s) at series tail; returns series head. 
    APPEND is an action! value.

ARGUMENTS:
    series       [series! bitset! port!] 
    value        [any-type!] 
...
</code></pre>
<p>Here, we see SERIES! which is not named in a way that makes it obvious that it's not a fundamental type.  It's named the same as BLOCK! or WORD!.</p>
<p><span class="mention">@earl</span> and I agreed that this was a stumbling block, so we thought that ANY-SERIES! was a better name.  That way you wouldn't make the mistake of saying:</p>
<pre><code>if series! = type? x [...]
</code></pre>
<p>...and have it always fail.  You'd be cued by that ANY- to know that it was a set of many types.  (You still might think that you could use the equals operator to see if something was in a typeset and be wrong, but that's a different level).</p>
<p><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">But Ren-C has done away with typesets.</a>  They were too limited, and we now use arbitrary functions to do typechecking via predicates (with some various supporting optimizations so the common cases aren't horrifically slow).</p>
<p>So ANY-SERIES! is pretty much going away.  Most of the time you just use ANY-SERIES? (e.g. in a function spec or regular code), and then &amp;ANY-SERIES? if you're in something like a parse rule.</p>
<h2>
<a name="do-we-still-need-the-any-1" class="anchor" href="https://forum.rebol.info#do-we-still-need-the-any-1"></a>Do We Still Need The ANY-?</h2>
<p>I'm a little torn on the question of whether we need the ANY-.</p>
<p>Sometimes it's required (e.g. with ANY-WORD?) because WORD? means specifically "plain word".  (Note you'd use WORD! generally in type specs, though technically you can use either...performance should be identical).</p>
<p>But on ANY-SERIES? it's now a bit superfluous. And SERIES? is certainly shorter.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>It's not a slam dunk to take the ANY- off.  I kind of like the realization it gives you as a reader... "hey, we're talking about multiple things here"... and it makes you stop and consider "just how many series are there?  is ANY-SERIES? really what I mean?"</p>
<p>I kind of lean to keeping it.  And I prefer ANY-VALUE? to just VALUE? as well.</p>
<p>But it's definitely less important than it was.</p> ]]></description>
        <link>https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152#post_1</link>
        <pubDate>Sat, 17 Feb 2024 06:47:13 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7147</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Note that MATCH returns the value:</p>
</blockquote>
</aside>
<p>Ah, didn’t realise that. But it looks like you understood me anyway.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The existence of type blocks doesn't mean type constraints can't exist too. They may just be different parts of the solution.</p>
</blockquote>
</aside>
<p>Possibly… but I prefer to <a href="https://en.wikipedia.org/wiki/Occam's_razor" rel="noopener nofollow ugc">avoid multiplying entities</a> when possible. (“<em>A designer achieves perfection when there is nothing left to take away</em>”, and all that.) I dislike the idea of two kinds of ‘type-describing things’ if one suffices.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_11</link>
        <pubDate>Sat, 17 Feb 2024 06:09:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7146</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="9" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I especially like the idea of this invariant holding:</p>
<pre><code class="lang-plaintext">&gt;&gt; match type of x x
== ~true~ (for all x)
</code></pre>
<p>(Where <code>match</code> specifically takes a type constraint.)</p>
</blockquote>
</aside>
<p>Note that MATCH returns the value:</p>
<pre><code> &gt;&gt; match integer! 1
 == 1

 &gt;&gt; match integer! "abc"
 == ~null~  ; anti
</code></pre>
<p>Other than that (and the exception for null as <strong>match try type of x</strong>, where the result is a "heavy" then-triggering null)...yes, I'd agree with the invariant...</p>
<p>But I don't see a problem with MATCH being willing to take either a TYPE-BLOCK! (in which case it looks for exact equality of the type) or a type constraint (in which case it calls the function)...or to take a BLOCK! (in which case it assumes you want to treat it as you would a function spec block).</p>
<pre><code>&gt;&gt; match [even? text!] 2
== 2

&gt;&gt; match [even? text!] 1
== ~null~  ; anti

&gt;&gt; match [even? text!] "abc"
== "abc"
</code></pre>
<aside class="quote no-group" data-username="bradrn" data-post="9" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Indeed, TYPE-BLOCK!s make type constraints difficult (unions, intersections, etc.). Which is precisely why <a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2">my original suggestion</a> was that they might not be a good fit for Rebol, and we should focus more heavily on type constraints as the fundamental building blocks for types.</p>
</blockquote>
</aside>
<p>The existence of type blocks doesn't mean type constraints can't exist too.  They may just be different parts of the solution.</p>
<p>Historical Rebol had DATATYPE! and TYPESET!, and for the datatype purposes I'm thinking TYPE-BLOCK! may work, while for the typeset purposes the type constraints are used.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_10</link>
        <pubDate>Sat, 17 Feb 2024 05:40:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7145</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>With TYPE-BLOCK! being the sort of "declarative expanded types" there's still going to be desires for some way to do type constraints</p>
</blockquote>
</aside>
<p>Indeed, TYPE-BLOCK!s make type constraints difficult (unions, intersections, etc.). Which is precisely why <a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2">my original suggestion</a> was that they might not be a good fit for Rebol, and we should focus more heavily on type constraints as the fundamental building blocks for types.</p>
<p>That is to say: if we’re relying on a system of type constraints in any case, then it makes sense to me that TYPE OF should return a type constraint too. I especially like the idea of this invariant holding:</p>
<pre><code class="lang-plaintext">&gt;&gt; match type of x x
== ~true~ (for all x)
</code></pre>
<p>(Where <code>match</code> specifically takes a type constraint.)</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_9</link>
        <pubDate>Sat, 17 Feb 2024 05:25:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7144</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Then we could get rid of TYPE-WORD! and all the rest.</p>
</blockquote>
</aside>
<p>With TYPE-BLOCK! being the sort of "declarative expanded types" there's still going to be desires for some way to do type constraints, in the spirit of:</p>
<pre><code>parse [a: $b c] [some any-word!]
</code></pre>
<p>Decorating constraint functions is an avenue of accomplishing this:</p>
<pre><code>any-word!: &amp;any-word?  ; confusing to make it look like a datatype
parse [a: $b c] [some any-word!]

parse [a: $b c] [some &amp;any-word?]  ; coherent, fewer definitions, faster
</code></pre>
<p>One could say that it's PARSE's job to have a MATCH keyword when it means "do a constraint".  However, BLOCK!s have meanings already, and ACTIONs have meanings, so this is a bit dicey... where the MATCH combinator has to quote, which is not impossible but I think it's the wrong idea:</p>
<pre><code>parse [a: $b c] [some match [any-word?]]  ; BLOCK! usually means parse rule here
</code></pre>
<p>So I do not see type constraints as having a notation as something that needs to go away.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_8</link>
        <pubDate>Sat, 17 Feb 2024 04:58:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7143</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The direction of saying TYPE OF always returns a TYPE-BLOCK! and that it is kind of a "broad answer" that you can destructure into parts makes it seem like it could give a good baseline behavior</p>
</blockquote>
</aside>
<p>I tend to agree with this. Then we could get rid of TYPE-WORD! and all the rest.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But would the TYPE OF an animal and a book come back with some component of the TYPE-BLOCK! mentioning they're both objects?</p>
</blockquote>
</aside>
<p>I’m not quite sure what else it would come back with.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><em>None</em> of this has any design concept, and I'm certainly willing to borrow or steal from elsewhere if it can be made to work in the paradigm with everything else.</p>
</blockquote>
</aside>
<p>OCaml is probably the closest to these ideas that I’m aware of. It may be worth having a look at its <a href="https://dev.realworldocaml.org/classes.html" rel="noopener nofollow ugc">class types</a>.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>whether we should be writing <strong>switch kind of x</strong> everywhere instead of <strong>switch type of x</strong> for common code</p>
</blockquote>
</aside>
<p>On this point, it’s worth noting that ‘kind’ already has <a href="https://en.wikipedia.org/wiki/Kind_(type_theory)" rel="noopener nofollow ugc">a well-established meaning</a> in type theory. (Specifically, it’s the type of a type.) So it’s probably a good idea to choose some other word.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_7</link>
        <pubDate>Sat, 17 Feb 2024 04:49:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7142</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One thing that has nagged me is if when we ask for the fundamental "cell type" of something, if we should avoid using the word "TYPE" for that at all...</p>
<p>Maybe there's some bigger idea in an object/class system where TYPE is meaningful to say something more than "this is an object" but rather "this is a book", where you can ask also "is a book readable". Etc.</p>
</blockquote>
</aside>
<p>The direction of saying TYPE OF always returns a TYPE-BLOCK! and that it is kind of a "broad answer" that you can destructure into parts makes it seem like it could give a good baseline behavior... that if you ask for the TYPE OF two things, they won't be equal if they're not equivalent to the maximum level of specificity that is known.</p>
<p>I'm happy if this means--for example--that things with different quoting levels aren't considered as having the same type...or things at the same quoting level of different types aren't the same:</p>
<pre><code>&gt;&gt; (type of first [''a]) = (type of first ['''a])
== ~false~  ; anti

&gt;&gt; (type of first ['a]) = (type of first ['1])
== ~false~  ; anti
</code></pre>
<p>But you could pick this apart and somewhere in the type of both of them is the notion that they wrap words, and if that were interesting you could suss that out.  The information is there in the answer to TYPE OF.</p>
<p>If this extends, and there's a way that you ask an object that if it's a book if it's equal to an object that is an animal, that these wouldn't come back as equal either.</p>
<p>But would the TYPE OF an animal and a book come back with some component of the TYPE-BLOCK! mentioning they're both objects?</p>
<pre><code>&gt;&gt; type of book
== &amp;[book object]  ; or [object book] ?

&gt;&gt; type of animal
== &amp;[animal object]
</code></pre>
<p>Or is the fact that they're both objects not part of the answer to TYPE OF, but something you have to find out from a different test?</p>
<p>If object is what's parameterized, that would give you an easier time destructuring two things that answered the TYPE OF question to see if they're both objects.  But it suggests an object with no subclass would have to fill in that parameter as something like a blank (or quasivoid or whatever)</p>
<pre><code> &gt;&gt; type of {x: 10 y: 20}
 == &amp;[object ~]
</code></pre>
<p><em>None</em> of this has any design concept, and I'm certainly willing to borrow or steal from elsewhere if it can be made to work in the paradigm with everything else.</p>
<p>But it does impact questions like:</p>
<pre><code>switch type of x [
    block! [...]
    object! [...]   ; does this mean only plain &amp;[object ~] ?
]
</code></pre>
<p>Just some rambling there, but it points to my sticking point of whether we should be writing <strong>switch kind of x</strong> everywhere instead of <strong>switch type of x</strong> for common code.  But <em>I don't like that being common</em>, so I really want a way for <strong>type of</strong> to be the go-to.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_6</link>
        <pubDate>Sat, 17 Feb 2024 04:38:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7141</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>It’s not necessarily about ‘good’ or ‘bad’, as such… I just don’t really see any alternatives, if everything is a constraint.</p>
</blockquote>
</aside>
<p>The direction of the proposal does accommodate either of:</p>
<pre><code> &gt;&gt; type of false
 == &amp;[logic]

 &gt;&gt; type of false
 == &amp;logic?
</code></pre>
<p>I'm leaning to think that TYPE OF always gives back a TYPE-BLOCK! (or null, for null input, if you indicate that's intentional).</p>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I like the idea of structuring, but it seems to go against conventional Rebol style.</p>
</blockquote>
</aside>
<p>Coding style and in dialects, yes.  But this is more on the "data" side of the spectrum than it is "code".  You won't be writing it out in source very much, I don't think.  Just analyzing it.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_5</link>
        <pubDate>Sat, 17 Feb 2024 04:06:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7140</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It's tough here though to assume the arity of each type is known</p>
</blockquote>
</aside>
<p>Why do you say this? I like the idea of structuring, but it seems to go against conventional Rebol style.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If the answer from TYPE OF came back immutable, then magic might be able to compress that behind the scenes.</p>
</blockquote>
</aside>
<p>I agree that the output of TYPE OF should be immutable.</p>
<p>(Though note that in the paragraph to which you replied, I was referring to the idea of generating new constraints at runtime, rather than using TYPE-BLOCK!s.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The idea of making terminal types equivalent to their predicates might be good or bad. Don't know.</p>
</blockquote>
</aside>
<p>It’s not necessarily about ‘good’ or ‘bad’, as such… I just don’t really see any alternatives, if everything is a constraint.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_4</link>
        <pubDate>Sat, 17 Feb 2024 03:45:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7139</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>From a Haskeller’s perspective, this is the obvious solution. <code>'a</code> could be <code>&amp;[quoted word]</code>, and <code>spread [1 2 3]</code> could be <code>&amp;[isotope group]</code> (or even <code>&amp;[isotope group integer]</code>), and so on. The elements of these series could simply be ordinary words, left unevaluated and unbound: one could test <code>'isotope = first type of spread [a b c]</code>, and so on.</p>
</blockquote>
</aside>
<p>Prior to antiforms, it was the case that TYPE-BLOCK!s were used, though it attempted to compress by putting the quote levels on the word in the block:</p>
<pre><code>&gt;&gt; type of first [a]
== &amp;[word]

&gt;&gt; type of first ['a]
== &amp;['word]

&gt;&gt; type of first [''a]
== &amp;[''word]
</code></pre>
<p>Even that starts to incur performance penalties when you ask for a type.  Because it's synthesizing an array on the spot to answer the question--not a huge deal, but it's something.  <em>(The only "stock" blocks were the unquoted forms, &amp;[word] etc.)</em></p>
<p>When quasiforms/antiforms came along, it ran afoul of representation questions.  Weird answers like having to do meta forms inside the block:</p>
<pre><code>&gt;&gt; type of first [(a)]
== &amp;['group]

&gt;&gt; type of first [''(a)]
== &amp;['''group]

&gt;&gt; type of spread [a b c]
== &amp;[~group~]

&gt;&gt; type of first [~(a)~]
== &amp;['~group~]
</code></pre>
<p>That was rejected as too obfuscating.  (Meta forms work all right for things like storing arbitrary values in PACKs, but the above sucks.)</p>
<p>With my performance-blinders on, I don't recall if I ever suggested attacking this via plain words that convey parameterized types as per your Haskell-like suggestion:</p>
<pre><code>&gt;&gt; type of first [(a)]
== &amp;[group]

&gt;&gt; type of first [''(a)]
== &amp;[quoted quoted group]

&gt;&gt; type of spread [a b c]
== &amp;[antiform group]  ; or &amp;[splice], if e.g. &amp;[logic] narrows &amp;[antiform word]

&gt;&gt; type of first [~(a)~]
== &amp;[quasi group]
</code></pre>
<p>It's tough here though to assume the arity of each type is known, if we imagine this generalizing it might be better to have it structured, where only terminal types aren't in blocks</p>
<pre><code>&gt;&gt; type of first [''(a)]
== &amp;[quoted [quoted group]]

&gt;&gt; type of quote matrix
== &amp;[quoted [matrix 10x10]]
</code></pre>
<p>Which adds another performance penalty to grapple with, but it seems important if you're going to say that array destructuring is the method of type destructuring.</p>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Possibly, these type constraints may need to have their own internal representations, different to that of ordinary Rebol functions.</p>
</blockquote>
</aside>
<p>If the answer from TYPE OF came back immutable, then magic might be able to compress that behind the scenes.  It only would work if it wasn't assumed you could change one reference to the result of TYPE OF and see that in another place.</p>
<pre><code>&gt;&gt; t: type of first ['a]
== &amp;[quoted word]

&gt;&gt; t2: t
== &amp;[quoted word]

&gt;&gt; take t
== quoted

&gt;&gt; t2
== &amp;[word]  ; only if cells for t and t2 variables point to common allocation   
</code></pre>
<p>To point to a common allocation, there has to be an allocation, which subverts some levels of optimization (at least, when one is trying to be competitive with code that does no allocations).</p>
<p>For a similar problem that's been solved, see: <a href="https://forum.rebol.info/t/path-and-tuple-compression-explained/1008" class="inline-onebox">PATH! and TUPLE! compression, explained</a></p>
<h2>
<a name="i-may-like-the-parameterized-type-direction-1" class="anchor" href="https://forum.rebol.info#i-may-like-the-parameterized-type-direction-1"></a>I May Like The Parameterized Type Direction</h2>
<p>I was already aiming to flip things back so that the &amp;word and &amp;tuple and &amp;path could be used as prettier impromptu type constraints:</p>
<pre><code>parse [1 3 5] [some &amp;odd?]

parse [...] [some &amp;tester?/refinement]

parse [...] [some &amp;obj.tester?]
</code></pre>
<p>I think this needs to be done regardless.  But if it is done, then switching around to TYPE-BLOCK! for the parameterized types would be available.</p>
<p>The idea of making terminal types equivalent to their predicates might be good or bad.  Don't know.</p>
<pre><code>&gt;&gt; group!
== &amp;group?

&gt;&gt; type of first [''(a)]
== &amp;[quoted [quoted &amp;group?]]
</code></pre>
<p>Certainly some food for thought here.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_3</link>
        <pubDate>Sat, 17 Feb 2024 03:24:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7138</guid>
      </item>
      <item>
        <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Or maybe TYPE can be parameterized:</p>
<pre><code class="lang-plaintext"> &gt;&gt; type of matrix
 == &amp;[matrix 10x10]
</code></pre>
</blockquote>
</aside>
<p>From a Haskeller’s perspective, this is the obvious solution. <code>'a</code> could be <code>&amp;[quoted word]</code>, and <code>spread [1 2 3]</code> could be <code>&amp;[isotope group]</code> (or even <code>&amp;[isotope group integer]</code>), and so on. The elements of these series could simply be ordinary words, left unevaluated and unbound: one could test <code>'isotope = first type of spread [a b c]</code>, and so on.</p>
<p>But I’m not convinced a Haskell-like type system is a great fit for Rebol. The biggest issue is that we want to have union and intersection types, and there’s no easy way to integrate them into a system like this. One could possibly make it more ergonomic using type synonyms, but then you’d have to handle those as well when testing types, and it becomes more complicated than it should.</p>
<p>I much prefer your alternative suggestion of making constraint functions fundamental… but with some small changes. If <code>type of ''a</code> is <code>&amp;quoted?</code>, then I feel that <code>type of spread [a b]</code> should be <code>&amp;isotope?</code>. But then one could have other basic predicates too. I think it’s particularly important to have a set of types <code>&amp;any-word?</code>, <code>&amp;any-block?</code>, and so on, which would match ‘under’ isotopes and quotes (and other sigils). From these, it should be possible to create other types by combining the existing predicates: for instance, a splice would be a type which is both <code>&amp;isotope?</code> and <code>&amp;any-group?</code>.</p>
<p>This does leave me uncertain about precisely how those combinations should be accomplished. The best idea I can come up with is to allow constraints to take arguments, like so:</p>
<pre><code class="lang-plaintext">&gt;&gt; splice!: &amp;all [&amp;isotope? &amp;any-group?]
== &amp;all [&amp;isotope? &amp;any-group?]

; or equivalently:
&gt;&gt; splice!: &amp;all [isotope! any-group!]
== &amp;all [&amp;isotope? &amp;any-group?]

&gt;&gt; match splice! spread [1 2 3]
== ~true~

&gt;&gt; match splice! [1 2 3]
== ~false~

; another demonstration, with more combinators:
&gt;&gt; series!: &amp;all [
     &amp;not isotope!
     &amp;any [any-block! any-group! any-path! any-tuple! string!]
   ]
== &amp;all [&amp;not &amp;isotope? &amp;any [&amp;any-block? &amp;any-group? &amp;any-path? &amp;any-tuple? &amp;any-string?]]

&gt;&gt; match series! "foobar"
== ~true~

&gt;&gt; match series! '[a b c]:
== ~true~

&gt;&gt; match series! spread [1 2 3]
== ~false~
</code></pre>
<p>I’m not sure how feasible this is to implement, though. As I recall, the key innovation which allowed constraints-as-types was implementing them as <a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">intrinsics</a>. Is there some way of getting these combinators <code>&amp;all</code>/<code>&amp;any</code>/<code>&amp;not</code> to construct new intrinsics at runtime? I really don’t know. Possibly, these type constraints may need to have their own internal representations, different to that of ordinary Rebol functions.</p> ]]></description>
        <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151#post_2</link>
        <pubDate>Sat, 17 Feb 2024 02:20:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7137</guid>
      </item>
      <item>
        <title>Upcoming Datatype $WORD... What Will It Mean?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="10" data-topic="2146">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Currently, there is only one exception to that trend: TYPE-*, which has no particular relationship to these operations, but can modify other datatypes nonetheless. And it shows, in that the usage of TYPE-GROUP! and TYPE-BLOCK! seems fairly ad-hoc, in that it’s hard to predict from the types themselves.</p>
</blockquote>
</aside>
<p>I will willingly admit/shout that there is a whole lot of nebulous murk regarding the question of datatypes, and I am extremely open to suggestions on what to do better.</p>
<p>I made a new thread where you can solve it:</p>
<p><a href="https://forum.rebol.info/t/datatype-ugliness-less-ugly-than-history-but-can-we-do-better/2151" class="inline-onebox">Datatype Ugliness: Less Ugly Than History, But Can We Do Better?</a></p> ]]></description>
        <link>https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146#post_11</link>
        <pubDate>Fri, 16 Feb 2024 23:30:28 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7136</guid>
      </item>
  </channel>
</rss>

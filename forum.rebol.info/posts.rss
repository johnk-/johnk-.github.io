<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision ü§π</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1786">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>(Makes me think of the <a href="https://en.wikipedia.org/wiki/Conservation_status">species extinction risk scale</a>. Sure, the source code is on GitHub, and the topic list of this forum seems to be on the Internet Archive...but if you click through to individual pages there's nothing about the post contents. Should we do a scrape of the data here and put it elsewhere?)</p>
</blockquote>
</aside>
<p>I couldn't find something here and so I did a google site search to see if it was better and found...</p>
<p>no hits!</p>
<p><strong><a href="https://www.google.com/search?q=site%3Aforum.rebol.info"><code>Google results for site:forum.rebol.info</code></a></strong></p>
<p>I don't think this is all bad, as the plan is re-launching the content under a new domain "when it's ready".  I'm okay with being under the radar until then.  And hey--it keeps one from worrying too much about keeping old <code>forum.rebol.info</code> links working.</p>
<p><em>--nevertheless--</em> it is a little bit unsettling in the sense that there are plenty of inbound links.  <em>Zero</em> Google indexing is surprising.  I think the quality of content is better than many other places (personally).</p>
<p>Not necessarily a particular action item--not trying to get found yet.  But definitely a call to arms, and praise for <a class="mention" href="/u/johnk">@johnk</a> making the valiant preservation effort!</p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/8</link>
        <pubDate>Mon, 09 May 2022 22:43:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5825</guid>
      </item>
      <item>
        <title>Key Exchange Methods in Ren-C</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Having given a summary of <a href="https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808/">Checksums and Secure Hashes</a>, I thought I'd follow up with a quick description of something you're likely not as familiar with: <strong>Key Exchanges</strong>.</p>
<p>There's old quote I like (but can't find a source for):</p>
<blockquote>
<p>"The shared secret is capital.  We may spend it or squander it."</p>
</blockquote>
<p>An example of taking advantage of a shared secret is when people want to share an encrypted .ZIP file.  If you and your friend both know the encryption password that no one else knows...then you could put the file on a public server for your friend to download.  If you trust the encryption, the fact it was public would not matter.</p>
<p><strong>But what if the situation is that your friend has a password that only they know... and you have a password that only you know?</strong>  That wouldn't seem to help with the .ZIP file scenario, because it expects the same password to decrypt as was used to encrypt it.</p>
<p>Key Exchange is a way of taking your individual "passwords" and coming to an agreement on a third "password" that only the two of you know.  Amazingly enough, you can carry out the conversation where you establish the shared password in public.</p>
<h2>Creating one Shared Secret from two Non-Shared Secrets</h2>
<p>For educational purposes, people use paint-mixing as an analogy for key exchange.  It's really "multiplying big prime numbers" instead of mixing paint, but it's visual and easy to see.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png" data-download-href="https://forum.rebol.info/uploads/default/184fa9035c24ffa1250e324b61acaa3915f7757e" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_345x500.png" alt="image" data-base62-sha1="3t485Do7kYfAw6HMsMv5klePtsq" width="345" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_345x500.png, https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png 1.5x, https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">480√ó695 28 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>This assumes everyone in the world has some kind of weird "common paint".  This paint isn't white (because if you mixed it with something that would be too easy to guess at the precise shade you had mixed it with).  And it isn't black (because mixing might just get you something too dark to measure well).</p>
<p>But the key point to absorb is what the diagram says: <strong>we assume that mixture separation is expensive</strong>.  Once you've mixed the common paint with your secret color, it produces a new shade that no one else knows how to make exactly.</p>
<p>When you and your friend exchange your mixtures you cleverly go to your private lairs and each add your secret color to the other's mixture.  <strong>Now both of you have the same weird color, and this is a secret you share.</strong></p>
<h2>Ren-C Supports Diffie-Hellman Key Exchange</h2>
<p>I oversimplified this by saying you each start with a "password"...because that made it sound like you could just pick a phrase out of your head.  In reality, choosing your secret involves some tricky math...to make sure your secret paint color is a <em>good</em> secret paint color.  You don't pick these--you ask the computer to generate it.</p>
<p>To get the ball rolling, you need to specify what kind of "common paint" to use.  You make that by picking two suitable prime numbers, a modulus and a base.  Then you can ask for a unique random secret to be generated.</p>
<p>For the sake of education, I've made it possible to use <em>relatively bad</em> paint mixes with the /INSECURE refinement.  It won't allow numbers that are so broken the process won't work (for instance: non-primes, or primes that don't meet the basic requirements of the algorithm).  This lets you work with small enough numbers that you can see for yourself what's going on more easily.</p>
<p>So let's use a modulus of 9 and a base of 3:</p>
<pre><code>&gt;&gt; mine: dh-generate-keypair/insecure #{09} #{05}
== make object! [
    modulus: #{09}
    generator: #{05}
    private-key: #{07}
    public-key: #{05}
]

&gt;&gt; theirs: dh-generate-keypair/insecure #{09} #{05}
== make object! [
    modulus: #{09}
    generator: #{05}
    private-key: #{05}
    public-key: #{02}
]
</code></pre>
<p>So privately, my secret is 7... and their secret is 5.  But we want to come to an agreement on a new number while only sharing with the public my "mixture" of 5 and their mixture of 2.</p>
<pre><code>&gt;&gt; my-shared: dh-compute-secret mine theirs.public-key
== #{02}

&gt;&gt; their-shared: dh-compute-secret theirs mine.public-key
== #{02}
</code></pre>
<p>So here you see each of us could come to a common agreement of 2.  You can follow through the math on the <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Wikipedia page</a> if you want...but it's enough to know that it works.</p>
<p>What makes for a good (big!) modulus and base to use?  You don't really need to come up with them yourself, although <a href="https://security.stackexchange.com/a/103924">there are algorithms for it</a>.  There are papers that publish some good choices--and we should probably provide a way to default to well-known ones, like maybe accept either an object or an ISSUE!</p>
<pre><code>&gt;&gt; dh-generate-keypair #RFC-3526
; ...or...
&gt;&gt; dh-generate-keypair make object [base: ..., modulus: ...]
</code></pre>
<p>But the main thing to know is that <strong>both sides have to agree on the "common paint" to use</strong>, in order to come to the same conclusion.  So <code>dh-compute-secret</code> won't work unless the same numbers were used here.</p>
<h2>We Also Support Elliptic Curve Key Exchange (ECHDE)</h2>
<p>Modern Internet Transport Security has moved on from traditional Diffie Hellman to trickier math.  But the premise is the same.</p>
<p>In the interface, we only support two "common paints" for this method: "secp256r1" and "curve25519".  There's no option for small answers here:</p>
<pre><code>&gt;&gt; mine: ecc-generate-keypair 'curve25519
== make object! [
    public-key: make object! [
        x: #{121413C34DC265025F24CBEBBA6065B9
             75F1BFA6E493D07A0F4776FAE03DC245}
        y: #{00000000000000000000000000000000
             00000000000000000000000000000000}
    ]
    private-key: #{610A8D99A72500B3A2E8A1FD714FA412
                   17F0A0EA5EDFC9CFBDAE0425E199DC70}
]

&gt;&gt; theirs: ecc-generate-keypair 'curve25519
== make object! [
    public-key: make object! [
        x: #{10D65366D8C9229591C99903D3B5EB0F
             57709AD27E37989E4782050D2B9B2B93}
        y: #{00000000000000000000000000000000
             00000000000000000000000000000000}
    ]
    private-key: #{7C3262BF6028B049EEDC6C37E37A8261
                   EA4DF31F16E4D534D92A7EF11D974618}
]
</code></pre>
<p>But it works the same way; you come to the same conclusion when combining your partner's public portion with your private portion:</p>
<pre><code>&gt;&gt; my-secret: (
    ecdh-shared-secret 'curve25519 mine.private-key theirs.public-key
)
== #{E27891074A60250580B8F2C7CB2448A9AA491C97161D7C8D381348D90E438025}

&gt;&gt; their-secret: (
    ecdh-shared-secret 'curve25519 mine.private-key theirs.public-key
)
== #{E27891074A60250580B8F2C7CB2448A9AA491C97161D7C8D381348D90E438025}

&gt;&gt; my-secret = their-secret
== #[true]
</code></pre>
<h2>Would Average Users Ever Need Key Exchange Functions?</h2>
<p>Right now, the main reason most people would care whether the language has these key exchanges is because without them you can't do TLS.  So no reading or writing over HTTPS.</p>
<p>You really only need key exchanges when protocols are trying to establish private channels of communication.  So notably, some cryptographic protocols (like Bitcoin) don't need key exchanges...because they're carrying out their work in public.</p>
<ul>
<li>
<p><strong>It would be neat if we could democratize the creation of cryptographic protocols</strong>.  I think giving people easier and more transparent access to these kinds of things could foster some grassroots innovation, where people would build <em>exactly the security they needed</em> into a program's design...no more and no less.</p>
<ul>
<li>This would stand in contrast to today's methods, where "security" is accomplished by standing on top of a mountain of protocols (using a literal zoo of cryptographic algorithms) to tunnel and log in somewhere that they are "safe"...and putting more data than they need to in that place.</li>
</ul>
</li>
<li>
<p><strong>But even "simple" cryptography is tricky to reason about, and people are lazy.</strong>  I myself am pretty guilty of doing things like falling back on my GitHub password and resetting my keys instead of doing a good job of filing them in safe places.</p>
<ul>
<li>Convincing people their programs should be "organic and locally sourced"... by tailor-making the protocols and asking their users to keep track of files, is going to be a hard sell to those who are happy to use OAuth and leave this all up to Google.</li>
</ul>
</li>
</ul>
<p>So pessimistically speaking, I don't know that we're going to be able to market easy-to-use key exchange to anyone as a killer feature.  It's a nice thought, and I certainly like having it available to tinker with.  But I'd be surprised if anyone reading this has an idea how to use it in something they're working on.</p> ]]></description>
        <link>https://forum.rebol.info/t/key-exchange-methods-in-ren-c/1809/1</link>
        <pubDate>Mon, 09 May 2022 18:20:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5824</guid>
      </item>
      <item>
        <title>LOGIN Magazine Historical Covers</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>As good a place as any to put a link to <a href="https://amr.abime.net/issue_274">Amiga Format #118</a>, the first I saw mention of 'Rebol'. I may even have that issue kicking around.</p> ]]></description>
        <link>https://forum.rebol.info/t/login-magazine-historical-covers/1803/2</link>
        <pubDate>Mon, 09 May 2022 17:35:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5823</guid>
      </item>
      <item>
        <title>JS testing with Cypress.io</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Looking at <a href="https://www.lambdatest.com/blog/cypress-test-automation-framework/">how Cypress works</a>, it is essentially a proxy server.</p>
<p>So when you ask for <code>http://hostilefork.com/media/shared/replpad-js</code>, it fires up a browser that is actually directed at <code>http://localhost:8000/cypress/media/shared/replpad-js</code> (or whatever).</p>
<p>What the proxy does is add code related to testing.  So by definition, it doesn't do anything we couldn't do ourselves by adding JavaScript into the page.</p>
<p>This means it can't be used to test any "meta" things--like how the page reacts to opening a new browser tab, or interacting across IFRAMEs.</p>
<p>But presumably (?) their injected JavaScript is tricky and tailored, for transmitting keydowns and keyups in a somewhat "realistic" way to mimic what actually happens in browsers...and it may wind up being faster and simpler to use.</p>
<p>My current technique talks to the Firefox webdriver directly (without using the Selenium layer, that abstracts all the webdrivers for all the browsers).  When I made it I figured it was better than nothing, and it has been so...but it is certainly slower than we'd like.</p>
<p>It's certainly worth a shot to see if this is a better answer that covers the cases we'd be interested in.</p> ]]></description>
        <link>https://forum.rebol.info/t/js-testing-with-cypress-io/1778/2</link>
        <pubDate>Mon, 09 May 2022 14:14:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5822</guid>
      </item>
      <item>
        <title>Checksums and Secure Hashes in Ren-C</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I thought I'd write up a quick post about algorithms that take in a bunch of bytes--like a BINARY!--and produce a (usually) shorter "fingerprint" of that data.</p>
<ul>
<li>
<p>It's not hard to make an <em>insecure</em> hash...like taking the first couple of letters of a string: <code>"DICKENS" =&gt; DI</code>.  That might be useful if you're trying to divide book authors into drawers of an old-fashioned library card catalog.</p>
</li>
<li>
<p>But it's easy to find another string that would make the same "DI" fingerprint, like "DIABOLICAL" or "DIR^/FORMAT C:"</p>
</li>
<li>
<p>If you were using a fingerprint to trust something was what it was supposed to be, the easiness of generating these "collisions" is a liability!! <img src="https://forum.rebol.info/images/emoji/twitter/skull_and_crossbones.png?v=9" title=":skull_and_crossbones:" class="emoji" alt=":skull_and_crossbones:"></p>
</li>
<li>
<p>Secure hashes do complicated "one-way functions" in math to make it <em>really hard</em> on today's computers to fabricate any binary sequence--even garbage--that will give you the same fingerprint as any other input.</p>
</li>
</ul>
<p>You've certainly seen web pages that redirect you off to download a file, but beforehand give you some bytes of what the file should securely hash to.  <sub>(And you've probably never checked to make sure they match.)</sub></p>
<h2>If the Fingerprint is Shorter than the data, <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">COLLISIONS EXIST!</a>
</h2>
<p>You obviously can't give every 500mb file in the universe a unique fingerprint that's 32-bits, 128-bits, 512-bits, 2048-bits etc.</p>
<p>So the concept behind a secure hash is just supposed to be you can't find a collision until we're all dead and no one cares.  Less grimly: we might pair a hash with an expiration date to say not to trust a hash after a very conservative guess at how long it would take for computers to advance enough to break it.</p>
<p>When this hope falls apart (e.g. if any researcher can show two inputs that generate the same fingerprint) it's generally considered that the "secure" part of that hash is broken...for the purposes of whatever time-bubble you're living in.</p>
<h2>We Have Four Secure Hashes in the Box Right Now...</h2>
<p>It shouldn't be surprising that longer fingerprints correlate with being harder to find collisions:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'md5
== #{3717A787E2F16310EA51DC0308E88803}  ; considered vulnerable

&gt;&gt; checksum/method {DICKENS} 'sha1
== #{DFE5DD61B2B19C319DBC4F44328CDF8D24366F88}  ; considered vulnerable

&gt;&gt; checksum/method {DICKENS} 'sha256
== #{52A095CF1F0319EF44FF9134AAD2EF5E2BFE1A48307DCB0AD0408F1CE393C950}

&gt;&gt; checksum/method {DICKENS} 'sha512
== #{
E8DBC26DE28FAA1BC2A6A3E1BC6DD22C1ECB3FD0D5FCBBFB69BC63C6AAC6A9CE
FB76294EFFB0522D4C90A5E5829233FC5BC5B811AE6684A6EA632ECB3FF88DA1
}

&gt;&gt; checksum/method {DICKENS} 'ripemd160         ; bitcoin uses this one
== #{ADC86945BE4CEF31F0CFCAF66775E1DA5160F877}  ; ...no one knows why
</code></pre>
<p>But longer isn't <em>intrinsically</em> better...there might be a weakness to exploit in the method used by a longer hash which isn't present in shorter ones.  However, a bunch of mathematicians look at this stuff and we would generally hope that we'd be getting what we pay for--more bytes meaning more security (unless they're from the NSA and trying to punk us).</p>
<h2>We Also Have Three <em>Insecure</em> Hashes...</h2>
<p>These are fine when you're doing something that is not supposed to be protecting against adversarial attacks.  They're smaller to store and much cheaper to calculate...but it's trivial to find other input data that would produces the same 32-bit result:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'crc32
== #{FB05F0BC}  ; used to very gzip files (among other places)

&gt;&gt; checksum/method {DICKENS} 'adler32
== #{0202D207}  ; used by zlib deflate and inflate
</code></pre>
<p>If you want a <em>really</em> cheapskate insecure checksum, we include the one that is in TCP packets on the internet:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'tcp
== #{CA32}
</code></pre>
<hr>
<blockquote>
<p><strong>Fun Corner</strong>: Let's find a collision!</p>
<pre><code>&gt;&gt; until [
    string: copy {}
    repeat (random 10) [append string make char! 64 + random 26]
    #{CA32} = checksum/method string 'tcp
]
== #[true]

&gt;&gt; print string
AOGTDDN

&gt;&gt; checksum/method {AOGTDDN} 'tcp
== #{CA32}
</code></pre>
<p>That wasn't so hard, but... if you can find collisions for any of the <em>secure</em> hashes above (even the relatively-weak MD5 or SHA1) <em>you will be famous!</em></p>
</blockquote>
<h2>We're Primed To Make <strong>STREAMING</strong> Secure (or Insecure) Hashes !</h2>
<p>R3-Alpha did not have fancy modern hashes like SHA256 or SHA512.  But also the code it used was copy-pasted out of a library that required you to have all the data at once.</p>
<p>Hence if you have a multi-gigabyte DVD .iso file that you want to checksum, you have to read that into a multi-gigabyte BINARY! to process it.</p>
<p>But since Ren-C is leveraging the cryptography of the <a href="https://github.com/Mbed-TLS/mbedtls">pure C library known as mbedTLS</a>, the foundations are there to stream in little blobs at a time...and it is generalized so we can just flip on or off any hashes we care about.  <a href="https://forum.rebol.info/t/what-is-a-port/617/5">If we only knew how to express streaming with PORT!s (or whatever)</a>.</p>
<p>And also, the CRC32 and ADLER32 algorithms we have "for free" by including Zlib are now set up in a way that the insecure hashes can be streamed too.</p>
<h2>
<img src="https://forum.rebol.info/images/emoji/twitter/globe_with_meridians.png?v=9" title=":globe_with_meridians:" class="emoji" alt=":globe_with_meridians:"> <em>"How Does This Tie Into The Web Repl Story"?</em> <img src="https://forum.rebol.info/images/emoji/twitter/globe_with_meridians.png?v=9" title=":globe_with_meridians:" class="emoji" alt=":globe_with_meridians:">
</h2>
<p>I really want to have a laser focus on whether investing effort into something is going to be something that pays off or not, and to me a part of that payoff question is "will people using the web build care".</p>
<p><strong>Right now the web build does not include the CHECKSUM function at all.</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>That is too bad, because I do believe that putting secure hashes into the hands of users at the Web Repl prompt (as well as other basic crypto parts) would be a great playground.</p>
<p>But it would be rather heavyweight to push secure hashing into the default .wasm being pulled down on every site if it didn't use it.  This is why I really want to get "Wasm extensions" working, that can be dynamically loaded.  There's something called "side modules" that I have meant to explore but haven't.</p>
<p>Anyway, I hope this summary gives a little insight into where this is at, and perhaps educational for those who don't have experience with the difference between secure/insecure hashing.</p> ]]></description>
        <link>https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808/1</link>
        <pubDate>Mon, 09 May 2022 04:04:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5821</guid>
      </item>
      <item>
        <title>Dropping RC4 Support from the Crypto Extension</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I pretty sure no one out there is using it, but the RC4 cipher has been deprecated for a pretty long time now.  Per Wikipedia:</p>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Cryptography">cryptography</a>, <strong>RC4</strong> (Rivest Cipher 4 also known as <strong>ARC4</strong> or <strong>ARCFOUR</strong> meaning Alleged RC4, see below) is a <a href="https://en.wikipedia.org/wiki/Stream_cipher">stream cipher</a>. While it is remarkable for its simplicity and speed in software, multiple vulnerabilities have been discovered in RC4, rendering it insecure.</p>
</blockquote>
<p>The insecurity of RC4 led the IETF to <a href="https://tools.ietf.org/html/rfc7465">prohibit RC4 for TLS use in 2015</a></p>
<p>However, the original cryptography code (mostly from AxTLS) had an RC4 function, and it was in mbedTLS 2.  So I went ahead and kept it working.</p>
<p>It is now dropped from mbedTLS 3.  So in the scheme of things, time to let it go.</p>
<h2>Code Being Dropped</h2>
<p>The files arc4.h and arc4.c from mbedTLS are now gone, and this was the crypt module code for supporting it:</p>
<pre><code>static void cleanup_rc4_ctx(const REBVAL *v)
{
    struct mbedtls_arc4_context *ctx
        = VAL_HANDLE_POINTER(struct mbedtls_arc4_context, v);
    mbedtls_arc4_free(ctx);
    FREE(struct mbedtls_arc4_context, ctx);
}


//
//  export rc4-key: native [
//
//  "Encrypt/decrypt data (modifies) using RC4 algorithm."
//
//      return: [handle!]
//      key [binary!]
//  ]
//
REBNATIVE(rc4_key)
//
// !!! RC4 was originally included for use with TLS.  However, the insecurity
// of RC4 led the IETF to prohibit RC4 for TLS use in 2015:
//
// https://tools.ietf.org/html/rfc7465
//
// So it is not in use at the moment.  It isn't much code, but could probably
// be moved to its own extension so it could be selected to build in or not,
// which is how cryptography methods should probably be done.
{
    CRYPT_INCLUDE_PARAMS_OF_RC4_KEY;

    struct mbedtls_arc4_context *ctx = TRY_ALLOC(struct mbedtls_arc4_context);
    mbedtls_arc4_init(ctx);

    REBSIZ key_len;
    const REBYTE *key = VAL_BINARY_SIZE_AT(&amp;key_len, ARG(key));
    mbedtls_arc4_setup(ctx, key, key_len);

    return Init_Handle_Cdata_Managed(
        D_OUT,
        ctx,
        sizeof(struct mbedtls_arc4_context),
        &amp;cleanup_rc4_ctx
    );
}


//
//  export rc4-stream: native [
//
//  "Encrypt/decrypt data (modifies) using RC4 algorithm."
//
//      return: &lt;none&gt;
//      ctx "Stream cipher context"
//          [handle!]
//      data "Data to encrypt/decrypt (modified)"
//          [binary!]
//  ]
//
REBNATIVE(rc4_stream)
{
    CRYPT_INCLUDE_PARAMS_OF_RC4_STREAM;

    REBVAL *data = ARG(data);

    if (VAL_HANDLE_CLEANER(ARG(ctx)) != cleanup_rc4_ctx)
        rebJumps ("fail [{Not a RC4 Context:}", ARG(ctx), "]");

    struct mbedtls_arc4_context *ctx
        = VAL_HANDLE_POINTER(struct mbedtls_arc4_context, ARG(ctx));

    REBVAL *error = nullptr;

    REBSIZ length;
    REBYTE *output = VAL_BINARY_SIZE_AT_ENSURE_MUTABLE(&amp;length, data);
    const REBYTE *input = output;
    IF_NOT_0(cleanup, error, mbedtls_arc4_crypt(
        ctx,
        length,
        input,  // input "message"
        output  // output (same, since it modifies)
    ));

  cleanup:
     if (error)
        rebJumps ("fail", error);

    return rebNone();
}
</code></pre>
<p>...and here is the very basic test, also being removed...</p>
<pre><code>ctx: rc4-key as binary! "Deprecated Algorithm"
data: as binary! "But Implemented Anyway"
rc4-stream ctx data
data = #{0C4E2F3BD157EA7214C33F280BE4D9DF1DFB580563A6}</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/dropping-rc4-support-from-the-crypto-extension/1807/1</link>
        <pubDate>Mon, 09 May 2022 01:32:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5820</guid>
      </item>
      <item>
        <title>About the Cryptography category</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Discussion of things related to cryptography, which includes low level primitives (ciphers, hashes, and key exchange) as well as higher-level protocols such as TLS.</p> ]]></description>
        <link>https://forum.rebol.info/t/about-the-cryptography-category/1806/1</link>
        <pubDate>Mon, 09 May 2022 01:11:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5819</guid>
      </item>
      <item>
        <title>REPL Querying</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>It might be worthwhile to take some inspiration from this:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/ellie/atuin" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://opengraph.githubassets.com/dca1958aebeb424b5526f3fa3c903c51716ab4f22eb7cd64a50259c3d4288398/ellie/atuin" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/ellie/atuin" target="_blank" rel="noopener">GitHub - ellie/atuin: üê¢ Magical shell history</a></h3>


  <p><span class="label1">üê¢ Magical shell history. Contribute to ellie/atuin development by creating an account on GitHub.</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>I'd like us to start using the <a href="https://github.com/hostilefork/replpad-js/blob/master/storage.md">persistence features</a> to remember previous sessions, and perhaps make it easier to <strong>curate past Repl interactions into scripts</strong>.</p> ]]></description>
        <link>https://forum.rebol.info/t/repl-querying/1804/1</link>
        <pubDate>Sat, 07 May 2022 19:11:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5814</guid>
      </item>
      <item>
        <title>LOGIN Magazine Historical Covers</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Those who are interested in Rebol history might be interested in these magazine covers.  I am trying to delete files off a computer and had them, and if they have any relevance they are better backed up as part of the forum backups:</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4.jpeg" data-download-href="https://forum.rebol.info/uploads/default/5385218e7af6c5e52f7dee3c114207f08668bbe4" title="rebol-login-nov-2001"><img src="https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_353x500.jpeg" alt="rebol-login-nov-2001" data-base62-sha1="bUQRrNKBWgwSAqtWhtOVp1zs0ks" width="353" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_353x500.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_529x750.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_706x1000.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">rebol-login-nov-2001</span><span class="informations">1448√ó2048 534 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/19d65a0ef0878828180a88f3257fae3cc465db94.jpeg" data-download-href="https://forum.rebol.info/uploads/default/19d65a0ef0878828180a88f3257fae3cc465db94" title="rebol-login-sep-2002"><img src="https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_353x500.jpeg" alt="rebol-login-sep-2002" data-base62-sha1="3GzbmOscS1RVPpGqNNJcrWd2PY0" width="353" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_353x500.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_529x750.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_706x1000.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">rebol-login-sep-2002</span><span class="informations">1448√ó2048 488 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p> ]]></description>
        <link>https://forum.rebol.info/t/login-magazine-historical-covers/1803/1</link>
        <pubDate>Fri, 06 May 2022 19:45:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5813</guid>
      </item>
      <item>
        <title>DO vs. IMPORT and &quot;Console-Extending Applications&quot;</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>During the module reworking, I roughly embraced the R3-Alpha distinction made in the header between two categories:</p>
<hr>
<pre><code>Rebol [Type: Script ...]  ; first category
</code></pre>
<ul>
<li>
<p>You would run these "Scripts" with DO</p>
</li>
<li>
<p>Performing a DO could have side effects, but should be isolated...not allowed to leak changes into the caller's environment</p>
<ul>
<li>This was a new rule I imposed as a default (because "Isolate" was made more economical, and I wanted to see how much we could get away with)</li>
</ul>
</li>
</ul>
<hr>
<pre><code>Rebol [Type: Module ...]  ; second category
</code></pre>
<ul>
<li>
<p>An "ideal" module would not have any "side-effects"...because the concept was that no matter how many times you run IMPORT you will only get one copy of that module in memory.</p>
<ul>
<li>Notably, if you run an IMPORT on a module that has already been loaded before...that will not run any code in the module body...it will just give you the MODULE! object that it already made.</li>
</ul>
</li>
</ul>
<hr>
<p><strong>We probably shouldn't be surprised that there are things that don't fit neatly into these categories!</strong></p>
<hr>
<h2>"Console-Extending Applications"</h2>
<p>So these add some functions to your environment, but also tend to have some side effects.  Like:</p>
<ul>
<li>
<p><strong><a class="mention" href="/u/gchiu">@gchiu</a>'s chess program</strong> - It wants to display a board, show you some help, and add various chess-related behaviors to the console.  But to add those commands which "contaminate" the calling environment, you have to say <strong>import</strong>.  On the other hand, by displaying a board and showing help, it sort of violates that "no side-effects" rule.</p>
<ul>
<li>He is working on another prescription-generating application that lets you automate a pop-up window that works in a similar way.</li>
</ul>
</li>
<li>
<p><strong>The ReplPad interactivity test</strong> - This test adds OKAY and NOPE to the vocabulary... where it's actually the typing of those words that runs commands which advance the console through steps in some way and instructs you on what to look for.</p>
<ul>
<li>
<p>If you don't use IMPORT, you don't get the commands added as commands to the context...</p>
</li>
<li>
<p>...but if you DO use IMPORT, you can only run through the test once... because doing it again will not load the code that prints out the instructions and launches it...</p>
</li>
</ul>
</li>
</ul>
<h2>Should DO allow you to EXPORT ?</h2>
<p>The nice thing about the word DO is it sounds pretty unambiguous, that you want to run something that has side effects.</p>
<p>But I do like the default of not leaking into the enclosing environment.</p>
<p>It seems like allowing scripts to export symbols could be a lazy compromise...which would let you ask to run something (vs. just bringing in a cached copy if previously loaded).</p>
<p>Yet this raises the question of what sort of behavior you'd expect from something that extends the console if you DO it multiple times.</p>
<p>There's also some things to think about regarding how modules will only load once, with respect to debugging.  If you have a complex multi-module project running and want to tweak something--reload it and retry without losing your current interpreter state, that's rather complicated semantically.</p>
<p>We might also consider the idea that there's a new script type.  Something like <strong><code>Rebol [Type: Commands ...]</code></strong> for lack of a better name.  Maybe this would by default give you a new console session separate from the one you were in?</p>
<p>Much more work is needed on binding and modules, to try and figure out how to deliver a good experience.  So hopefully if I don't die in a tornado here in Tennessee, I will work on that soon.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p> ]]></description>
        <link>https://forum.rebol.info/t/do-vs-import-and-console-extending-applications/1802/1</link>
        <pubDate>Fri, 06 May 2022 19:42:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5812</guid>
      </item>
      <item>
        <title>Suppressing verbosity in the replpad</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="gchiu" data-post="1" data-topic="1801">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/gchiu/40/22_2.png" class="avatar"> gchiu:</div>
<blockquote>
<p>Maybe <code>http://hostilefork.com/media/shared/replpad-js/@rx</code> would be better</p>
</blockquote>
</aside>
<p>This notation seems nice, but the way browsers work this can't be dispatched to a single script living at <code>http://hostilefork.com/media/shared/replpad-js/</code>.</p>
<p>When serving the ReplPad statically, the only way to do that is with the URI "query" and "fragment"  portions...so it has to be done with things that follow a question mark or a hash mark.  Such as <code>http://hostilefork.com/media/shared/replpad-js/?import=@rx</code> or similar.</p>
<p>In order to do better, there has to be actual server-side code before the page is fetched as part of the "dispatch", which somehow routes the information to the page.  That would be worth it for a hosted service that's trying to be as slick as possible...but the ReplPad is not being prescriptive about the server-side hosting at this time.</p>
<p>It's something we should keep in mind for <code>https://example.com/@rx</code> when things are streamlined.</p> ]]></description>
        <link>https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801/3</link>
        <pubDate>Mon, 02 May 2022 17:40:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5811</guid>
      </item>
      <item>
        <title>Suppressing verbosity in the replpad</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p>if a module is provided then verbose mode is automatically suppressed.</p>
</blockquote>
<p><strong>My main thought about verbosity is that we should think about options beyond just "on" and "off".</strong></p>
<p>Verbose output is something that is helpful when debugging, but you don't always know in advance if you're going to end up in a situation that needs debugging or not.  So having a log running regardless is the best default option--then you can choose to view it after the fact.</p>
<p>This is demonstrated fairly well by the JavaScript console in browsers.  Users aren't troubled by it if all goes well...but if something goes wrong you can bring it up.  Errors are highlighted distinctly from just basic logging.</p>
<p>In the case of the ReplPad, we can actually leverage this by sending the information about module loads and such to the browser console--as opposed to the ReplPad console.  That seems like a reasonable default, and then maybe have a way to send it to the standard output.</p>
<p>When you're running in a desktop console, there could be options:</p>
<ul>
<li>Write informational logging output to a file</li>
<li>Mix it in with the console output</li>
<li>Just keep the last N lines of it in memory and be able to ask for it on an as-needed basis</li>
</ul>
<p><strong>One thing I worry about is superfluous logging that <em>isn't</em> visible getting out of hand and taking up memory and time...</strong> so there should be some way of knowing a lot of logging output is being made.  Not sure when these notices would be given, but perhaps something it says when it prints out a prompt.</p> ]]></description>
        <link>https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801/2</link>
        <pubDate>Mon, 02 May 2022 15:17:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5810</guid>
      </item>
      <item>
        <title>Suppressing verbosity in the replpad</title>
        <dc:creator><![CDATA[@gchiu]]></dc:creator>
        <description><![CDATA[ <p>I am developing a replpad app but I want the users to go straight to a URL and start the app.  I'd rather that they didn't have to type</p>
<pre><code>import @rx
</code></pre>
<p>when a lot of module stuff is sent to the console interrupting the interface, eg</p>
<pre><code>`== make module! [
    alpha: make bitset! #{00000000000000007FFFFFE07FFFFFE0}  
    rx: '#[action! {rx} [drug]]  
    ...  
</code></pre>
<p>`</p>
<p>Maybe <code>http://hostilefork.com/media/shared/replpad-js/@rx</code> would be better and if a module is provided then verbose mode is automatically suppressed.</p>
<p>Anyway, suggestions for a standardised way to run our apps?</p> ]]></description>
        <link>https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801/1</link>
        <pubDate>Thu, 28 Apr 2022 09:49:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5809</guid>
      </item>
      <item>
        <title>Getting data into replpad-js</title>
        <dc:creator><![CDATA[@gchiu]]></dc:creator>
        <description><![CDATA[ <p>I think at least Chrome that local storage is limited to 5Mb.  Other browsers you can set this value.</p>
<p>I'd want a way to also take the local storage data and transfer it to another browser on a different machine.</p> ]]></description>
        <link>https://forum.rebol.info/t/getting-data-into-replpad-js/1742/4</link>
        <pubDate>Thu, 28 Apr 2022 09:38:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5808</guid>
      </item>
      <item>
        <title>Danny, dRebol, Inetw3 (Daniel Murrill)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Hi Danny,</p>
<aside class="quote no-group quote-modified" data-username="Danny" data-post="21" data-topic="1503">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/848f3c/40.png" class="avatar"><a href="https://forum.rebol.info/t/pack-sequence-type/1503/21">PACK! Sequence Type</a>
</div>
<blockquote>
<p>I would like to start coding the Rebol-Dom.r script in Ren-C, but im not sure if it needs to be written as (Redbol) compatible or R3 syntax. Any heads up would be nice.</p>
</blockquote>
</aside>
<p>Last year, Ren-C underwent some necessary but painful transitions... as I try to reason about a working module system, and what the future of binding might look like.  It means the already-not-well-documented variations from historical Rebol are even more of a minefield--I'll do what I can to improve it, but it will be slow.</p>
<p>But likely relevant to what you want is that I think it's going to be crucial that binding be able to let you access "binding environments" for strings.  If you haven't got a chance to read this, I talk some about that:</p>
<p><strong><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">Rebol and Scopes: Well, why Not?</a></strong></p>
<p><strong>So that's one heads-up I'd give you: that the best way to embed "JavaScript-like intents" inside of Ren-C may be something that is done with strings, vs. the kinds of syntax tricks you were trying.</strong></p>
<p>This isn't to say that we couldn't use some experimentation in the area of Ren-C/web interoperability.  <a class="mention" href="/u/rgchris">@rgchris</a> made "StyleTalk" which <a href="https://www.youtube.com/watch?v=sM7uGKCZMl0">he explains in a video</a>.  I'd like to see us to see where things can go with that kind of thinking before bending ourselves too far into pretzels and asking if <strong><code>a[b]c</code></strong> should be its own lexical type.</p>
<p><strong>Another heads up I'll give is that I've been traveling since December, and not programming much at all.</strong>  Hence I'm a bit behind on the mountain of design (as well as my own pet projects...)  I likely won't have the bandwidth to support anyone's new experiments that I'm not already supporting.</p>
<p>Though much of the current efforts are on things in the browser.  If you are interested in HTML interoperability then I'd definitely encourage you to look at the ReplPad and where that is going.  I'm effectively "doubling-down" on the approach of using the browser for GUI <em>(vs. Red's strategy of writing their own code)</em></p>
<p><strong>So if you want to be experimental in Ren-C land, the place where you'll be more likely to find support (though not promising...) is if you're trying things in the web build.</strong>  It may lead you to different ideas about how to attack your problems, specifically as a mixture of JavaScript strings with Ren-C.</p>
<p>I'd suggest looking at <a href="https://forum.rebol.info/t/js-eval-and-js-do/1504">JS-EVAL and JS-DO</a> for instance, things like what <a class="mention" href="/u/gchiu">@gchiu</a> wrote just the other day:</p>
<pre><code>add-content: func [
    txt [text!]
][
    txt: append copy txt newline
    js-do ["document.getElementById('script').innerHTML +=" spell @txt]
]
</code></pre>
<p>That's pretty smooth language interoperability... and I'm sure it can be better!  (If you read the JS-EVAL post I explain why this winds up being smarter than gluing strings together, and avoids various escaping problems.)</p> ]]></description>
        <link>https://forum.rebol.info/t/danny-drebol-inetw3-daniel-murrill/1502/4</link>
        <pubDate>Sun, 17 Apr 2022 00:37:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5807</guid>
      </item>
      <item>
        <title>PACK! Sequence Type</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was merged into an existing topic: <a href="/t/danny-drebol-inetw3-daniel-murrill/1502/3">Danny, dRebol, Inetw3 (Daniel Murrill)</a></p> ]]></description>
        <link>https://forum.rebol.info/t/pack-sequence-type/1503/21</link>
        <pubDate>Sat, 16 Apr 2022 23:04:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5806</guid>
      </item>
      <item>
        <title>Danny, dRebol, Inetw3 (Daniel Murrill)</title>
        <dc:creator><![CDATA[@Danny daniel murrill]]></dc:creator>
        <description><![CDATA[ <p>I would like to start coding the Rebol-Dom.r script in Ren-C, but im not sure if it needs to be written as Rebdol compatible or R3 syntax. Any heads up would be nice.</p>
<p>I also would like to see its node sequence type coded as Red/sys or Ren-C if its possible.</p>
<p>I really like Uparse, but for me to focus on its intricacies would take up more free time that i really don't have right now.</p>
<p>Although i like Rebol, my coding style may not do it much justice, but that's ok. Rebol is still somewhat an unknown. So if anyone have any criticism, good or bad, i welcome it.</p> ]]></description>
        <link>https://forum.rebol.info/t/danny-drebol-inetw3-daniel-murrill/1502/3</link>
        <pubDate>Thu, 14 Apr 2022 02:33:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5803</guid>
      </item>
      <item>
        <title>Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</title>
        <dc:creator><![CDATA[@BlackATTR Black Attr]]></dc:creator>
        <description><![CDATA[ <p>Great refresher and summary of the issues.</p> ]]></description>
        <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799/2</link>
        <pubDate>Thu, 07 Apr 2022 11:58:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5802</guid>
      </item>
      <item>
        <title>Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><code>~null~</code> isotopes are a novel solution shaped to solve a specific problem.  As a reminder of what the goal is...</p>
<h1>The Goal is to Please <a class="mention" href="/u/rgchris">@rgchris</a> <em>AND</em> Please me</h1>
<p>NULL is the signal of "soft failure".  It's a unique result reserved for when a branch fails, or when a loop is halted by a BREAK, when PARSE fails...etc.</p>
<p>Its property of not being storable in blocks makes it critical to disambiguating this historical problem:</p>
<pre><code>redbol&gt;&gt; third [a b #[none]]
== #[none]

redbol&gt;&gt; third [a b]
== #[none]
</code></pre>
<p>In a language that prides itself on letting you work with code structure, <em>this is the tip of the iceberg of the problems that null solves</em>, and you will find the distinction's utility across the board (obviously, in tools like COMPOSE).  It facilitates rigorous analysis and rearrangements...without needing to drop to C or write convoluted code:</p>
<pre><code>&gt;&gt; third [a b _]
== _

&gt;&gt; third [a b]
; null
</code></pre>
<p>Hence NULL has taken the place of blank ("none!") in many places, one of which is the unique result of failed conditionals.</p>
<p>But unlike the elements in a block, a branch that evaluates isn't required to be non-NULL.  Which leads us to the long running question of what to bend NULL branches to so they don't conflate with the branch-not-taken result.</p>
<h2>Chris has (rightly) expressed concern</h2>
<p>At times I've said that it's not that big a deal that branches can't evaluate to NULL and get distorted.  "You didn't have a NULL before, so why get so worked up about control constructs not returning it?"</p>
<p>But the now-pervasive nature of NULL means it can't be avoided.  So:</p>
<p><em>"How do you express branching code which wants to do some work but also produce NULL as an evaluative product?"</em></p>
<p>Conflation was not a problem, e.g. in Rebol2:</p>
<pre><code>rebol2&gt;&gt; exampler: func [x] [
     print "returning sample or none if not found"
     case [
         x = &lt;string&gt; [print "sample string" {hello}]
         x = &lt;integer&gt; [print "sample integer" 3]
         x = &lt;none&gt; [print "sample none" none]
     ]
  ]

rebol2&gt;&gt; exampler &lt;string&gt;
returning sample or none if not found
sample string
== "hello"

rebol2&gt;&gt; exampler &lt;blatz&gt;
returning sample or none if not found
== #[none]

rebol2&gt;&gt; exampler &lt;none&gt;
returning sample or none if not found
sample none
== #[none]
</code></pre>
<p>However NULL is now the basic currency of "soft failure".  As such it would not be uncommon to be in the situation where a branching decision process would want to intentionally return NULL as part of the work it does.</p>
<p>Without something like the isotope decay mechanism, unpleasant convolutions would be needed, for instance surrounding anything that wanted to tunnel a NULL with a CATCH and THROW'ing it:</p>
<pre><code>x: catch [
    throw switch 1 + 2 [
        1 [print "one" 1]
        2 [print "two", &lt;two&gt;]
        3 [print "three", throw null]
     ]
]
</code></pre>
<p>Definitely not good.  But regarding the pleasing-me-part, remember I am trying to avoid this situation:</p>
<pre><code>&gt;&gt; case [
     true [
          print "case branch"
          if 1 &gt; 2 [print "failed inner"]
     ]
   ] else [
     print "else branch"
   ]

case branch
else branch  ; ugh
</code></pre>
<p>I don't want the CASE branch to evaluate to NULL just because the failed IF inside the branch was NULL.  That would mean the ELSE tied to the CASE runs even though the code for the branch ran.</p>
<h2>Enter Isotopes</h2>
<p>One thing null isotopes have in common with NULL (like all BAD-WORD! isotopes) is that they can't be put in blocks.  But they have been automatically "decaying" into regular NULL when stored into variables.</p>
<pre><code>&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; x: ~null~
== ~null~  ; isotope  &lt;-- note the overall expression is still an isotope

&gt;&gt; x
; null
</code></pre>
<p>The twist is that they are <em>different enough</em> from true NULL such that a THEN or an ELSE can consider them a situation where the branch did not run:</p>
<pre><code>&gt;&gt; if false [&lt;ignored&gt;]
; null

&gt;&gt; if true [null]
== ~null~  ; isotope

&gt;&gt; if true [null] else [print "This won't run"]
== ~null~  ; isotope
</code></pre>
<p>The reason functions like ELSE can "see" the isotope is that they don't take an ordinary parameter on their left.  They take a ^META argument.  These can see the distinction between a ~null~ isotope and a "true" NULL.</p>
<p><strong>I'd largely say this has been working well...certainly better than its conceptual predecessors.</strong>  It makes piping NULL out of branches trivially easy, when the fear of conflation is not a problem.</p>
<pre><code>&gt;&gt; x: switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
== ~null~

&gt;&gt; x
; null
</code></pre>
<p>The automatic decay in variable storage prevents you from needing an explicit operation to turn ~null~ isotopes into pure nulls:</p>
<pre><code>&gt;&gt; x: decay switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
; null
</code></pre>
<h1>But <a class="mention" href="/u/rgchris">@rgchris</a> Would Likely Want any <em>NORMAL</em> arg decay</h1>
<p>At the very moment I am writing this, ~null~ isotopes are like all other BAD-WORD! isotopes and not accepted as normal parameters.</p>
<p><strong>They <em>could</em> decay to pure NULL for all normal args.</strong>  But let me explain a bummer of what we lose in that bargain.</p>
<p>It takes away a safety idea I had with functions like MATCH.</p>
<pre><code>&gt;&gt; match [&lt;opt&gt; integer!] 3
== 3

&gt;&gt; match [&lt;opt&gt; integer!] "notaninteger"
; null

&gt;&gt; match [&lt;opt&gt; integer!] null
== ~null~  ; isotope
</code></pre>
<p>The idea was that it could say "yes, this matched" but if ~null~ isotopes were tested, they'd give an error:</p>
<pre><code>&gt;&gt; if (match [&lt;opt&gt; integer!] null) [print "Yes it matched!"]
** Error: IF does not accept ~null~ isotopes without a ^META condition
</code></pre>
<p>Were MATCH to have passed through a plain NULL it would have succeeded in the match but not run the branch.  So it's nice to get the warning on the isotope.</p>
<p><strong>Or it could just return a ~matched~ isotope</strong>.  But this loses the following nice isotopic property:</p>
<pre><code>&gt;&gt; x: match [&lt;opt&gt; integer!] null else [fail "NO MATCH"]
== ~null~  ; isotope

&gt;&gt; x
; null
</code></pre>
<p>In fact I instituted other decaying variants for ~blank~ and ~false~</p>
<pre><code>&gt;&gt; y: match [blank!] _ else [fail "NO MATCH!"]
== ~blank~  ; isotope

&gt;&gt; y
== _

&gt;&gt; z: match [logic!] 1 = 2 else [fail "NO MATCH!"]
== ~false~  ; isotope

&gt;&gt; z
== #[false]
</code></pre>
<h1>So What To Do About MATCH and its bretheren?</h1>
<p>Seems the options are:</p>
<ol>
<li>
<p><em>Don't worry about it.</em>  If you write <strong>match [logic!] 1 = 2</strong> you get back <strong>#[false]</strong> and should you write an expression like <strong>if (match [logic!] 1 = 2) [print "Match!]</strong> you get what you deserve.</p>
</li>
<li>
<p><em>Use a different isotope.</em>  Let's say that <strong><code>match [&lt;opt&gt;] null</code></strong> is simply <strong>~matched~ (isotope)</strong>.  It wouldn't have the decaying property, but would have the invalidness property.</p>
</li>
<li>
<p><em>Have a MATCH/FALSEY variant.</em>  Let plain <strong>match</strong> on a falsey thing trigger an error and if you write <strong>if match/falsey ...</strong> then you clearly do know what you're doing so it becomes like case (1).</p>
</li>
<li>
<p><em>Make all conditional arguments take ^META arguments for their conditions.</em>  This would put the responsibility for checking for isotopes on them, and they'd uniquely disallow them before UNMETA'ing them and then testing for truth/falsehood.</p>
</li>
</ol>
<p>Option (4) is too taxing...impacting not just the interface to IF but the implementation of CASE and any conditional construct.</p>
<p><strong>I think I like (3) because it punts the ball down the road a bit.</strong></p>
<p>But this might still not suit Chris.</p>
<h1>Should Non-Meta Arguments Decay Null isotopes?</h1>
<p>The "auto-decay" of ~null~ isotopes means no variable can ever hold a NULL isotope.  And there's also a rule that no <em>normal</em> parameter can ever be passed an isotope, only ^META parameters.</p>
<p>In the beginning, it seemed useful if normal arguments would automatically decay null isotopes:</p>
<pre><code>&gt;&gt; foo: func [x] [if null? x [print "Yup, it's null"]]

&gt;&gt; foo if true [null]
Yup it's null

&gt;&gt; metafoo: func [^x] [
    case [
        null? x [print "regular null"]
        x = '~null~ [print "null isotope"]
        true [print "something else"]
     ]
   ]

&gt;&gt; metafoo if false [null]
regular null

&gt;&gt; metafoo if true [null]
null isotope
</code></pre>
<p>There is a manual DECAY operator which could be used, but would not meet that wish:</p>
<pre><code>&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; decay ~null~
; null

&gt;&gt; ~blank~
== ~blank~  ; isotope

&gt;&gt; decay ~blank~
== _

&gt;&gt; ~false~
== ~false~  ; isotope

&gt;&gt; decay ~false~
== #[false]
</code></pre>
<h1>Should DECAY Conflation Be A Customization?</h1>
<p>Another avenue of satisfaction could be to say that you simply customize your environment with some definitions to make auto-decaying constructs:</p>
<pre><code>switch: chain [:switch | :decay]
case: chain [:case | :decay]
...

&gt;&gt; case [true [null]]
; null

&gt;&gt; case [false [10]]
; null
</code></pre>
<p>I don't like it, but if someone isn't going to use ELSE (or is willing to accept this very easily unintentional conflation if they do) it could be an option.</p>
<p><strong>I really do believe the ability to tell from outside the construct if a branch has been taken is an interesting property, which even those who think they won't use ELSE or THEN can leverage, especially when building constructs atop each other.</strong>  But this isn't something that can be appreciated without usage, or trying to write something like UPARSE generically in usermode.</p>
<h1>Should function RETURN decay by default?</h1>
<p>Continuing along these lines, this has to do with the pattern of:</p>
<pre><code>foo: func [x] [
    return switch x [
         1 [print "one", #one]
         2 [print "two", null]
         3 [print "three", &lt;three&gt;]
    ]
]

&gt;&gt; foo 1 + 2
two
== ???   ; should this be ~null~ isotope or just NULL
</code></pre>
<p>Also, should it matter whether there's a RETURN there or not?  Is this something the type spec should distinguish?</p>
<p>Right now there's a refinement called /ISOTOPE on RETURN which asks it not to decay.</p>
<p><strong>If all non-^META parameters decay by default, then it seems isotopic decay is the right default for RETURN even though it takes a ^META parameter and returns non-decaying isotopes.</strong></p>
<h2>As Always, A Lot To Think About</h2>
<p>Want to get this posted because it's preventing me from making new drafts (Discourse won't let you have multiple top-level post drafts in-flight for some reason).</p>
<p>Will keep mulling it all over.</p>
<p><em>"A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away."</em></p> ]]></description>
        <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799/1</link>
        <pubDate>Thu, 07 Apr 2022 04:14:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5801</guid>
      </item>
      <item>
        <title>Improving the ASK Dialect (and replacing INPUT)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="onebox githubissue">
  <header class="source">
      <a href="https://github.com/hostilefork/replpad-js/issues/97" target="_blank" rel="noopener">github.com/hostilefork/replpad-js</a>
  </header>
  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Issue">
	  <svg width="60" height="60" class="github-icon" viewbox="0 0 14 16" aria-hidden="true"><path d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/hostilefork/replpad-js/issues/97" target="_blank" rel="noopener">Paste of Multi-Line Text should enter multiline editing mode</a>
    </h4>

    <div class="github-info">
      <div class="date">
        opened <span class="discourse-local-date" data-format="ll" data-date="2022-04-01" data-time="12:28:02" data-timezone="UTC">12:28PM - 01 Apr 22 UTC</span>
      </div>


      <div class="user">
        <a href="https://github.com/hostilefork" target="_blank" rel="noopener">
          <img alt="hostilefork" src="https://avatars.githubusercontent.com/u/20440?v=4" class="onebox-avatar-inline" width="20" height="20">
          hostilefork
        </a>
      </div>
    </div>
  </div>
</div>

<div class="github-row">
  <p class="github-content">Typically hitting enter in the REPL will trigger an evaluation. But if you hit Ctrl-Enter, this goes into a multi-line editing...</p>
</div>

<div class="labels">
</div>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
 ]]></description>
        <link>https://forum.rebol.info/t/improving-the-ask-dialect-and-replacing-input/1124/15</link>
        <pubDate>Fri, 01 Apr 2022 12:28:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5800</guid>
      </item>
      <item>
        <title>Improving the ASK Dialect (and replacing INPUT)</title>
        <dc:creator><![CDATA[@gchiu]]></dc:creator>
        <description><![CDATA[ <p>I'm trying to parse multi line text in the clipboard so control enter doesn't help.</p> ]]></description>
        <link>https://forum.rebol.info/t/improving-the-ask-dialect-and-replacing-input/1124/14</link>
        <pubDate>Fri, 01 Apr 2022 05:47:13 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5799</guid>
      </item>
      <item>
        <title>Improving the ASK Dialect (and replacing INPUT)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><em><a class="mention" href="/u/gchiu">@gchiu</a> has raised an additional question about how to get multiline input, where we can do a reasonably good job in a browser with a textarea of that in the browser.  I moved the discussion here so I could keep the GitHub issue focused on the technical issue it was about.</em></p>
<hr>
<p>Already multi-line input is in the ReplPad when you hit Ctrl-Enter.  I've always intended to make that feature available to ASK...somehow.  But if the caller of ASK can only handle one line, they don't want to have to check it.</p>
<p>So it's a question of intent...whether you want one line or many.  So would it be READ-LINE vs. READ-LINE/MULTI, or READ-TEXT/LINE, or...what?  Then the question of whether ASK TEXT! assumes one or the other.</p>
<p>I kind of feel like ASK TEXT! strikes me as unconstrained.  It's like "as much as you want to say" and if you really just want one line that should be a different request.  But if you want to read only one line it shouldn't be any worse than:</p>
<pre><code>ask ["Enter a single line:" text! /lines 1]
</code></pre>
<p>Maybe worth it to have a "macro":</p>
<pre><code>ask ["Enter a single line:" #line]
</code></pre>
<h2>I will advocate for <em>modelessness</em>
</h2>
<p><em>I'm generally a fan of modeless editing</em>.  So even if you only intend to accept one line, don't constrain me while I'm typing or copy/pasting.  Give me a chance to edit it down to fit what you'll accept.  If we can lean in that direction that would be nice.</p>
<h2>Might we leverage PARSE rules?</h2>
<p>Could we find a way to blend in parsing as part of the asking?  Could there be a way to even guide people to why their input wasn't satisfactory?</p>
<pre><code>ask [text! constraint [thru newline]]
</code></pre>
<p>Would be nice to be creative here, but also to study prior art.</p> ]]></description>
        <link>https://forum.rebol.info/t/improving-the-ask-dialect-and-replacing-input/1124/13</link>
        <pubDate>Fri, 01 Apr 2022 00:46:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5798</guid>
      </item>
      <item>
        <title>Reviving the Rebmu Dialect</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>One small step for a fork, one giant leap for a Rebmu...</p>
<p><strong><a href="https://github.com/hostilefork/rebmu/runs/5486704767?check_suite_focus=true#step:5:1">The roman numeral example (roman.rebmu) is now running on GitHub CI against the current Ren-C.</a></strong></p>
<p>Minus getting the input string into S, right now the converter looks like:</p>
<blockquote>
<p><code>J K 0 feCs[Nse[I01V05X10L50C100D500M1000]twCinzJ[a+KeiL?jN[sbNjEL N00]j]Jn]adKj</code></p>
</blockquote>
<p>The input routine hit a snag, because what used to be <strong>rS</strong> would translate to <strong>readin-mu s</strong>, where it would quote the argument and read based on its type.  And S started out as a string.</p>
<p>For reasons maybe good or bad, I dropped all the preloaded single-character values (like S starting as an empty string and B as empty block) because I thought that was a cheap trick.  It was only chopping off a tiny constant factor...and wasn't really teaching anything about the language.  Will have to rethink that.</p>
<p>In any case, I created the <a href="https://forum.rebol.info/c/domains/rebmu/56">Rebmu forum category</a> to discuss points as they come up.</p>
<h2>Priorities?</h2>
<p>Making the roman numeral converter work was the first order of business.  And I think I'd like to kind of keep going on getting <a href="https://github.com/hostilefork/rebmu/tree/master/examples">the example programs</a> working and tested before getting too involved in trying to rewrite any of the "engine".</p>
<p>Rebmu introduces some new challenges to the fledgling module system, with "sea of words" and "isolation" all being usermode concepts.  As well as how much might the interpreter recognize alternative headers?  Should a Rebmu file end in <strong>.reb</strong> or <strong>.rebmu</strong> or <strong>.rebmu.reb</strong>... and whether the header should say <strong>Rebol [Type: Rebmu]</strong> or <strong>Rebmu [...]</strong> and have that registered somewhere.</p>
<p>So there's no small amount of work here.  As usual, I'm not throwing softballs.  I'll post issues as they come up.</p> ]]></description>
        <link>https://forum.rebol.info/t/reviving-the-rebmu-dialect/1377/4</link>
        <pubDate>Wed, 09 Mar 2022 21:19:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5793</guid>
      </item>
      <item>
        <title>Kaj Gets on the Meta Train</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I looked to see if there were any updates on Kaj's Meta project, and it looks like he is kind of focusing on porting existing Atari 2600 demos written in assembly to the language.</p>
<p>There the usual debate on the Atari forum of people talking about why languages succeed or not, asking and trying to get at why anyone would care about Rebol, expressing skepticism that Kaj will strike gold...but he says it's successful even if he just uses it and it gives him a "competitive edge".</p>
<p>If you're interested you can read the threads:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://atariage.com/forums/topic/326694-meta-language-released/" target="_blank" rel="noopener">AtariAge Forums</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:123/93;"><img src="https://atariage.com/forums/uploads/monthly_2021_11/MortalCoil.png.b6702cc80f0f198707eede8eae92e82f.png" class="thumbnail" width="123" height="93"></div>

<h3><a href="https://atariage.com/forums/topic/326694-meta-language-released/" target="_blank" rel="noopener">Meta language released</a></h3>

<p>Introduction thread here: I am starting a new thread, because Meta has a new website: https://language.metaproject.frl The old links from the early development period are gone, and a few of the method names in the program examples have changed. I...</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>One thing I noticed is that he has chosen to go with <strong>FIRST-OF</strong> instead of just <strong>FIRST</strong>.  I've questioned this before, because things like NEXT and FIRST are useful variable names.  In Ren-C there would be presumably no hyphen, so you could write:</p>
<pre><code>first: first of block
</code></pre>
<p>Similar to how you can today say:</p>
<pre><code>type: type of block
</code></pre>
<p>This is because OF quotes its left argument, with the idea that this is learnable.</p>
<p>You could of course still say:</p>
<pre><code>first: specialize :of [property: 'first]
</code></pre>
<p>Which is actually how it works today.</p> ]]></description>
        <link>https://forum.rebol.info/t/kaj-gets-on-the-meta-train/1753/3</link>
        <pubDate>Wed, 09 Mar 2022 06:00:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5792</guid>
      </item>
      <item>
        <title>Rebmu History Removed from File (is History: a good idea?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>When I started Rebmu I followed along the pattern of having seen people put <strong><code>History:</code></strong> in the headers of files.  And as it got longer, I kind of questioned the value of it.</p>
<p>I'm not sure what the "best practices" for history is, but it's a lot of stuff to skip over when you're trying to get to the meat of a file.  It warrants its own discussion topic (which I guess can be discussed here, with the extracted history).</p>
<pre><code>History: [
    0.1.0 [10-Jan-2010 {Sketchy prototype written to cover only the
    Roman Numeral example I worked through when coming up with the
    idea.  So very incomplete, more a proof of concept.}]

    0.2.0 [22-Jun-2010 {Language more complete, includes examples.
    Ditched concept of mushing symbols like + and - into single
    character operators is removed due to realization that A+
    B+ C+ etc. are more valuable in the symbol space than one
    character for AD.}]

    0.3.0 [24-Jun-2010 {Made backwards compatible with Rebol 2.
    Note that things like CN for continue or PERCENTAGE! datatype
    were added in Rebol 3.  You can use these in your Rebmu programs
    but they will only work if using Rebmu with an r3 interpreter.
    Also did several name tweaks like instead of AA for AND~ it's
    now A~ along with other consistencies.}]

    0.5.0 [16-Feb-2014 {Version bump to indicate growing maturity
    of the language.  Abandon Rebol 2 support.  Rebmu files now
    have proper Rebol ecology headers.}]

    0.6.0 [6-Apr-2014 {Large cleanup creating incompatibility with
    most all previous Rebmu code solutions.  Examples have been updated
    in GitHub.  Major theme was removing the custom IF/UNLESS/EITHER
    implementation and some clearer names.}]

    0.7.0 [15-Sep-2015 {Project revisited to incorporate new ideas and
    decisions from the Ren/C effort.  Incorporates the rebol-proposals
    module to work with experimental language features instead of
    having its own "incubator" project.  "Mu library" features removed
    in favor of embracing the language default more closely.}]
]</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/rebmu-history-removed-from-file-is-history-a-good-idea/1798/1</link>
        <pubDate>Mon, 07 Mar 2022 08:22:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5791</guid>
      </item>
      <item>
        <title>Symbols and Mushing in Rebmu</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>There are symbols like &amp; and | which were applied somewhat haphazardly in the original Rebmu, as experiments.</p>
<p>For instance, <strong>&amp;</strong> was a shortcut for DOES.</p>
<pre><code>phi: does [print "hi"]
=&gt;
PHI &amp;[print "hi"]
</code></pre>
<p>(There've been murmurs of other uses for &amp;, but no hard decisions on it yet...and even if it were used for HTML characters like <strong>&amp;nbsp</strong>, it might remain free standalone as a symbol.)</p>
<p>For a time, <strong>|</strong> in Ren-C was not something you could redefine as a WORD!, it was its own datatype "BAR!".  But that has been replaced by the successful COMMA!, retaking it as a word.  It was used in function definition, and some of the contractions I've suggested as things like <strong><code>fqC[...]</code></strong> =&gt; <strong>function [a b c] [...]</strong> were contracted as simply <strong><code>c|[...]</code></strong></p>
<p>There was a handling of dots which allowed a quick way of doing redefinitions:</p>
<pre><code>     .[aBCdEF] =&gt; .[a bc d ef] =&gt; a: :bc d: :ef
</code></pre>
<p>There's still some back-and-forth on the handling of lone dot.  I like it being a reduced case of a TUPLE! in some sense...because it makes it easier to write generic fusing code for things like JOIN.  But putting into the new SYMBOL! class (which cannot appear in TUPLE! or PATH!) might have advantages, and helpers to count the dots might serve just as well.</p>
<p>I'm not sure what the in-language default function for plain dot will be, but it's likely that it will not be more powerful than either <strong>.a</strong> or <strong>a.</strong> enough to justify that <strong>a.a</strong> should be interpreted as <strong>a . a</strong>.</p>
<p>It's important to look at the specifics of mushing with symbols as they have no case, so the breakapart rules are different.  I've diagrammed some of these before.</p>
<pre><code>a+b =&gt; a+b  ; compatibility with all lowercase code
a+B =&gt; a+ b  ; favors breaking to the left, vs. a +b
</code></pre>
<p>I'll delve into these justifications, but since I'm deleting the old definitions of things like <strong>a&amp;</strong> and <strong>a|</strong> I wanted to put a placeholder topic for discussing it.</p> ]]></description>
        <link>https://forum.rebol.info/t/symbols-and-mushing-in-rebmu/1797/1</link>
        <pubDate>Mon, 07 Mar 2022 08:08:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5790</guid>
      </item>
      <item>
        <title>Rebmu&#39;s FUNQTION (FQ): Dialecting Function Definition Itself</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1796">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It doesn't do anything <em>terribly</em> tricky because its arguments are both evaluative.</p>
</blockquote>
</aside>
<p>I say <em>not terribly</em> tricky, but it's a <em>little</em> tricky.</p>
<p>It defines R and RT as local synonyms for the function's definitional return.  Remember you can't globally say something like:</p>
<pre><code>r: rt: :return
</code></pre>
<p>Because each function defines its own local RETURN function.  So you have to basically augment the body during construction to get it bound to local definitions of RT and R:</p>
<pre><code>fn: adapt :function [
    body: compose [
        let rt: :return
        let r: :rt 
        (as group! body)
    ]
]
</code></pre>
<p>Another twist I think would be smart would be that while normal parameters don't accept isotopes in plain functions...it could turn all normal parameters to be ^META and then un-meta them implicitly.  Though that would affect the function's interface in ways that could lead to undesirable behaviors, so it might be better to put that in FQ (or something else, FX?)</p>
<p>There could also be some decisions that once an argument has been evaluated, it could treat invalid types differently:</p>
<pre><code>X 1  ; =&gt; x: 1
Y 2  ; =&gt; y: 2
fnADxY[...] ; =&gt; fn ad x y [...]
            ; =&gt; function add x y [...]
            ; =&gt; function 3 [...]   ; could mean something vs. error?
</code></pre>
<p>But again: I don't know how far one wants to bend the "standard" definitions in the space where things are errors today.  Worth being cautious about it.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebmus-funqtion-fq-dialecting-function-definition-itself/1796/2</link>
        <pubDate>Mon, 07 Mar 2022 07:25:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5789</guid>
      </item>
      <item>
        <title>Rebmu&#39;s FUNQTION (FQ): Dialecting Function Definition Itself</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p>After writing this I realized I had <a href="https://forum.rebol.info/t/function-mu-rebmus-function-generator-dialect/1379">already written a post about this in 2020</a>, but... here it is again, I guess!  Maybe I said it better or worse this time?</p>
</blockquote>
<p><em>(Note: FQ is pronounced EFF-QUEUE, say it carefully. <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">)</em></p>
<p>So in Rebmu, <strong>FN</strong> is a superset of <strong>FUNC</strong> (itself a synonym for <strong>FUNCTION</strong>).</p>
<p>It doesn't do anything <em>terribly</em> tricky because its arguments are both evaluative.  So you can pass it specs and bodies that are variables.  Here's a useless example of taking advantage of that with a spec in a variable:</p>
<pre><code>; define a spec which takes two arguments
S[xY]   ; =&gt; s: [x y]

; define function A that adds X and Y.
AfnS[adXy]  ; =&gt; a: fn s [ad x y]
            ; =&gt; a: function s [add x y]

; define function M that multiplies X and Y
MfnS[mpXy]  ; =&gt; m: fn s [mp x y]
            ; =&gt; m: function s [multiply x y]
</code></pre>
<p><em>...but what might a Code-Golf-Dialected FUNQTION (FQ) Do, unbound by rote evaluation of its parameters?</em>  Let's use our imagination...</p>
<h2>A Quoted Spec could permit Spec Compression</h2>
<p>How about if you gave a WORD! that was a letter and a number, you'd get 3 args starting with that letter?</p>
<pre><code>fqR3[adMPrSt]
; =&gt; fq r3 [ad mp r s t]
; =&gt; fn [r s t] [ad mp r s t]
; =&gt; function [r s t] [add multiply r s t]
; =&gt; function [r s t] [add (multiply r s) t]
</code></pre>
<p>That's a three character savings vs. having to express the block for <strong>[r s t]</strong> explicitly with a plain function:</p>
<pre><code>fn[rSt][adMPrSt]
</code></pre>
<p>If you didn't include a number that might be a different memoization of what the arguments were, such as:</p>
<pre><code>fqA[...] =&gt; fn [a] [...]
fqB[...] =&gt; fn [a b] [...]
fqC[...] =&gt; fn [a b c] [...]

fqX[...] =&gt; fn [z y x] [...]
fqY[...] =&gt; fn [z y] [...]
fqZ[...] =&gt; fn [z] [...]
</code></pre>
<p>The idea being that you need to sort of spread out your variable names in code golf, for instance when working with nested functions.  From a tactical standpoint one might be served to throw in curveballs:</p>
<pre><code>fqM[...] =&gt; fn [m j z] [...]
</code></pre>
<p>Though that lessens the readability/learnability.  Anyway, what else...?</p>
<h2>Variadically Quoted Bodies Could Circumvent Brackets</h2>
<p>Let's say if it found a word in the slot where the body block would ordinarily be, it would treat that as a function that should be called.</p>
<p>To make it easier, let's just think about this un-Rebmu'd:</p>
<pre><code>foo: func [x y z] [any [x y z]]

bar: funq [x y z] any [x y z]
</code></pre>
<p>If FUNQ is variadic and quoting its body slot, it could notice the body does not contain a block but a WORD!.  Seeing that function is ANY, it could count the number of parameters ANY needs and pick them up from the callsite.</p>
<p><em>Such mechanics are within reach using today's FRAME!s</em>, in fact <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">they are used by things like POINTFREE</a>...itself clearly useful in Rebmu.</p>
<h2>What Else Might FQ do?</h2>
<p>There's also things like GROUP!s, and <strong>fq(x)...</strong> could imply a completely different thing from <strong>fq[x]...</strong>, suggesting a mode switch in how the ensuing information is interpreted.</p>
<p>Or <strong>fqX(...)</strong> and <strong>fqX[...]</strong> could be completely different.  What about strings?  How might string interpolation fit into all of this?</p>
<pre><code>ZfqC{Implicit printing of $a and $b and $c?}
; =&gt; z: fn [a b c] [print interpolate {Implicit print of $a and $b and $c}]
</code></pre>
<p>Maybe the implicit printing is different, like FP, and FQ with a string simply interpolates it.</p>
<p><strong>Hopefully you get the drift.</strong>  I'm talking about making Rebmu a powerhouse showcase of what Ren-C is driving at.</p>
<p>How can quoting, variadics, frames, interpolation, and all of that be applied to dialecting the act of function definition itself?</p>
<h1><code>[insert your ideas here]</code></h1> ]]></description>
        <link>https://forum.rebol.info/t/rebmus-funqtion-fq-dialecting-function-definition-itself/1796/1</link>
        <pubDate>Mon, 07 Mar 2022 07:07:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5788</guid>
      </item>
      <item>
        <title>What was REBMU-WRAP (and why we no longer need it)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>As I bring the Rebmu dialect up to date I'll try and talk about any teachable moments that it provides.</p>
<p>Let's look at one of the earliest weird functions, REBMU-WRAP:</p>
<pre><code>rebmu-wrap: function [refined [path!] args [block!]] [
    func args compose [
        (refined) (args)
    ]
]
</code></pre>
<p>It was designed to make it (slightly) easier to define something like <code>APO</code> as a synonym for <code>APPEND/ONLY</code>.</p>
<pre><code>APO: rebmu-wrap 'append/only [series value]
</code></pre>
<p>So that turns into effectively:</p>
<pre><code>APO: func [series value] [
    append/only series value
]
</code></pre>
<p><strong>Basically this was an incredibly weak way to save a few characters while making a partial specialization.</strong>  Some of its weaknesses:</p>
<ol>
<li>
<p>You still have to specify the number and names of arguments the specialization takes.</p>
</li>
<li>
<p>If you make a mistake at the time of definition (like mentioning an unavailable refinement) you don't get the error until the call.</p>
</li>
<li>
<p>The other refinements are missing from the wrapped function, e.g. you can't invoke <code>apo/part</code> or <code>apo/dup</code>.</p>
</li>
<li>
<p>You don't inherit anything about the original function's parameter conventions; e.g. if an argument were quoted you'd get the parameter name word you passed for it.</p>
</li>
<li>
<p>Performance-wise you generate a whole new function call...path evaluation...argument evaluation...</p>
</li>
<li>
<p>Your new function doesn't have any HELP... etc. etc.</p>
</li>
</ol>
<h2>How To Make This Better in Classical "Redbol"?</h2>
<p>Let's put yourself in the mind of someone thinking about how I was at that time, <em>who wanted to use the same strategy but merely address (1) and (2)</em>.  So to be able to write the slightly shorter hand:</p>
<pre><code>APO: rebmu-wrap 'append/only
APD: rebmu-wrap 'append/dup
APDP: rebmu-wrap 'append/dup/part
APPD: rebmu-wrap 'append/part/dup  ; ...etc.
</code></pre>
<p>This version of REBMU-WRAP would need to analyze the spec, presumably with WORDS-OF:</p>
<pre><code>r3-alpha&gt;&gt; words-of :append
== [series value /part length /only /dup count]
</code></pre>
<p>So you might try something like the following nightmare...<strong>which took me at least an hour to write and debug!</strong> (probably more like two, because of the glitch of trying to mutate the spec in place and needing to notice when the insertion position matches the position a refinement argument is being moved from):</p>
<pre><code>rebmu-wrap: func [refined [path!] /local spec body pos insert-pos item] [
    if not any-function? (action: get first refined) [
        do make error! "first element of path must refer to a function"
    ]
    spec: words-of :action
    body: reduce [refined]
    insert-pos: spec  ; find where refinement args should be inserted
    while [all [not tail? insert-pos not refinement? insert-pos/1]][
        append body insert-pos/1
        insert-pos: next insert-pos
    ]
    foreach refinement-name (next refined) [
        if not pos: find spec to-refinement refinement-name [
            do make error! "missing or duplicate refinement specified"
        ]
        take pos  ; drop refinement from spec
        while [all [not tail? pos not refinement? pos/1 pos != insert-pos]] [
             insert-pos: insert insert-pos item: take pos
             append body item
        ]
    ]
    func ?? spec ?? body
]
</code></pre>
<p>If you try this in R3-Alpha, yes it does indeed work for (1) and (2). I put in the probes so you can see the spec and body of the new function:</p>
<pre><code>r3-alpha&gt;&gt; apo: rebmu-wrap 'append/only
spec: [series value /part length /dup count]
body: [append/only series value]

r3-alpha&gt; apd: rebmu-wrap 'append/dup
spec: [series value count /part length /only]
body: [append/dup series value count]

r3-alpha&gt;&gt; apdp: rebmu-wrap 'append/dup/part
spec: [series value count length /only]
body: [append/dup/part series value count]

r3-alpha&gt;&gt; appd: rebmu-wrap 'append/part/dup
spec: [series value count length /only]
body: [append/part/dup series value count]
</code></pre>
<p>It gets a head-start on (3) by leaving the refinements that haven't been partially specialized on the spec, but they're ignored in the call.</p>
<h2>That's A Lot Of Work for Something That Still Sucks! <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">
</h2>
<p>When you think of everything it entails to get (3) and (4), you are going to either need to COMPOSE your invocation on each call -or- change methodology to use APPLY.  But even if you are aware of APPLY it doesn't make this a trivial exercise, and doesn't help with (5) or (6).</p>
<p><strong>...and this is why I never even tried to write such things (before)... instead trying to add core interpreter features for partial specialization.</strong></p>
<h2>The Happy New World of Partial Specialization <img src="https://forum.rebol.info/images/emoji/twitter/sun_with_face.png?v=9" title=":sun_with_face:" class="emoji" alt=":sun_with_face:">
</h2>
<p>In today's Ren-C, all you have to do is get a function as a path, and you have (1) (2) (3) (4) (5).</p>
<pre><code>ren-c&gt;&gt; ap: :append
 == #[action! {ap} [series value /part /dup /line /only]]

ren-c&gt;&gt; ap [a b c] [d e]
== [a b c d e]

ren-c&gt;&gt; apo: :append/only
== #[action! {apo} [series value /part /dup /line]]

ren-c&gt;&gt; apo [a b c] [d e]
== [a b c [d e]]

ren-c&gt;&gt; apo/dup [a b c] [d e] 2  ; e.g. demonstrating (3)
== [a b c [d e] [d e]]
</code></pre>
<p>The new function call is just as efficient as the original (you might think of it moreso since there's no path processing, e.g. <strong>apo</strong> is faster than invoking <strong>ap/only</strong>!)</p>
<p>You don't get the HELP inherited automatically (it has an associated cost), but there is a function that will do it if you want to... you say <strong>inherit-meta :apo :append</strong> and then <strong>help apo</strong> will have the help strings copied into its meta information.</p>
<p>So that's some assistance with (6), but do remember that it's not a perfect world when talking about how to automatically write meaningful adjusted help.  If any parameter descriptions refer to the argument you specialized out, it's no longer on the interface, so they may not make sense!</p>
<p><em>(Note: Now that refinements are their own arguments, you can't tell by parameter list alone if a refinement is a 0 or 1 arg case.  It's determined by the typeset: if the typeset is empty--no types accepted--it is a 0 arg refinement.  Something to ponder if this can be done better, but see all the other nice things...like caching the label of the function name for stack traces, etc.)</em></p>
<h2>So long, REBMU-WRAP...</h2>
<p>...but I wanted to write this up just to show a good example of how early experiences playing with Rebmu led me to question Rebol, and want to shore up its abilities.</p>
<blockquote>
<p>"Beware of the Turing tar-pit in which <strong>everything is possible but nothing of interest is easy</strong>."</p>
</blockquote> ]]></description>
        <link>https://forum.rebol.info/t/what-was-rebmu-wrap-and-why-we-no-longer-need-it/1795/1</link>
        <pubDate>Mon, 07 Mar 2022 06:06:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5787</guid>
      </item>
      <item>
        <title>About the Rebmu category</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Rebmu is a dialect for solving <a href="https://en.wikipedia.org/wiki/Code_golf">Code Golf challenges</a>, where the goal is to express the source code for solving a puzzle in the fewest characters of source code possible.  See the README here:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/hostilefork/rebmu" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://opengraph.githubassets.com/1d67e812b647b23547cabb9d53af90f2917089ce3978ae8f525e7b31a26b475d/hostilefork/rebmu" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/hostilefork/rebmu" target="_blank" rel="noopener">GitHub - hostilefork/rebmu: Microscopic Rebol Dialect ("mooshed") for Code Golf</a></h3>


  <p><span class="label1">Microscopic Rebol Dialect ("mooshed") for Code Golf</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Significant design points in Ren-C were inspired by wanting to make the implementation and bending of Rebmu more effective.</p> ]]></description>
        <link>https://forum.rebol.info/t/about-the-rebmu-category/1794/1</link>
        <pubDate>Mon, 07 Mar 2022 04:15:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5786</guid>
      </item>
      <item>
        <title>(No) Alternative Local Notation in the Func Spec Dialect</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h1>TL;DR:</h1>
<p>When using a spec in FUNCTION (remember <a href="https://forum.rebol.info/t/abbreviations-as-synonyms/1211">FUNC is a synonym now</a>):</p>
<ul>
<li>
<p><strong>if you want to specify locals you say <code>[... &lt;local&gt; x y z ...]</code></strong> (/LOCAL is a normal refinement like any other in Ren-C.</p>
</li>
<li>
<p><strong>there is no longer a datatype-based shortcut for locals as a way to save the trouble of finding <code>&lt;local&gt;</code> in specs and inserting at the right point</strong>.</p>
<ul>
<li>
<p>Once you could toss random SET-WORD!s anywhere in a spec, like <strong><code>[a b c: d]</code></strong> and it would act like <strong><code>[a b d &lt;local&gt; c]</code></strong>.  This feature was to make higher-level function generators easier to write, to save them from having to find <code>&lt;local&gt;</code> in the spec...add it if not there...and do everything at the right point.</p>
</li>
<li>
<p>When multi-returns began using SET-WORD! this was changed to be <strong><code>[a b .c d]</code></strong> just to move it out of the way.</p>
</li>
<li>
<p>What this was trying to achieve has been obsoleted by newer and better methods, which actually entwine with the idea that <em>you should never know what local variables a function you are composing on top of has</em>.</p>
</li>
</ul>
</li>
</ul>
<h1>More Explanation</h1>
<p>Long ago, when I was looking at some of the higher-level function generators (like FUNCT on top of FUNCTION) I was struck by how tricky it was to get the adaptations written correctly.</p>
<p>We can look at <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28">FUNCT from R3-Alpha</a> and see some of that complexity, even just to try and add some local variables.</p>
<p>It had to check to see if there was already a /LOCAL, and add it if not:</p>
<pre><code>; Copy the spec and add /local to the end if not found
unless find spec: copy/deep spec /local [append spec [
	/local ; In a block so the generated source gets the newlines
]]
</code></pre>
<p><em>Bear in mind that specifying /LOCAL twice would be a duplicate refinement error, and /LOCAL did not have to be at the end of a spec.</em>  Things were tricky, because there were "private refinements".  These refinements were an artifact of how help worked--they were not shown--but weren't actually private.</p>
<p>So you had to be careful, to insert things after local but not after the private refinements, or they'd be arguments to those refinements:</p>
<pre><code>; Collect all set-words in the body as words to be used as locals, and add
; them to the spec. Don't include the words already in the spec or object.
insert find/tail spec /local collect-words/deep/set/ignore body either with [
   ...
]
</code></pre>
<p><strong>I wanted to take better advantage of datatypes, so I adopted the TAG! <code>&lt;local&gt;</code> in the spec so that /LOCAL could be used like any other refinement... e.g. GET-TIME/LOCAL or GET-LANGUAGE/LOCAL.</strong>  This is an idea preserved to this day, and I think it's a better move (though LET has been developing as the more viable general option for making locals).</p>
<p>But another concept I had was to make SET-WORD! in the dialect be another way to put a local anywhere in the spec.  So if you were writing code munging function specs you could just throw local variables on:</p>
<pre><code>foo: func [a b c: d] [...]

&lt;= equivalent to =&gt;

foo: func [a b d &lt;local&gt; c] [...]
</code></pre>
<p>But the idea was that <code>&lt;local&gt;</code> itself was transformed into the SET-WORD!, so the only language you needed to understand was that of the SET-WORD!s:</p>
<pre><code>&gt;&gt; foo: func [a b d &lt;local&gt; c] [...]

&gt;&gt; spec-of :foo
== [a b d c:]
</code></pre>
<p>When multi-returns came about and took SET-WORD!s, this idea was bumped around to be done with TUPLE!s with leading blanks like <strong>.c</strong></p>
<h1><a href="https://www.youtube.com/watch?v=2q9MaEKHakY">... but Everything Changed <img src="https://forum.rebol.info/images/emoji/twitter/robot.png?v=9" title=":robot:" class="emoji" alt=":robot:"> ...</a></h1>
<p>I've been marching toward something more like <a href="https://forum.rebol.info/t/seeing-all-action-s-as-variadic-frame-makers/1002">"Seeing all ACTION!s as Variadic Frame Makers?"</a></p>
<p>Function composition tools operate on FRAME!s using tools like ADAPT, SPECIALIZE, AUGMENT, ENCLOSE, etc.  There is no API for getting at the locals <em>because when you build on top of a function you can't see them, they're not part of the interface...they are sealed inside.</em>   This is good because you can build on top of a function without worrying about the details of the parts from which it was composed.</p>
<p>The migration to where <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">refinements are their own arguments</a> has been key in making function calls easier to model as an object.</p>
<p><strong>In this world we do not need a representation for locals in the spec to add them...because the entire concept of how FUNCT was written is gone.</strong>  If you want to add locals you use tools like AUGMENT and don't worry about it.</p>
<h1>There Are Still (many) Problems To Solve</h1>
<p>Consider that you can do something like ask for a FRAME! of something like APPEND, then enumerate the keys:</p>
<pre><code>&gt;&gt; f: make frame! :append

&gt;&gt; for-each key f [print mold key]
return
series
value
part
dup
line
only
</code></pre>
<p>There are a lot of questions to answer about the unique nature of the main function's RETURN.  Although other multi-returns have to be on the interface, should you be able to put a variable in that return?  Consider that you could use multi-return with append today:</p>
<pre><code>&gt;&gt; [var]: append "abc" "d"
== "abcd"

&gt;&gt; var
== "abcd"
</code></pre>
<p>So should you be able to preload the frame with <strong>f.return: 'var</strong> and get the same effect?  This is competitive with the notion that RETURN is a concept of a local variable to the action, that holds an action that returns specifically from that action... so the responsibilities are somewhat murky for this distinguished result.</p>
<p>But we can also see that if we only look at object keys, we don't know which things are refinements or which are not...if they are refinements we don't know if they are 0-arg or 1-arg form, we don't know what types they take... or are they <code>&lt;end&gt;</code>-able.  <strong>I believe getting at this information should be done by means other than analysis of some spec block you filter out for description strings/etc. so that is on the right track.</strong>  But it's still a long road.</p> ]]></description>
        <link>https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793/1</link>
        <pubDate>Sat, 05 Mar 2022 20:33:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5785</guid>
      </item>
      <item>
        <title>Could strings have context?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Red is continuing their investment in a kind of string interpolation:</p>
<p><a href="https://github.com/red/red/pull/5085">https://github.com/red/red/pull/5085</a></p>
<p>They are defaulting to parentheses instead of $, and escaping parentheses with backslash <code>(\on the inside, curiously\)</code></p>
<p>It's worth thinking about what a good default is, though ultimately I think it should be customizable (as with historical REWORD).  I had been considering plain parentheses for the same reasons at first, but leaned to $ just because of how popular it is in other languages for interpolation.</p>
<p>My concept is different because it is not a hardcoded preprocessor behavior, but making binding information available on strings as a map of words to values.  See <a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">"Rebol and Scopes: Well, why not?"</a> for thoughts on that distinction and the challenges it presents.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-strings-have-context/587/13</link>
        <pubDate>Wed, 23 Feb 2022 19:18:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5784</guid>
      </item>
      <item>
        <title>Shall we CONTINUE?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1790">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>How about WHILE or REPEAT or FOR-EACH? If we wanted it to be novel, it could say "don't change the pending overall result from whatever the last loop iteration would have returned":</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
]
== 20
</code></pre>
<p>Although I like that in theory, it would break the loop composition rules unless loops were allowed to be invisible. :-/</p>
</blockquote>
</aside>
<p>So what I'd missed here in the composition rules is a wrinkle that if you try the FOR-BOTH construct and the second list is <em>empty</em>, then you wind up overwriting the last result from the first list.  It creates the same kind of problem as if you wanted a CONTINUE with ~none~ to preserve the last value.</p>
<p>The tool to tackle this would be something that vanishes plain ~none~ after a META, or a version of meta that elides ~none~ isotopes.  So:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each :var blk1 body
        none-to-void/meta meta for-each :var blk2 body
    ]
]
</code></pre>
<p>or:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each :var blk1 body
        meta/none-to-void for-each :var blk2 body
    ]
]
</code></pre>
<p>Naming is open to discussion there.  Could be META/VANISHABLE or somesuch.  You can also make it symmetrical by doing it for both loops, it just doesn't matter because the ALL will give ~none~ isotope if the body turns up empty:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta/vanishable for-each :var blk1 body
        meta/vanishable for-each :var blk2 body
    ]
]
</code></pre>
<p>The consequence of this, though, is that you can't force a ~none~ isotope return result from a loop once the body has returned any non-~none~-isotope value.  You'd have to do something like a CATCH with a THROW of ~none~.</p>
<p>I can't offhand tell you if that's annoying or a feature.  You could always META your body result and UNMETA it outside the loop.</p> ]]></description>
        <link>https://forum.rebol.info/t/shall-we-continue/1790/2</link>
        <pubDate>Wed, 23 Feb 2022 16:57:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5783</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1792">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think if you look at the FOR-BOTH example in Ren-C, it really tells a story that isn't there in historical Rebol.</p>
</blockquote>
</aside>
<p>Hmmm, I realize there is a deficiency here...</p>
<pre><code> &gt;&gt; for-both x [1 2] [] [print ["x is" x], x * 10]
 x is 1
 x is 2
 == ~none~  ; isotope
</code></pre>
<p>What I want is for that to be 20.</p>
<p>For that to happen, the second FOR-EACH would have to vaporize somehow.</p>
<p>This means either the second clause would be invisible -or- something about the nature of ALL would choose to throw out a product.</p>
<p>There is NONE-TO-VOID but then you get in the trap of what if the second loop ran but intentionally produced a ~none~.  I guess we could say that ~none~ is skipped, which would manifest something along the lines of:</p>
<pre><code>&gt;&gt; for-each x [1 2] [
      if x = 2 [~none~] else [x * 10]
  ]
 == 10
</code></pre>
<p>Basically saying that "none isotopes don't count".  If that were the policy then turning nones into voids so they vanish in aggregating constructs would be considered acceptable.</p>
<p>I still maintain this is getting closer.  Just have to keep looking at it.</p> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/5</link>
        <pubDate>Wed, 23 Feb 2022 07:30:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5782</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="rgchris" data-post="3" data-topic="1792">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>which <em>more solidly designed language</em> used by non-crackpots are people more likely to opt for vs. popular languages</p>
</blockquote>
</aside>
<p>I'd guess the sort of competition in the homoiconic space I'd have in mind would be people using things like Clojure (or <a href="https://clojurescript.org/">ClojureScript</a>).  But I think if you look at things like Julia or Go, there are some real strengths there.  And Rust and Haskell are good projects for those who want to step away from popularity but get rigor as a benefit.</p>
<blockquote>
<p>The language itself wasn't <em>composable</em> the way one might like languages to be</p>
</blockquote>
<p>I think if you look at the FOR-BOTH example in Ren-C, it really tells a story that isn't there in historical Rebol.</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each :var blk1 body
        meta for-each :var blk2 body
    ]
]
</code></pre>
<p>It's just across the board more solid.  Not only does definitional RETURN mean that a return in the body will act as the person using the loop would expect, but BREAK and CONTINUE will behave correctly...returning the aggregate loop result.</p>
<pre><code> &gt;&gt; for-both x [1 2] [3 4] [print ["x is" x], x * 10]
 x is 1
 x is 2
 x is 3
 x is 4
 == 40

&gt;&gt; for-both x [1 2] [3 4] [print ["x is" x], if x = 2 [break]]
x is 1
x is 2
; null

&gt;&gt; for-both x [] [] [print ["x is" x], &lt;result&gt;]
== ~none~  ; isotope
</code></pre>
<p>All the ideas come together here.  With META ~unset~ isotopes and ~none~ isotopes etc. become plain BAD-WORD!s which are truthy, NULL goes to NULL, everything else (including plain BAD-WORD!) becomes one level more quoted than it was, and all QUOTED! (including a quoted #[false]) are truthy.  NULL is reserved uniquely for the signal of BREAK, and so everything... works.</p> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/4</link>
        <pubDate>Tue, 22 Feb 2022 20:24:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5781</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>Not disputing this overview <em>per se</em>‚Äîhowever these statements aren't immediately elucidated without some digging. Is there a succinct citation for each of them?</p>
<ul>
<li>
<p>When serious language theorists look at Rebol, they notice it is riddled with design holes</p>
</li>
<li>
<p>The language itself wasn't <em>composable</em> the way one might like languages to be</p>
</li>
</ul>
<hr>
<p>Would echo (I think) <a class="mention" href="/u/iarnold">@iArnold</a>'s sense on 3‚Äîwhich <em>more solidly designed language</em> used by non-crackpots are people more likely to opt for vs. popular languages which may have the same or worse design issues but have the security blanket implied by that popularity?</p> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/3</link>
        <pubDate>Mon, 21 Feb 2022 22:21:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5780</guid>
      </item>
      <item>
        <title>Should END-able constructs all use ^META parameters?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1783">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Killing off <code>&lt;end&gt;</code> as a core parameter flag would simplify things...</p>
</blockquote>
</aside>
<p>Trying to do this creates an unappealing situation, because it means all ^META parameters start accepting end conditions by default.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>That's a bit of an overreach.  Just because you say you want an argument to be passed via meta protocol, having to handle the ~void~ case of there being nothing there becomes a hassle.  Labeling things <code>&lt;end&gt;</code> is much more convenient, otherwise you will end up with a lot of accidental tolerance of ends...producing particularly troublemaking invisibility signals.</p>
<p>Nevertheless, I think we can say that if you care about the difference between an end and an evaluated NULL then we now have an answer: an endable ^META parameter which receives ~void~ can only get that if at an end.  With what I observed about <strong>^(...)</strong> I think we can say there are no "supermeta" parameters... so the only way you will get a ~void~ indication will be if the evaulation reaches an END (or a comma).</p>
<p>So "endish nulls" are dying, which should get rid of bugs like this:</p>
<aside class="onebox githubissue">
  <header class="source">
      <a href="https://github.com/metaeducation/ren-c/issues/1129" target="_blank" rel="noopener">github.com/metaeducation/ren-c</a>
  </header>
  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Issue">
	  <svg width="60" height="60" class="github-icon" viewbox="0 0 14 16" aria-hidden="true"><path d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/metaeducation/ren-c/issues/1129" target="_blank" rel="noopener">END being tolerated when it shouldn't</a>
    </h4>

    <div class="github-info">
      <div class="date">
        opened <span class="discourse-local-date" data-format="ll" data-date="2021-07-06" data-time="03:35:27" data-timezone="UTC">03:35AM - 06 Jul 21 UTC</span>
      </div>


      <div class="user">
        <a href="https://github.com/hostilefork" target="_blank" rel="noopener">
          <img alt="hostilefork" src="https://avatars.githubusercontent.com/u/20440?v=4" class="onebox-avatar-inline" width="20" height="20">
          hostilefork
        </a>
      </div>
    </div>
  </div>
</div>

<div class="github-row">
  <p class="github-content">&gt;&gt; collect [keep/line [a b c] keep/dup/line [d e f]]
== [
 a b c
 d e f
]
Is missing /DUP count, this...</p>
</div>

<div class="labels">
    <span style="display:inline-block;margin-top:2px;background-color: #B8B8B8;padding: 2px;border-radius: 4px;color: #fff;margin-left: 3px;">type.bug</span>
</div>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
 ]]></description>
        <link>https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783/2</link>
        <pubDate>Sun, 20 Feb 2022 17:34:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5779</guid>
      </item>
      <item>
        <title>Pure vs. Impure Invisibility: Do We Need Both?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1782">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Pondering the potential implications of this form of thinking, it would mean there wouldn't be a form of invisibility that could beat a ^META operation:</p>
<pre><code>&gt;&gt; z: ^ comment ["hi"] ~something~
== ~something~  ; isotope

&gt;&gt; z
== ~void~
   ; ^-- the COMMENT was seen by the ^META, instead of bypassed
   ; (today COMMENT's status as a purely invisible construct means you
   ; would get Z as a non-isotope ~something~)
</code></pre>
</blockquote>
</aside>
<p>It occurs to me that <strong><code>^(...)</code></strong> could be leveraged as a defeat for this.</p>
<pre><code>&gt;&gt; z: ^ comment "hi" 1 + 2
== 3

&gt;&gt; z
== 3

&gt;&gt; z: ^(comment "hi") 1 + 2
== 3

&gt;&gt; z
== ~void~
</code></pre>
<p>Additionally, multi-returns with ^META could defeat invisibility, because multi-return is a syntactic convenience that applies to one-and-only-one function.  So if you meta its result, it can't vanish.</p>
<pre><code>&gt;&gt; [^x]: comment "hi" 1 + 2
== 3

&gt;&gt; x
== ~void~
</code></pre>
<p>This might be enough, actually!</p> ]]></description>
        <link>https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782/2</link>
        <pubDate>Sun, 20 Feb 2022 02:58:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5778</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>3 is also dealing with the shortcomings of the alternatives like there are ugly syntax and dependency hells.</p>
<p>Besides there are holes everywhere, they are more hidden or plugged with another library you do not control.<br>
And most important there is no fun and nothing to learn from option 3 and that is also a rectification for following option 2. We need to remember the state original Rebol was at before Red project started, it was not open sourced and it was abandonware.<br>
The effort of Oldes is imo to be placed as making it work for personal use mainly, like the World language and Boron.<br>
Kaj"s Meta is an interesting alternative bringing Rebol back to some computing roots to get the basics right, without need for fixing R3 or Red designs.</p> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/2</link>
        <pubDate>Sat, 19 Feb 2022 22:16:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5777</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I wrote this to someone in a GitHub issue and thought it was pretty salient:</p>
<blockquote>
<p>What has drawn people to Rebol historically has varied. But a large number who praised it and used it were less interested in the language itself, rather the properties of the executable. It was small, and you could run on any OS without installing anything else...it came with a GUI built in.</p>
<p>But when serious language theorists look at Rebol, they notice it is riddled with design holes. The language itself wasn't <em>composable</em> the way one might like languages to be: mixing constructs in new ways that weren't specifically accounted for never worked. It was more like a "scriptable app" that had a few features that pleased its userbase...and had to be extended by the designer every time a new need came up.</p>
<p>So put briefly: If you don't understand what these holes are, then you won't appreciate the many issues that Ren-C is trying to solve. Starting from scratch inevitably makes the same mistakes.</p>
<p>Once you know that historical Rebol was fundamentally broken, there are basically 3 choices:</p>
<ol>
<li>Inventory and address the holes one at a time and try to fix or mitigate them</li>
<li>Ignore the holes and just hope that if you add enough features and integration no one will notice</li>
<li>Turn away and run from the crackpots using it, and work with a more solidly designed language</li>
</ol>
<p>(1) is Ren-C's hard-chosen path. Energy is spent on identifying certain patterns in source that users <em>must</em> be able to write and have work, if the language is to justify its existence at all. While it would be nice if stack traces were beautiful and if building the sources was 100% easy, all of that would be meaningless if the punch line was <em>"oh, and the language this is all supporting doesn't actually work"</em></p>
<p>(2) is chosen by people like Red and <a href="https://github.com/Oldes/Rebol3">Oldes's branch of R3-Alpha</a>, as well as some clones that have popped up over the years.</p>
<p>(3) is probably the most sensible choice, but if I didn't think there was some promise in the language I wouldn't be pursuing (1).</p>
</blockquote> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/1</link>
        <pubDate>Fri, 18 Feb 2022 19:37:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5776</guid>
      </item>
  </channel>
</rss>

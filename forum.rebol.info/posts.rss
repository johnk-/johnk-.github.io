<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>Console Treatment of VOID vs. NONE (isotopic void)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Rebol2 and Red both have a console property that when the console sees an UNSET!, it prints nothing:</p>
<pre><code>&gt;&gt; block: reduce [&lt;a&gt; #[unset!] &lt;b&gt;]
== [&lt;a&gt; unset &lt;b&gt;]

&gt;&gt; first block
== &lt;a&gt;

&gt;&gt; second block

&gt;&gt; third block
== &lt;b&gt;
</code></pre>
<p>This doesn't provide the best grounding in the console, especially considering that in their world an UNSET! is a reified value that can be found in a block.</p>
<p>However, returning an UNSET! is how functions like PRINT avoid outputting anything with <strong><code>==</code></strong> in the console:</p>
<pre><code>rebol2&gt;&gt; print "Notice no == result"
Notice no == result

rebol2&gt;&gt; type? print "Test"
Test
== unset!
</code></pre>
<h2>
<a name="but-what-result-should-ren-c-suppress-1" class="anchor" href="https://forum.rebol.info#but-what-result-should-ren-c-suppress-1"></a>But What Result Should Ren-C Suppress?</h2>
<p>Ren-C has the concept of VOID which has an isotopic form known as "NONE", that is used as the unfriendly contents of an unset variable.</p>
<p>For educational purposes, I feel it makes the most sense to have voids not print anything, and nones print out the standard isotopic form:</p>
<pre><code>&gt;&gt; void

&gt;&gt; quote void
== '

&gt;&gt; quasi void
== ~

&gt;&gt; ~
== ~  ; isotope
</code></pre>
<p>Looking at this it might seem to make a lot of sense to have functions like PRINT and HELP return VOID.</p>
<p>But as I explain in <a href="https://forum.rebol.info/t/why-doesnt-print-return-void-or-vaporize-via-nihil/1466">"Why doesn't PRINT return VOID or NIHIL"</a>, there is a bit of a pitfall.  Voids are friendly in terms of opting out of things:</p>
<pre><code>&gt;&gt; append [a b c] print "If PRINT returned void..."
If PRINT returned void...
== [a b c]
</code></pre>
<p><em>This seems too friendly to me.</em>  There's another possibility of returning NIHIL, which would be void if no other expressions were in play...and would prohibit use as an argument.  But it would let previous results fall out:</p>
<pre><code>&gt;&gt; print "If PRINT returned nihil"
If PRINT returned nihil

&gt;&gt; append [a b c] "If PRINT returned void..."
If PRINT returned void...
** Error: APPEND is missing its VALUE argument

&gt;&gt; 1 + 2 print "If PRINT returned nihil..."
== 3
</code></pre>
<p>So returning NONE makes the most sense to me...it has the right amount of ornery-ness to my tastes:</p>
<pre><code>&gt;&gt; print "Mechanically this works best"
Mechanically this works best
== ~  ; isotope
</code></pre>
<p>But it's ugly to have that <strong>== ~  ; isotope</strong> after every HELP or PRINT or other function.</p>
<p>Previously I had it so that voids printed out a comment, and nones printed nothing:</p>
<pre><code>&gt;&gt; ~

&gt;&gt; void
; void
</code></pre>
<p>But this is making the console pretty at the cost of obfuscation.  I'll point out that the web console can make the <strong>== ~  ; isotope</strong> some kind of light gray so it's less noticeable.</p>
<h2>
<a name="people-always-bend-to-get-what-they-want-2" class="anchor" href="https://forum.rebol.info#people-always-bend-to-get-what-they-want-2"></a>People Always Bend To Get What They Want...</h2>
<p>I might not like the idea of returning a "friendly" void to get invisibility, and try forcing everyone to use NONE for console commands.  But if they see VOID/NIHIL as the better way to get what they want, they'll choose that in their own commands to cut down on the clutter.</p>
<p>It seems there's at least a rationale here for why isotopic void would output nothing, while void would give a comment.  If you consider the fact that isotopic void is "less than" a void, then giving it the special nothing-printed status makes some amount of sense.</p> ]]></description>
        <link>https://forum.rebol.info/t/console-treatment-of-void-vs-none-isotopic-void/2045#post_1</link>
        <pubDate>Thu, 03 Aug 2023 22:48:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6667</guid>
      </item>
      <item>
        <title>Could we replace PARSE&#39;s OPT with TRY ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This definition makes it a candidate for being a very literate alternative to OPT in parse!</p>
<pre><code>&gt;&gt; parse "aaaccc" [some "a", try some "b", some "c"]
== "c"
</code></pre>
</blockquote>
</aside>
<p>I'd been letting this turn over in my head a bit before committing to it <em>(and deprecating OPT in the main UPARSE combinator set...though it would be defined in Redbol's parse a.k.a. PARSE2)</em>.</p>
<p>I started going through replacing it.  For the most part I think it reads much smoother, yet there was a little bit of a speedbump when I saw it used with literals.</p>
<p>For example, changing:</p>
<pre><code>parse url ["http" opt "s" "://gitlab.com/" ...]
</code></pre>
<p>To:</p>
<pre><code>parse url ["http" try "s" "://gitlab.com/" ...]
</code></pre>
<p>TRY feels imperative...like it is telling you to attempt to run some function.  While OPT feels more declarative... this is a thing that may or may not be there.</p>
<p>As it happens, it really is imperative: you are running a function... "s" produces a combinator.  That combinator can be redefined in parse variants via the combinator map.</p>
<p>Yet it still felt a bit strange to me at first to say you were "trying S".</p>
<p><strong>I think this is just a lack of familiarity, and it will seem more natural with time.</strong>  Even looking at it now, I think the OPT is ugly, and I can rationalize why it's even probably better to have people think of it as "trying S".</p>
<aside class="quote no-group" data-username="gchiu" data-post="3" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/gchiu/40/22_2.png" class="avatar"> gchiu:</div>
<blockquote>
<p>If you wanted one could try <code>MAYBE</code></p>
</blockquote>
</aside>
<p>I did give this a shot... and it can be argued to be the most coherent choice in reading:</p>
<pre><code>parse url ["http" maybe "s" "://gitlab.com/" ...]
</code></pre>
<p>But its alignment with how MAYBE is used in the language to produce voids and invisibility is not clear.  having MAYBE return null instead of void feels confusing.  Whereas TRY will align more closely.</p>
<p><strong>It feels safe to say that TRY is better than OPT when you look at the big picture.</strong>  I don't think having synonyms in the default combinator set is a good idea, and so that rules out OPT.  Perhaps MAYBE could be a combinator if we figure out what the difference is in a way that aligns with its other uses.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-we-replace-parses-opt-with-try/1888#post_5</link>
        <pubDate>Thu, 03 Aug 2023 11:38:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6666</guid>
      </item>
      <item>
        <title>Is The Script Compression Feature Necessary?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>R3-Alpha introduced the option that when you SAVE a script, you can ask that it be compressed.</p>
<p>It doesn't compress the header...just the body of the script.  There were two options for how this body could be compressed after the header: either as a Base64 BINARY literal ("script compression"), or directly as gzip'd bits ("raw compression").</p>
<p>As an example:</p>
<pre><code>&gt;&gt; data: save/compress blank [1 &lt;two&gt; "three"] 'script
== #{
    5245424F4C205B0A202020204F7074696F6E733A205B636F6D70726573735D0A
    5D0A3634237B483473494141414141414141436A4E5573436B707A3764545543
    724A4B45704E56654943414E425746325951414141417D
}

&gt;&gt; print as text! data
REBOL [
     Options: [compress]
]
64#{H4sIAAAAAAAACjNUsCkpz7dTUCrJKEpNVeICANBWF2YQAAAA}

&gt;&gt; [body header]: load data
== [1 &lt;two&gt; "three"
]

&gt;&gt; body
== [1 &lt;two&gt; "three"
]

&gt;&gt; header
== make object! [
    Title: "Untitled"
    File: ~null~
    Name: ~null~
    Type: 'script
    Version: ~null~
    Date: ~null~
    Author: ~null~
    Options: [compress]
    Description: ~null~
]
</code></pre>
<h2>
<a name="rebol2-didnt-have-it-red-doesnt-have-it-1" class="anchor" href="https://forum.rebol.info#rebol2-didnt-have-it-red-doesnt-have-it-1"></a>Rebol2 Didn't Have It, Red Doesn't Have It...</h2>
<p>Arguments that it helps with transmitting over networks don't hold up much these days, because the HTTP protocol itself does compression.</p>
<p>Plus, keeping scripts in compressed form is an annoying form of opaqueness on a language that's supposed to be about simplicity.</p>
<p>I've kept it around just because there were tests for it, and it exercised compression code (including showcasing a really bad design method of trying to decompress garbage to see if it was the raw compressed form, causing a crazy memory allocation).  But I'm not sure what the compelling use case for this feature is.</p> ]]></description>
        <link>https://forum.rebol.info/t/is-the-script-compression-feature-necessary/2044#post_1</link>
        <pubDate>Thu, 27 Jul 2023 23:20:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6665</guid>
      </item>
      <item>
        <title>Skinning REPLACE with Red&#39;s String PARSE Hack</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Red made an unusual choice with their implementation of REPLACE when you use a pattern that's a block with a string.  Instead of trying to stringify the block, <a href="https://github.com/red/red/blob/40096dd12ca9c3b9b47e9eaa995d425b9faf620b/tests/source/units/replace-test.red#L72">they assume it's a PARSE rule</a>:</p>
<pre><code>red&gt;&gt; replace/case/all "aAbbabAAAa" ["Ab" | "Aa"] "-"
== "a-babAA-"
</code></pre>
<p>It seems like a bad idea to make the choice to do this based on the input type.  What if you actually want to do this when the input is a BLOCK!?  I'd prefer something like <strong>parse-replace</strong> <em>(or if we ever allow the same word to be a function and a module, maybe <strong>parse.replace</strong>)</em>.</p>
<p>But honestly, I think that the answer is just to keep pushing on UPARSE itself to be slick enough that you wouldn't feel the need to reach for a shorthand like this.  It's pretty easy to write as is:</p>
<pre><code>&gt;&gt; parse/case "aAbbabAAAa" [
       try some thru [change ["Ab" | "Aa"] ("-")]
       return &lt;input&gt;
   ]
== "a-babAA-"
</code></pre>
<p>That's probably reaching the limits of how short UPARSE can do an equivalent.  Yet it's more powerful if you want to deviate or customize it, so I would reach for this more often than a limited REPLACE.</p>
<h2>
<a name="still-ren-c-does-backflips-and-lets-you-have-it-your-way-1" class="anchor" href="https://forum.rebol.info#still-ren-c-does-backflips-and-lets-you-have-it-your-way-1"></a>Still, Ren-C Does Backflips And Lets You Have It Your Way</h2>
<p>So you should be able to adapt REPLACE to have Red's behavior if you want it.</p>
<p>Super easy.  Barely an inconvenience!</p>
<pre><code>replace: enclose :lib.replace func [
     f [frame!]
     &lt;local&gt; head tail rule
][
    if not all [
        match [text! binary!] f.target
        block? f.pattern
    ][
        return do f  ; use normal REPLACE semantics
    ]

    rule: if activation? :f.replacement '[  ; function generates replacement
        head: &lt;here&gt;
        change [f.pattern, tail: &lt;here&gt;] (
            apply/relax :f.replacement [const head, const tail]
        )
    ] else '[  ; replacement can be used as-is
        change f.pattern (f.replacement)
    ]

    apply :parse [/case f.case, f.target [
        while [thru rule] (
            if not f.all [return f.target]
        )
        to &lt;end&gt;
    ]]
    return f.target
]
</code></pre>
<h2>
<a name="it-worked-the-first-time-i-ran-it-2" class="anchor" href="https://forum.rebol.info#it-worked-the-first-time-i-ran-it-2"></a>It worked the first time I ran it!</h2>
<p>There's so much interesting stuff going on here that it's hard to list it all. I can quickly hit some high points.</p>
<ul>
<li>
<p>You don't have to repeat the interface of REPLACE.  This is an ENCLOSE, so it just passes the frame built for LIB.REPLACE to the wrapper and lets it choose whether to run that frame as-is (or modified), or do its entirely own thing.</p>
</li>
<li>
<p>It uses the <a href="https://forum.rebol.info/t/the-cool-new-repurposing-of-while-in-parse/1875">kickass new arity-2 WHILE combinator</a> to great effect...simply iterating over the replacement rule.</p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">Modern kickass APPLY</a> for PARSE lets you put arguments in any order, and does refinements by name... here we put /CASE first because it's clearer... then passing the series and the rule.</p>
</li>
<li>
<p>It doesn't just run isotopic actions if they are passed, but it also optionally passes them the head and tail of where in the input is matched.  If the function is arity-1, it just receives the head.  If it's arity-0, it doesn't receive either.  (This is due to APPLY's /RELAX that tolerates too many arguments.)</p>
</li>
</ul>
<p>I wrote a little demo of the fancier function invocation:</p>
<pre><code>&gt;&gt; data: "(real)1020(powerful)0304(magic)"

&gt;&gt; collect [
       replace/all data [between "(" ")"] func [head tail] [
            let item: copy/part head tail
            keep item
            if item = "(powerful)" [item: copy "(ren-c)"]
            return uppercase item
        ]
    ]
== ["(real)" "(powerful)" "(magic)"]

&gt;&gt; data
== "(REAL)1020(REN-C)0304(MAGIC)"
</code></pre>
<p>Not only that, but the references to the head and tail of the match are CONST...which prevents the replacement function from messing up the in-progress iteration of the series where the replace is happening.  It only achieves modification by means of what result it synthesizes.</p>
<p>How about that?</p>
<p>cc: <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a>, <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>, <a class="mention" href="https://forum.rebol.info/u/johnk">@johnk</a></p> ]]></description>
        <link>https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043#post_1</link>
        <pubDate>Thu, 27 Jul 2023 06:23:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6664</guid>
      </item>
      <item>
        <title>The Naming of NULL vs. The &quot;Meaningless&quot; Value</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><strong>2023 UPDATE</strong>: Significant changes to the system ushered in by isotopes mean that true vaporization is actually accomplished through "empty isotopic blocks", which are called NIHIL.  VOID expressions are the product of failed conditionals, and they often vanish but can be stored in variables.</p>
<p>Explaining that design and why the parts are all necessary is beyond the scope of this historical post.  See <a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">"Invisibility Reviewed Through Modern Eyes"</a> for the rationale... and I think it holds up!</p>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="5" data-topic="1427">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>You're right in that I need to grapple with code...</p>
</blockquote>
</aside>
<p>Where things stand now hopefully performs to your expectations.  Voids have no representation and there's nothing to display in the console.  <strong>do []</strong> gives back voids, and void vanishes in REDUCE and acts as a no-op for an APPEND.  It is also the result of failed conditionals, and vaporizes in COMPOSE/etc.</p>
<pre><code>&gt;&gt; void

&gt;&gt; reduce [1 + 2 do [] 10 + 20]
== [3 30]

&gt;&gt; append [a b c] void
== [a b c]

&gt;&gt; if false ['b]

&gt;&gt; compose [a (if false ['b]) c]
== [a c]
</code></pre>
<p>Because it has no representation, the quoted form of void is simply a lone apostrophe.  And its quasi form is just a lone tilde.  <em>(See the post about <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/3">three single-character intents</a> for deeper discussion.)</em></p>
<pre><code>&gt;&gt; quote void
== '

&gt;&gt; '

&gt;&gt; append [a b c] '
== [a b c]

&gt;&gt; quasi void
== ~
</code></pre>
<p>Then there's the isotopic form...we call this NONE for convenience, and it is the contents of an unset variable:</p>
<pre><code>&gt;&gt; ~
== ~  ; isotope (a "none")

&gt;&gt; x: ~  ; will unset the variable
== ~  ; isotope
</code></pre>
<p>NULL is an isotopic form of the WORD! "null".  In the API this is represented as the 0 pointer and does not require having its handle released, so it is like C's NULL.  It is used as an "ornery nothing"...but unlike NONE it doesn't indicate an unset variable, so it can be fetched by normal WORD! access.  The system accomplishes elegant error locality using the VOID-in-NULL-out protocol in many places, which hinges on the MAYBE function that converts NULL to void.</p>
<pre><code>&gt;&gt; third [d e]
== ~null~  ; isotope

&gt;&gt; append [a b c] third [d e]
** Error: Cannot put ~null~ isotopes in blocks

&gt;&gt; maybe third [d e]

&gt;&gt; append [a b c] maybe third [d e]
== [a b c]
</code></pre>
<p>Then NIHIL is an empty isotopic block...which is a parameter pack with no values in it.  This unstable isotopic form can't be stored in variables or API handles, and can only be handled in its meta form.  <em>(Again, beyond the scope of this thread...so <a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">read the post on modern invisibility</a> to understand why the shade of distinction from VOID is justified.)</em></p>
<aside class="quote no-group" data-username="rgchris" data-post="5" data-topic="1427">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I'd still lean toward my own sense of what I'd consider (or feel) my primary definitions of NULL and VOID—where NULL is the product of nothing and VOID is the realm of emptiness—a place with no beginning or end, or indeed no definition (<em>void</em> as in <em>voided checks</em> is not the first meaning that comes to mind).</p>
</blockquote>
</aside>
<p>Something that might seem counter-intuitive is that VOID feels kind of "further out" than NULL... given it has absolutely no representation.  Yet it's tolerated as inputs more places to indicate "intentional nothingness".  It's the real deal of nothing.</p>
<p>But then <em>isotopic</em> VOID comes in to be the "bad check".  A variable holding it is considered to not be set, and it trips up access via WORD!.</p>
<p>NULL sits somewhere between.  It's a state you put things in when you want to be able to see if it's good or not (falsey)...yet most non-conditionals trip up on it when you try to use it as an argument.  Easy to test for via WORD!; ornery to use most places.</p>
<p>All three of these states can be held in variables or API handles.  And then pure invisibility is built upon a weirder mechanic of NIHIL, which can only be handled by ^META-aware code.  You don't need to know how it works to use it (the implementations of COMMENT and ELIDE are trivial in both the main language and UPARSE combinators).  But the mechanics are there required to implement them.</p>
<p><strong>I'm happy to address questions about this, and I have answers for a whole slew of complex things.</strong>  UPARSE has been the crown jewel of showing off how usermode code can achieve rigorous factoring and wrapping, and there are lots of other examples as well.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-naming-of-null-vs-the-meaningless-value/1427#post_13</link>
        <pubDate>Thu, 27 Jul 2023 02:36:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6662</guid>
      </item>
      <item>
        <title>Discouraging Semantics for COMMA! in Dialects</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Today I consider <a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387">COMMA! to be an indispensible addition to the language</a>.</p>
<p>But something that feels like a Rebol philosophy point is that we should strongly discourage the idea of commas having semantic meaning in dialects.  The status quo should be that they just provide visual separation.</p>
<p>In this mindset, the only impact adding a comma should have on code would be an error if they're not put in an "interstitial" position.  If you want a grouping to have semantic meaning, then a BLOCK! or GROUP! should be used... or perhaps a vertical bar |.</p>
<p>I think giving this guidance helps preserve Rebol's natural language stream aesthetic, where the kinds of problems mandatory commas introduce can be avoided.  Whether you are doing things at source level or in code generation, having N entries needing (N - 1) commas can be an annoyance.</p> ]]></description>
        <link>https://forum.rebol.info/t/discouraging-semantics-for-comma-in-dialects/2042#post_1</link>
        <pubDate>Wed, 26 Jul 2023 16:30:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6658</guid>
      </item>
      <item>
        <title>The Language World&#39;s Weirdest COMMA! Mechanic</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Above I mention the idea of "error parity" between comma and reaching the end of a group:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1387">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>&gt;&gt; all [1 +, 2 3 + 4]
** Script Error: + is missing its value2 argument

&gt;&gt; all [(1 +) 2 3 + 4]
** Script Error: + is missing its value2 argument
</code></pre>
</blockquote>
</aside>
<p>Today we get this equivalence due to a number of complex flags and conditions, in particular BARRIER_HIT:</p>
<pre><code>//=//// FEED_FLAG_BARRIER_HIT /////////////////////////////////////////////=//
//
// Evaluation of arguments can wind up seeing a comma and "consuming" it.
// But the evaluation will advance the frame.  So if a function has more than
// one argument it has to remember that one of its arguments saw a "barrier",
// otherwise it would receive an end signal on an earlier argument yet then
// get a later argument fulfilled.
//
#define FEED_FLAG_BARRIER_HIT \
    FLAG_LEFT_BIT(3)
</code></pre>
<p>So what's going on is:</p>
<ul>
<li>
<p>Explicit commas (as well as specially marked functions) put the evaluator into a BARRIER_HIT state.</p>
</li>
<li>
<p>While in the barrier state, subsequent evaluations trying to gather arguments for the same function are rigged to act the same as end-of-block.</p>
<ul>
<li>
<p>If a function's arguments don't tolerate <strong><code>&lt;end&gt;</code></strong> then this will give an error</p>
</li>
<li>
<p>If it is tolerant of <code>&lt;end&gt;</code> then it will be able to call the function.</p>
</li>
</ul>
</li>
<li>
<p>Starting the next fresh evaluation step clears the BARRIER_HIT state.</p>
</li>
</ul>
<h2>
<a name="an-early-weakness-noted-literal-arguments-1" class="anchor" href="https://forum.rebol.info#an-early-weakness-noted-literal-arguments-1"></a>An Early Weakness Noted: Literal Arguments</h2>
<p>I quickly spotted the case of taking the next argument literally (remember that <strong>the x</strong> is just <strong>x</strong>):</p>
<pre><code>the, 1 + 2
; vs
(the) 1 + 2
</code></pre>
<p>I wasn't sure of the value of protecting people from themselves here, vs. making COMMA! the one datatype you could not pass as quoted.  If it were to be prohibited, we could ask where the right place for the prohibition is:</p>
<ol>
<li>
<p>In the evaluator guts, by simulating an <strong><code>&lt;end&gt;</code></strong> signal for this case</p>
</li>
<li>
<p>Inside of THE, testing for <strong><code>if comma? arg [...]</code></strong> in the implementation</p>
</li>
<li>
<p>In the type checking, via <strong><code>the: native [arg [(non-comma? element?)]]</code></strong></p>
</li>
</ol>
<p>Today we could choose (1), which is what happens for evaluative parameters.  However we don't do this for quoted parameters...so today it is allowed:</p>
<pre><code>; today's behavior
&gt;&gt; the,
== ,
</code></pre>
<p>Or it could be an error unless you say <strong>THE/COMMA</strong>, which would force use of (2).</p>
<h2>
<a name="but-would-simpler-be-better-2" class="anchor" href="https://forum.rebol.info#but-would-simpler-be-better-2"></a>But... Would Simpler Be Better?</h2>
<p>The existing designs predate NIHIL (an isotopic empty pack).  One major aspect of nihil is that almost no functions will accept it as a parameter.</p>
<p>So we might ask how different COMMA! needs to be from reaching a nihil state, e.g. a COMMENT?  Would this be sensible as being equivalent mechanics:</p>
<pre><code>&gt;&gt; all [1 +, "hi" 2 3 + 4]
** Script Error: + is missing its value2 argument

&gt;&gt; all [1 + comment "hi" 2 3 + 4]
** Script Error: + is missing its value2 argument
</code></pre>
<p>e.g. <strong>How bad would it be if the BARRIER_HIT mechanics went away, and we simply leveraged the idea that commas evaluated to nihil...and most functions refuse nihil arguments?</strong></p>
<h2>
<a name="downside-of-simplicity-behavior-in-pack-3" class="anchor" href="https://forum.rebol.info#downside-of-simplicity-behavior-in-pack-3"></a>Downside of Simplicity: Behavior in PACK!</h2>
<p>I decided to test this idea of making COMMA! evaluate NIHIL just like a comment would.  But found trouble because I had code that was doing something like this:</p>
<pre><code>[a b]: pack [1 + 2, 10 + 20]
</code></pre>
<p>It didn't work, because PACK was built on top of REDUCE-EACH with a ^META variable.  REDUCE-EACH performed three evaluation steps on the right hand side... the second evaluated the comma and got back a nihil (empty pack):</p>
<pre><code>&gt;&gt; meta pack [1 + 2, 10 + 20]
== ~['3 ~[]~ '30]~
</code></pre>
<p>The concept here is that if you use REDUCE-EACH with a ^META variable, you have to handle everything--that includes packs and errors.  This needs to be legal in order to do things like multi-returns with unstable isotopes (this is integral to UPARSE, for instance).</p>
<p>So this means we <em>definitely</em> want this behavior:</p>
<pre><code>&gt;&gt; meta pack [1 + 2 comment "hi" 10 + 20]
== ~['3 ~[]~ '30]~
</code></pre>
<p><strong>This suggests either that you can't use commas in PACK, -or- that PACK needs to be proactive about skipping over the commas at source level.</strong>  So long as PACK is based on REDUCE-EACH, then that suggests REDUCE-EACH needs to be able to skip commas...because you wouldn't be able to distinguish the cases based on the NIHIL evaluation product alone.</p>
<p>Something to notice about that idea is that if it's literally looking for commas, that means you can't make your own comma-like construct that acts like a barrier.</p>
<h2>
<a name="another-wrinkle-set-block-with-comma-on-right-4" class="anchor" href="https://forum.rebol.info#another-wrinkle-set-block-with-comma-on-right-4"></a>Another Wrinkle: SET-BLOCK! with Comma on Right</h2>
<p>If you were to write something like this, it wouldn't give an error:</p>
<pre><code>&gt;&gt; [/a /b]: ,
== ~null~  ; isotope

&gt;&gt; a
== ~null~  ; isotope

&gt;&gt; b
== ~null~  ; isotope
</code></pre>
<p>This is because the slashes indicate the results are optional, e.g. a shorter pack is accepted.  If COMMA!'s stopping power in the main evaluator comes only from the idea that it evaluates to an empty pack, it won't complain at the lack of a meaningful expression to its right.</p>
<p>Things like META which can accept empty packs would also not trigger an error:</p>
<pre><code>&gt;&gt; meta,
== ~[]~
</code></pre>
<p>These don't offhand seem that bad, and maybe could even be seen as good if you look at it from a certain point of view.  But it does show that the "stopping power" of commas isn't bullteproof.</p>
<h2>
<a name="what-about-thenelseetc-5" class="anchor" href="https://forum.rebol.info#what-about-thenelseetc-5"></a>What About THEN/ELSE/etc. ?</h2>
<p>THEN and ELSE are enfix and treat their left hand side evaluatively:</p>
<pre><code>(1 + 2, then [print "what happens here?"])
</code></pre>
<p>This would wind up acting the same as:</p>
<pre><code>(1 + 2 comment "hi" then [print "what happens here?"])
</code></pre>
<p>It needs to be an error...and it currently is.  The error arises because THEN and ELSE refuse to operate on nihil.  But at the moment this is a distinct case from not having a left hand argument at all.</p>
<pre><code>(then [print "what happens here?"])
</code></pre>
<p>Today, there are mechanics that make the left hand side look like an <code>&lt;end&gt;</code> condition...which falls under the complexity of BARRIER_HIT.</p>
<h2>
<a name="alternative-evaluator-skips-over-comma-when-possible-6" class="anchor" href="https://forum.rebol.info#alternative-evaluator-skips-over-comma-when-possible-6"></a>Alternative: Evaluator Skips Over COMMA! When Possible</h2>
<p>This would mean if you wrote something like:</p>
<pre><code>&gt;&gt; do/next [, , , 1 + 2, , 10 + 20] 'pos
== 3

&gt;&gt; pos
== [, , 10 + 20]  ; or possibly just [10 + 20] if it skipped trailing commas
</code></pre>
<p><em>I think this is how things worked long ago before the BARRIER_HIT flag was introduced.</em>  The concept was that a literal barrier (was <strong><code>|</code></strong>, now <strong><code>,</code></strong>) would be greedily consumed in interstitial evaluations, but raise errors otherwise.</p>
<p>This way, a COMMA! could just stay un-consumed by the evaluator.  Function calls gathering their argument would look ahead and say "hey is there <em>either</em> an end of block or a COMMA!" and if so, not run an evaluation and report an <code>&lt;end&gt;</code> condition.  This could be reported for arbitrarily many arguments...and so long as they were endable you would receive that condition.  In other words: the BARRIER_HIT flag was conveyed merely by a lagging comma that would stick around.</p>
<p><em>This feels very regressive, because every stepwise evaluating function inherits this complexity.</em>  The nice consequence of saying that COMMA! just evaluates to NIHIL is that it triggers the same handling you would use for COMMENT-like functions.</p>
<h2>
<a name="on-balance-i-think-the-barrier_hit-flag-has-to-die-7" class="anchor" href="https://forum.rebol.info#on-balance-i-think-the-barrier_hit-flag-has-to-die-7"></a>On Balance, I Think the BARRIER_HIT Flag Has To Die</h2>
<p><strong>I'm bullish on COMMA! as a great addition to the language.</strong>  But the various hoops that are jumped through to try and make it mimic the end of a block seem like a bridge too far.</p>
<p>To me, having commas vaporize is neat tech... and the idea is that if you handle things like COMMENT and ELIDE you get the comma handling for free.  This seems quite elegant to me.</p>
<p>Maybe functions like REDUCE-EACH need a refinement that lets you detect commas differently:</p>
<pre><code>&gt;&gt; reduce-each x [1 + 2, (elide print "Hi!") 10 + 20] [probe x]
3
Hi!
30
== 30

&gt;&gt; reduce-each ^x [1 + 2, (elide print "Hi!") 10 + 20] [probe x]
'3
Hi!  ; skipped over comma, by default
~[]~
'30
== '30

&gt;&gt; reduce-each/comma ^x [1 + 2, (elide print "Hi!") 10 + 20] [probe x]
'3
~,~  ; isotope
Hi!
~[]~
'30
== '30
</code></pre>
<p>Here I fancifully suggest giving back an isotopic comma to draw attention to it.  Since all other values come back meta'd, this doesn't conflate with any "real" evaluative result.  e.g. <strong><code>[~,~, ~,~]</code></strong> could distinguish "real isotopic commas" from source-level commas that REDUCE-EACH is offering to tell you about.</p>
<p>That requires commas to be stable isotopes.  But one could also not worry about the conflation, and reduce to an unstable isotope:</p>
<pre><code>&gt;&gt; ,
== ~,~  ; isotope
</code></pre>
<p>Then instead of people directly testing for NIHIL? most people could test for NOTHING? or VAPOR? which meant either nihil or isotopic comma.  :-/</p>
<p>Some crazy ideas here, but I think on balance that trying to make commas "bulletproof" leads to more confusion and problems than just making them do whatever comments do, with meta-REDUCE-EACH skipping them by default.</p>
<h2>
<a name="this-means-killing-off-user-defined-expression-barriers-8" class="anchor" href="https://forum.rebol.info#this-means-killing-off-user-defined-expression-barriers-8"></a>This Means Killing Off User-Defined Expression Barriers</h2>
<p>Paring it down such that NIHIL results are "mean" enough to stop evaluations for all practical purposes, the special flag for letting functions cause the BARRIER_HIT flag can be dropped too.  This was made available via the TWEAK function:</p>
<pre><code>//=//// DETAILS_FLAG_IS_BARRIER ///////////////////////////////////////////=//
//
// Special action property set with TWEAK.  Used by |
//
// The "expression barrier" was once a built-in type (BAR!) in order to get
// a property not possible to achieve with functions...that it would error
// if it was used during FULFILL_ARG and would be transparent in evaluation.
//
// Transparency was eventually generalized as "invisibility".  But attempts
// to intuit the barrier-ness from another property (e.g. "enfix but no args")
// were confusing.  It seems an orthogonal feature in its own right, so it
// was added to the TWEAK list pending a notation in function specs.
//
#define DETAILS_FLAG_IS_BARRIER \
    SERIES_FLAG_25
</code></pre>
<p><strong>I don't feel any particular qualm about losing this feature, because I've never really used it.</strong></p>
<p>And under the new concept, you get "barriery-enough" just by evaluating to NIHIL.  You're no better or worse than COMMA!</p>
<p><em>(Actually that's not quite true, because currently COMMA! doesn't do lookahead, so it can't serve as the left hand side of an enfix function that doesn't quote the left hand side.  But WORD! does do lookahead.  If we wanted to go for full parity, we'd allow the lookahead for evaluative commas...but making comma worse just to give it parity with a WORD! doesn't seem too smart.  If we decided that COMMA! was actually a WORD! that was a synonym for NIHIL and just rendered funny, then it might make sense... but that would wreck other things--like the PACK exception for commas.)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387#post_6</link>
        <pubDate>Mon, 24 Jul 2023 04:47:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6650</guid>
      </item>
      <item>
        <title>libuv Integration Has Started...an I/O Renaissance</title>
        <dc:creator><![CDATA[@BlackATTR Black Attr]]></dc:creator>
        <description><![CDATA[ <p>Bravo !! Great to see sawdust piling up on the shop floor again !</p> ]]></description>
        <link>https://forum.rebol.info/t/libuv-integration-has-started-an-i-o-renaissance/1694#post_6</link>
        <pubDate>Sun, 02 Jul 2023 14:37:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6647</guid>
      </item>
      <item>
        <title>libuv Integration Has Started...an I/O Renaissance</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1694">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Right now the only time we call the event loop is in WAIT, and it's still using some ad hoc timer logic instead of libuv timers.</p>
</blockquote>
</aside>
<p>I've gotten rid of the "EVENT Extension"...instead moving WAIT into the libuv-based Network extension.  This is because WAIT on PORT! is now only used for waiting for incoming network connections on a server (and waiting for a time, but you can use SLEEP from the TIME extension if you don't want your build to include libuv networking.)</p>
<p>While doing so, I converted the event loop inside that WAIT to use libuv timers...instead of the decades-old tangled multi-platform timing logic.</p>
<p>This means it's finally the case that the language core itself doesn't need the <code>Reb_Device</code> datatype, or functions like Register_Device() or OS_Poll_Devices().</p>
<h2>
<a name="and-so-the-last-bit-of-host-kit-is-thus-gone-1" class="anchor" href="https://forum.rebol.info#and-so-the-last-bit-of-host-kit-is-thus-gone-1"></a>And So, The Last Bit Of "Host-Kit" is Thus Gone!</h2>
<p>...yet Ren-C is demonstrating itself doing more, on more platforms.  What's the difference in approach?</p>
<p>R3-Alpha aimed to be closed-source, hardcoding the implementations of things like WAIT and READ and WRITE, as a fixed body of natives.  These attempted to be extensible via the means of hookpoints that would be supplied as C code, with a grab-bag of structures and parameters to each function.  This was supposed to <a href="https://forum.rebol.info/t/back-to-personal-computing/186/5">avoid use of Rebol datatypes</a>, with the concept that the functionality could be used as its own independent OS.</p>
<p>Ren-C basically throws that out the window.  When you are packaging up a distribution of the language, you write your own natives...and any "extensibility" architectures are done through Rebol calls to those natives.</p>
<p>As an example: a fixed implementation of NOW is not based on a Rebol-defined "GetTime()" C API.  There are various implementations of NOW... which actually <em>is</em> the Ren-C "get-time-API".  If another extension wants the current time, it's supposed to use NOW to get it.</p>
<p>The implementations of READ of a URL vary so drastically between the WebAssembly build and the Desktop builds that URL reads are intercepted much earlier, and done via JavaScript fetch().  You really wouldn't want to convolute it so that network reads had to contort themselves in some way to fulfill an abstract C byte-level API.  It calls "rebol functions" that are actually the JavaScript equivalent of a native.</p>
<p>Anyway, the desktop builds are still a lower priority than Wasm, but it's nice to see the last bit of hostkit cruft finally gone from the core.</p> ]]></description>
        <link>https://forum.rebol.info/t/libuv-integration-has-started-an-i-o-renaissance/1694#post_5</link>
        <pubDate>Sat, 01 Jul 2023 22:42:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6646</guid>
      </item>
      <item>
        <title>Compiling ren-c with zig?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="1" data-topic="2017">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>They claim to be able to compile c-code using zig cc</p>
</blockquote>
</aside>
<p>Given that I'm back at coding with a bit more enthusiasm right now, I thought it would probably be worth it to take a crack at building Ren-C with Zig again.</p>
<p><strong>Lo and behold, I managed to generate an x86_64 executable on Linux via Zig.</strong>  Woo.  <img src="https://forum.rebol.info/images/emoji/twitter/partying_face.png?v=12" title=":partying_face:" class="emoji" alt=":partying_face:" loading="lazy" width="20" height="20"></p>
<p>It also had test parity with GCC builds (at the moment a lot of failures, but no crashes).</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2017">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I couldn't figure out how to get it to act like a C99 compiler. It defines <code>__cplusplus</code> but then doesn't provide the headers for C++ (like <code>&lt;string&gt;</code> or <code>&lt;type_traits&gt;</code>).</p>
</blockquote>
</aside>
<p>Some of this turned out to be my mistake.  I failed to notice the makefile was passing a "--std=c++17" and "-x c++" flag even though invoking zig in C mode (<strong>zig cc</strong>).</p>
<p>But I hacked through it in both C++ and C compilation modes.</p>
<aside class="quote no-group quote-modified" data-username="IngoHohmann" data-post="1" data-topic="2017">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>[Zig has] an impressive list of cross compilation targets, wasm among them.</p>
</blockquote>
</aside>
<p>While this may sound great, be prepared for a bit of disappointment...</p>
<p><strong>That cross-compilation comes from the fact that Zig is dependent on LLVM (~169 MiB), just as Emscripten is.</strong></p>
<p>There was a <a href="https://kristoff.it/blog/zig-new-relationship-llvm/">roadmap document in 2020</a> about letting go of the "training wheels".  And circa October 2022, an issue on their GitHub <a href="https://github.com/ziglang/zig/issues/13265">offers "reasons why one want an LLVM-less binary"</a>, painting an optimistic picture:</p>
<blockquote>
<ul>
<li>
<p>The executable is 4.4 MiB instead of 169 MiB.</p>
</li>
<li>
<p>Bootstrapping it only requires a C compiler instead of requiring a modern C++ compiler, Python 3, bash, and CMake (also C++).</p>
<ul>
<li>This would make it much easier to obtain a Zig compiler on a new operating system or a limited environment such as a calculator.</li>
</ul>
</li>
</ul>
</blockquote>
<p>But that's still some future vision.  They say currently <em>"Zig is not very useful without enabling LLVM extensions."</em>  I think this just means that they're like every other project (including Red, including Ren-C)... talking about a future thing when that future may be very very far off.</p>
<p>It certainly doesn't hurt to have Ren-C's deep vetting for standards show it building successfully on yet another compiler.  And if that compiler does perchance make a decision aiming in the same vicinity as Ren-C (e.g. "we're going to focus on Wasm, vs requiring to target every esoteric LLVM emitter") it may make a better choice than other toolchains.</p>
<p>But for the moment, their Wasm doesn't have the integration Emscripten provides, and it's not that much thinner so long as the LLVM dependency is there.</p> ]]></description>
        <link>https://forum.rebol.info/t/compiling-ren-c-with-zig/2017#post_4</link>
        <pubDate>Thu, 29 Jun 2023 08:13:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6645</guid>
      </item>
      <item>
        <title>Should ANY and ALL Vaporize VOID (or require ELIDE-IF-VOID ?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I've written up how <a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">the evolution of invisibility gave rise to VOID vs. NIHIL</a>.</p>
<p>The default evaluator (and UPARSE) accept that void is "nothing" and can't be put in blocks.  But they don't vaporize VOID on a whim: it will still be the result of expressions whose last result is a void.</p>
<pre><code>&gt;&gt; 1 + 2 if false [&lt;a&gt;]
; void
</code></pre>
<p>On the other hand, the empty parameter pack of NIHIL truly vaporizes unless you pipe it around with ^META:</p>
<pre><code>&gt;&gt; 1 + 2 nihil
== 3
</code></pre>
<p>This means it's up to constructs to decide if they want to erase voids or not.  DELIMIT does, so you will see that reflected in things like UNSPACED:</p>
<pre><code>&gt;&gt; unspaced ["A" if false ["B"] "C"]
== "AC"
</code></pre>
<p>COMPOSE vaporizes void slots (and errors on null ones).  <a href="https://forum.rebol.info/t/vaporizing-failed-conditionals-in-reduce/1665">REDUCE is currently vaporizing VOID</a> because it seems like the default people want.</p>
<h2>
<a name="should-any-and-all-vaporize-voids-1" class="anchor" href="https://forum.rebol.info#should-any-and-all-vaporize-voids-1"></a>Should ANY and ALL Vaporize Voids?</h2>
<p>To me, this is a bit of a tough decision.</p>
<p>VOID is neither truthy nor falsey, and IF will reject it:</p>
<pre><code>&gt;&gt; if (if false [true]) [&lt;unreachable&gt;]
** Error: IF doesn't accept VOID as its condition argument
</code></pre>
<p>When there was no VOID/NIHIL distinction, then ANY and ALL were backed into a corner.  If they decided to error on void, you couldn't use an ELIDE or ASSERT in the middle of them.  If they didn't error on VOID then the risk was that you could write something like <strong><code>all [1 = 1, 2 = 2, value]</code></strong> and if VALUE was just incidentally void you'd get the 2 = 2 result as ~true~.</p>
<p>Today, things like ELIDE and ASSERT return NIHIL and can be safely vaporized by ANY and ALL, while retaining the choice to error on voids as not being true or false.  If you really want to erase voids, we can have something that converts voids to nihil called ELIDE-IF-VOID</p>
<pre><code>&gt;&gt; value: void

&gt;&gt; all [1 = 1, 2 = 2, value]
** Error: VALUE is VOID which is neither truthy nor falsey

&gt;&gt; all [1 = 1, 2 = 2, elide-if-void value]
== ~true~  ; isotope
</code></pre>
<h2>
<a name="things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2" class="anchor" href="https://forum.rebol.info#things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2"></a>Things Like <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">FOR-BOTH</a> Would Get More Awkward...</h2>
<p>I was fairly proud of this formulation:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        meta* for-each (var) blk1 body
        meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>(I wound up deciding that META would meta-raise everything--including pure null and void--so the asterisks were probably best included there for the alternative formulation.)</p>
<p>But if ALL and ANY errored on void, and you had to erase it, this would become:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        elide-if-void meta* for-each (var) blk1 body
        elide-if-void meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>If I put on my formalism hat, I can see how this is <em>safer</em>.  But I've made similar arguments about why I don't want this:</p>
<pre><code>&gt;&gt; compose [a (if false ['b]) c]
** Error: COMPOSE cannot erase VOID (use ELIDE-IF-VOID if intentional)

&gt;&gt; compose [a (elide-if-void if false ['b]) c]
== [a c]
</code></pre>
<p>It is admittedly a bit different in ANY and ALL's case, because they're mixing in a test for truthiness.  But erasing voids by default has other advantages in writing wild control constructs.</p>
<p>I'm really torn on this, as it's right on the edge.  <strong>But when all things are mostly equal, safety isn't as compelling as enabling creativity in my current view of the language.</strong>  I think I'm going to wait until I see a really bad consequence of vaporizing the voids here... it hasn't broken any real code yet, and it has proven its convenience.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-any-and-all-vaporize-void-or-require-elide-if-void/2040#post_1</link>
        <pubDate>Thu, 29 Jun 2023 02:09:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6643</guid>
      </item>
      <item>
        <title>Should PARSE Rules Always Be BLOCK!s ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1390">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I feel a twinge of prescriptivism in saying that you either use the <span class="mention">@xxx</span> syntax at your reference sites or you form your subrules as proper blocks -or- inert values (strings and binaries).</p>
<p>So I think this is the option we should go with.</p>
</blockquote>
</aside>
<p>While words-looking-up-to-words were prohibited (along with words looking up to integer, or group, etc.), I thought maybe supporting QUOTED! would be all right.  It seemed like variables holding quoted things were kind of rare, and it could help with efficiency.</p>
<pre><code>&gt;&gt; rule: first ['skip]
== 'skip

&gt;&gt; parse [skip skip skip] [some rule]
== skip
</code></pre>
<p>This optimization over <strong>rule: ['skip]</strong> is only going to be applicable when the user of the rule is using it abstractly...e.g. they don't know enough to know whether it's something complex that's got a lot of rules in it or if it's just matching a single value.  What we lose here is the optimization that the authors of such rules could avoid the overhead of a BLOCK! and still say <strong><code>rule</code></strong> undecorated vs. need to psychically choose between <strong><code>@rule</code></strong> and <strong><code>rule</code></strong> based on how the rule is expressed.</p>
<p>So this exception was carried over from PARSE3 to UPARSE.</p>
<p><em>But nowadays, QUOTED!s aren't so rare.</em>  You might be intending to actually match quoted skip, and giving an error could provide guidance to use the <code>@</code> operations.</p>
<p>Also, making these "optimized rules" isn't the most intuitive thing in the world.  e.g. the person making the rule has to quote the quoted somehow:</p>
<pre><code>rule: ''something
rule: first ['something]
</code></pre>
<p>Cleanliness-wise, using a block is more obvious, and looks more "rule-like" in that it's how you would write the match inline.</p>
<pre><code>rule: ['something]
</code></pre>
<p><strong>In practice, I've just about never used the QUOTED!-to-avoid-a-block optimization.</strong>  It's a very rare scenario...now that @ exists, that covers most cases in a much more clear way (because what you're matching in the variable can be as-is).  So it's an optimization for an almost-never-occuring case of using a rule written by someone else that has nothing to match but a single literal item.</p>
<p>Actually...I can't think of this having come up, <em>ever</em>.  Hence the potential for confusion of not catching when someone actually meant to match a QUOTED! is almost certainly too great.  I'm going to kill it.</p>
<p><sub>As usual...I'm glad we had this talk.  <img src="https://forum.rebol.info/images/emoji/twitter/stuck_out_tongue.png?v=12" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:" loading="lazy" width="20" height="20"></sub></p> ]]></description>
        <link>https://forum.rebol.info/t/should-parse-rules-always-be-block-s/1390#post_2</link>
        <pubDate>Mon, 26 Jun 2023 18:17:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6638</guid>
      </item>
      <item>
        <title>BLANK! (_) as SPACE in String-Oriented Dialects</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Experiments have run the gamut to where a plain BLANK! once would opt out of appending to a series, and you had to quote it to append it:</p>
<pre><code>experiment&gt;&gt; append [a b] _
= [a b]

experiment&gt;&gt; append [a b] quote _
== [a b _]
</code></pre>
<p>But the satisfying world we have now is that anything you can pick out of a block will append as-is to another block.  So adding a blank is additive:</p>
<pre><code>&gt;&gt; append [a b] _
== [a b _]
</code></pre>
<p>It feels like a decent fit to say that appending a blank to a string is additive...since VOID and such are available if you want to opt out:</p>
<pre><code>&gt;&gt; append "ab" _
== "ab "
</code></pre>
<p>Though it raises the question of what BINARY! should do:</p>
<pre><code>&gt;&gt; append #{0102} _
== ???
</code></pre>
<p>It seems that adding a UTF-8 representation is the story for ASCII:</p>
<pre><code>&gt;&gt; as binary! "AB"
== #{4142}

&gt;&gt; append #{0102} "AB"
= #{01024142}
</code></pre>
<p>But when it comes to integers, strings append the molded form...while binaries just add one byte, not the bytes of the formed string of the integer:</p>
<pre><code>&gt;&gt; append "ab" 10
== "ab10"

&gt;&gt; append #{0102} 10
== #{01020A}
</code></pre>
<p>A bit of a mixed bag, that could support arguments that BLANK! could be "the space of binaries" (e.g. #{00})</p>
<pre><code>&gt;&gt; append #{0102} _
== #{010200}
</code></pre>
<p>But I think that's not so useful.  It's more likely that the character representation of space is useful:</p>
<pre><code>&gt;&gt; to binary! #" "
== #{20}

&gt;&gt; append #{0102} _
== #{010220}
</code></pre>
<p>Ren-C FIND and PARSE mechanics already allows you to search for strings in BINARY!, implicitly looking for the UTF-8 representation.</p>
<h2>
<a name="what-if-_-was-really-the-canon-representation-of-space-chars-1" class="anchor" href="https://forum.rebol.info#what-if-_-was-really-the-canon-representation-of-space-chars-1"></a>What If _ Was Really The Canon Representation of Space Chars?</h2>
<pre><code>&gt;&gt; pick "ab " 3
== _

&gt;&gt; #" "
== _

&gt;&gt; char? _
== ~true~  ; isotope

&gt;&gt; space? _
== ~true~  ; isotope
</code></pre>
<p>I've mentioned that single character intents are on the rise... we could call quoted void (apostrophe) "blank" and it could be used in contexts where you want to say there's no value:</p>
<pre><code>&gt;&gt; blank? first [']
== ~true~  ; isotope

&gt;&gt; blank
== '
</code></pre>
<p>You'd still have _ as an evaluator-inert dialecting part that can't be redefined.  You just would need to use something like <strong>#</strong> or <strong>'</strong> or <strong>~</strong> in cases where you had a slot that could be either any character -or- some out of band thing.</p>
<p>Off the top of my head, I can see a few problems.  If _ became a character literal, it shouldn't be used for vacant spots in paths.  So let's say paths start using this "new blank":</p>
<pre><code>&gt;&gt; as block! first [/a]
== [' a]
</code></pre>
<p>Doesn't look too bad, but if you want to parse it you need double apostrophes to match those spots:</p>
<pre><code>parse [/a] [into path! ['' 'a]]
</code></pre>
<p>This is because a single apostrophe is matched as void, e.g. matches without advancing the parse position.  <a href="https://forum.rebol.info/t/parse-behavior-for-words-that-lookup-to-quoted/2038">And it wouldn't work if you used a word to reference the blank</a>:</p>
<pre><code>&gt;&gt; parse [/a] [into path! [blank 'a]]
** Error: To match a QUOTED! you must use @blank

&gt;&gt; parse [/a] [into path! [@blank 'a]]  ; would need to do this...
== a
</code></pre>
<p>But it's not awful, and at least it doesn't silently treat the quote as a vanishing rule.</p>
<p><strong>It's still kind of an interesting thought to make _ the literal char! of space.</strong>  Still inert, still usable in dialects.  It would leave <strong><code>'</code></strong> and <strong><code>~</code></strong> as "friendly nothing" and "unfriendly nothing".</p>
<pre><code>&gt;&gt; spread first [']  ; would return void

&gt;&gt; spread first [~]
** Error: Cannot spread meta-NONE
</code></pre>
<p>Either way, I think the conclusion here is that <strong>append #{0102} _</strong> should be <strong>#{010220}</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/blank-as-space-in-string-oriented-dialects/1885#post_6</link>
        <pubDate>Mon, 26 Jun 2023 17:39:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6636</guid>
      </item>
      <item>
        <title>ASSERT vs. [end]able FAIL</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="756">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If you think about it, a FAIL with no arguments doesn't have a lot of options for what to do besides report an error. So why not make it <code>&lt;end&gt;</code>-able (the same way HELP can accept either no arguments or one argument), and assume that a FAIL with no arguments is just a way of saying "fail here"?</p>
<p>There are other applications for this:</p>
<pre><code>switch type of x [
    integer! [...]
    text! [...]
    fail
]
</code></pre>
<p>That's more succinct than <code>switch ... [...] else [fail]</code>.</p>
</blockquote>
</aside>
<p>This five-year-old idea has been put to good use and feels like it has proven its mettle.</p>
<p>But reviewing old posts I realized that it does theoretically suffer from the <strong><a href="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965">line continuation arity bug</a></strong>.</p>
<p>This is to say you might have some code like:</p>
<pre><code> blah blah blah
 more blah blah
</code></pre>
<p>And decide you're going to just throw a FAIL in the middle:</p>
<pre><code> blah blah blah
 fail
 more blah blah
</code></pre>
<p>Because you're used to the idea that FAIL can be used with no arguments.  Yet the <strong>more blah blah</strong> will be picked up as an argument to fail, as if you'd written:</p>
<pre><code> blah blah blah
 fail (more blah blah)
</code></pre>
<p>The consequences aren't quite as dire as when this was being used with the likes of RETURN...because FAIL generally stops execution anyway.  But it could lead to unexpected results.</p>
<p>I just wanted to reiterate that <code>&lt;end&gt;</code>-able constructs...cool as they seem...have this blind spot when code is broken across lines.</p> ]]></description>
        <link>https://forum.rebol.info/t/assert-vs-end-able-fail/756#post_2</link>
        <pubDate>Mon, 26 Jun 2023 07:19:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6635</guid>
      </item>
      <item>
        <title>Vaporizing Failed Conditionals In REDUCE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1665">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>min: null
max: _

&lt;&lt;BUNCH OF CODE THAT MUST SET MIN AND MAY OR MAY NOT SET MAX&gt;&gt;

uparse data [repeat (:[min max]) rule]
</code></pre>
<p>The reason I didn't say <strong><code>(min: ~)</code></strong> or <strong><code>(min: ~overwrite-me~)</code></strong> is because I wanted min to be "middlingly ornery". So I wanted to use it in expressions like <strong>any [min, ...]</strong> but I didn't want it to be able to be used as an opt out intention. This is the weird zone that NULL occupies and we're making the most of it.</p>
<p>Under this understanding...I'd be displeased if that turned into <strong><code>[repeat ([_]) rule]</code></strong>, because I'd have liked to have been told about the issue.</p>
</blockquote>
</aside>
<p>I feel like a bit of a broken record revisiting all these old posts from when NULL was the only non-valued state, that was trying to do double duty as both "soft failure" and "opt out".</p>
<p>But this is yet another solved case.  Nowadays NULL doesn't vaporize in REDUCE (it's an error), but VOID does vanish.  And you can convert NULL to void with MAYBE if that's what you want to do.</p>
<p>Ever since introducing this distinction, I haven't really seen problems with vaporizing voids...and the NULL erroring has caught many issues.  The abstract potential for problems with void opting out of REDUCE is there, but I haven't seen any problems.  It feels especially solid now that these behaviors are specific to constructs like REDUCE, and <a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">the evaluator doesn't vaporize VOID...just the much rarer NIHIL</a>.</p> ]]></description>
        <link>https://forum.rebol.info/t/vaporizing-failed-conditionals-in-reduce/1665#post_2</link>
        <pubDate>Mon, 26 Jun 2023 03:18:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6634</guid>
      </item>
      <item>
        <title>Function That Errors on NULL (But Passes Thru Everything Else)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="11" data-topic="1250">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The construct that has been committed is called MUST:</p>
<pre><code>&gt;&gt; must find "abc" "b"
== "bc"

&gt;&gt; must find "abc" "q"
** Error: MUST requires argument to not be NULL
</code></pre>
<p>But an issue that should make everyone happier is that NULL is becoming accepted fewer places.  For instance, APPEND of NULL is an error--not a no-op. You have to MAYBE it to turn it into a VOID.</p>
</blockquote>
</aside>
<p><em>Reviewing this two years later...</em></p>
<p>Technically what I say here is true: you don't have to ensure things aren't NULL any more, because you'll get an error anyway if you try to pass nulls as arguments.</p>
<p>Yet the landscape has shifted: <strong>now the issue (if there is still an issue) is having certain spots potentially be void, and opting out when you didn't mean to.</strong></p>
<p>Fortunately that means the map of the problematic territory has shrunk significantly.  There are fewer void-returning situations than there are null-returning situations.  But branching constructs are candidates for returning void.</p>
<pre><code>&gt;&gt; append [a b c] case [1 = 2 [&lt;d&gt;] 3 = 4 [&lt;e&gt;]]
== [a b c]
</code></pre>
<p>Does a VOID-sensing MUST make sense?  It's going to read a bit weirdly:</p>
<pre><code>&gt;&gt; append [a b c] must case [1 = 2 [&lt;d&gt;] 3 = 4 [&lt;e&gt;]]
** Error: MUST requires argument to not be VOID
</code></pre>
<p>I'd certainly prefer <strong>non void</strong> on the rare cases you would do this:</p>
<pre><code>append [a b c] non void case [1 = 2 [&lt;d&gt;] 3 = 4 [&lt;e&gt;]]
</code></pre>
<p>But furthermore, the design of functions like CASE and SWITCH allows you to tack on a FAIL if they reach the end, which seems more legible to me... same number of characters as MUST if you don't supply a message, but also having the option of giving a message:</p>
<pre><code>append [a b c] case [1 = 2 [&lt;d&gt;] 3 = 4 [&lt;e&gt;] fail]

append [a b c] case [1 = 2 [&lt;d&gt;] 3 = 4 [&lt;e&gt;] fail "your message here"]
</code></pre>
<p><strong>So I think the story here has a happy ending, which is that splitting out NULL and VOID intents (with a clear function for converting between them) has basically made MUST obsolete.</strong>  Constructs are plugging together naturally and giving errors at the right places.</p>
<p>NULL-sensing MUST winds up only having a purpose if you're generating nulls and not passing them anywhere.  But the only place I can think of that arising would be like an assert:</p>
<pre><code>str: "abc"
append str "de"
must find str "cd"
</code></pre>
<p>I'd rather read that as <strong>assert [find str "cd"]</strong>... particularly because assert is invisible.</p>
<h2>
<a name="long-story-short-im-killing-must-1" class="anchor" href="https://forum.rebol.info#long-story-short-im-killing-must-1"></a>Long Story Short: I'm Killing MUST</h2>
<p>I certainly wouldn't add it today.  That's a solid argument for deleting it.</p>
<p>It seems to me <strong>non null</strong> and <strong>non void</strong> are clearer for the few cases this comes up!</p> ]]></description>
        <link>https://forum.rebol.info/t/function-that-errors-on-null-but-passes-thru-everything-else/1250#post_12</link>
        <pubDate>Mon, 26 Jun 2023 02:34:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6633</guid>
      </item>
      <item>
        <title>Using Invisibles To Opt Out of Functions In a Chain</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="gchiu" data-post="1" data-topic="2036">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/gchiu/40/22_2.png" class="avatar"> gchiu:</div>
<blockquote>
<p>One idea for using invisibles is to chain functions where you make some functions disappear from the chain if they're not needed.</p>
</blockquote>
</aside>
<p>This is a creative idea... and I think this sort of creativity is what makes the language fun... having so many different ways to attack problems!</p>
<p>But in this particular case, you could actually use CHAIN to build the composite function, and it might be more obvious:</p>
<pre><code>imagemagick: func [
    data 
    /monochrome
    /sharpen
    /blur
    /pixelise
][
     ... code ..
    return run chain reduce [
        if sharpen [:sharpenf]
        if blur [:blurf]
        if pixelize [:pixelf]
    ] data
]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/using-invisibles-to-opt-out-of-functions-in-a-chain/2036#post_2</link>
        <pubDate>Sun, 25 Jun 2023 23:56:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6627</guid>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I've done some pruning of dead-ends and tangents in this thread, to try and hone in on the real issues.  But this is the central point:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="17" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One blind spot in the above discussion is that it assumes NULL is the only variable state that cannot be put in blocks.</p>
<p>The attempts to make suggestions other than NULL for <strong>do []</strong> give "ornery" values like <strong>~void~</strong>...but in a world that still allows those values to be put in blocks. <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p>But with isotopes, there's a whole spectrum of states that are legal in variables but not blocks. We can very simply say that in constructs like DELIMIT or COMPOSE or REDUCE:</p>
<p><strong>NULLs error, VOIDs vaporize, and the MAYBE function lets you convert nulls to voids!</strong></p>
</blockquote>
</aside>
<p>In the intervening two years...things have evolved to where VOID is not an isotopic word, but a distinct non-valued state (which has its own quoted and isotopic forms).     And it's not just the product of <strong>do []</strong> but also any failed conditional.</p>
<pre><code>&gt;&gt; do []  ; since void has no representation, console prints nothing

&gt;&gt; if false [&lt;a&gt;]

&gt;&gt; if true [&lt;a&gt;]
== &lt;a&gt;
</code></pre>
<p>There's a lot of satisfying interplay, in terms of how isotopic voids are used to represent unset variables...and quoted and quasi voids are the <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/3">single-character intents of <strong><code>'</code></strong> and <strong><code>~</code></strong></a>.  Singing the praises of the details would be redundant on this old thread, but I hope I've pared it down to where one can grasp the thought process that led to the current abilities.</p>
<h2>
<a name="at-this-point-im-sure-about-do-returning-void-1" class="anchor" href="https://forum.rebol.info#at-this-point-im-sure-about-do-returning-void-1"></a>At This Point I'm Sure About <code>(do [])</code> Returning VOID</h2>
<h2>
<a name="however-2" class="anchor" href="https://forum.rebol.info#however-2"></a>...However...</h2>
<h2>
<a name="still-not-sure-if-reduce-if-false-x-should-vaporize-3" class="anchor" href="https://forum.rebol.info#still-not-sure-if-reduce-if-false-x-should-vaporize-3"></a>Still Not Sure If <code>(reduce [if false [&lt;x&gt;]])</code> Should Vaporize</h2>
<p>There's evidence suggesting that some of the motivating cases for Red's religiosity no longer apply to Ren-C.  e.g. <strong>set [a b c] reduce [expr1 expr2 expr3]</strong> is not how we operate... <a href="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634/10">SET-BLOCK! and parameter packs are much better and account for voids</a></p>
<p>But I don't know about whether the default should be <strong>reduce/exact</strong> vs. <strong>reduce/vanishable</strong>.  The feedback here suggests a lack of concern about the lax behavior, and the void vs. null distinction certainly puts a lot more control in the hands of the user.</p>
<p>Just wanted to come back and paint a picture of how far this has come!</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426#post_19</link>
        <pubDate>Sat, 24 Jun 2023 05:21:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6624</guid>
      </item>
      <item>
        <title>Invisibility Reviewed Through Modern Eyes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The first idea of making constructs that would "vanish completely" leveraged a special kind of enfix function, that would receive the entire evaluated value of the left hand side:</p>
<pre><code> elide: enfix func [
     left [&lt;evaluate-all&gt; any-value!]
     right
 ][
     print ["ELIDE got left as" mold left]
     return left
 ]

 &gt;&gt; 1 + 2 + 3 comment [magic!]
 hi
 ELIDE got left as 6
 == 6  ; wow!
</code></pre>
<p>This was a workaround for the (seeming?) fundamental fact that you can't have such a thing as "invisible variables" or "invisible values".  <em>Certain functions just faked invisibility by repeating the previous value in the evaluator chain.</em></p>
<p>The possibilities seemed endless.  For instance, imagine something like this:</p>
<pre><code>case [
   conditionA [...code...]
   elide print "conditionA didn't succeed but running this"
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>To do that in Rebol2 or Red would be incredibly awkward.  e.g. using a condition that runs code but evaluates to false, and then a throwaway block for the never-executed branch:</p>
<pre><code>case [
   conditionA [...code...]
   (
       print "conditionA didn't succeed but running this"
       false
   ) [&lt;unreachable&gt;]
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>Similar awkwardness would arise in things like ANY and ALL, where you'd have to switch from using true and false based on which you were using...</p>
<pre><code>any [conditionA (print "vanish" false) conditionB]
all [conditionA (print "vanish" true) conditionB]
</code></pre>
<p>Beyond being awkward, it simply can't work if what you want to vanish is the last expression.  But ELIDE handled all these cases:</p>
<pre><code>any [conditionA elide print "vanish" conditionB]
all [conditionA elide print "vanish" conditionB]
any [conditionA conditionB elide print "vanish"]
all [conditionA conditionB elide print "vanish"]
</code></pre>
<h2>
<a name="it-was-a-neat-trickbut-problems-emerged-1" class="anchor" href="https://forum.rebol.info#it-was-a-neat-trickbut-problems-emerged-1"></a>It Was A Neat Trick...But Problems Emerged</h2>
<p>The trick of invisibility requiring a function to receive its left hand side meant a GROUP! or COMMA! would break these constructs, as there was no access to a previous value:</p>
<pre><code> &gt;&gt; 1 + 2 + 3 (elide print "hi")
 hi
 ELIDE got left as null
 == ~null~  ; not 6, d'oh!

 &gt;&gt; 1 + 2 + 3, elide print "hi"
 hi
 ELIDE got left as null
 == ~null~
</code></pre>
<p>Plus being enfix forced the invisible functions to execute in the same step as whatever came before them, causing unsuspected results:</p>
<pre><code>&gt;&gt; case [
        1 = 1 [print "branch"]
        elide print "reached here first :-("
        1 = 2 [fail "Unreachable"]
    ]
ELIDE got left as [print "branch"]
reached here first :-(
branch
</code></pre>
<p>There we see that when the evaluator visited the <strong>[print "branch"]</strong> block in the CASE it had to greedily run the ELIDE, which evaluates its argument and then yielded the code block as its result.  CASE ran that code after the elide...out of order from what was desired.</p>
<p>Issues seemed to keep compounding.  These invisible functions couldn't be reliably used with MAKE FRAME!, and people trying to simulate the evaluator's logic found it hard to detect and wrap them.  That led to major issues with UPARSE trying to implement combinators that acted like ELIDE.</p>
<p>So the enfix mechanism wasn't going to cut it.  But it was too late: having been able to try out and develop all kinds of invisible constructs convinced me of their value.  I had to try another way...</p>
<h2>
<a name="formalizing-a-void-state-and-corresponding-meta-state-2" class="anchor" href="https://forum.rebol.info#formalizing-a-void-state-and-corresponding-meta-state-2"></a>Formalizing a VOID State And Corresponding Meta State</h2>
<p>The seeming impossibility of having a "void value" was addressed with the idea of folding special treatment in the evaluator of voids, but offering a meta domain in which they could be handled safely.</p>
<pre><code>&gt;&gt; var: void
; void

&gt;&gt; 1 + 2 var
== 3

&gt;&gt; var: meta void
== '

&gt;&gt; 1 + 2 var
== '

&gt;&gt; 1 + 2 unmeta var
== 3
</code></pre>
<p>The concept of being able to pipe around and process "slippery" values in this meta domain (including unset states and other isotopes) wound up being very successful.</p>
<p>Evaluators like DO and UPARSE would specially preserve the last evaluative value in order to give the illusion of invisibility when voids were seen on the next step.  Other constructs got to make a choice as to whether they wanted to embrace voids as part of the mechanic, or think of them as errors:</p>
<pre><code>&gt;&gt; comment "comments returned void"  ; Note: console doesn't show void results

&gt;&gt; if comment "hi" [print "not tolerated in conditions"]
** Error: IF doesn't accept void as its condition argument

&gt;&gt; all [comment "begin" 1 + 2 10 + 20 comment "end"]
== 30

&gt;&gt; any [comment "begin" 1 + 2 10 + 20 comment "end"]
== 3
</code></pre>
<p>e.g. for the above to work, ALL has to hang on to the last evaluated result as it goes...in case the next evaluated result is a comment.  This allows the 30 to fall out.</p>
<h2>
<a name="a-flexible-approach-but-here-be-dragons-3" class="anchor" href="https://forum.rebol.info#a-flexible-approach-but-here-be-dragons-3"></a>A Flexible Approach... But... Here Be Dragons</h2>
<p>Something that concerned me early on was that what had started as a narrow ability of just a few functions (like COMMENT and ELIDE) was becoming a case where generalized execution could possibly return voids, leading to unexpected results.</p>
<pre><code>&gt;&gt; code: [comment "some arbitary code block"]

; ... then much later ...

&gt;&gt; result: (mode: &lt;reading&gt; do code)
== &lt;reading&gt;

&gt;&gt; result
== &lt;reading&gt;  ; oops
</code></pre>
<p>Increasing dependence on void as a "vanishing" alternative to the noisier null also raised the demand for void variables, with them becoming slippery to generate:</p>
<pre><code>&gt;&gt; parse [x] [rule: ['x (void) | 'y ([some "y"])]
== x

&gt;&gt; rule
== x  ; wanted void
</code></pre>
<p>VOID was becoming a victim of its own popularity.  When it was rare coming from only a few constructs like ELIDE and COMMENT it was rare to see problems.  Yet when every IF/CASE/SWITCH statement that didn't run a branch started returning voids, things got hairier.</p>
<p>There were also snags when making void isn't a parameter...but a product of something like the body on a MAP-EACH. At first it looks fine:</p>
<pre><code>map-each item [1 &lt;one&gt; 2 &lt;two&gt; 3 &lt;three&gt;] [
    maybe match tag! item  ; leaving it as NULL would be an error
]
== [&lt;one&gt; &lt;two&gt; &lt;three&gt;]
</code></pre>
<p>But what if you had something else in the loop body?</p>
<pre><code>map-each item [1 &lt;one&gt; 2 &lt;two&gt; 3 &lt;three&gt;] [
    append log spaced ["Logging:" item]
    maybe match tag! item  ; remember, void vanishes
]
== ["Logging: 1" "Logging: &lt;one&gt;" "Logging..." ...]
</code></pre>
<h2>
<a name="once-again-isotopes-to-the-rescue-4" class="anchor" href="https://forum.rebol.info#once-again-isotopes-to-the-rescue-4"></a>Once Again: Isotopes To The Rescue</h2>
<p>As part of <a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">solving the problem of multi-returns</a>, parameter pack isotopes were introduced.  These would "decay" to their first item, unless something handled the isotope specially.</p>
<pre><code>&gt;&gt; pack [1 + 2 10 + 20]
== ~['3 '30]~  ; isotope

&gt;&gt; a: pack [1 + 2 10 + 20]
== 3

 &gt;&gt; [a b]: pack [1 + 2 10 + 20]  ; SET-BLOCK! handles PACK! isotopes specially
 == 3

 &gt;&gt; a
 == 3

 &gt;&gt; b
 == 30
</code></pre>
<p>Unpacking the packs raised a question: <em><strong>What if the PACK! is Empty</strong></em>?  As far as variable assignment goes, it seems it can't do anything.  So erroring made the most sense:</p>
<pre><code>&gt;&gt; pack []
== ~[]~  ; isotope

&gt;&gt; a: pack []
** Error: No values available in empty parameter pack
</code></pre>
<p>Then there was a breakthrough of the next thought: <em><strong>Empty isotopic packs could be used as the vanishing intent!!</strong></em></p>
<pre><code>&gt;&gt; 1 + 2, pack []
== 3
</code></pre>
<p>This would mean VOID could be less "slippery" in the evaluator, being treated normally most of the time and falling out of expressions vs. vaporizing:</p>
<pre><code>&gt;&gt; 1 + 2, if false [&lt;a&gt;]  ; overall result is void (no console output)

&gt;&gt; 1 + 2, if true [&lt;a&gt;]
== &lt;a&gt;
</code></pre>
<h2>
<a name="empty-isotopic-packs-were-then-given-a-name-nihil-5" class="anchor" href="https://forum.rebol.info#empty-isotopic-packs-were-then-given-a-name-nihil-5"></a>Empty isotopic packs were then given a name: <strong>"NIHIL"</strong>
</h2>
<p>The terminology has varied over time.  I accomplished the distinction another way before isotopic packs, and at that time I called the distinction "impure invisibility" (non-vaporizing) vs. "pure invisibility" (vaporizing).</p>
<p>But I think the "impure" vs. "pure" terms just caused confusion.  This is where things stand today, and it seems comfortable:</p>
<pre><code>&gt;&gt; 1 + 2 void

&gt;&gt; 1 + 2 nihil
== 3

&gt;&gt; 1 + 2 null
== ~null~   ; isotope
</code></pre>
<h2>
<a name="i-think-this-is-a-comfortable-balance-6" class="anchor" href="https://forum.rebol.info#i-think-this-is-a-comfortable-balance-6"></a>I Think This Is A Comfortable Balance</h2>
<p>No matter what way you slice it, an expression that can truly vaporize is something that can make you uneasy.  Look at this CASE statement and imagine if FOO or BAR could vanish:</p>
<pre><code> case [
     foo [print "hi"]
     bar [print "bye"]
 ]
</code></pre>
<p>Sure... we can lament that if FOO comes back as NIHIL, it will wreck the geometry of the CASE completely.  After dropping the FOO it will treat [print "hi"] as a condition and use BAR as a code branch.</p>
<p><em>But if FOO is a function that takes a BLOCK! as a parameter, it will also wreck the geometry of the CASE completely!</em>  This is just the cost of doing business in the Rebol paradigm.</p>
<p>This modern model with NIHIL being an unstable isotope brings us back to where you can only get vanishing function calls--not vanishing variables.  FOO can be a variable holding VOID, but there's no risk of that wrecking the CASE statement...because CASE is not one of the constructs that willfully erases VOID.  Neither does the foundational evaluator (and nor does UPARSE)</p>
<p>So long as usage of NIHIL is judicious, I think this is about as terra firma as the rest of Rebol is.  And UPARSE stands as a great example of a system that has been able to build on meta-representation in order to be able to pipe around vanishing states using "special gloves" and build upon it to make new invisible behaviors...</p>
<pre><code>&gt;&gt; parse "aaabbb" [collect some keep "a", elide some "b"]
== ["a" "a" "a"]
</code></pre>
<p>It's rather satisfying.</p> ]]></description>
        <link>https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034#post_1</link>
        <pubDate>Fri, 23 Jun 2023 17:06:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6622</guid>
      </item>
      <item>
        <title>The Handling of NULL and VOID in UPARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h2>
<a name="okay-voided-variables-should-be-no-ops-in-uparse-1" class="anchor" href="https://forum.rebol.info#okay-voided-variables-should-be-no-ops-in-uparse-1"></a>Okay, voided variables should be no-ops in UPARSE</h2>
<p>This is consistent with how quoted voids work:</p>
<pre><code>&gt;&gt; parse [a b] ['a ' 'b]
== b
</code></pre>
<p>Or how voided expressions work in GET-GROUP! substitution:</p>
<pre><code>&gt;&gt; parse [a b] ['a 'b :(if false [[some 'c]])]
== b

&gt;&gt; parse [a b c c c] ['a 'b :(if true [[some 'c]])]
== c
</code></pre>
<p><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/4">And with more liberal policies for void variables via word access in the main evaluator</a>, extending this to WORD! references seems consistent:</p>
<pre><code>&gt;&gt; c-rule: if false [[some 'c]]

&gt;&gt; parse [a b] ['a 'b c-rule]
== b

&gt;&gt; c-rule: if true [[some 'c]]

&gt;&gt; parse [a b c c c] ['a 'b c-rule]
== c
</code></pre>
<h2>
<a name="a-quirky-maybe-combinator-is-probably-bad-news-2" class="anchor" href="https://forum.rebol.info#a-quirky-maybe-combinator-is-probably-bad-news-2"></a>A Quirky MAYBE Combinator Is Probably Bad News</h2>
<p>Not everything in the evaluator universe is going to have a PARSE parallel.  If you have a null rule, I guess you may just have to use a GET-GROUP! and call the evaluator's MAYBE.</p>
<pre><code>&gt;&gt; c-rule: null

&gt;&gt; parse [a b] ['a 'b :(maybe c-rule)]
== b
</code></pre>
<p>This will keep you from erroring on the null by turning the null into a void.</p>
<p>UPARSE has richer mechanisms to help the higher-order rules, to more intentionally express the R3-Alpha progress rule...which you could use:</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)))" [
        opt some further :(maybe prefix)
        some "a"
        opt some further :(maybe suffix)
     ]
== ")"
</code></pre>
<p>If you don't want PREFIX to be "ornery" when it's used in PARSE, then initialize it to void instead of null and this cleans up a bit:</p>
<pre><code>&gt;&gt; prefix: void, suffix: ")"

&gt;&gt; parse "aaa)))" [
        opt some further prefix
        some "a"
        opt some further suffix
     ]
== ")"
</code></pre>
<p>There are a lot of tools at one's disposal, and I don't think we need anything crazier than this.  I'm content enough with it, I think!</p> ]]></description>
        <link>https://forum.rebol.info/t/the-handling-of-null-and-void-in-uparse/2023#post_2</link>
        <pubDate>Fri, 23 Jun 2023 01:00:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6621</guid>
      </item>
      <item>
        <title>Shades of Distinction In Non-Valued Intents</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Void variables were deemed to be something it would be undesirable to have be "too friendly". So they were slated to be mean on WORD!-access...</p>
<pre><code>[2]  &gt;&gt; void-value
     ** Error: VOID-VALUE is void (use GET-WORD! or GET/ANY)

     &gt;&gt; append [a b] :void-value
     == [a b]
</code></pre>
</blockquote>
</aside>
<p><strong>So... I'm questioning the necessity of making accesses of void variables require a GET-WORD!.</strong></p>
<p>There's a certain amount of historical bias against "liberal voids" that dates back to the old-timey havoc that voids could wreak on code structure.  They'd just skip the evaluator ahead:</p>
<pre><code>old-ren-c&gt;&gt; append [a b c] void 'd
== [a b c d]
</code></pre>
<p>Those were the days when it had no way to represent in an object whatsoever.  A bit later, a voided variable meant an <em>unset</em> variable...so it couldn't be too easy to read them.  <a href="https://forum.rebol.info/t/how-became-quoted-void-and-became-quasi-void/1915/5">That was supplanted with the idea that unset variables are actually <em>void isotopes</em>,</a> completely distinct.</p>
<p>Today voids are meta-representible with a lone apostrophe:</p>
<pre><code>&gt;&gt; make object! [
    a: if false [10]
    b: void
    c: '
 ]
 == make object! [
     a: '
     b: '
     c: '
 ]
</code></pre>
<p>The main point of lingering concern is that void variables might be "too easy to make", and if you assign void to a variable you might wind up opting out of things you didn't mean to opt out of.</p>
<pre><code>var: case [
    conditionA [...]
    conditionB [...]
]  ; imagine none of the cases run

append [a b c] var  ; is this too easy to be a no-op?
</code></pre>
<p>But is that fear really justified, when you could have written:</p>
<pre><code>append [a b c] case [
    conditionA [...]
    conditionB [...]
]  ; again, imagine none of the cases run, no-op by design
</code></pre>
<p><a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880">The whole idea of void-in-null-out</a> is designed to limit the issues of error locality that historical "none propagation" had.  The odds of protecting someone are probably lower than interfering with legitimate void intent.</p>
<p>Some of the most "fearsome" motivating cases are no longer applicable.  For instance, REDUCE was historically used to assign variables itemwise...and a vanishing expression could wreak havoc:</p>
<pre><code> set [a b c] reduce [expr1 expr2 expr3]
</code></pre>
<p>Modern ideas like PACK don't vaporize voids... they preserve them in a meta state:</p>
<pre><code> &gt;&gt; meta pack [1 void 3]
 == ~['1 ' '3]~
</code></pre>
<p><a href="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634/10">And the SET-BLOCK! and SET-WORD! unpacking logic is much more clever!</a></p>
<p>By and large people lobbied for the convenience of REDUCE being able to splice and evaporate expressions.  Cases where an exact number of expressions with no splices or evaporations are needed are less common, and could be handled with REDUCE/EXACT or other routine.</p>
<p><strong>And if UPARSE became void-friendly it would help with the issue of <a href="https://forum.rebol.info/t/the-handling-of-null-in-uparse/2023">dealing with NULL (and void) in UPARSE</a>.</strong>  Null rules would error, void rules would bypass without advancing the input.</p>
<p>While you can't skip voids as arguments, interstitial voids do still cause some oddness in the evaluator:</p>
<pre><code>&gt;&gt; x: if 1 &gt; 2 [print "not run"]

&gt;&gt; 10 + 20 x
== 30
</code></pre>
<p>But this oddness is really just kind of an epicycle of the rest of the oddness of what voids do inside COMPOSE or REDUCE or anything else.  Are these examples any scarier than one another?</p>
<pre><code> &gt;&gt; do [10 + 20 x]
 == 30

 &gt;&gt; reduce [1 + 2 x 10 + 20]
 == [3 30]
</code></pre>
<p><strong>Considered in total, I think it's time to be more accepting of the fluidity and power of void variables.</strong>  If you don't like them, don't make them.</p>
<p><em>(This might mean making constructs like CASE and SWITCH yield null when no branches are taken?  Or that could be a choice people make in their own base library.. to tweak voiding control structures to be nulling when no branches taken... so you'd have to say <strong>maybe case [...]</strong> to get voiding behavior)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604#post_4</link>
        <pubDate>Thu, 22 Jun 2023 23:51:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6620</guid>
      </item>
      <item>
        <title>Working With Truthy BLANK! (in SPLIT-PATH Tests)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>As a further note, <a href="https://github.com/red/red/issues/5024">I borrowed the tests for SPLIT-PATH from a Red issue</a>.</p>
<p><em>And I want to say how bad historical Rebol/Red SPLIT-PATH seems to be!</em></p>
<p>Instead of giving you a directory and an optional file, you get the last directory fragment if there is no file part:</p>
<pre><code>rebol2&gt;&gt; split-path %/c/rebol/tools/test/test.r
== [%/c/rebol/tools/test/ %test.r]  ; seems reasonable...

rebol2&gt;&gt; split-path %/c/rebol/tools/test/
== [%/c/rebol/tools/ %test/]  ; what?

rebol2&gt;&gt; split-path http://
== [http:/ %/]  ; seriously?
</code></pre>
<p><a href="https://github.com/red/red/issues/5024#issuecomment-1006032330">hiiamboris sums up my opinion</a>, which is that you should never get a directory back for the file part.</p>
<p>So that is the Ren-C behavior:</p>
<pre><code>&gt;&gt; [file dir]: split-path %/c/rebol/tools/test/
== ~null~  ; isotope

&gt;&gt; file
== ~null~  ; isotope

&gt;&gt; dir
== %/c/rebol/tools/test/
</code></pre>
<p>It uses multiple return values instead of returning a block.  So there had to be a decision about which would be the primary and secondary results.  It's a tough call, but I felt like splitting out the filename as the first result was probably the better option.  You can of course use "circling" to get the directory instead without having to name a variable:</p>
<pre><code>&gt;&gt; [_ @]: split-path %/c/rebol/tools/test/
== %/c/rebol/tools/test/
</code></pre>
<p>There was some debate about whether a null (none) signifier was better than coming back with an empty file like <strong>%""</strong> to help with joining the parts back together.  Historical #[none] doesn't have the voidability through MAYBE and just tends to create garbage.  Oldes complains about having to remember to write the likes of <strong>any [file %""]</strong> to work around the problems:</p>
<pre><code>rebol2&gt;&gt; join %/c/rebol/tools/test/ none
== %/c/rebol/tools/test/none  ; d'oh
</code></pre>
<p>But Ren-C has what I believe is just the right mix of caution on this... giving you a null that can be tested for truthiness, as well as alerting you to the absence if you try to use it...all while being able to easily MAYBE it into a void that can systemically act like emptiness:</p>
<pre><code>&gt;&gt; [file dir]: split-path %/c/rebol/tools/test/

&gt;&gt; combined: join dir file
** Script Error: Invalid use of ~null~ isotope

&gt;&gt; combined: join dir maybe file
== %/c/rebol/tools/test/

&gt;&gt; file: join file %".temp"
** Error: JOIN does not allow null for its BASE argument
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007#post_2</link>
        <pubDate>Thu, 22 Jun 2023 20:29:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6619</guid>
      </item>
      <item>
        <title>A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1634">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We can prototype the behavior by making PACK quote a SET-WORD! or SET-BLOCK! on its left, and combine that with the unpacking.</p>
</blockquote>
</aside>
<p>Circa 2023 we now have a PACK! representation simply as isotopic blocks, with the "unpacking" done by the internal implementation of SET-BLOCK!</p>
<pre><code>&gt;&gt; pack [1 + 2 10 + 20]
; first in pack of length 2
== 3

&gt;&gt; a: pack [1 + 2 10 + 20]
== 3

&gt;&gt; [b c]: pack [1 + 2 10 + 20]
== 3

&gt;&gt; b
== 3

&gt;&gt; c
== 30
</code></pre>
<p>It's much more freeform, and can be META'd and UNMETA'd into a quasiform...allowing you to put as much distance between the generation of the pack and the unpacking done by SET-WORD! or SET-BLOCK!</p>
<pre><code>&gt;&gt; [b c]: (print "No tight coupling of PACK with SET-BLOCK!", pack [1 + 2 10 + 20])
== 3

&gt;&gt; c
== 30

&gt;&gt; meta pack [1 + 2 10 + 20]
== ~['3 '30]~
</code></pre>
<p><strong>Hence the PACK! representation now underlies the entirety of multi-return mechanics.</strong>  <a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/12">This allows wrapping and composability options for multi-return that were not possible with the early implementations.</a></p>
<p>Due to its generality you can do interesting things that don't involve making a multi-return function at all, such as having some branches of a CASE return packs while others don't:  <em>(The /B indicates optionality, and you're okay with no value in that slot to unpack.)</em></p>
<pre><code>[a /b]: case [
    conditionA [1]
    conditionB [pack [2 3]]
    conditionC [4]
]
</code></pre>
<p>Neat though all of this is, questions are raised about <a href="https://forum.rebol.info/t/unstable-isotope-conundrums/2033">which constructs must--by necessity--decay packs to their first value</a>.  So there are still dragons to be slain here.</p> ]]></description>
        <link>https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634#post_10</link>
        <pubDate>Thu, 22 Jun 2023 17:16:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6618</guid>
      </item>
      <item>
        <title>Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Early on, I wanted to avoid situations where an invisible could be in a position where it might look like it was an assignment:</p>
<pre><code>x: elide print "It's confusing when X gets [a]"
append [] 'a
</code></pre>
<p>Since the ELIDE vanished, the result of the APPEND is what X gets.  Confusing!</p>
<p>So at first, I figured it should be illegal to do that.  But I later backed off on ruling it out when I thought about a vanishing BREAKPOINT:</p>
<pre><code>x: breakpoint append [] 'a
</code></pre>
<p>Why shouldn't you be able to put a breakpoint wherever you want, I wondered?  So it became legal.</p>
<p>In the fever dream of making invisibles able to do anything, there were tests like this:</p>
<pre><code>unset 'x
unset 'y
unset 'z
x: 10
y: 1 comment [+ 2
    z: 30] + 7
did all [
    x = 10
    y = 8
    not set? 'z
]
</code></pre>
<p>But the same problems apply when a SET-WORD! is not present in the general case; the ability to bend the "shape" of the source so arbitraily has a big complexity cost in the interpreter.  It then has to be explained in terms of <a href="https://github.com/metaeducation/ren-c/blob/0b5b42003a4c181f38f3eb28e4378dc53d3a14f1/src/mezz/base-defs.r#L150">why COMMENT is ENFIX</a> and a litany of limitations where it doesn't work.  Documenting it is maddening...and it seems to have diminishing returns.</p>
<p><strong>Now I'm having serious second thoughts about the lenience.</strong>  I don't know this tradeoff is ultimately worth it; it becomes very slippery when you are dealing with constructs that you aren't necessarily noticing are invisible.</p>
<p>So I'm thinking that the error on invisibility for non-interstitials (e.g. assignment sources or argument slots) may make sense...to say that invisibility is something that can only happen in interstitial locations.</p>
<p>You can still get your breakpoint at odd positions, just introduce a GROUP! so it's not picked up:</p>
<pre><code>x: (breakpoint append [] 'a)
</code></pre>
<p>Of course, a group might interfere with something like a COMPOSE, so you might need to use DO or be otherwise creative:</p>
<pre><code>x: do [breakpoint append [] 'a]
</code></pre>
<p>We might lament the need to worry more about restructuring the code to accommodate the breakpoint in ways that could disrupt the code.  But with dialecting, the appearance of the word BREAKPOINT even just in itself could have caused a disruption.  It's the cost of doing business in this paradigm.</p> ]]></description>
        <link>https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405#post_9</link>
        <pubDate>Mon, 12 Apr 2021 16:40:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6628</guid>
      </item>
  </channel>
</rss>

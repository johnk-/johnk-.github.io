<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This is a pretty tough call, but I think I'm on the side of saying that COMPOSE should be arity-2.</p>
<p>Beyond the necessity of providing a binding environment when you want to apply COMPOSE to strings, I'm seeing too many places where an arity-1 COMPOSE <em>can't</em> do what you want.</p>
</blockquote>
</aside>
<p>I've had a bit of time to ruminate on this, and "deal with my feelings" about it.</p>
<p>I find myself lamenting things like this:</p>
<pre><code>compose $(a).b
=&gt;
compose $() $(a).b
; or...
compose $() '(a).b
; ...when would you use which ??
</code></pre>
<p>But it's hard to gauge because this is kind of the first year where binding has any sort of shot of working.  The existing corpus has kind of  a selection bias... it doesn't do very ambitious things with binding, because none were possible.</p>
<p>These little decisions may matter more than we know, and glossing over them could be a pretty bad idea.  I think that's where my leaning is, and arity-2 compose still seems like it's probably the right direction.</p>
<h2><a name="p-7987-whats-really-got-me-puzzled-is-use-existing-binding-1" class="anchor" href="https://forum.rebol.info#p-7987-whats-really-got-me-puzzled-is-use-existing-binding-1"></a>What's Really Got Me Puzzled Is "Use Existing Binding"</h2>
<p>The operator I can't quite entirely get my mind around is actually the one that doesn't bring in a binding from outside, but that uses bindings that are "already there".</p>
<p>How much of the binding should be used, exactly?</p>
<p>This one seems "obvious":</p>
<pre><code> foo: func [x y] [
     return compose-existing [a (x + y) b]
 ]
</code></pre>
<p>You'd want that to add the function parameters, right?  We'd presume here that comes from taking the binding on the tip, which was established when the block evaluated.  The contents are unbound, so that tip binding gets used...</p>
<p>Except what if the GROUP! had a binding?  Should that be honored, or does it only take the binding from the tip?</p>
<p>This is a semantic problem, because we're descending down into a nested structure that may not be fit for evaluation--and may not be intended to ever be evaluated as some kind of cohesive form.  We don't know what this structure is going to be used for.  So how would COMPOSE know if it was a good idea to be descending the structure, using evaluator-like rules to inherit the bindings?</p>
<p><strong>Seen in this light, it makes a stronger case for arity-2 COMPOSE.</strong>  Which in fact faces some problems of its own, when there's a binding on the patterns you are composing already.  Though that's a narrower problem, because it <em>definitely</em> wouldn't be deriving binding as it descends into a structure, so it really would only be cases where the specific thing it found on descent had a binding on it.</p>
<p>A safe default would be to error if the things you are trying to compose have already been bound.  Then perhaps have a <strong><code>compose:override</code></strong> switch to say to use the passed in binding.  (Or probably better to just require a predicate function that gets passed the list and you have to decide what to do with it, instead of getting involved in the details.)</p>
<h2><a name="p-7987-but-there-are-casual-cases-which-come-up-2" class="anchor" href="https://forum.rebol.info#p-7987-but-there-are-casual-cases-which-come-up-2"></a>But There Are Casual Cases Which Come Up</h2>
<p>Consider for instance the ENCODE and DECODE operations.  The way I'm working them up is that there's a dialected block for specifying the encoder and decoder.</p>
<pre><code> encode 'UTF-8 string  ; use default settings
 encode [UTF-8] string  ; equivalent form of dialected block
 encode [UTF-8 ...] string  ; block can pass settings
</code></pre>
<p>But I also thought it would be good if it "pre-composed" the block.  So the meaning of GROUP!s in all encode dialects is to compose.  This is an expedient convention, which frees the authors of encoders from having to worry about it and lets users assume they know what groups will do, because it's very likely that you want to supply settings from expressions or variables:</p>
<pre><code>num-bytes: 4
encode [BE +/- (num-bytes)] integer
</code></pre>
<p>This is one of the cases where traditional "just do it" COMPOSE feels like a fit.  But with arity-2 compose it winds up being a mouthful, something like:</p>
<pre><code>compose (bind binding of spec '()) spec
</code></pre>
<p>You have to produce a GROUP! which has the same binding as the BLOCK!.</p>
<p>There needs to be a shorter way to say this, and I think arity-2 compose can do this for us if it uses a different part of speech:</p>
<pre><code>compose @() spec
</code></pre>
<p>This goes along with some other uses of THE-XXX! to mean "reuse binding".  It's better to do this with something that's explicitly seen by the COMPOSE operation as a signal of meaning, instead of making an assumption about what an unbound GROUP! meant:</p>
<pre><code>compose '() spec  ; looks "intentional" here...
compose patern spec  ; but an unbound group could just be an accident
</code></pre>
<p>This still gives the freedom to use other patterns like <strong><code>@{{}}</code></strong> or <strong><code>@(&lt;*&gt;)</code></strong> without having to use some other refinement to the process.  These would be meaningless for strings--as there's no binding to reuse.</p>
<p>I don't know what it means in terms of descending.  Just use the tip is probably the sanest default.</p>
<p><strong>I think with this adjustment, arity-2 compose still comes out ahead.</strong></p>
<p>I'm still wondering about the COMPOSE* operation with sneaky environment capture, and assumption of parentheses.  Maybe COMPOSE** would look for doubled parentheses.</p>
<pre><code>&gt;&gt; x: 1000, y: 20

&gt;&gt; compose* "The sum is (x + y), with an easy comma."
== "The sum is 1020, with an easy comma."

&gt;&gt; compose** "The sum is ((x + y)), with an easy comma."
== "The sum is 1020, with an easy comma."

&gt;&gt; compose $(()) "Is that ((x + y)), actually worth it?"
== "Is that 1020, actually worth it?"
</code></pre>
<p>More food for thought.</p> ]]></description>
        <link>https://forum.rebol.info/t/envelop-and-compose-by-example/2294#post_7</link>
        <pubDate>Sun, 22 Dec 2024 20:23:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7987</guid>
      </item>
      <item>
        <title>-&gt; for Lightweight Lambda (&quot;Arrow Functions&quot;)</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2172">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><em>But wait, you'd never use it with a branch... because a branch only produces one value.</em></p>
<p>UNLESS... what if what this form of lambda did was unpack packs?</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">case [
    true [pack [10 + 20, 3 + 4]]  ; makes antiform ~['30 '7]~
    ...
] then [a b] -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a -&gt; [
    assert [a = 30]
]
</code></pre>
<p>So I've been thinking this is what it should actually do.</p>
</blockquote>
</aside>
<p>It occurs to me that both can be possible, using a notation that suggests the semantics... quasiform block!</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]  ; makes antiform ~['30 '7]~
    ...
] then ~[a b]~ -&gt; [
    assert [a = 30, b = 7]
]
</code></pre>
<p>Maybe it looks a little bit weird, but is coherent considering that this is how antiform packs are proxied in places like multi-return values:</p>
<pre><code>foo: func [
    return: [~[integer! integer!]~ text!]
    x [integer!]
][
    if even? x [
        return pack [x + 1, x + 2]
    ]
    return "It wasn't even..."
]
</code></pre>
<p>Anyway, this means that plain block can suggest multiple arguments, quasi-block can suggest unpacking, and you have both forms.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2172">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Is There A Good Name For "Lambda Lite"?</strong></p>
<p>We could call it an "unpacking lambda". Maybe it's controlled with a refinement:</p>
<p><code> &gt;&gt; foo: lambda/unpack [a b] [a + b + 20]</code></p>
</blockquote>
</aside>
<p>I think we can probably get away with calling this ARROW.</p>
<p><a href="https://www.digitalocean.com/community/tutorials/understanding-arrow-functions-in-javascript">"Arrow functions"</a> is an established terminology.  If people want to make a variable called ARROW they probably wouldn't notice they were overriding it, because all uses will be through <strong><code>-&gt;</code></strong>... and it'd be available as LIB.ARROW.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2172">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<ol>
<li>does <strong><code>-&gt;</code></strong> make a deep copy of the block?</li>
<li>or does it just make a small structure that pairs the name of the parameter(s) with the body of code?</li>
</ol>
<p>Today's it's [2]... <strong><code>-&gt;</code></strong> just makes that small structure (while LAMBDA makes the full copy). But this means you get the semantics of a non-copying construct:</p>
</blockquote>
</aside>
<p>Branches definitely shouldn't be deep copied.  Whether they run or not.  Especially not if they don't.  But if they do it would make a deep copy each time...pretty useless.</p>
<p>It's a bit unsettling to say that <strong><code>x -&gt; [...]</code></strong> and <strong><code>lambda [x] [...]</code></strong> have distinct semantics, but I think having it run a different function generator called ARROW may help make it seem less insane.</p> ]]></description>
        <link>https://forum.rebol.info/t/for-lightweight-lambda-arrow-functions/2172#post_4</link>
        <pubDate>Sun, 22 Dec 2024 17:49:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7986</guid>
      </item>
      <item>
        <title>Get_Xxx_Flag() vs Has_Xxx_Flag() ?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Kind of a fiddly naming issue, but there are a lot of places where flag-testing helpers are defined, which usually have 4 variants like this:</p>
<pre><code>#define Set_Details_Flag(p,name) \
    Set_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)

#define Get_Details_Flag(p,name) \
    Get_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)

#define Clear_Details_Flag(p,name) \
    Clear_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)

#define Not_Details_Flag(p,name) \
    Not_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)
</code></pre>
<p>The savings add up for having things like the NOT form, it unclutters things pretty well:</p>
<pre><code>Not_Details_Flag(details, CAN_BE_DISPATCHED_AS_INTRINSIC)
// vs
not Get_Details_Flag(details, CAN_BE_DISPATCHED_AS_INTRINSIC)
</code></pre>
<p>I hadn't really questioned these.  But lately I've been wondering... would HAS be better than GET?</p>
<pre><code>if (Has_Details_Flag(...)) ...

if (Get_Details_Flag(...)) ...
</code></pre>
<p>It's a subtle semantics thing.  You could argue that even if a flag is not set, the structure still <em>has</em> the flag.</p>
<p>But is "if Get(...)" like asking if the get operation itself succeeded?  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Of course, in the interpreter we have taken for granted that <strong><code>if get $var</code></strong> isn't asking if you successfully got the variable, but whether the variable's contents are null or not.  And <strong><code>has obj field</code></strong> is really asking about the presence or absence of the field.</p>
<p>When I first thought of it, I was thinking that HAS was better.  But after writing this I'm kind of thinking GET may be the more consistent choice after all.</p>
<p>To be painfully precise, we'd call it: <strong><code>Is_Details_Flag_Set(...)</code></strong>... but I certainly prefer <strong><code>Get_Details_Flag(...)</code></strong> to that.</p> ]]></description>
        <link>https://forum.rebol.info/t/get-xxx-flag-vs-has-xxx-flag/2358#post_1</link>
        <pubDate>Sun, 22 Dec 2024 16:29:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7985</guid>
      </item>
      <item>
        <title>What Should Returning a String From a Native Do?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I've raved about <a href="https://forum.rebol.info/t/no-preprocessing-no-ffi-just-awesome-rebfunction/2224">how cool rebFunction() is</a>... though it may seem like mundane C interop, it's not.  <strong>It's quite novel.</strong></p>
<p>But to recap, a trivial example:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">const char* Add_1000_Spec = "[ \
    -{Adds 1000 to whatever you pass in}- \
    return: [integer!] \
    x [integer!] \
]";
Bounce Add_1000_Impl(Context* binding)
{
    int x = rebUnboxInteger("x");
    int bigger = x + 1000;
    return rebInteger(bigger);
}

Value* action = rebFunction(Add_1000_Spec, &amp;Add_1000_Impl);
</code></pre>
<p>So here you see us returning a synthesized Rebol Value, an INTEGER!.</p>
<p>You can return other things, such as <strong><code>rebDelegate("...");</code></strong> which defers execution to code which can do all kinds of things like throw or raise errors, or produce unstable antiforms.</p>
<h2><a name="p-7984-but-no-return-states-overlap-utf-8-strings-1" class="anchor" href="https://forum.rebol.info#p-7984-but-no-return-states-overlap-utf-8-strings-1"></a>But No Return States Overlap UTF-8 Strings</h2>
<p>This is by design.  All Cells and Stubs in the system are out-of-band from valid UTF-8 leading characters.</p>
<p>This means that the meaning for this is wide open:</p>
<pre><code>const char* Return_Utf8_Spec = "[ \
    -{return of a C const char literal pointer}- \
    return: [???] -{what do you think?}- \
]";
Bounce Return_Utf8_Impl(Context* binding)
{
    return "ðŸ˜¸ Some UTF-8 Here ðŸ˜¸";
}
</code></pre>
<h2><a name="p-7984-obvious-answer-return-text-2" class="anchor" href="https://forum.rebol.info#p-7984-obvious-answer-return-text-2"></a>"Obvious" Answer: Return TEXT!</h2>
<p>You might think that it's completely obvious what should happen in this case: that it returns TEXT! and that's the end of that.</p>
<p>Hence this would be a synonym for:</p>
<pre><code>return rebText("ðŸ˜¸ Some UTF-8 Here ðŸ˜¸");
</code></pre>
<p>Given that we could make the "instructions" legal to return as well, it could be equivalent to something even shorter:</p>
<pre><code>return rebT("ðŸ˜¸ Some UTF-8 Here ðŸ˜¸");
</code></pre>
<p>So this doesn't really rock anyone's world with a capability they didn't already have.</p>
<h2><a name="p-7984-or-it-could-run-code-3" class="anchor" href="https://forum.rebol.info#p-7984-or-it-could-run-code-3"></a>OR... It Could Run Code...</h2>
<p>I'll point out that plain C strings aren't generally seen in the API as being equivalent to text literals.  They're equivalent to code.</p>
<pre><code>rebElide("this isn't a string -{but this is}-");
</code></pre>
<p>So shifting into non-code interpretation requires some kind of marker.</p>
<p>By this logic, we might say that the specific relationship between <strong>return</strong> and a string runs code...but more than that, <em>delegated</em> code.</p>
<p>This is to say that because you are returning, you can do things safely that you couldn't do otherwise... because you've passed control back to the trampoline.  Hence something like a FAIL would not cross your own C stack levels.</p>
<pre><code>return "fail -{This would be safe!}-"
</code></pre>
<p>It's not as powerful as <strong><code>rebDelegate()</code></strong>, because you can't splice things in variadically.  And you might wonder how it could work at all...since it doesn't have a way to capture the shadowed binding variable.</p>
<p><strong>But interestingly, it doesn't need to capture the shadowed variable, because in processing the return it's actually the point of control of the Dispatcher that passed the variable in the first place!</strong></p>
<p>So indeed, you have access to the full context...including the local variables in the frame.</p>
<pre><code>const char* Return_Delegates_Spec = "[ \
    -{Demonstrate returning UTF-8 as delegation}- \
    return: [tag!] \
    x [integer!] \
]";
Bounce Return_Delegates_Impl(Context* binding)
{
    if (rebUnboxInteger("x") &gt; 1020)
         return rebValue("&lt;nice large number!&gt;");
    return "raise [-{X value is too small:}- x]";
}
</code></pre>
<h2><a name="p-7984-rebdelegate-still-is-a-lot-more-full-featured-4" class="anchor" href="https://forum.rebol.info#p-7984-rebdelegate-still-is-a-lot-more-full-featured-4"></a>rebDelegate() Still Is  A Lot More Full-Featured</h2>
<p>Not only can you splice, but you can use commas to separate runs of text:</p>
<pre><code>return rebDelegate(
    "you", "can",
    "do", "this"
    "and splice", values, "in the midst"
);
</code></pre>
<p>That doesn't wind up doing anything weird like giving you "cando".  The commas in the variadic are token stops.</p>
<p>C++ offers raw strings and you can do things like:</p>
<pre><code>return R"(fail [
    -{You can write a really long failure message here}-
    -{And the raw string will do the right thing}-
])"
</code></pre>
<p>I'm used to the commas, but maybe that's an improvement over:</p>
<pre><code>return rebDelegate("fail [",
    "-{You can write a really long failure message here}-",
    "-{And the raw string will do the right thing}-"
"]");
</code></pre>
<h2><a name="p-7984-overall-i-think-string-as-delegation-is-the-winning-choice-5" class="anchor" href="https://forum.rebol.info#p-7984-overall-i-think-string-as-delegation-is-the-winning-choice-5"></a>Overall, I Think String-As-Delegation Is The Winning Choice</h2>
<p>Making a TEXT! string is both counter to the default interpretation of C strings, and will have a well-known shorthand.</p>
<p>I don't think <strong><code>return rebD()</code></strong> for rebDelegate() has any particular clarity to it.</p>
<p>Where I see this being most useful is for short failure messages, which are pretty common to be returned...even in the middle of functions.</p>
<p>But it also lets you do things you couldn't otherwise, like <strong><code>return "quit 1"</code></strong> or <strong><code>return "halt"</code></strong>.</p>
<p>If you want to return nothing, you can just say <strong><code>return "~"</code></strong> instead of <strong><code>return rebNothing()</code></strong>... we can make that particular case fast where it doesn't call the evaluator (and maybe some other cases too...)</p>
<p>Really, it's just a greater force multiplier!</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-returning-a-string-from-a-native-do/2357#post_1</link>
        <pubDate>Sun, 22 Dec 2024 07:39:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7984</guid>
      </item>
      <item>
        <title>Equivalent to [[nodiscard]] ?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>C++ has an attribute on functions called <code>[[nodiscard]]</code> that instructs the compiler to make sure you do something with a result.</p>
<p><a href="https://en.cppreference.com/w/cpp/language/attributes/nodiscard" class="inline-onebox">C++ attribute: nodiscard (since C++17) - cppreference.com</a></p>
<p>I've long wondered about whether there's some kind of discard-sensitivity that should/could be thrown in, e.g. for noticing when a stray value in evaluation doesn't do anything:</p>
<pre><code>&gt;&gt; append [a b c] [d e] 2 print "Could we error?"
** Error: 2 was discarded
</code></pre>
<p>How much code would break if we didn't allow stray values like that in the evaluator?  I could actually test that question.</p>
<p>Anyway, the mechanics behind RAISE means there's already a place to implement this.  There's a spot where it is decided if a definitional error would be discarded, and if so it's escalated to an abrupt failure.  It's only okay if it falls out of the evaluation to get picked up by someone else, and stays as a hot potato.</p>
<p>But could we have other hot potatoes?  Results of functions that are marked NO-DISCARD?   Plain values?</p>
<p>I can't offhand think of any important techniques this would break.  But I'll have to try it and see.</p> ]]></description>
        <link>https://forum.rebol.info/t/equivalent-to-nodiscard/2356#post_1</link>
        <pubDate>Sat, 21 Dec 2024 18:44:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7983</guid>
      </item>
      <item>
        <title>Multiple Return Values in JavaScript</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>rebRescue() in the C API returns an error, or null if no error... in which case your result is the value that's passed by pointer-to-pointer:</p>
<pre><code> Value* result;
 Value* error = rebRescue(&amp;result, "append 123 456");  // illegal, fails
 if (error) {  // non-0 pointer value means not ~null~ antiform
     /* handle error */
 }
 else {
     /* result is valid */
 }
</code></pre>
<p>But JavaScript doesn't have pointer-to-value semantics.  So you have to use multi-returns.</p>
<p>I didn't know how they did that, so I looked it up.  <a href="https://stackoverflow.com/questions/2917175/return-multiple-values-in-javascript/2917186#2917186">There are two ways</a>.  You can destructure an array:</p>
<pre><code>function getValues() {
    return [getFirstValue(), getSecondValue()]
}
const [a, b] = getValues()  ; any names you want here
</code></pre>
<p>Or you can destructure an object, where you have to use the names of the fields as the same names as your destructure variables:</p>
<pre><code>function getValues() {
    return {
        first: getFirstValue(),
        second: getSecondValue(),
    }
}

const {first, second} = getValues()
</code></pre>
<p>If you don't want to use the exact names, there's another syntax:</p>
<pre><code>const {a: first, b: second} = getValues()
</code></pre>
<p>I don't know if naming multi-returns is super important, and have had bigger ambitions for antiform objects.</p>
<p>The StackOverflow question has someone prescribing that it's very important to pick the named version over the non-named one.  I don't agree, and plan on using the array form for <code>rebRescue()</code></p>
<p><strong>The much bigger issue in my mind is forgetting to do the destructure, and getting back a value that's in-band as a plain array or object, when you really just forgot to destructure.</strong>  Isotopes do a very good thing here, not seen in other languages...decaying to the first item by default, and generalizing moving the out-of-band into band via meta/quasi/etc. forms in order to write peer destructuring operators when you need to.</p>
<p>This is a repeat of JavaScript's issue with Promise, where if you forget to do an AWAIT then you wind up with a Promise by value that you didn't expect.  But AWAIT is terrible for all kinds of other reasons, so we're not going down that road.</p>
<p><a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" class="inline-onebox">What Color is Your Function? â€“ journal.stuffwithstuff.com</a></p> ]]></description>
        <link>https://forum.rebol.info/t/multiple-return-values-in-javascript/2355#post_1</link>
        <pubDate>Sat, 21 Dec 2024 18:32:13 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7982</guid>
      </item>
      <item>
        <title>Exceptions or longjmp() Across Client C/C++ Code</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>So there's a somewhat uncomfortable issue in using the API, of what to do if an abrupt failure happens.</p>
<pre><code>void my_c_function(int x) {
    char* memory = malloc(1020);
    ...
    rebElide("append 1020", rebI(x));  // can't append to integers, FAILs
}
</code></pre>
<p>Currently what happens in this situation depends on whether you're in the body of an API native which is being invoked by the trampoline or not.  If you're not, the program just terminates.  If you are, then there will be a longjmp or C++ exception (based on which you built with) thrown up the stack which gets caught at the trampoline layer of the API native invocation, and then propagated by that.</p>
<p>Either way you'll get a memory leak.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7981-every-api-could-return-failure-values-1" class="anchor" href="https://forum.rebol.info#p-7981-every-api-could-return-failure-values-1"></a>Every API Could Return Failure Values</h2>
<p>Then you would be forced to check it:</p>
<pre><code>Value* abrupt;
Value* result = rebValue(&amp;abrupt, "append 1020", rebI(x));
if (abrupt) {  // an ERROR! value, we'd presume
    free(memory);
    /* handle error */
}
</code></pre>
<p>Currently if you want to do something like this, there are tools like ENRESCUE, which will give you an ERROR! if there's a failure, or a ^META of whatever else:</p>
<pre><code>Value* meta = rebValue("sys.util/enrescue [append 1020", rebI(x), "]");
if (rebUnboxLogic("error?", meta")) {
    free(memory);
    /* handle error */
}
Value* result = rebValue(meta);  // evaluating meta will unmeta it
</code></pre>
<p>So yes, we could make that easier...and should:</p>
<pre><code>Value* value;
Value* error = rebRescue(&amp;value, "append 1020", rebI(x));
if (error) {
    free(memory);
    /* handle error */
}
/* use value, corrupt if error was non-null */
</code></pre>
<p>The API is built programmatically, so there's no real reason it couldn't have a Rescue variation for every entry point:</p>
<pre><code>int result;
Value* error = rebRescueUnboxInteger(&amp;result, ...);
</code></pre>
<p>I... guess we could do that.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20">  It's a bit unfortunate that you have to make separate entry points in C for all of these things.   JavaScript can have interface modifiers:</p>
<pre><code>const [error, result] = reb.Rescue.UnboxInteger(...);
</code></pre>
<h2><a name="p-7981-but-lets-say-you-dont-want-that-2" class="anchor" href="https://forum.rebol.info#p-7981-but-lets-say-you-dont-want-that-2"></a>But Let's Say You Don't Want That...</h2>
<p>What if you want plain old <code>rebElide()</code>, not <code>rebRescueElide()</code>, and you want something automatic to happen.</p>
<p>The API exports C functions that are declared with <strong><code>extern "C"</code></strong>.  This means they cannot throw C++ exceptions.  So if you want C++ exceptions so your code is unwound properly, that would have to be done in an inline wrapper of some kind, kind of like:</p>
<pre><code>inline void rebElide(...) {  // not extern "C"
    Value* error = rebRescueElide(...);  // extern "C", can't throw
    if (error)
        throw error;  // throw is legal in non-extern "C" (if C++)
}
</code></pre>
<p>But then, <code>rebFunction()</code> would have to do its own exception handling to intercept these throws so you didn't cross the interpreter stack.  It's doable.</p>
<p>The other option is to use <code>longjmp()</code>.</p>
<h2><a name="p-7981-what-do-other-languages-do-3" class="anchor" href="https://forum.rebol.info#p-7981-what-do-other-languages-do-3"></a>What Do Other Languages Do?</h2>
<p>Well, one case would be Ruby, which has <code>rb_rescue2()</code>, <code>rb_protect()</code>, <code>rb_ensure()</code>...</p>
<p><a href="http://silverhammermba.github.io/emberb/c/#rescue">http://silverhammermba.github.io/emberb/c/#rescue</a></p>
<p>These seem to be longjmp()-based, and nothing special.  Won't work with C++.</p>
<p>That's actually where I adopted the term RESCUE from (in the sense used here, and SYS.UTIL/RESCUE).</p>
<p>Long ago I thought to mirror the Ruby API, but I don't think we need to.  There doesn't need to be a special "Dangerous Function" type or routines to handle it.  Instead we just say that your dangerous function is simply a <strong><code>rebFunction()</code></strong> which has a C function as its implementation.  So we piggy-back on whatever exception handling protects that implementation.</p>
<p>Anyway, short term I've just made a new <strong><code>rebRescue()</code></strong> function implementing the better idea, and gotten rid of the very-very-old Ruby clone routines.  More work is needed, but I do want an answer for being able to properly run destructors in C++ code.</p>
<h2><a name="p-7981-added-convenience-rebmalloc-rebrealloc-rebfree-4" class="anchor" href="https://forum.rebol.info#p-7981-added-convenience-rebmalloc-rebrealloc-rebfree-4"></a>Added Convenience: rebMalloc(), rebRealloc(), rebFree()...</h2>
<p>For the sake of convenience, there is a memory allocator which lets you allocate memory that will be cleaned up automatically in case of a failure, and doesn't require destructors to do it.  It's just taken care of when a failed frame is taken off the stack.</p>
<p>These actually back the memory with a BINARY! series, and are cleaned up by the same mechanics that clean up unmanaged series that are in flight when an internal error occurs.</p>
<p>Just an added thing, but better to use C++ constructs if you have a C++ codebase and if the API is tweaked to properly support destructors, which it should be able to do without needing to compile the interpreter itself as C++!</p> ]]></description>
        <link>https://forum.rebol.info/t/exceptions-or-longjmp-across-client-c-c-code/2354#post_1</link>
        <pubDate>Sat, 21 Dec 2024 17:19:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7981</guid>
      </item>
      <item>
        <title>C++ Magic for LVALUE Checking...or Use Functions?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2350">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">Tweak_Binding(cellA, Binding_Of(cellB));
</code></pre>
</blockquote>
</aside>
<p>After a bit of contemplation, I decided this is the better path.  When you look at the code in context, the all-caps BINDING is actually jarring.</p>
<p>I ended up choosing even longer names:</p>
<pre><code>Tweak_Cell_Binding(x, Cell_Binding(y));
</code></pre>
<p>You actually get something for your typing there... you reinforce that what you're passing is a cell.</p>
<p>But the term "Tweak" is doing the heavy lifting here, as a term that you know when you see it is doing the equivalent of an assignment...with extra checking only in debug builds.</p>
<p>Plain inline functions are easily adapted to, and it's much easier to debug and instrument.  Using "general trickery" may provide some brevity, but at the cost of not having your helper functions tailored to the specific fields you are working with.</p>
<p>I'll invoke one of my favorite phrases lately: "it's a false economy".  There are actually several other changes that have made this kind of thing less necessary.</p>
<h2><a name="p-7980-heres-some-more-code-in-this-vein-getting-dropped-1" class="anchor" href="https://forum.rebol.info#p-7980-heres-some-more-code-in-this-vein-getting-dropped-1"></a>Here's Some More Code In This Vein Getting Dropped</h2>
<p>The need for lengthy explanations is another reason for dropping it.  Lots of explanation for something that doesn't do anything an inline function can't do better.</p>
<h3><a name="p-7980-nodeholder-2" class="anchor" href="https://forum.rebol.info#p-7980-nodeholder-2"></a>NodeHolder</h3>
<pre><code>//=//// NODE HOLDER C++ TEMPLATE //////////////////////////////////////////=//
//
// The NodeHolder is a neat trick which is used by accessors like LINK() and
// MISC() to be able to put type checking onto the extraction of a node
// subclass, while not causing errors if used as the left-hand side of an
// assignment (on a possibly uninitialized piece of data).  This means you
// don't need to have separate macros:
//
//    LINK(Property, s) = foo;
//    bar = LINK(Property, s);
//
// It simply puts the reference in a state of suspended animation until it
// knows if it's going to be used on the left hand side of an assignment or
// not.  If it's on the left, it accepts the assignment--type checked to the
// template parameter.  If it's on the right, it runs a validating cast of
// the template parameter type.

#if CPLUSPLUS_11
    template&lt;typename T&gt;
    struct NodeHolder {
        const Node* &amp; ref;

        NodeHolder(const Node* const&amp; ref)
            : ref (const_cast&lt;const Node* &amp;&gt;(ref))
          {}

        void operator=(T &amp;right)
          { ref = right; }
        void operator=(NodeHolder&lt;T&gt; const&amp; right)
          { ref = right.ref; }
        void operator=(nullptr_t)
          { ref = nullptr; }

        T operator-&gt; () const
          { return cast(T, m_cast(Node*, ref)); }

        operator T () const
          { return cast(T, m_cast(Node*, ref)); }
    };

  #if RUNTIME_CHECKS
    template&lt;class T&gt;
    INLINE void Corrupt_Pointer_If_Debug(NodeHolder&lt;T&gt; const&amp; nh)
      { nh.ref = p_cast(Node*, cast(uintptr_t, 0xDECAFBAD)); }
  #endif
#endif
</code></pre>
<h3><a name="p-7980-link-misc-inode-comments-3" class="anchor" href="https://forum.rebol.info#p-7980-link-misc-inode-comments-3"></a>LINK, MISC, INODE Comments</h3>
<pre><code>//=//// LINK, MISC, and INODE HELPERS /////////////////////////////////////=//
//
// Every Stub Node has two generic platform-pointer-sized slots, called LINK
// and MISC, that can store arbitrary information.  How that is interpreted
// depends on the Flex subtype (its FLAVOR_XXX byte).  If a Stub isn't a
// Flex that uses its INFO bits, then it can use that space for another
// generic platform-pointer slot.
//
// Some of these slots hold other Node pointers that need to be GC marked.  But
// rather than a switch() statement based on subtype to decide what to mark
// or not, the GC is guided by generic flags in the Stub header called
// LINK_NODE_NEEDS_MARK, MISC_NODE_NEEDS_MARK, and INFO_NODE_NEEDS_MARK.
//
// Yet the link and misc actually mean different things for different subtypes.
// A FLAVOR_NONSYMBOL node's LINK points to a list that maps byte positions to
// UTF-8 codepoint boundaries.  But a FLAVOR_SYMBOL Flex uses the LINK for a
// pointer to another symbol's synonym.
//
// A C program could typically deal with this using a union, to name the same
// memory offset in different ways.  Here `link` would be a union {}:
//
//      BookmarkList* books = string.link.bookmarks;
//      string.link.bookmarks = books;
//
//      const Symbol* synonym = symbol.link.synonym;
//      symbol.link.synonym = synonym;
//
// The GC could then read a generic field like `stub-&gt;link.node` when doing
// its marking.  This would be fine in C so long as the types were compatible,
// it's called "type punning".
//
// But that's not legal in C++!
//
//  "It's undefined behavior to read from the member of the union that
//   wasn't most recently written."
//
//  https://en.cppreference.com/w/cpp/language/union
//
// We use a workaround that brings in some heavy checked build benefits.  The
// LINK() and MISC() macros force all assignments and reads through a common
// field.  e.g. the following assigns and reads the same field ("node"), but
// the instances document it is for "bookmarks" or "synonym":
//
//      BookmarkList* books = LINK(Bookmarks, string);  // reads `node`
//      LINK(Bookmarks, string) = books;
//
//      const Symbol* synonym = LINK(Synonym, symbol);  // also reads `node`
//      LINK(Synonym, symbol) = synonym;
//
// The syntax is *almost* as readable, but throws in benefits of offering some
// helpful debug runtime checks that you're accessing what the Flex holds.
// It has yet another advantage because it allows new "members" to be "added"
// by extension code that wouldn't be able to edit a union in a core header.
//
// To use the LINK(), MISC() or INODE(), you define two macros, like this:
//
//      #define LINK_Bookmarks_TYPE     BookmarkList*
//      #define HAS_LINK_Bookmarks      FLAVOR_NONSYMBOL
//
// You get the desired properties of being easy to find cases of a particular
// interpretation of the field, along with type checking on the assignment,
// and a cast operation that does potentially heavy debug checks on the
// extraction.
//
</code></pre>
<h2><a name="p-7980-link-misc-inode-implementation-4" class="anchor" href="https://forum.rebol.info#p-7980-link-misc-inode-implementation-4"></a>LINK, MISC, INODE Implementation</h2>
<pre><code>#if NO_RUNTIME_CHECKS || NO_CPLUSPLUS_11
    #define LINK(Field,stub) \
        *x_cast(LINK_##Field##_TYPE*, m_cast(Node**, &amp;(stub)-&gt;link.node))

    #define MISC(Field,stub) \
        *x_cast(MISC_##Field##_TYPE*, m_cast(Node**, &amp;(stub)-&gt;misc.node))

    #define INODE(Field,stub) \
        *x_cast(INODE_##Field##_TYPE*, m_cast(Node**, &amp;(stub)-&gt;info.node))
#else
    #define LINK(Field,stub) \
        NodeHolder&lt;LINK_##Field##_TYPE&gt;( \
            ensure_flavor(HAS_LINK_##Field, (stub))-&gt;link.node)

    #define MISC(Field,stub) \
        NodeHolder&lt;MISC_##Field##_TYPE&gt;( \
            ensure_flavor(HAS_MISC_##Field, (stub))-&gt;misc.node)

    #define INODE(Field,stub) \
        NodeHolder&lt;INODE_##Field##_TYPE&gt;( \
            ensure_flavor(HAS_INODE_##Field, (stub))-&gt;info.node)
#endif
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/c-magic-for-lvalue-checking-or-use-functions/2350#post_2</link>
        <pubDate>Sat, 21 Dec 2024 09:42:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7980</guid>
      </item>
      <item>
        <title>Limiting API Entry Points in Favor of Exchanging Strings</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="540">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If the "official" API scales back the number of entry points, what justifies a new one?</p>
</blockquote>
</aside>
<p>There are some conveniences I think people might want to define--even just in their own files, e.g.:</p>
<pre><code>#define rebFunction(...)  rebValue("function", __VA_ARGS__)

Value* f1 = rebFunction("[x y] [if x &gt; y [return x] return y]"); 
</code></pre>
<p>This is 6 characters briefer than having to write it out the long way:</p>
<pre><code>Value* f2 = rebValue("function [x y] [if x &gt; y [return x] return y]");
</code></pre>
<p><em>(Not a huge savings, but how much you'd care really depends how many times you're calling it.)</em></p>
<p>I've previously had a convention about their name hinted they weren't actually part of the API:</p>
<pre><code>#define rebFunctionX(...)  rebValue("function", __VA_ARGS__)

Value* f1 = rebFunctionX("[x y] [if x &gt; y [return x] return y]"); 
</code></pre>
<p>Maybe that's helpful, maybe it isn't.  Maybe <strong>rebxFunction()</strong> is better.  The idea here is that you don't want to get in trouble by putting things in the API's "namespace" that may eventually become an API itself.  But also, the behavior of APIs is supposed to not change based on the definition of words...and here we're dealing with something that would change if the meaning of "function" changed.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<hr>
<p>In any case... <strong>I chose this particular example to point out a contention in naming with <a href="https://forum.rebol.info/t/no-preprocessing-no-ffi-just-awesome-rebfunction/2224">the implemented-with-a-<code>CFunction*</code> rebFunction() API entry point</a></strong>.</p>
<p>So perhaps that should be called <strong><code>rebNative()</code></strong> or <strong><code>rebNativeFunction()</code></strong> instead?  (Probably just rebNative() would be fine.)</p> ]]></description>
        <link>https://forum.rebol.info/t/limiting-api-entry-points-in-favor-of-exchanging-strings/540#post_4</link>
        <pubDate>Thu, 19 Dec 2024 14:29:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7979</guid>
      </item>
      <item>
        <title>API Idea: Prepared Statements</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="1" data-topic="2353">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/48/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">rebElide("f: function[a] [return a * 2]");
handle = rebPrepare("print [(f #1) #2]");
rebCall(handle, 5, "apples");
</code></pre>
</blockquote>
</aside>
<p>Looking at this question 7 years later...I think we're not going to get too much better than functions for the "prepared statement handle", in terms of "parameterized thing you can execute".</p>
<pre><code>rebElide("f: function[a] [return a * 2]");
Value* printer = rebValue("lambda [a label] [print [(f a) label]]");
rebElide(printer, 5, "-{apples}-");
</code></pre>
<p>The good news is that you should be able to use <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">innovations like POINTFREE</a> (or whatever it's called), or any other in-language conveniences to define these functions.</p>
<pre><code>rebElide("f: function[a] [return a * 2]");
Value* printer = rebValue("pointfree [print [(f _) _]]");  // single scan
rebElide(printer, 5, "-{apples}-");  // not scanning POINTFREE/PRINT
rebElide(printer, 10, "-{bananas}-");  // not scanning POINTFREE/PRINT
rebElide(printer, 15, "-{kiwis}-");  // not scanning POINTFREE/PRINT
</code></pre>
<p>It's not completely known how that will work, but this is pretty much what's on the table for "prepared statements"...just various convenient usermode function generators.</p>
<h2><a name="p-7977-convenience-entry-points-possible-1" class="anchor" href="https://forum.rebol.info#p-7977-convenience-entry-points-possible-1"></a>Convenience Entry Points Possible...</h2>
<p>I've mentioned the idea of <a href="https://forum.rebol.info/t/limiting-api-entry-points-in-favor-of-exchanging-strings/540/4">making macros to make these calls briefer</a>.</p>
<pre><code>#define rebPointfree(...)  rebValue("pointfree [", __VA_ARGS__, "]")

rebPointfree("print [(f _) _]")
</code></pre>
<p>So that should be able to syntactically match the brevity of <a class="mention" href="https://forum.rebol.info/u/ingohohmann">@IngoHohmann</a> 's <strong><code>rebPrepare()</code></strong></p> ]]></description>
        <link>https://forum.rebol.info/t/api-idea-prepared-statements/2353#post_2</link>
        <pubDate>Thu, 19 Dec 2024 14:12:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7977</guid>
      </item>
      <item>
        <title>No Preprocessing, No FFI, Just Awesome: rebFunction()</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2224">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>You can ask to be called back again after that work is done (<code>rebContinue()</code>)...or you can just transfer control to some additional code and let what it does be the answer (<code>rebDelegate()</code>).</p>
<p>And within that code, it can use the definitional RETURN to deliver the value to the caller of your native!</p>
</blockquote>
</aside>
<p>While this is kind of cool, I wondered if it was a bit superfluous, and couldn't just be done with CATCH and THROW, and define with <code>rebLambda()</code> instead of <code>rebFunction()</code></p>
<pre><code>const char* Use_Catch_Spec = "[ \
    -{Showing that you can use CATCH in an API Continuation}- \
    return: [tag!]  /* here is the problem, discussed below */ \
    arg [integer!] \
];
Bounce Use_Catch_Spec_Impl(Specifier* specifier)
{
    int bigger = rebUnboxInteger(arg) + 1000;  // whatever C processing

    return rebDelegate("catch [",  /* here is the catch */
        "if", rebI(bigger), "&gt; 10000 [throw &lt;big&gt;]",  /* a throw */
        "print -{It wasn't big!}-",
        "throw &lt;small&gt;"  /* another throw */
     "]");
}
</code></pre>
<p>The problem is the longstanding one that lambdas don't have a notation to say they do type checking.  And type checking is a nice feature to have.  But we don't have a way to denote it besides <strong><code>[return: ...]</code></strong> in specs, which implies that there is a RETURN function available.  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>Could we ignore this, and say the <strong><code>RETURN:</code></strong> can be dissociated from the idea that a variable in the frame is also called return?</p>
<pre><code>&gt;&gt; /foo: lambda [return: [integer!] return] [return + 1]

&gt;&gt; foo 5
== 6

&gt;&gt; /bar: lambda [return: [block!] return] [return + 1]
** Error: BAR is supposed to return [block!]
</code></pre>
<p>This doesn't seem as crazy as it might have seemed at one time.  There's kind of a similar question about yielders, which currently do it with:</p>
<pre><code> &gt;&gt; /y: yielder [yield: [integer] x] [yield x + 1, yield x + 2]

 &gt;&gt; y 10
 == 11

 &gt;&gt; y 20
 == 22
</code></pre>
<p>Would it read better as:</p>
<pre><code> &gt;&gt; /y: yielder [return: [integer] x] [yield x + 1, yield x + 2]
</code></pre>
<p>In that case, I kind of feel like the <strong>yield:</strong> reinforces the fact that if you want to call an argument or local RETURN for some reason (and you well might, e.g. as a specialization of YIELD:FINAL for instance)... it feels better.</p>
<p>Anyway... the existence of LAMBDA has gone from an appeasement of people who wanted functions to drop out their last result to instead being a building block of necessity--for making higher level constructs like FUNC that have alternative definitions of RETURN, or for simply writing service code that wants to use RETURN as defined in its calling context.  That can apply to API functions as well, so there will need to be a rebLambda().</p> ]]></description>
        <link>https://forum.rebol.info/t/no-preprocessing-no-ffi-just-awesome-rebfunction/2224#post_4</link>
        <pubDate>Thu, 19 Dec 2024 02:04:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7976</guid>
      </item>
      <item>
        <title>The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Overall, I have been tremendously happy with how the ideas of the <strong><a href="https://forum.rebol.info/t/big-alien-proposal-word-runs-functions/1905">Big Alien Proposal</a></strong> have worked out.</p>
<p>That started from the concept that when slashes appear, they either come <em>before</em> a function they run, or <em>after</em> a function they suppress execution for.</p>
<pre><code>foo.bar
; ^-- foo is an entity from which BAR is being selected.  BAR is not
; allowed to be an antiform frame, so this syntax cannot invoke a
; function call (though it can invoke an 'accessor', e.g. a "getter"
; which is 0-arity).

foo/bar
; ^-- foo is an entity from which BAR (an a FRAME! or antiform FRAME!)
; is being selected and then invoked.  This will generate an error if
; bar is not a frame or antiform frame.

foo.bar/
; ^-- bar is a field which is an antiform FRAME!, whose execution is
; being suppressed.  This expression will return an antiform frame, or
; an error if not an antiform frame.

foo
; ^-- conventional WORD! reference, will run an antiform frame as an
; action invocation or fetch other values as-is

/foo
; ^-- invocation reference, will run an antiform frame (or plain frame)
; as an action invocation and give errors on other types

foo/
; ^-- action suppression, will give you back an antiform frame as-is
; and error on other types.
</code></pre>
<p><em>(If you're curious about why <strong><code>/foo</code></strong> will run plain FRAME! as well as antiform, while <strong><code>foo/</code></strong> will not return an antiform frame for plain FRAME!, this is based on the idea that it's better to be conservative when fetching values so that you won't get surprised by getting a plain frame back from <strong><code>foo/</code>~</strong> which gives everything back as-is.)</em></p>
<hr>
<p>I've written elsewhere <a href="https://forum.rebol.info/t/trailing-slash-is-a-winner-for-defused-actions/2327">how pleased I am that the way you suppress a function's execution is by throwing up a "barrier"</a> with a separating slash that makes it clear arguments are not being gathered at the callsite.  That's really slick.</p>
<p>For this idea to work, something else had to be used for refinements.  That meant <a href="https://forum.rebol.info/t/introducingnew-chain-datatype/2226">invention of the CHAIN! datatype</a> has opened a lot of interesting doors, and I find it's quite learnable to see things like <strong><code>trim:auto:tail</code></strong> instead of <strong><code>trim/auto/tail</code></strong>.</p>
<p><em>I actually prefer it!</em>  What some might think of a disadvantage of being "less noticeable" turns into an advantage... <strong><code>trim:auto</code></strong> really could have been a function called <strong><code>trim-auto</code></strong> just as easily.  Why would you want a slash to make the fact that it has a refinement "pop"?  The slashes to make function calls or suppression pop are much better applied.</p>
<p><strong>So that's all good. <img src="https://forum.rebol.info/images/emoji/twitter/smile_cat.png?v=12" title=":smile_cat:" class="emoji" alt=":smile_cat:" loading="lazy" width="20" height="20"> No regrets!</strong></p>
<h2><a name="p-7975-but-leading-slash-for-functions-rule-hasnt-100-geld-1" class="anchor" href="https://forum.rebol.info#p-7975-but-leading-slash-for-functions-rule-hasnt-100-geld-1"></a>But... Leading-Slash For Functions Rule Hasn't 100% Gel'd</h2>
<p>Another part of the proposal was that in order to get tighter control on what was a function or not, you would be required to assign functions using a leading-slash kind of SET-WORD!.</p>
<pre><code>&gt;&gt; foo: func [a b] [return a + b]
** Error: FOO: can't be used to assign antiform FRAME!, use /FOO:

&gt;&gt; /foo: func [a b] [return a + b]
== ~#[frame! "foo" [a b]]]~  ; anti
</code></pre>
<p><strong>It hasn't fully settled with me after working with it for some time.</strong></p>
<p>As I mentioned above, colons for refinements was easy to adapt to...and now that I'm adapted, I prefer it.</p>
<p>But I'm still typing <strong><code>test: cascade [add/ even?/]</code></strong>.  I love the trailing slashes (and this will be even better when the whole cascade can be done with just <strong><code>even?/add/</code></strong>).  But I'm kind of cursing under my breath the thought of having typed <strong><code>test:</code></strong> and having to backspace over it so it says <strong><code>/test:</code></strong>.  And then I go "hrmph."</p>
<p>When I'm reading code, I probably appreciate it more than I find it to be "messy".  It gives you a better compass.  The eye can scan and comprehend much better... it's of particular value when you're not using an obvious function generator like FUNC, but something else.  This cues readers to go "oh, I guess that's a function generator".</p>
<p>Yet still... it's a burden in a way the other changes are not.  It's the only change that increases the character count.</p>
<h2><a name="p-7975-whats-at-stake-by-not-enforcing-this-2" class="anchor" href="https://forum.rebol.info#p-7975-whats-at-stake-by-not-enforcing-this-2"></a>What's At Stake By Not Enforcing This?</h2>
<p>Ren-C has a powerful story about how antiforms can't be put in blocks, which means you can write this kind of code and it "just works":</p>
<pre><code>block2: collect [
    for-each 'item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<p>When you compare it to Rebol2/R3-Alpha/Red, it's one of those vastly superior situations.  You aren't getting tricked into receiving an ITEM in the FOR-EACH that would generate an unset variable error, or conflate with the state that gets returned when an item can't be picked from a block, or accidentally run a function.  It's a solid solution.</p>
<p>But that's only for blocks.  What about other places, like objects?</p>
<p>If we don't put barriers on how action antiforms get assigned to variables, we get the problem all over again:</p>
<pre><code>for-each [key value] obj [
    if integer? value [  ; oops, what if VALUE is an action antiform!
        print "Found an integer"
    ]
]
</code></pre>
<p>There's no way in this case to say "variables can't hold antiforms".  Logic is an antiform.  Words holding antiform frames are actions.</p>
<p>Getting this under control with slashes is the kind of thing I've been trying to do for a long time, I've just never had the syntax.  Leading slashes felt like it could be the key:</p>
<pre><code>for-each [key value] obj [...]  ; value can't be frame antiform

for-each [key /value] obj [...]  ; value must be frame antiform

for-each [key ~/value] obj [...]  ; value may be frame antiform
</code></pre>
<p>But if these rules are applied everywhere, what you have to do gets more complex:</p>
<pre><code>set $x does [print "Is this an error?"]

set $/x does [print "Do you have to do this?"]

&gt;&gt; var: $x
== x  ; bound

set var does [print "If this errors, how to make VAR into bound /x?"]

set:active var does [print "Do you use refinements?"] (or just SET:ANY ?)
</code></pre>
<p>Nothing is free.  And the already more complicated world where <strong><code>x:</code></strong> is a CHAIN! instead of a fundamental different type of word has its own issues, that these all pile on top of.</p>
<h2><a name="p-7975-theres-likely-not-enough-value-in-optional-slash-3" class="anchor" href="https://forum.rebol.info#p-7975-theres-likely-not-enough-value-in-optional-slash-3"></a>There's Likely Not Enough Value In Optional Slash</h2>
<p>If <strong><code>/foo: func [...] [...]</code></strong> will enforce that the thing you're assigning is an antiform action, but <strong><code>foo: func [...] [...]</code></strong> still works... I have a feeling that the complexity it takes to offer the feature doesn't give a sufficient payoff to be worth it.</p>
<p>You have everyone paying the tax of dealing with complicated path structures and bookkeeping--vs. being able to just SET and GET words and tuples at will... and then you're not even giving any additional guarantees in the source.</p>
<p>This makes me feel like it really is an all-in or not-at-all situation.</p>
<h2><a name="p-7975-long-story-short-im-still-weighing-it-4" class="anchor" href="https://forum.rebol.info#p-7975-long-story-short-im-still-weighing-it-4"></a>Long Story Short: I'm Still Weighing It</h2>
<p>I'm not ready to make a verdict.</p>
<p>The techniques for working with these new CHAIN! and PATH! situations are still being learned.  Most of my hesitance isn't from the looks or typing an extra character, but from frustrations in that...and maybe that frustration will lessen as I work on it more.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-grand-leading-slash-safety-or-burden-question/2352#post_1</link>
        <pubDate>Thu, 19 Dec 2024 01:12:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7975</guid>
      </item>
      <item>
        <title>What to call Antiform PARAMETER! (&quot;Hole&quot;?)</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2351">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Looking over this, UNSPECIALIZED is a pretty lengthy name.</p>
<p>In a frame, these represent information for parameters that need to be gathered.</p>
<p>Should <em>this</em> be what's called a HOLE? It almost makes the most sense. "A frame with holes in it needs to fill those holes from the callsite</p>
</blockquote>
</aside>
<p>A lot of things have jumbled around as I've gotten more experience with this.  Notably the idea of making antiform parameters "vacant" in order to let them act as unfulfilled in FRAME! turned out to be a very poor choice in practice.</p>
<p>I've written up how antiform parameters were normalized, and NOTHING is the unspecialized state exclusive to MAKE FRAME!:</p>
<p><a href="https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347" class="inline-onebox">Default Values and MAKE FRAME! - 2024 Edition</a></p>
<p>What this means is we have an in-memory FRAME! representation for functions, which is what you get back from UNRUN (all it does is remove the antiform state on the FRAME! by changing the quote byte from ANTIFORM_0 to NOQUOTE_1), which gives a plain frame that looks like this:</p>
<pre><code>&gt;&gt; unrun append/
== #[frame! [
    series: ~#[
        parameter! [~void~ any-series? port! map! object! module! bitset!]
    ]~
    value: ~#[parameter! [~void~ element? splice?]]~
    part: ~#[parameter! :[any-number? any-series? pair!]]~
    dup: ~#[parameter! :[any-number? pair!]]~
    line: ~#[parameter! :[]]~
]]
</code></pre>
<p>But in contexts where you're not just trying to de-antiform an action, but actually inquire about the parameters, you might think to ask it like this:</p>
<pre><code>&gt;&gt; parameters of append/
== #[frame! [
    series: ~#[
        parameter! [~void~ any-series? port! map! object! module! bitset!]
    ]~
    value: ~#[parameter! [~void~ element? splice?]]~
    part: ~#[parameter! :[any-number? any-series? pair!]]~
    dup: ~#[parameter! :[any-number? pair!]]~
    line: ~#[parameter! :[]]~
]]
</code></pre>
<p>There might be some shade of distinction...where UNRUN might give you a mutable view of an action, and PARAMETERS OF gives you a read-only view.  I don't know.</p>
<p>But you might ask: <em>"Why not have PARAMETERS OF give back a frame with <em>plain</em> PARAMETER! instead of the antiforms, so they're 'easier' to work with?"</em></p>
<p>That would be more costly and require a separate allocation.  The thing is, that what you see there is actually just a <em>Lens</em> of the actual frame that contains non-antiform cells also (specializations and locals), but because of the view it's only showing you the antiform parameters.</p>
<p>But also, a frame with non-antiform PARAMETER! in it isn't useful for building functions.</p>
<p>So really this is <strong><code>holes of append/</code></strong> <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7973-could-parameter-be-the-antiform-ofsomething-else-1" class="anchor" href="https://forum.rebol.info#p-7973-could-parameter-be-the-antiform-ofsomething-else-1"></a>Could PARAMETER be the antiform of...something else?</h2>
<p>It feels like maybe it should be the case that parameter is the name of the antiform.  But the antiform of <em>what</em> exactly?</p>
<p>It isn't really a TYPESET! because there's more information in it (a textual description, whether it's optional or literal, etc.)  It could be maybe a TYPESPEC!</p>
<p>This is enough information to gather an argument at a callsite.  A GATHER?  Maybe a MATCHER?</p>
<p><em>"parameters are the antiform of matcher!"</em></p>
<p>The problem is that what's in a PARAMETER! cell is so particular to gathering parameters, and for most practical purposes they're always antiforms.</p>
<h2><a name="p-7973-or-is-there-no-real-reason-to-use-antiforms-here-2" class="anchor" href="https://forum.rebol.info#p-7973-or-is-there-no-real-reason-to-use-antiforms-here-2"></a>Or Is There No Real Reason To Use Antiforms Here?</h2>
<p>Things have shaken around, and antiform parameters are legal to pass at callsites as non-^META values.  The only restriction that you get is that you can't specialize frame slots to antiform parameters (without a bit of effort).</p>
<p><strong>So why not just say that plain PARAMETER! is what represents unspecialized slots?</strong></p>
<p>What led me to resist this initially was that whatever represented unspecialized slots couldn't be passed as a plain argument to functions.  This meant if you were going to make some query function for PARAMETER! you had to ^META it, and the meta mechanics are tailored to helping you manage antiforms&lt;-&gt;quasiforms&lt;-&gt;plain.  If PARAMETER! was irregular then it breaks this rhythm, because your meta form is quoted, not quasi...it could be made to work but it would then be rather irregular.</p>
<p><em>Yet things have changed.</em>  You can pass "unspecializeds" normally, you just can't specialize to their value (by definition, since they're a value that represents a lack of specialization).  Though I described a workaround through ENCLOSE-based meta mechanics if you ever <em>really</em> need to do this to a parameter that wasn't already defined ^META.</p>
<p><strong>I think being too invested in the isotope story works against practical usage here.</strong>  If plain PARAMETER! represents unspecialized values in function interfaces, that avoids needing another name for them.  You'll have to learn that they are a little weird, but their weirdness is not "you can't put these in blocks" (which there's a good reason for with other types, but never was a particularly good one for parameter antiforms).</p>
<h2><a name="p-7973-its-really-the-best-option-3" class="anchor" href="https://forum.rebol.info#p-7973-its-really-the-best-option-3"></a>It's Really The Best Option</h2>
<p>Putting aside whether you know what this code is doing or not:</p>
<pre><code>   let f: make frame! make varargs! condition
   for-each [key param] (parameters of f) [
       all [not param.optional, ~end~ = f.(key)] then [
           f.(key): value
           break
       ]
   ]
</code></pre>
<p>vs.</p>
<pre><code>   let f: make frame! make varargs! condition
   for-each [key hole] (holes of f) [
       all [not hole.optional, ~end~ = f.(key)] then [
           f.(key): value
           break
       ]
   ]
</code></pre>
<p>vs.</p>
<pre><code>   let f: make frame! make varargs! condition
   for-each [key unspecialized] (unspecialized of f) [
       all [not unspecialized.optional, ~end~ = f.(key)] then [
           f.(key): value
           break
       ]
   ]
</code></pre>
<p><strong>It needs to be the <code>PARAMETERS OF</code>, and the variable needs to be called <code>PARAM</code>.</strong></p>
<p>So would dropping antiform PARAMETER! be for the best&gt;  Isotopes solve a lot of problems, but once NOTHING moved to the sole unspecialized state in MAKE FRAME! scenarios, having parameter antiforms just seems to be causing mechanical and terminology problems here without adding a lot of benefit...</p>
<h2><a name="p-7973-wed-lose-one-piece-of-terra-firma-maybe-4" class="anchor" href="https://forum.rebol.info#p-7973-wed-lose-one-piece-of-terra-firma-maybe-4"></a>We'd Lose One Piece Of Terra Firma, Maybe?</h2>
<p>If you write a function like:</p>
<pre><code>/specialize-x: func [/action [action?] value] [
    let f: copy unrun action/
    f.x: value
    return runs f
]
</code></pre>
<p>That could specialize any function's X value and give you back a function with X fixed.  Unless you passed an antiform parameter...which is a stable value (by necessity) and would be legal since you didn't give value a type spec.</p>
<p>But in today's antiform-PARAMETER!-is-unspecialized world, if you said:</p>
<pre><code>/specialize-x: func [/action [action?] element [element?]] [
    let f: copy unrun action/
    f.x: element
    return runs f
]
</code></pre>
<p>You'd be able to promise that the specialization would work.  There's arguably a non-zero value to say that the set of things you can put in blocks is a subset of all things you can specialize a value in a frame to.</p>
<p>But what about null, or any of the other antiform states that are legal to specialize to?  That seems kind of arbitrary.</p>
<p>Really, it may just be that there needs to be a SPECIALIZABLE? (or NOT/PARAMETER?) constraint, and that would address this issue without the "maybe not even that useful" guarantee that array elements can always act as specializations.  Who said that specialization-ability and put-in-block-ability had anything to do with each other, anyway?</p>
<p><em>Not only that, there's nothing stopping there being a richer way of saying 'yes I want to specialize with this PARAMETER! explicitly'.</em>*  I've tried to avoid making there be any hidden bits, but SPECIALIZE could offer the feature and implement it however it wanted to.  Which doesn't even have to be hidden, it could be METASPECIALIZE and just fulfill all the arguments as one level meta of what was expected.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p> ]]></description>
        <link>https://forum.rebol.info/t/what-to-call-antiform-parameter-hole/2351#post_2</link>
        <pubDate>Tue, 17 Dec 2024 02:17:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7973</guid>
      </item>
      <item>
        <title>C++ Magic for LVALUE Checking...or Use Functions?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>If you write traditional C like:</p>
<pre><code>BINDING(cellA) = BINDING(cellB);
</code></pre>
<p>Regardless of what the BINDING() macro expands to, there's no way to do any sort of validation in any build (debug or otherwise).  Whatever this becomes can only be a simple assignment.</p>
<p>But if you instead wrote:</p>
<pre><code>Tweak_Binding(cellA, Binding_Of(cellB));
</code></pre>
<p>Then even if the intent is just a simple assignment in a release build, you could define that in a checked build to something that runs arbitrary code :</p>
<pre><code>#if NO_RUNTIME_CHECKS
    #define Tweak_Binding(dest,src) \ 
        (dest)-&gt;extra.binding = (src)-&gt;extra.binding
#else
    #define Tweak_Binding(dest,src) \
        Tweak_Binding_With_Added_Checks((dest), (src))
#endif
</code></pre>
<p><strong>But if you're willing to confine your extra checks to C++ builds, you can leave the source looking like <code>BINDING(cellA) = BINDING(cellB)</code></strong></p>
<p>This is because C++ has operator overloading, and you can create a wrapper class which "does the right thing", e.g. notices whether a <code>BINDING(...)</code> is used as a left hand side operator or right side operator.</p>
<h2><a name="p-7972-just-because-i-can-does-that-mean-i-should-1" class="anchor" href="https://forum.rebol.info#p-7972-just-because-i-can-does-that-mean-i-should-1"></a>Just Because I Can, Does That Mean I Should?</h2>
<p>Most of my original rationale was that I didn't want the source to make it look like you were making a function call when you were not.</p>
<p>When you see something like <code>Tweak_Binding(...)</code> you don't know how many instructions that's going to be, or what side effects its going to have.  But when you see a plain assignment (that you know compiles in C to something quite simple), then that tells you not much is going on.</p>
<p>However...I specifically came up with the term <strong><code>"Tweak"</code></strong> as a convention for functions like this that do very little.  It's a pretty good name, and it's learnable to say "oh, if it says Tweak, that means it's as cheap as an assignment".</p>
<p>Here are some of the points to consider:</p>
<ol>
<li>
<p>Because things like BINDING() are doing weird magic allowing them to be on the left side of assignments, by convention I believe they must be in all caps.  This is kind of noisy.</p>
<ul>
<li>On the plus side, it can be brief, with the same term used for extracting and for tweaking.  Since datatypes use the leading-caps with no underscore convention, plain <strong><code>Binding()</code></strong> looks like a parameterized datatype, so it would have to be <strong><code>Binding_Of()</code></strong> for the extractor</li>
</ul>
</li>
<li>
<p>Using C++ magic to get the RUNTIME_CHECKS means the C build won't have assertion-parity with the C build.  Bugs that only happen in the C build (perhaps on platforms that only offer C) would thus be harder to find.</p>
</li>
<li>
<p>The C++ operator overloading is going to be over the heads of those reading the code who only know C.</p>
</li>
<li>
<p>In debug builds, the C++ compilers do not inline the operator overloading, constructors, etc. that are involved in making the weird objects that are behind the scenes making the trick work.  That means using the C++ debugger to step into an expression like <strong><code>BINDING(cellA) = BINDING(cellB)</code></strong> takes an annoying number of step-in and step-out operations.</p>
</li>
</ol>
<h2><a name="p-7972-heres-the-scary-implementation-2" class="anchor" href="https://forum.rebol.info#p-7972-heres-the-scary-implementation-2"></a>Here's The "Scary" Implementation</h2>
<p>It really isn't rocket science, but it is something.  And it's something that can't be compiled by plain C compilers, meaning you can't do DEBUG_CHECK_BINDING in C builds.</p>
<pre><code>#if (! DEBUG_CHECK_BINDING)
    #define BINDING(cell) \
        *x_cast(Context**, m_cast(Node**, &amp;(cell)-&gt;extra.node))
#else
    struct BindingHolder {
        Cell* &amp; ref;

        BindingHolder(const Cell* const&amp; ref)
            : ref (const_cast&lt;Cell* &amp;&gt;(ref))
        {
            assert(Is_Bindable_Heart(Cell_Heart(ref)));
        }

        void operator=(Stub* right) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = right;
            Assert_Cell_Binding_Valid(ref);
        }
        void operator=(BindingHolder const&amp; right) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = right.ref-&gt;extra.node;
            Assert_Cell_Binding_Valid(ref);
        }
        void operator=(nullptr_t) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = nullptr;
        }
        template&lt;typename T&gt;
        void operator=(Option(T) right) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = maybe right;
            Assert_Cell_Binding_Valid(ref);
        }

        Context* operator-&gt; () const
          { return x_cast(Context*, ref-&gt;extra.node); }

        operator Context* () const
          { return x_cast(Context*, ref-&gt;extra.node); }
    };

    #define BINDING(cell) \
        BindingHolder{cell}
#endif
</code></pre>
<h2><a name="p-7972-looking-at-them-side-by-side-3" class="anchor" href="https://forum.rebol.info#p-7972-looking-at-them-side-by-side-3"></a>Looking at them Side-By-Side</h2>
<pre><code>BINDING(cellA) = BINDING(cellB);

Tweak_Binding(cellA, Binding_Of(cellB));
</code></pre>
<p>I do feel a pretty strong bias for the briefer notation...</p>
<p>But I can see the argument for not doing the "weird" thing when there's no increase in functionality... in fact, only losing functionality in C builds.  <em>(Most C++-isms are there to add something that would be fundamentally not possible in C, vs. just syntax sugar like this.)</em></p>
<p>The invention of the "Tweak" term does change my calculation a little bit here.  Because if it's used only in these "single-assignment-equivalent" circumstances, you can comprehend it as a C assignment statement.</p> ]]></description>
        <link>https://forum.rebol.info/t/c-magic-for-lvalue-checking-or-use-functions/2350#post_1</link>
        <pubDate>Thu, 12 Dec 2024 13:07:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7972</guid>
      </item>
      <item>
        <title>About the C/C++ Implementation category</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>This category is for discussing issues in the source code for the interpreter itself.</p>
<p>e.g. what versions of the C or C++ language spec are supported, or how variables are named, or anything pertinent to that.</p> ]]></description>
        <link>https://forum.rebol.info/t/about-the-c-c-implementation-category/2349#post_1</link>
        <pubDate>Thu, 12 Dec 2024 12:22:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7971</guid>
      </item>
      <item>
        <title>HIJACK-protection: Preserve a Weird Feature? :face_with_diagonal_mouth:</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2348">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It also lets you avoid ordering problems:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext"> hijack foo/ (adapt copy foo/ [print "Doesn't need an extra step!"])
</code></pre>
<p>You'd have to do this in multiple steps otherwise, with some kind of dummy hijacking:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext"> /old-foo: hijack foo/ noop/
 hijack foo/ (adapt old-foo/ [print "Without COPY, you have to do this"])
</code></pre>
</blockquote>
</aside>
<p>I've made this slightly more efficient and slightly more foolproof by letting you HIJACK with VOID.</p>
<p>So you can extract the old code under a new identity, and then if you call the function without hijacking it with a new implementation you get an error:</p>
<pre><code>&gt;&gt; /old-foo: hijack foo/ void

&gt;&gt; foo 10
** Error: FRAME! hasn't been associated with code, or HIJACK'd VOID
</code></pre>
<p>A little safer, a little cheaper.</p>
<p>But this would lead to a common pattern--parentheses not necessary, but help illustrate what's going on:</p>
<pre><code>hijack foo/ (adapt (hijack foo/ void) [
    print "Some adaptation code, or ENCLOSE, or whatever"
])
</code></pre>
<p>It's not <em>that</em> much worse than when you had to do this with COPY (when COPY semantics made sense).  But it is a little worse.</p>
<p>If there were one word for it, like STEAL it would be similar:</p>
<pre><code>hijack foo/ adapt (steal foo/) [
    print "Some adaptation code, or ENCLOSE, or whatever"
]
</code></pre>
<p>But STEAL actually does something else, kind of interesting, FYI:</p>
<pre><code>&gt;&gt; x: 10
== 10

&gt;&gt; steal x: 20
== 10

&gt;&gt; x
== 20
</code></pre>
<p>What would be nice, would be something that looked like this:</p>
<pre><code>adapt (hijack foo/) [
    print "It would be neat if this 'just worked'"
]
</code></pre>
<p>As if creating a new adaptation of that hijack result would somehow in and of itself know how to patch the adapted functionality in to be the new behavior for FOO.  Not that there's a general mechanism for that making sense with this design, but, it "seems convenient".</p>
<p>Of course, ADAPT could have a refinement...</p>
<pre><code>adapt:hijack foo/ [
    print "ADAPT, ENCLOSE, etc. *could* fold in hijacking... :-("
]
</code></pre>
<p>But I'm not a huge fan of anything that makes every such generator need that refinement, they're supposed to be composable orthogonal parts.</p>
<h2><a name="p-7970-leaving-it-how-it-is-for-now-1" class="anchor" href="https://forum.rebol.info#p-7970-leaving-it-how-it-is-for-now-1"></a>Leaving It How It Is For Now...</h2>
<p>I had to muck around with HIJACK just because the old way was impeding the design.  Things are in good enough shape now to work and move on.  Just wanted to write some more thoughts down.</p> ]]></description>
        <link>https://forum.rebol.info/t/hijack-protection-preserve-a-weird-feature/2348#post_2</link>
        <pubDate>Wed, 11 Dec 2024 20:55:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7970</guid>
      </item>
      <item>
        <title>Should NOTHING and NIHIL be Offered as Named Actions?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2234">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; no-op
== ~  ; anti
</code></pre>
<p>Don't know about the hyphen. "literate" but as it's an abbreviation already, kind of annoying. We know what a noop is.</p>
</blockquote>
</aside>
<p>AI are usually very circumspect.  But they were pretty much unanimous saying <em>"programmers know what NOOP (or NOP) is, and this is industry-wide (e.g. jQuery.noop). The hyphen is noise, and if someone didn't know what 'noop' was they'd learn it quickly. Once they learned they would find the hyphen unnecessary."</em></p>
<p>I was motivated to finally pull the trigger on this due to <a href="https://forum.rebol.info/t/preserving-weird-features-hijack-protection/2348">the new rules for HIJACK</a>.  You can use NOOP here as a placeholder, just long enough to get a new identity... then use that identity in a derivation for the function you're going to hijack with.</p>
<p>Example:</p>
<pre><code>let /panic-old: hijack panic/ noop/

hijack panic/ adapt panic-old/ [
    print "PANIC ACTION! is being triggered from a usermode call"
    print mold reason
    ;
    ; ...adaptation falls through to our copy of the original PANIC
]
</code></pre>
<p>Maybe a better placeholder would be some kind of UNREACHABLE that errors when called... if you forgot to fill it in.  But, NOOP is at least not the worst choice.</p>
<p>(Actually, it occurs to me that if you could HIJACK with VOID, it could just leave the stub as a dummy... and then completely overwrite it with the subsequent HIJACK and just give back NULL to say nothing was there...thus not allocating anything extra.  That's probably best.)</p> ]]></description>
        <link>https://forum.rebol.info/t/should-nothing-and-nihil-be-offered-as-named-actions/2234#post_5</link>
        <pubDate>Wed, 11 Dec 2024 13:58:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7969</guid>
      </item>
      <item>
        <title>HIJACK-protection: Preserve a Weird Feature? :face_with_diagonal_mouth:</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>The HIJACK functionality was proposed by <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>, many years ago:</p>
<pre><code>&gt;&gt; /foo: func [x] [print ["FOO" (x + 1)]
&gt;&gt; /foo-reference: foo/

&gt;&gt; foo 20
FOO 21

&gt;&gt; foo-reference 20
FOO 21

&gt;&gt; /bar: func [x] [print ["HIJACKED!" (x + 1000)]

&gt;&gt; hijack foo/ bar/

&gt;&gt; foo 20
HIJACKED! 1020

&gt;&gt; foo-reference 20
HIJACKED! 1020
</code></pre>
<p>And so, way back when... I worked up a mechanic for how to do this.  There's some nuance to how efficient it can be, based on whether the thing you're hijacking uses a parameter list that's in the same "derivation chain".</p>
<p>While it was originally a somewhat fringe feature, it became central to certain parts of the implementation--including the web ReplPad.</p>
<h2><a name="p-7968-what-if-you-want-to-use-the-old-implementation-1" class="anchor" href="https://forum.rebol.info#p-7968-what-if-you-want-to-use-the-old-implementation-1"></a>What If You Want To Use The Old Implementation?</h2>
<p>Note that all references to the old function will run the hijacker.  What if you wanted the old implementation?</p>
<p>The seemingly simplest answer would be to return the old implementation under a new identity by HIJACK:</p>
<pre><code>&gt;&gt; /foo: func [x] [print ["FOO" (x + 1)]
&gt;&gt; /bar: func [x] [print ["HIJACKED!" (x + 1000)]

&gt;&gt; /foo-old: hijack foo/ bar/

&gt;&gt; foo 20
HIJACKED! 1020

&gt;&gt; foo-old 20
FOO 21
</code></pre>
<h2><a name="p-7968-but-i-did-something-different-2" class="anchor" href="https://forum.rebol.info#p-7968-but-i-did-something-different-2"></a>But I Did Something Different...</h2>
<p>In that old era of ACTION! and FRAME! as distinct types, I decided to be clever.</p>
<p>I said that COPY of an ACTION! would create a new action identity that ran the same code... but that wouldn't be affected by a HIJACK of the old action.</p>
<pre><code>&gt;&gt; /foo: func [x] [print ["FOO" (x + 1)]
&gt;&gt; /bar: func [x] [print ["HIJACKED!" (x + 1000)]

&gt;&gt; /foo-copy: copy foo/ 

&gt;&gt; hijack foo/ bar/

&gt;&gt; foo 20
HIJACKED! 1020

&gt;&gt; foo-copy 20
FOO 21
</code></pre>
<p>So HIJACK didn't return anything.</p>
<p>On the one hand: this is strictly more powerful, it means any code anywhere can make a new identity and ensure it won't be affected by <em>subsequent</em> HIJACKs of the original function.</p>
<p>It also lets you avoid ordering problems:</p>
<pre><code> hijack foo/ (adapt copy foo/ [print "Doesn't need an extra step!"])
</code></pre>
<p>You'd have to do this in multiple steps otherwise, with some kind of dummy hijacking:</p>
<pre><code> /old-foo: hijack foo/ noop/
 hijack foo/ (adapt old-foo/ [print "Without COPY, you have to do this"])
</code></pre>
<p>So it seemed superior.</p>
<p>BUT this turned out to be more complicated to implement, and opens a bit of a can of worms about the meaning of COPY.</p>
<h2><a name="p-7968-what-should-could-copy-an-action-mean-3" class="anchor" href="https://forum.rebol.info#p-7968-what-should-could-copy-an-action-mean-3"></a>What Should (Could?) "COPY an ACTION" Mean?</h2>
<p>Let's just simplify matters a little and think about the actions which have an implementation "BLOCK!" behind them...what I've called the "Details Array".</p>
<p>You might imagine that making a copy that would not be subject to the same HIJACK-ings is as easy as making a copy of that array.  Maybe (?) that sounds a little expensive, but, you'd imagine this isn't done <em>too</em> often.</p>
<p>However, consider something like this:</p>
<pre><code>&gt;&gt; /g: generator [yield 1 yield 2 yield 3]

&gt;&gt; g
== 1

&gt;&gt; /g-copy: copy g/

&gt;&gt; g
== 2

&gt;&gt; g-copy
== ???  ; what do you think?
</code></pre>
<p>There's actually a huge problem here, in that the Details Array contains delicate state.  You can't just assume duplicating that state is going to lead to a situation that won't be confused or crashy.  It may contain unique pointers that one of the instances assumes it can free because it thinks it is unique.</p>
<p>Given this reality, the interaction between COPY of ACTION! and HIJACK was very crafty.  The HIJACK only did a <em>minor</em> disruption to the original Details array, basically rewriting a bit of it to say "you've been hijacked" but leaving the contents of the array state in place.  Copies were small stubs that could chain through to the original Details identity--and despite the fact that it had been hijacked, still run it.</p>
<p>But things got fairly twisted.  This meant HIJACK couldn't be simple, and function copies became strange beasts that had to be conscious of the possibility that they were representations of hijackings and be conditional and that.</p>
<h2><a name="p-7968-further-copy-of-action-is-now-copy-of-frame-4" class="anchor" href="https://forum.rebol.info#p-7968-further-copy-of-action-is-now-copy-of-frame-4"></a>Further... COPY of "action" is Now COPY of FRAME!</h2>
<p>The unification of FRAME! and action brought about a bit of a semantics problem.</p>
<p>COPY of an "action" now is just a mechanism of getting another FRAME! with the same parameters, that you can tweak.  It doesn't imply anything about "protect against hijacking".</p>
<p>Hence this notion of "make new action identity that can't be hijacked" would have to be some new operator, not COPY.</p>
<p>We're thus talking about something called <strong><code>make-unhijackable-reference</code></strong>.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7968-or-just-say-screw-it-hijack-returns-new-identity-5" class="anchor" href="https://forum.rebol.info#p-7968-or-just-say-screw-it-hijack-returns-new-identity-5"></a>Or... Just Say "Screw It", HIJACK Returns New Identity?</h2>
<p>This is almost certainly the best answer.</p>
<p>Redoing this doesn't necessarily rule out the idea of inventing MAKE-UNHIJACKABLE-REFERENCE some day.  But that would mean a hijacking would have to preserve the old implementation in a more "costly" way than it has historically, and those references would also be more costly.</p>
<p>Seeing it relatively clearly after having written this post, I think the added cost would be the right way to do it, if this feature were decided to actually matter to anyone.</p>
<p>So far the only uses of COPY of action to avoid hijackability have been done at the moment of hijacking, to re-use the implementation as part of the hijacking.  The concept of "shielding references from HIJACK" for any other reason is not something that I can think of applications for.</p>
<p>(If you are the one exporting a function, and you think you someone might hijack it and you don't want to be subject to those hijackings, you can export an ADAPT with an empty block...or something of that sort...and then your implementation is safe, because if someone hijacks that adaptation it won't affect what the adaptation called.)</p> ]]></description>
        <link>https://forum.rebol.info/t/hijack-protection-preserve-a-weird-feature/2348#post_1</link>
        <pubDate>Wed, 11 Dec 2024 12:53:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7968</guid>
      </item>
      <item>
        <title>Performance Implications of Antiform-FRAME!-is-Action</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2083">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It does mean that if you want to actually take an antiform parameter as an argument, it has to be a ^META parameter...even though it's stable. But that's not such a problem.</p>
</blockquote>
</aside>
<p>It ultimately turned out that this <em>was</em> a problem, and a problem that is resolved now...by pushing back to where NOTHING (antiform blank, e.g. ~ antiform) is the only stable form that requires you to use ^META conventions.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2083">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>When you look at what I mention in the other thread about how you can't really "re-skin" actions anyway (at least with trivial mechanics), I think this suggests that whatever the "MAKE FRAME!" operator is needs to go back to filling the unfulfilled arguments with antiform blank. Antiform parameters need to be friendly when reflecting specs.</p>
</blockquote>
</aside>
<p><a href="https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347/2">I followed through the implications of this</a>, to really get all the ducks in a row.</p>
<p>The results are converging on something quite coherent and useful:</p>
<pre><code>&gt;&gt; append/
== ~#[frame! "append" [series value part dup line]]]~  ; anti

&gt;&gt; words of append/
== [series value part dup line]

&gt;&gt; append.dup
== ~#[parameter! :[any-number? pair!]]~  ; anti

&gt;&gt; append.dup.text
== "Duplicates the append a specified number of times"

&gt;&gt; append.dup.optional  ; seems better than ".is-refinement"
== ~okay~  ; anti

&gt;&gt; append.dup.spec  ; would ".types" be better?  :-/
== [any-number? pair!]
</code></pre>
<p>Here we see the real power coming from the Ren-C concepts.  We're exploiting the duality of FRAME! and action, where the antiform of a frame <em>is</em> the action.  And then further, the idea that there's a separate dot operation for tuple picking...we can keep that meaning so that it still works on the antiform frame, to select out the antiform parameters.</p>
<p>And MAKE FRAME! goes back to unsetting slots:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]]
</code></pre>
<p>While COPY UNRUN can be used to get a FRAME! that lets you tinker with the interface:</p>
<pre><code>&gt;&gt; copy unrun append/  ; UNRUN is just UNQUASI META for antiform frames
== #[frame! [
    series: ~#[parameter! [
        ~void~ any-series? port! map! object! module! bitset!]
    ]~
    value: ~#[parameter! [~void~ element? splice?]]~
    part: ~#[parameter! :[any-number? any-series? pair!]]~
    dup: ~#[parameter! :[any-number? pair!]]~
    line: ~#[parameter! :[]]~
]]
</code></pre>
<p>This stuff may look obvious or clear in retrospect (well it <em>should</em> look clear and obvious, though you'd probably have to use it to really have it sink in.)  But it's quite hard to reason about and adjust in a system that has to keep running.</p> ]]></description>
        <link>https://forum.rebol.info/t/performance-implications-of-antiform-frame-is-action/2083#post_5</link>
        <pubDate>Mon, 09 Dec 2024 09:07:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7967</guid>
      </item>
      <item>
        <title>Default Values and MAKE FRAME! - 2024 Edition</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p><em>Still paying off technical debt, here...this frame stuff has been agonizing.</em></p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2347">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It would mean sacrificing another value to have to be passed ^META. Though bear in mind, most of the damage is done from having one form: e.g. a function like SET is having to take its value ^META already in order to be able to set things to antiform PARAMETER!.</p>
</blockquote>
</aside>
<p>As part of trying out this "two unspecialized forms" concept, I started tightening the screws so I can better reason about the invariants.  It quickly exposed something fundamental, that I might classify as <em>"genuinely interesting"</em>.</p>
<p>Consider the native for testing if something is an INTEGER?.  Let's say it's able to accept ANY-VALUE?, and it should not return true for PARAMETER! antiforms:</p>
<pre><code>/integer?: native [return: [logic?] value [any-value?]]
</code></pre>
<p>We don't want to be in a situation where a function like this needs to take its argument as ^META, because that's a trap we don't want to fall in... where <em>every</em> parameter has to be meta.  You don't want the edge case to spread like that.</p>
<p>But now we have to ask: what if you have an antiform PARAMETER!, and you ask INTEGER? of it.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<p>The options are limited to basically 2 choices:</p>
<ol>
<li>
<p>Antiform PARAMETER! is removed from the ANY-VALUE? class.  That means testing INTEGER? on an antiform parameter would trigger an abrupt failure.</p>
</li>
<li>
<p>Antiform PARAMETER! is made legal in EVAL frame contexts to mean "itself" (while its meaning in RUN frame contexts is "unspecialized").</p>
</li>
</ol>
<p>When you put it that way, I get bad vibes from (1).</p>
<p>Though (2) has consequences that I've explained.  Any function that takes antiform PARAMETER! which doesn't take it ^META will not be able to create <em>partial specializations</em> that fix arguments as antiform parameters, while still gathering other parameters.  You will only be able to use antiform parameters in <em>full specializations</em>.</p>
<p>But I realized you -could- create partial specializations on functions taking antiform parameters non-META.  You'd just have to get creative: make a variant with the parameter adjusted to be ^META and then, use an ENCLOSE...after all the arguments are fulfilled, unmeta it before passing through to the original function.</p>
<p><em>Having <strong>a</strong> way to do it is good enough for me.</em>  I do not think that partial specializations to antiform parameters is going to be something anyone does frequently (or ever, probably, outside of the test files I'm going to write that prove it can be done.)</p>
<h2><a name="p-7966-down-to-just-one-meta-exception-nothing-1" class="anchor" href="https://forum.rebol.info#p-7966-down-to-just-one-meta-exception-nothing-1"></a>Down To Just One ^META Exception: <em>NOTHING</em> (<code>~</code>)</h2>
<p>A "genuinely interesting" aspect of this is that it brings a renewed motivation to the existence of the unset state.  It has been challenged before:</p>
<p><strong><a href="https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113">Why Have an "Unset State" in Rebol-like Languages?</a></strong></p>
<p>I actually was reflecting on the question of the necessity of "nothing" once I realized that protecting-you-from-typos is no longer one of the reasons, due to binding becoming "strict".  So I had a panicky moment where I wondered if <code>~null~</code> and <code>~</code> antiforms should be merged, after all.  <img src="https://forum.rebol.info/images/emoji/twitter/worried.png?v=12" title=":worried:" class="emoji" alt=":worried:" loading="lazy" width="20" height="20"></p>
<p>Almost certainly not... <em>but</em> with PARAMETER! antiforms now in frames as "themselves", something has to give.  There's a strong incentive to pare that back to as few states as possible... and hence, just one thing: NOTHING.</p>
<p>Note it's thus subject to the limitations of (1) above, and hence <em>you can't call INTEGER? on NOTHING</em>.</p>
<p><strong>So NOTHING becomes (as it was) the one stable antiform state that a variable can hold, which cannot be accepted by functions that don't take ^META parameters.</strong></p>
<p>If we didn't do something special, the error you'd get would look like:</p>
<pre><code>&gt;&gt; integer? ~
** Error: INTEGER?'s VALUE argument is unspecified (~ antiform)
</code></pre>
<p>Maybe that's good enough, though the argument-gathering machinery could pre-empt the FRAME! typechecking layer with a clearer message:</p>
<pre><code>&gt;&gt; integer? ~
** Error: INTEGER?'s VALUE argument can't be NOTHING (~ antiform)
</code></pre>
<p>That may be seem like splitting hairs, but I don't think it is.</p>
<h2><a name="p-7966-casualty-unblocks-eval-of-unspecialized-frames-2" class="anchor" href="https://forum.rebol.info#p-7966-casualty-unblocks-eval-of-unspecialized-frames-2"></a>Casualty: Unblocks EVAL of Unspecialized FRAME!s</h2>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2347">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Antiform ~ would still have to turn into ~null~ if EVAL found it in a refinement slot. But I'm not sure PARAMETER! antiforms would need to do that too. One could argue that you should never be EVAL'ing a frame with antiform parameters in it, so it could be a sort of safety mechanism (?).</p>
</blockquote>
</aside>
<p>So with antiform parameters being treated as-is under EVAL, then when you don't use MAKE FRAME! and get the slots filled with nothing, you get the slots filled with antiform parameters.  And that means this would happen:</p>
<pre><code>&gt;&gt; f: copy unrun parameter?/
== #[frame! [value: ~#[parameter! [any-value?]]~]

&gt;&gt; eval f
== ~okay~  ; anti
</code></pre>
<p>I can live with this.  COPY on an action's FRAME! is something you should do only if you're building something you mean to run as an action, and if you EVAL it instead, that's kind of your fault.</p>
<p>Maybe there could be some kind of prevention of this, but I'd be loathe to see the FRAME! type bifurcate into "EVAL-able frames" and "RUN-able frames".</p>
<p>Anyway, this is <em>far</em> less a concern with MAKE FRAME! unsetting the slots, than it was when those were antiform parameters.</p> ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347#post_2</link>
        <pubDate>Sun, 08 Dec 2024 11:56:28 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7966</guid>
      </item>
      <item>
        <title>Default Values and MAKE FRAME! - 2024 Edition</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p><em><strong>NOTE:</strong> The below summarizes history with some adjustments made for simplification purposes.  See posts in <a href="https://forum.rebol.info/c/archive/61">Archive</a> regarding frames for all the exact detours.</em></p>
</blockquote>
<hr>
<p>Something like this has worked ever since the first FRAME!:</p>
<pre><code>f: make frame! append/
f.series: [a b c]
f.value: 10

&gt;&gt; eval f
== [a b c 10]
</code></pre>
<p>Notice that although APPEND has refinements, you don't have to explicitly go through and set them to NULL.  That was done for you.</p>
<p>That might make you think the result of <strong>(make frame! append/)</strong> looked like this:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [  ; you might think...
    series: ~null~
    value: ~null~
    part: ~null~
    dup: ~null~
    line: ~null~
]]
</code></pre>
<p>e.g. all fields defaulting to null, whether they are refinements or not.</p>
<h2><a name="p-7965-thats-not-what-it-did-here-is-why-1" class="anchor" href="https://forum.rebol.info#p-7965-thats-not-what-it-did-here-is-why-1"></a>That's Not What It Did... Here Is Why</h2>
<p>Even before the full-on unification of ACTION! and FRAME! into one datatype, there was a concept that you could make an action out of a frame.  This meant some state of the frame variables had to represent the idea that an argument was still to be gathered.</p>
<p>The goal was something like this:</p>
<pre><code>f: make frame! append/
f.value: 10
; don't assign f.series, leave it however it was

&gt;&gt; run f [a b c]
== [a b c 10]
</code></pre>
<p>If all the argument slots were eagerly set to <strong><code>~null~</code></strong> then you'd get something like:</p>
<pre><code>&gt;&gt; run f [a b c]
** Error: APPEND doesn't allow ~null~ for its VALUE argument
</code></pre>
<p>So instead, MAKE FRAME! would leave the slots all unset, to indicate they were unspecialized:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]]
</code></pre>
<p>If it got to the point of execution, optional parameters (e.g. refinements) would be turned from NOTHING into NULL implicitly.  But if you didn't set a slot for a required parameter, it would give a helpful error:</p>
<pre><code>f: make frame! append/
f.value: 10

&gt;&gt; eval f
** Error: APPEND's SERIES argument is unspecified
</code></pre>
<h2><a name="p-7965-but-what-if-you-want-to-specialize-to-nothing-2" class="anchor" href="https://forum.rebol.info#p-7965-but-what-if-you-want-to-specialize-to-nothing-2"></a>But What If You Want To Specialize To Nothing?</h2>
<p>It might seem that "nothing" is a rare thing to want to specialize to.  But it's a legitimate value, and represents a valid frame state.</p>
<p>e.g. let's say you wanted to write UNSET as a specialization:</p>
<pre><code>/unset: specialize set/ [value: ~]
</code></pre>
<p>This would wind up making UNSET a synonym for SET.  Because it would think you were saying <em>"specialize SET's value to be unspecialized"</em>...which is what it was by default.</p>
<p>In this sense, using NOTHING as the unspecialized value just pushed the problem around a little bit.  No matter what you pick to represent the unspecialized state, you're going to have a problem.  It just happens that functions which take ~null~ antiforms are relatively common compared to those that take ~ antiforms.</p>
<h2><a name="p-7965-leveraging-meta-on-a-stable-antiform-3" class="anchor" href="https://forum.rebol.info#p-7965-leveraging-meta-on-a-stable-antiform-3"></a>Leveraging ^META On a Stable Antiform</h2>
<p>If you start thinking about being sneaky, you might imagine adding extra hidden bits somewhere to say <em>"no, this is a magic kind of specialized NOTHING"</em>.  But sneaky hidden bits are a tangled web, adding cost in the routines to manipulate them.</p>
<p>So the idea was to use a not-so-hidden bit: any function that could legitimately take "nothing" as an argument had to take it as a ^META parameter.</p>
<pre><code>x: 1020

f: make frame! set/
f.var: $x
f.value: first [~]  ; ~ is meta-NOTHING, aka "quasi-BLANK!", aka "TRASH"

&gt;&gt; eval f
== ~  ; anti

&gt;&gt; x
** Error: X is unset (antiform BLANK!)
</code></pre>
<p>This works, but creates an additional burden: functions that truly want to receive a value that can represent any stable form must take their arguments as ^META... which usually you'd think you only need for unstable forms.</p>
<h2><a name="p-7965-theres-still-an-ambiguity-gather-or-error-4" class="anchor" href="https://forum.rebol.info#p-7965-theres-still-an-ambiguity-gather-or-error-4"></a>There's Still an Ambiguity: Gather, Or Error?</h2>
<p>The above was the status quo for a couple of years: MAKE FRAME! gave you back a frame whose slots were all unset.  Those unset slots represented arguments that were unspecialized.</p>
<p>But still you have a question: should an unspecialized argument be gathered from a callsite, or should it trigger an error?</p>
<p>That decision came from the operation.  If you used EVAL on a FRAME!, it would assume all the frame slots were finalized...and any nothing cells would raise errors.  If you used RUN (or converted the FRAME! into an action) then it assumed the unspecialized slots meant you wanted to gather arguments.</p>
<h2><a name="p-7965-evolution-antiform-parameter-for-unspecialized-slots-5" class="anchor" href="https://forum.rebol.info#p-7965-evolution-antiform-parameter-for-unspecialized-slots-5"></a>Evolution: Antiform PARAMETER! For Unspecialized Slots</h2>
<p>A big change came through with a user exposure of the PARAMETER! type.  With antiform parameters representing unspecialized slots, you had the signal of "this is unspecialized", but also the information required to gather the parameter: what types it checked, whether it was a refinement or not, whether it should be taken literally from a callsite, etc.</p>
<p>This heralded even more exposure of the mechanics of function composition to user mode.  Instead of just specializing a function argument to a value, you could do things like "tweak" the argument's accepted types.</p>
<p>For instance: what if you wanted a version of APPEND that only appended integers?</p>
<pre><code>&gt;&gt; ap-int: make frame! append/

&gt;&gt; ap-int.value: anti make parameter! [integer!]  ; or whatever syntax
== ~#[parameter! [integer!]]~  ; anti

&gt;&gt; /ap-int: anti ap-int
== ~#[frame! ...]~  ; anti

&gt;&gt; ap-int [a b c] 1020
== [a b c 1020]

&gt;&gt; ap-int [a b c] "illegal"
** Error: AP-INT requires [integer!] for its value argument
</code></pre>
<p>This meant that MAKE FRAME! gave back something that looked rather weird:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~#[parameter! [
        ~void~ any-series? port! map! object! module! bitset!]
    ]~
    value: ~#[parameter! [~void~ element? splice?]]~
    part: ~#[parameter! :[any-number? any-series? pair!]]~
    dup: ~#[parameter! :[any-number? pair!]]~
    line: ~#[parameter! :[]]~
]]
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji only-emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<p>Although this gives you a useful and actionable information about the parameters, that's fairly noisy for most purposes.  You haven't done any assignments to the frame, and yet it looks like it's "full".</p>
<p>Let's put a pin in that.</p>
<h2><a name="p-7965-are-meta-exceptions-still-needed-6" class="anchor" href="https://forum.rebol.info#p-7965-are-meta-exceptions-still-needed-6"></a>Are ^META Exceptions Still Needed?</h2>
<p>In this model, there is no way of expressing a specialization of a function to an antiform parameter unless that function defined the parameter as ^META.</p>
<p>That doesn't <em>necessarily</em> mean we'd have to be prescriptive.  I mentioned that EVAL expects all the arguments to be specified to their final values, while RUN accepts some will be unspecialized.  So EVAL <em>could</em> treat antiform parameters as the actual values to pass, while RUN would gather them from the callsite.</p>
<p>This would produce a strange conflation.  You couldn't tell by looking at a frame whether or not an antiform parameter was a legitimate argument, or an unspecialized parameter definition.</p>
<p>As an example, consider the HOLE? function, that tells you whether or not a value is an antiform parameter.  Let's assume it's operating in a world that it doesn't need to take the argument as ^META:</p>
<pre><code>&gt;&gt; f: make frame! hole/
== #[frame! [value: ~#[parameter! [any-value?]]~]
</code></pre>
<p>The interface says it takes ANY-VALUE? as the first parameter to HOLE?  Yet we don't have any mechanical way of telling that <strong><code>f2</code></strong> isn't a completed frame for calling HOLE?.  So if EVAL accepts this:</p>
<pre><code>&gt;&gt; eval f
== ~okay~  ; anti
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>It really seems the best plan is to keep erroring when you try to EVAL frames with antiform PARAMETER! in them, when those parameters are required:</p>
<pre><code>&gt;&gt; eval f2
** Error: HOLE?'s VALUE parameter is unspecified (antiform PARAMETER!)
</code></pre>
<p>It does require the ^META exception: functions which need to accept antiform arguments must take that parameter in a meta form.  A function like HOLE? would fit into this category, and so would SET (which has to take unstable antiforms anyway, e.g. to do SET of a BLOCK! to a PACK)</p>
<p>Under this design, any function that can accept antiform parameters at all, will also able to be specialized with antiform parameters.</p>
<h2><a name="p-7965-denoising-make-frame-different-frame-makers-7" class="anchor" href="https://forum.rebol.info#p-7965-denoising-make-frame-different-frame-makers-7"></a>Denoising MAKE FRAME!: Different Frame Makers?</h2>
<p>I pointed out that having antiform parameters in frame slots is a bit noisy.</p>
<p>So what if there were two ways of making frames: one that gives you the parameter antiforms (suitable for tweaking and writing your own specialization operations), and another that clears the fields out?</p>
<p>For instance, keeping the old behavior for MAKE FRAME!:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]]
</code></pre>
<p>But if you wanted antiform parameters, you could just copy the non-antiform version of the FRAME!:</p>
<pre><code>&gt;&gt; copy unrun append/
== #[frame! [
    series: ~#[parameter! [
        ~void~ any-series? port! map! object! module! bitset!]
    ]~
    value: ~#[parameter! [~void~ element? splice?]]~
    part: ~#[parameter! :[any-number? any-series? pair!]]~
    dup: ~#[parameter! :[any-number? pair!]]~
    line: ~#[parameter! :[]]~
]]
</code></pre>
<p>In this design, you'd have <em>two</em> stable forms which you'd have to use ^META conventions to take as an argument.</p>
<p>Antiform ~ would still have to turn into ~null~ if EVAL found it in a refinement slot.  But I'm not sure PARAMETER! antiforms would need to do that too.  One could argue that you should never be EVAL'ing a frame with antiform parameters in it, so it could be a sort of safety mechanism (?).  I'm not sure if it's necessary to enable, so I'd probably just raise an error until I saw a compelling case.</p>
<h2><a name="p-7965-is-the-added-nuance-worth-it-8" class="anchor" href="https://forum.rebol.info#p-7965-is-the-added-nuance-worth-it-8"></a>Is The Added Nuance Worth It?</h2>
<p>Continuing to handle unset variables as placeholders is not strictly necessary, given that antiform parameters are the more fundamental "unspecialized" slot representation.</p>
<p>But it's definitely a lot better than something I tried that <em>sucked</em>: which was trying to make variables holding antiform PARAMETER! act like they were unset.  This made manipulating function interfaces programmatically <em>very</em> painful.</p>
<p>It would mean sacrificing another value to have to be passed ^META.  Though bear in mind, most of the damage is done from having one form: e.g. a function like SET is having to take its value ^META already in order to be able to set things to antiform PARAMETER!.  So it isn't like you'd be able to specialize SET with antiform <code>~</code> to get UNSET if this wasn't done... it would affect the NOTHING? function (and probably not a lot else).</p>
<p><strong>Having used MAKE FRAME! a fair bit, I am inclined to believe it's worth it.</strong>  It's a clear indicator of whether you've assigned fields or not, with some teeth by actually making the variables unset (erroring on use before assignment, and reacting to things like DEFAULT).</p> ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347#post_1</link>
        <pubDate>Sat, 07 Dec 2024 20:48:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7965</guid>
      </item>
      <item>
        <title>BINARY! Dialected Encoding/Decoding instead of TO conversions?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1270">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; encode [LE + 2] 32
== #{2000}  ; little-endian, 2 byte, unsigned

&gt;&gt; encode [LE +/- 3] -2
== #{FEFFFF}  ; little-endian, 3 byte, signed
</code></pre>
</blockquote>
</aside>
<p>I got to wondering "why isn't there a numeric encoding for just negative numbers"?</p>
<p>Then I thought "uh, duh...no such representation is needed, as you just would negate the all-positive representation".</p>
<pre><code>&gt;&gt; negate decode [BE +] #{FF}
== -255
</code></pre>
<p>But with these encoders/decoders... why not build it in as an option?</p>
<pre><code>&gt;&gt; decode [BE -] #{FF}
== -255
</code></pre>
<p>And on encoding, you can ensure the input value is negative:</p>
<pre><code>&gt;&gt; encode [BE -] -255
== #{FF}

&gt;&gt; decode [BE -] 255
** Error: DECODE [BE -] requires input value to be negative
</code></pre>
<p>Not sure how often it would be used... I just like the completeness of it.</p>
<p>There's another axis of potential feature here, which is offset encoding.  So if you're trying to encode a range of numbers between 128 and 383, you can do that in a byte... just consider it to be offset by 128.  I can see it being kind of convenient if that offset were part of the dialected block, and could be reused on the encode and decode side.</p>
<p>Far from being any kind of priority, but, have to stay entertained somehow.</p> ]]></description>
        <link>https://forum.rebol.info/t/binary-dialected-encoding-decoding-instead-of-to-conversions/1270#post_3</link>
        <pubDate>Fri, 06 Dec 2024 16:52:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7964</guid>
      </item>
      <item>
        <title>Should (1 + #A) Equal (#A + 1) ?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I ran across this peculiarity:</p>
<pre><code>rebol2&gt;&gt; 1 + #"A"
== 66

rebol2&gt;&gt; #"A" + 1
== #"B"
</code></pre>
<p>Red and R3-Alpha do this too.</p>
<p>Loosely speaking, there's an internal policy which is something along the lines of <em>"if the types don't match, convert the second operand into the type of the first, and then do the add"</em>.</p>
<p>Because of this, it's necessary to support the addition of characters to each other to get <strong>(<span class="hashtag-raw">#A</span> + 1)</strong> to work:</p>
<pre><code>red&gt;&gt; #"A" + #"B"
== #"^(83)"  ; only useful in implementation of old coercion rule
</code></pre>
<p>...which seems nonsensical to me.</p>
<h2><a name="p-7963-what-do-other-languages-do-1" class="anchor" href="https://forum.rebol.info#p-7963-what-do-other-languages-do-1"></a>What Do Other Languages Do?</h2>
<p>If "implicit type promotion" is supported, many languages, including C, C++, and Java, use a system where the "smaller" type is converted to the "larger" type (<a href="https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap02/exp-2.html">e.g., int to float</a>).  Having an idea of what's bigger and what's smaller helps avoid the commutativity problem.</p>
<p>And in the specific case of adding characters to integers, Rebol is weird to give a different answer depending on order.</p>
<ul>
<li>
<p><strong>Python:</strong> In Python, adding an integer to a character (or vice versa) would raise a TypeError. Python doesn't implicitly convert between these types.</p>
</li>
<li>
<p><strong>JavaScript:</strong> JavaScript would convert the character to its ASCII value and perform integer addition in both cases, resulting in a number.</p>
</li>
<li>
<p><strong>Ruby:</strong> Similar to Python, Ruby would raise a TypeError when trying to add an integer to a character.</p>
</li>
<li>
<p><strong>Java:</strong> Java doesn't allow direct addition between char and int types without explicit casting.</p>
</li>
</ul>
<p>I think adding integers to characters and wanting a character back is the more common operation, so if it's legal, I'd advocate for:</p>
<pre><code>&gt;&gt; 1 + #A
== #B

&gt;&gt; #A + 1
== #B
</code></pre>
<p>But if we want to rule out addition of characters to characters (which I do) this commutative behavior doesn't fall out from a system of implicit conversion with an ordering on "bigger" types... since characters are smaller.</p>
<p>I don't see an obvious "rule" besides hardcoding it.</p>
<h2><a name="p-7963-what-about-commutativity-in-general-2" class="anchor" href="https://forum.rebol.info#p-7963-what-about-commutativity-in-general-2"></a>What About Commutativity In General?</h2>
<p>We can imagine decisions on what you would make <strong><code>+</code></strong> mean that would not be commutative.  For instance, if you were allowed to make it mean "join strings":</p>
<pre><code>&gt;&gt; "abc" + "def"
== "abcdef"

&gt;&gt; "def" + "abc"
== "defabc"
</code></pre>
<p>So you might try and argue that the rules for <strong>add</strong> are different than the rules for <strong>+</strong>, and it's only when + is acting as ADD that it enforces commutativity.  However... even in the domain of math, you have exceptions... e.g. matrix multiplication is not commutative.</p>
<p>The more general question of commutativity seems to be that there aren't any popular languages that do it automatically.  e.g. in C++ you have to overload <strong><code>operator+(T1,T2)</code></strong> and <strong><code>operator+(T2,T1)</code></strong> separately...one of them can call the other, but that never happens automatically.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-1-a-equal-a-1/2346#post_1</link>
        <pubDate>Fri, 06 Dec 2024 12:30:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7963</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Wanting to move refinements is actually a pretty big thinking point at the moment, if you saw this:</p>
</blockquote>
</aside>
<p>Sure, but that isnâ€™t relevant to the order of the mandatory parameters, which is what youâ€™re talking about hereâ€¦ right?</p> ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_10</link>
        <pubDate>Tue, 03 Dec 2024 02:55:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7962</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="8" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>But maybe thereâ€™s some other part of the language which is affected by parameter order. (Refinements? Not sureâ€¦)</p>
</blockquote>
</aside>
<p>Wanting to move refinements is actually a pretty big thinking point at the moment, if you saw this:</p>
<aside class="quote quote-modified" data-post="1" data-topic="2331">
  <div class="title">
    <div class="quote-controls"></div>
    <img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar">
    <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">Refinement Arguments at Head of Args List, Not Tail</a> <a class="badge-category__wrapper " href="https://forum.rebol.info/c/development/functions/59"><span data-category-id="59" style="--category-badge-color: #25AAE2; --category-badge-text-color: #FFFFFF; --parent-category-badge-color: #25AAE2;" data-parent-category-id="8" data-drop-close="true" class="badge-category --has-parent" title="Discussions of Functions and Generators, e.g. how things like RETURN work... or the mechanics of generators and composers like ADAPT, SPECIALIZE, ENCLOSE, HIJACK, etc."><span class="badge-category__name">Functions</span></span></a>
  </div>
  <blockquote>
    In the corpus of code we have so far, it seems to me that when a refinement adds an argument to a function that it would be preferable if that argument would become the first parameter... not tacked onto the end. 
Some cases might not be completely obvious one way or another: 
&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append:dup [a b c] [d e] 2  ; old way
== [a b c [d e] [d e]] 

&gt;&gt; append:dup 2 [a b c] [d e]  ; new idea
== [a b c [d e] [d e]]

I think it's better if it's first, but it's not â€¦
  </blockquote>
</aside>
 ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_9</link>
        <pubDate>Tue, 03 Dec 2024 02:41:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7961</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It's really hard, though, to see this systemically with fresh eyes.</p>
</blockquote>
</aside>
<p>I think that considerations of parameter order in Haskell go more or less like this:</p>
<ol>
<li>If thereâ€™s an obviously intuitive ordering, use that.</li>
<li>Otherwise, if thereâ€™s an ordering which simplifies the definition, use that.</li>
<li>Otherwise, if thereâ€™s no other deciding factor, order them according to what is most useful for partial application.</li>
</ol>
<p>I think to some extent these criteria are less helpful for Ren-C, because it doesnâ€™t make as much use of eta-reduction, currying or partial application. But maybe thereâ€™s some other part of the language which is affected by parameter order. (Refinements? Not sureâ€¦)</p> ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_8</link>
        <pubDate>Tue, 03 Dec 2024 02:39:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7960</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>If someone wants to specify the second parameter first they can always write <code>flip cons</code> or <code>flip snoc</code>.</p>
</blockquote>
</aside>
<p><a href="https://forum.rebol.info/t/design-for-something-like-flip-to-reverse-arguments/2345/1">Some thoughts here</a></p>
<aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>So really this parameter order is so intuitive that it overrides considerations of â€˜less/more importantâ€™.</p>
</blockquote>
</aside>
<p>It's really hard, though, to see this systemically with fresh eyes.</p>
<p>Today for instance REPLACE takes the thing to do the replacement in first:</p>
<pre><code>&gt;&gt; replace [a b b a] 'b 'c
== [a c c a]
</code></pre>
<p>But if this philosophy were extended that would become either of:</p>
<pre><code>&gt;&gt; replace 'c 'b [a b b a]
== [a c c a]

&gt;&gt; replace 'b 'c [a b b a]
== [a c c a]
</code></pre>
<p>It's hard to say which makes more sense.  If the "how you would write it out in English" argument comes up,  it seems briefest as:</p>
<pre><code>replace 'b &lt;with&gt; 'c &lt;in&gt; [a b b a]
</code></pre>
<p>I'm not sure how that would hammer out in the other case:</p>
<pre><code>replace 'c &lt;wherever you find&gt; 'b &lt;in&gt; [a b b a]
</code></pre>
<p>But once you move away from the "obvious-seeming" cases, the whole thing stops seeming obvious.  There's a lot of inertia behind the historical choices...this is tough to reason about.</p> ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_7</link>
        <pubDate>Mon, 02 Dec 2024 14:45:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7959</guid>
      </item>
      <item>
        <title>Design for Something Like FLIP To Reverse Arguments</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238/6">Parameter Order in Rebol</a></div>
<blockquote>
<p>If someone wants to specify the second parameter first they can always write <code>flip cons</code> or <code>flip snoc</code>.</p>
</blockquote>
</aside>
<p>The design of a FLIP-like operation raises some questions.</p>
<p>If it were an operator that acted on functions, it wouldn't retrigger them.  You'd have to say:</p>
<pre><code>&gt;&gt; append 'd [a b c]
== [a b c d]

&gt;&gt; run flip append/ [a b c] 'd
== [a b c d]
</code></pre>
<p>Alternately, I guess you could use slash to run a GROUP!, but then you'd have a disabling slash and a running slash:</p>
<pre><code>&gt;&gt; /(flip append/) [a b c] 'd
== [a b c d]
</code></pre>
<p>If it were instead something along the lines of RUN, where applying the flipped function was implicit, you could write:</p>
<pre><code>&gt;&gt; flip append/ [a b c] 'd
== [a b c d]
</code></pre>
<p>I don't think <strong><code>flip/append</code></strong> being a synonym for <strong><code>/(flip append/)</code></strong> is a generically useful idea, compared to the likes of <strong><code>not/even?/</code></strong> for cascading.</p>
<p>But if the <a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">weird idea of dialected CHAIN!</a> ever came to pass, FLIP could go into a distinct mode based on receiving a function in the place other functions have refinements...</p>
<pre><code>&gt;&gt; append/
== ~#[frame! [value series]]~

&gt;&gt; flip append/
== ~#[frame! [series value]]~

&gt;&gt; flip:append [a b c] 'd
== [a b c d]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/design-for-something-like-flip-to-reverse-arguments/2345#post_1</link>
        <pubDate>Mon, 02 Dec 2024 14:41:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7958</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>In Haskell, a lot of collection libraries define two operations, such as these ones from <code>text</code>:</p>
<pre data-code-wrap="hs"><code class="lang-hs">cons :: Char -&gt; Text -&gt; Text
snoc :: Text -&gt; Char -&gt; Text
</code></pre>
<p>(The name <code>snoc</code> comes from being the reverse of <code>cons</code>â€¦ geddit?)</p>
<p>So really this parameter order is so intuitive that it overrides considerations of â€˜less/more importantâ€™. If someone wants to specify the second parameter first they can always write <code>flip cons</code> or <code>flip snoc</code>.</p> ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_6</link>
        <pubDate>Mon, 02 Dec 2024 01:24:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7957</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Most-or-Least Important Thing First</p>
</blockquote>
</aside>
<h2><a name="p-7956-i-formulated-this-question-1" class="anchor" href="https://forum.rebol.info#p-7956-i-formulated-this-question-1"></a>I Formulated This Question</h2>
<p>If you were to look at it with fresh eyes, as someone who had never programmed before (but spoke English), how different would you perceive these orderings of parameters to some array mutation operations... would one seem preferable over the other?</p>
<pre><code>&gt;&gt; append 'd [a b c]
== [a b c d]

&gt;&gt; append [a b c] 'd
== [a b c d]

&gt;&gt; insert 'a [b c d]
== [a b c d]

&gt;&gt; insert [b c d] 'a
== [a b c d]
</code></pre>
<hr>
<h2><a name="p-7956-claudeai-says-2" class="anchor" href="https://forum.rebol.info#p-7956-claudeai-says-2"></a>Claude.AI Says...</h2>
<blockquote>
<p>Let me analyze these parameter orderings from a fresh, beginner's perspective.</p>
<p>The first thing I notice is there's a subtle but important pattern in these operations. If we look at the append and insert examples, there are two variations:</p>
<ol>
<li><code>append 'd [a b c]</code> and <code>insert 'a [b c d]</code></li>
<li><code>append [a b c] 'd</code> and <code>insert [b c d] 'a</code></li>
</ol>
<p>From a newcomer's perspective, I'd argue that the first set (1) feels more intuitive and readable. Here's why:</p>
<ul>
<li>The target collection (the array/list) comes <em>after</em> the element being added</li>
<li>This reads more like natural language: "append 'd to [a b c]"</li>
<li>It feels like you're specifying "what" first (the element), then "where" second (the collection)</li>
</ul>
<p>The alternative ordering (2) requires a bit more mental gymnastics. When you say <code>append [a b c] 'd</code>, you're essentially saying "append this whole list to this single item", which feels counterintuitive.</p>
<p>The same logic applies to the <code>insert</code> operations. <code>insert 'a [b c d]</code> reads more naturally as "insert 'a into [b c d]" compared to <code>insert [b c d] 'a</code>.</p>
<p>So if I were completely new to programming, I would find the first set of orderings (<code>append 'd [a b c]</code> and <code>insert 'a [b c d]</code>) more:</p>
<ul>
<li>Readable</li>
<li>Predictable</li>
<li>Aligned with how I might describe the operation in spoken language</li>
</ul>
<p>This suggests the design prioritizes clarity and cognitive ease for the programmer, which is crucial when learning a new programming language or concept.</p>
</blockquote>
<hr>
<p>I'm wondering if we didn't have our preconceptions, would it be obviously the case that the reverse order was more natural...or not?  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<p>It is true that it takes some gymnastics to write it out:</p>
<pre><code>append [a b c] 'd
=&gt;
append to [a b c] the value 'd

vs.

append 'd [a b c]
=&gt;
append 'd to [a b c]
</code></pre>
<p>But along with that, this idea of the "lesser important" (configuring) parameters being first, is something that's really gotten into my head...the reverse-OOP argument from Haskell.  I've made it possible now for generics to dispatch on any parameter, so it's technically not an issue any longer to choose a different dispatch.</p> ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_5</link>
        <pubDate>Sun, 01 Dec 2024 16:03:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7956</guid>
      </item>
      <item>
        <title>Module Startup and Shutdown (Constructors, Destructors?)</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="960">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I noticed something in Go related to this, <a href="https://blog.golang.org/defer-panic-and-recover">which is their <code>defer</code> keyword</a>:</p>
</blockquote>
</aside>
<p>In <a href="https://forum.rebol.info/t/rebol-1-0-retrospective/1788/5">Rebol 1.0</a>, there's something called SHIELD:</p>
<blockquote>
<p><strong><code>shield before-block main-block after-block</code></strong></p>
<p>Shield a block from catch and other types of exception handling, allowing it to take the necessary steps to initialize and finalize its state.</p>
<pre><code>print catch 'throw [
    shield [
        print "entering"
    ][
        repeat n 10 [if n &gt; 5 [throw "thrown out"]]
    ][
        print "exiting"
    ]
]
</code></pre>
<p>This will output:</p>
<pre><code>entering
exiting
thrown out
</code></pre>
</blockquote>
<p>It might seem unclear as to why you would need to have a "before-block" instead of just writing your code before the call to SHIELD.  But Rebol 1.0 is very function-driven.  So:</p>
<pre><code>(before-code shield main-block after-block)
</code></pre>
<p>...would be a GROUP! instead of a single function call, and I believe the thinking was more that if it was a function that it would "fit in more slots" where a GROUP! would complicate things.  (?)</p>
<p>Anyway...this category of things is still a functionality gap in Ren-C, because all you can do is trap and rescue and catch things...and you have to care about whether you're catching or trapping, and you have to rethrow or re-fail.  Things like SHIELD and DEFER are all trivial to implement, but it's just not certain what the right way to get constructor/destructor type behaviors is in this language.</p> ]]></description>
        <link>https://forum.rebol.info/t/module-startup-and-shutdown-constructors-destructors/960#post_5</link>
        <pubDate>Sun, 01 Dec 2024 15:38:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7955</guid>
      </item>
      <item>
        <title>The %rebol.r Boot File From Rebol 1.0</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <h2><a name="p-7954-exception-handling-1" class="anchor" href="https://forum.rebol.info#p-7954-exception-handling-1"></a>Exception Handling</h2>
<pre><code>do-with-exception-handler: make function! [handler body] [
    do make function! [outside-value inside-value] [
        shield [outside-value: :exception-handler-stack
                exception-handler-stack: :inside-value]
               :body
               [inside-value: :exception-handler-stack
                exception-handler-stack: :outside-value]
        ] :exception-handler-stack 
          stack-push :exception-handler-stack :handler
    ]
</code></pre>
<p>So DO-WITH-EXCEPTION-HANDLER is defined in <code>%rebol.r</code>, but not used by it (e.g. it's not how the REPL traps errors).  Hence we don't see any usages of the exception handling functions.</p>
<p>But what we do see is that it depends on a native called SHIELD, which is in the user guide:</p>
<pre><code>shield before-block main-block after-block
</code></pre>
<p>This appears to be a convenience of some kind, to let you register a handler to keep you from having to go around SHIELD-ing all your individual calls.</p>
<h2><a name="p-7954-readevalprint-loop-repl-2" class="anchor" href="https://forum.rebol.info#p-7954-readevalprint-loop-repl-2"></a>Read/Eval/Print Loop (REPL)</h2>
<p>The REPL is initialized by a call to INIT-REPL, which passes in some messages and ports, and a context to do evaluations in:</p>
<pre><code>init-repl
    [linefeed prin "REBOL top level."]         ; start-message
    [linefeed prin "Returning to top level."]  ; resume-message
    "&gt;&gt; "                                      ; prompt
    user-context                               ; repl-context
    input-port                                 ; repl-input-port
    output-port                                ; repl-output-port
</code></pre>
<p>The meat of INIT-REPL is in this code that it passes to PUSH-REPL, which I've</p>
<pre><code>do make function! [form] [
     write-block-or-element :repl-output-port (
         shield [&amp;trace repl-trace nearest-repl]  ; before-block
                [eval-reduce :form :repl-context]  ; main-block
                [&amp;trace false]  ; after-block
     )
] (port-read :repl-input-port)
</code></pre>
<p>If we were to make this a bit less obtuse:</p>
<pre><code>form: port-read :repl-input-port  ; READ

result: shield [&amp;trace repl-trace nearest-repl] 
               [eval-reduce :form :repl-context]  ; EVAL
               [&amp;trace false]

write-block-or-element :repl-output-port :result  ; PRINT
</code></pre>
<p>So I gather the SHIELD is there to make sure that if code was being traced and there was an error, you don't wind up tracing the REPL itself.  It doesn't actually catch errors or throws, it just seems to make sure your AFTER-BLOCK code runs.  <img src="https://forum.rebol.info/images/emoji/twitter/confused.png?v=12" title=":confused:" class="emoji" alt=":confused:" loading="lazy" width="20" height="20"></p>
<p><strong>I don't see anything about printing error messages, and there's nothing in the user's guide about an ERROR! type, so it seems like errors aren't values.</strong></p>
<p>So what probably happens when there's an error is that the interpreter just prints it.  I don't know what the SHIELD's result is... NONE?</p>
<p>It would be easier to understand the situation with errors or uncaught throws with a working interpreter.</p>
<h2><a name="p-7954-ctrl-c-handling-3" class="anchor" href="https://forum.rebol.info#p-7954-ctrl-c-handling-3"></a>Ctrl-C Handling</h2>
<pre><code>;;; The repl-driver drives the console interaction.  The argument
;;; 'once' is assumed to do a single interaction.  We capture a return 
;;; continuation and then turn on the interrupts before calling
;;; 'once'.  If an error or control C happens, control is transfered
;;; to the captured continuation.  Since this continuation is captured 
;;; in a (dynamic) context with interrupts turned off, the interrupts
;;; are disabled while iterating around the loop (so the loop cannot
;;; be broken by a lucky interrupt).
</code></pre>
<p>So at least this has something in common with Ren-C, which is the implementation of the REPL in usermode...and being sensitive to questions like not wanting you to be able to Ctrl-C the REPL implementation itself.  Ren-C also disables the Ctrl-C while inside the console's implementation.</p>
<p><em>(Though interestingly, you can Ctrl-C if you're in console <em>skin</em> code...a misbehaving skin where you've customized your I/O can be canceled, and it will fall back on the default skin.)</em></p>
<p>There's a definition exported to the user context:</p>
<pre><code> halt: func [] [top-level-continuation none]
</code></pre>
<p>Which this does the same thing as Ctrl-C.  I still kind of want to understand the limits of what is possible with these "throws" that are being called continuations, and just how arbitrarily you can throw the program around.</p>
<p>Anyway, it's still a bit murky what some of it is doing, but by-and-large I pretty much understand it.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344#post_2</link>
        <pubDate>Sun, 01 Dec 2024 12:44:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7954</guid>
      </item>
      <item>
        <title>The %rebol.r Boot File From Rebol 1.0</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>While we don't have the C source code for Rebol 1.0, we do have the <code>%rebol.r</code> initialization file:</p>
<p><a href="https://gist.github.com/hostilefork/d6cfac90141688bd41b1b38a9a203b02" class="inline-onebox">Rebol 1.0.2 Initialization File (October 7, 1998) Â· GitHub</a></p>
<p>It would seem that if there were an ability to pack source code in with the executable, they would have done it...given that the Quick Start says <em>"do not modify <code>rebol.r</code>. If you accidentally do modify <code>rebol.r</code>, reinstall it."</em></p>
<p><em><strong>Hence this is probably the entire portion of Rebol 1.0 that's written in Rebol, e.g. the whole "Mezzanine".</strong></em></p>
<p>It says:</p>
<pre><code>;;; Note: Code in rebol.r runs in the system context.  The system
;;; context [has] all the built in bindings of the user context, but also
;;; has extra bindings to allow rebol to be bootstrapped.  Many of the 
;;; rebol functions available in user code are actually written in
;;; terms of simpler rebol natives, or in terms of special
;;; system natives.

;;; REBOL reserves the right to change the system natives at any time, 
;;; so you shouldn't depend on them for portable code.
</code></pre>
<h1><a name="p-7953-remarks-on-contents-in-no-particular-order-1" class="anchor" href="https://forum.rebol.info#p-7953-remarks-on-contents-in-no-particular-order-1"></a>Remarks On Contents, In No Particular Order</h1>
<h2><a name="p-7953-func-definition-2" class="anchor" href="https://forum.rebol.info#p-7953-func-definition-2"></a>FUNC Definition</h2>
<pre><code>func: make function! [args body] [make function! :args :body]
</code></pre>
<p>I found it a bit interesting that the <a href="https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340/6#p-7944-func-shortcut-5">User Guide talked about how FUNC was defined</a>, as an illustrative example, of an important thing for users to know about.  (It turns out there's a <a href="https://www.rebol.com/docs/core23/rebolcore-9.html">brief mention in the Rebol2 User's Guide</a>, but the Rebol 1.0 Guide writes it up twice, probably on accident.)</p>
<p>It's worth pointing out that there's big questions even in this seemingly simple definition.  Such as, should a function copy its arguments or body?  What should this do?</p>
<pre><code> body: [print "Hello"]
 foo: func [] body
 append body [print "Goodbye"]
 bar: func [] body
</code></pre>
<p>Does <strong>foo</strong> print just "Hello", or does it print "Hello" and "Goodbye"?</p>
<p>I don't yet know what Rebol1 did, but Rebol2's MAKE FUNCTION! would <em>not</em> copy the body.  So FUNC would do a deep copy as the "higher level" operator, before passing it to MAKE FUNCTION!.</p>
<p>But during bootstrap, it used a definition of FUNC that <em>didn't</em> copy the body, for performance reasons...which it switched over to the copying implementation at the end of boot.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p>Some version of these crazy optimizations are on the table for future Ren-C.</p>
<h2><a name="p-7953-print-prin-probe-3" class="anchor" href="https://forum.rebol.info#p-7953-print-prin-probe-3"></a>PRINT, PRIN, PROBE</h2>
<pre><code>write-block-or-element:
    make function! [port element] [
             do
                if block? :element [:write-block] else [:form-to-port]
                :port
                :element]

write-block: func [port block] [    ; !!! needs work
    foreach element :block [form-to-port :port :element form-to-port :port " "]
]

prin: func [value] [
    if block? :value [write-block output-port reduce :value]
    else [form-to-port output-port :value]
    exit
]

print: func [value] [
    prin :value
    linefeed-port output-port
    exit
]

probe: func [value] [
     prin " PROBE --&gt; "
     send output-port :value
     linefeed-port output-port
     :value
 ]
</code></pre>
<p>Weird.  (and prints a space after every element, so you get a space at the end of the line vs. just delimited between, etc.)</p>
<p>At least one interesting aspect of this is to see the rigid "EXIT" at the end to make sure that PRIN and PRINT don't leak a result on accident.  Things like this feel like a vindication of Ren-C's <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">requirement to use a RETURN</a> in order to give back a result from FUNC (but not LAMBDA).</p>
<h2><a name="p-7953-is-as-to-logic-4" class="anchor" href="https://forum.rebol.info#p-7953-is-as-to-logic-4"></a>IS? as TO-LOGIC</h2>
<pre><code>is?: func [value] [not not :value]
</code></pre>
<p>This was called TRUE? in Rebol2, and I very much disliked the ambiguity of that vs. testing to see if a value was <code>= #[true]</code> the LOGIC! literal.</p>
<p>I wrote something up about <a href="http://blog.hostilefork.com/did-programming-opposite-of-not/">how DID could be the opposite of NOT</a> (which even goes together as DIDN'T for DID NOT).  But due to some various shades of meaning the current state is that it means THEN? and DIDN'T means ELSE? as prefix tests for the trigger conditions that would run THEN or ELSE.  It needs thought.</p>
<p>Anyway, interesting to see the choice of <code>IS?</code> here.</p>
<h2><a name="p-7953-a-recursive-folding-any-and-all-interrobang-5" class="anchor" href="https://forum.rebol.info#p-7953-a-recursive-folding-any-and-all-interrobang-5"></a>A Recursive Folding ANY and ALL <img src="https://forum.rebol.info/images/emoji/twitter/interrobang.png?v=12" title=":interrobang:" class="emoji" alt=":interrobang:" loading="lazy" width="20" height="20"></h2>
<pre><code>any: func [block] [
    eval-one block
        make function! [value rest] [
            if not value [any rest]
            else [value]
        ]
        make function! [value] [value]
]

all: func [block] [
    eval-one block
        make function! [value rest] [
            if is? value [all rest]
            else [false]
        ]
        make function! [value] [value]
]
</code></pre>
<p>So this is based on a function called EVAL-ONE, that takes a list and two functions.  It isn't defined in %rebol.r and isn't in the reference guide either.  But it's a right fold with early termination.</p>
<p>One can definitely imagine the Joe Marshall and Carl friction on this (<em>"why are you making all these usermode functions and calls, why not just use a loop?"</em>).</p>
<p>While there's a time and a place for this, I do think that if you are starting to push out into the usermode layers and finding this mentality is driving it...you're going to end up with something that isn't hitting the mark that Rebol was aiming at.</p>
<h2><a name="p-7953-why-is-pick-so-weird-6" class="anchor" href="https://forum.rebol.info#p-7953-why-is-pick-so-weird-6"></a>Why Is PICK So Weird?</h2>
<pre><code>pick: func [series index] [
  do make function! [offset] [
    if (:offset + index? :series) &lt;= 1
        [none]
    else [do make function! [disp] [
            if (length? :disp) = 0 
               [none]
            else
               [&amp;peek :disp 0]
            ] skip :series if :offset &lt; 0 [:offset] else [:offset - 1]
         ]
    ] if logic? :index [if :index [1] else [2]] else [:index]
]
</code></pre>
<p>My guess here is that the pattern:</p>
<pre><code>do make function! [arg] [...code with arg...] value-for-arg
</code></pre>
<p>...is probably some holdover from before USE existed.  Or maybe USE is just an abstraction built on functions, and so it's done this way for optimization.  I dunno.</p>
<h2><a name="p-7953-poor-mans-export-7" class="anchor" href="https://forum.rebol.info#p-7953-poor-mans-export-7"></a>Poor-Man's EXPORT</h2>
<pre><code>;;; These functions can be defined in terms of system natives that are
;;; not available in the user context.  Since we made the functions in 
;;; this context, the values of the words in the body are relative to
;;; this context.  But we place the functions in the user context so
;;; that the users can call them.  This allows the user to call the
;;; system natives through a defined API in a controlled manner.

user-functions: [
    dir? [file] [do func [info] [info/dir?] info? :file]
    size? [file] [do func [info] [info/size] info? :file]
    ...
]

foreach [name args body] user-functions [
    context-set user-context name func args body
]
</code></pre>
<p>So the comment says what's going on here, it's the attempt to push functions out into the user context when they're implemented in terms of functions that aren't available in the user context.  I'm not sure what's not available <em>(these implementations of DIR? and FILE? are based on INFO?, is that not exported to the user context?)</em></p>
<p>As far as I know, there's nothing like this in Rebol2 (there's no separate <code>user-context</code> from a <code>system-context</code>, is there?)  Interesting if that was something that disappeared in Rebol2 and came back in Rebol3.</p>
<h2><a name="p-7953-more-modularization-eval-reduce-takes-context-8" class="anchor" href="https://forum.rebol.info#p-7953-more-modularization-eval-reduce-takes-context-8"></a>More Modularization: EVAL-REDUCE Takes Context</h2>
<pre><code>if not none? REBOL/script [
    if exists? REBOL/script [
        do make function! [] [
                top-level-continuation: :return
                if not REBOL/silent [
                        linefeed
                        prin "Loading script "
                        print REBOL/script]
                eval-reduce [do REBOL/script] user-context
                ]
        ]
    ]
</code></pre>
<p>Rebol1 seems to have been working with modularization ideas, because even during startup, the script you pass on the command line is run via something called EVAL-REDUCE that takes a parameter of where to do the evaluation.</p>
<p>So definitely a shame that Rebol2 seems to have moved away from the idea that evaluations needed to be done in a context.</p>
<h2><a name="p-7953-catch-is-defined-in-terms-of-catch-func-9" class="anchor" href="https://forum.rebol.info#p-7953-catch-is-defined-in-terms-of-catch-func-9"></a>CATCH is defined in terms of CATCH-FUNC</h2>
<p>We know from the <code>user-functions</code> exporting that this:</p>
<pre><code>catch [word block] [catch-func func reduce [word] :block]
</code></pre>
<p>Is actually:</p>
<pre><code>catch: func [word block] [catch-func func reduce [word] :block]
</code></pre>
<p>Since there's no type checking, there's a <code>:BLOCK</code> GET-WORD! just to be sure it's not a function, I guess?  And then it's FUNC's job to do a check in its implementation.  But then, why not <code>:WORD</code> just to be sure WORD! isn't a function you're calling?  <em>(I like pointing this out, due to Ren-C's better answers to this issue...avoiding the "pox of documenting what you <strong>don't</strong> know")</em></p>
<p>So the idea of using functions as proxies for "virtual binding" is the <em>old way</em>.  What's going on here is that the block contains code that wants to be bound to whatever the throw construct is, and so that block is made the body of a function, that you call and pass the thing you want bound to that name as the argument.  (COLLECT+KEEP worked this way).  But it's undesirable, because it means you've lost the fluidity of having the currency of a structural BLOCK!...replaced with the black box of a function just because you wanted to bind something.</p>
<p>I'm pretty sure this CATCH mechanic (being called a "continuation") is stackful and can't do anything too bizarre, but I'd like an executable to try and ensure that.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344#post_1</link>
        <pubDate>Sun, 01 Dec 2024 12:40:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7953</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 Quick Start Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p>Discovered at FTP cache: <a href="https://grumbeer.dyndns.org/ftp/www.ibiblio.org/distributions/redhat-5.1/apps-i386/REBOL/">https://grumbeer.dyndns.org/ftp/www.ibiblio.org/</a></p>
<p><em>README.txt says Rebol 1.0.2 was released 6-October-1998</em></p>
<p>See also:</p>
<ul>
<li>
<p><a href="https://forum.rebol.info/t/rebol-1-0-retrospective/1788">Discussion Thread: <strong>Rebol 1.0 Retrospective</strong></a></p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340"><strong>Rebol 1.0.2 User's Guide</strong></a></p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344"><strong>The %rebol.r Boot File From Rebol 1.0</strong></a></p>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>Copyright (c)1998 REBOL Technologies. All Rights Reserved.</strong></p>
</blockquote>
<hr>
<h1><a name="p-7948-rebolcore-quick-start-guide-1" class="anchor" href="https://forum.rebol.info#p-7948-rebolcore-quick-start-guide-1"></a>REBOL/Core Quick Start Guide</h1>
<h3><a name="p-7948-about-this-guide-2" class="anchor" href="https://forum.rebol.info#p-7948-about-this-guide-2"></a>About This Guide</h3>
<p>This guide includes the facts you need to start using REBOL (pronounced REB-ul) quickly. It offers concise information for installing REBOL on any of numerous computer operating systems. This guide then summarizes the spirit of REBOL: what it is, how it functions, and how to put it to work for you quickly. Finally, this guide offers steps for learning more about the power of REBOL.</p>
<p>No prior knowledge of computer languages is needed to use REBOL. In fact, if you have used other languages, forget what you know because REBOLâ€™s approach to computer language is refreshingly unique. Itâ€™s simple.</p>
<h3><a name="p-7948-how-to-install-rebol-3" class="anchor" href="https://forum.rebol.info#p-7948-how-to-install-rebol-3"></a>How to Install REBOL</h3>
<p>Here are the procedures for installing REBOL on your computer:</p>
<ol>
<li>
<p>Make a new directory for the files, typically named REBOL.</p>
</li>
<li>
<p>Uncompress the distribution file using the standard method for the operating system.</p>
</li>
<li>
<p>Move the uncompressed files to the new directory.</p>
</li>
</ol>
<p>Thatâ€™s it. The three REBOL files are <strong>rebol.exe</strong> (executable program), <strong>rebol.r</strong> (initialization file), and <strong>user.r</strong> (your definitions file). You can customize your copy of REBOL using <strong>user.r</strong>, but do not modify <strong>rebol.r</strong>. If you accidentally do modify <strong>rebol.r</strong>, reinstall it.</p>
<p>Also included in the release are documentation files in HTML format: <strong>quick.html</strong>, <strong>users.html</strong>, and <strong>experts.html</strong>. They can be read with a web browser program.</p>
<p>To uninstall REBOL, simply delete the directory and files.</p>
<h3><a name="p-7948-the-rebol-spirit-4" class="anchor" href="https://forum.rebol.info#p-7948-the-rebol-spirit-4"></a>The REBOL Spirit</h3>
<p>Computers are designed to solve problems for people (though it may not always seem that way). The problems are defined using a computer <em>language</em> .</p>
<p>REBOL is an acronym for <strong>relative expression-based object language</strong> . That means itâ€™s a language that uses clear expressions rather than cryptic codes to instruct a computer.</p>
<p>A <em>programming language</em> communicates between computers and programs. You must understand how computers function to write programs for them. For example, instructing a computer to print the phrase "REBOL World" on the screen would look like this in Java programming language:</p>
<pre><code>class REBOLWorldApp {
    public static void main(String[] args) {
        System.out.println("REBOL World!")
    }
}
</code></pre>
<p>Most computer languages require that you think like a computer rather than a human to communicate with it. REBOL communicates in human terms. The REBOL instruction for "REBOL World" looks like this:</p>
<pre><code>print "REBOL World"
</code></pre>
<p>Much simpler!</p>
<p>Simplicity is power. REBOL can do much more than display phrases on your computer. It can do mathematical calculations, filter and respond to your email, send files to other computers, manage databases, and more. And information isnâ€™t lost if moved to another computer. REBOL is system independent.</p>
<p>Thatâ€™s because REBOL is a messaging language. A <em>messaging language</em> communicates information between applications running on other computers. Unfortunately, most computers donâ€™t communicate well with other computers. Some data from Windows applications, for example, canâ€™t be read on Linux or Macintosh computers, and vise versa. REBOL passes useable data and messages between otherwise incompatible computer systems.</p>
<p>English and other human languages are messaging languages between people. REBOL is a messaging language between computer applications. That makes REBOL easier and more natural to use than other computer languages.</p>
<p>Letâ€™s get started using REBOL!</p>
<h3><a name="p-7948-getting-started-in-rebol-5" class="anchor" href="https://forum.rebol.info#p-7948-getting-started-in-rebol-5"></a>Getting Started in REBOL</h3>
<p>You write REBOL instructions as a <strong>script</strong> . Think of a REBOL script as the first half of a conversation with REBOL. The second half is the answer that REBOL gives you, called the <strong>result</strong> .</p>
<p>Youâ€™ve learned from the "REBOL World" example that <strong>print</strong> requests an output and that <strong>""</strong> encloses a <strong>string</strong> of characters. Easy enough, but not very useful yet.</p>
<p>What if you could give REBOL data that it works on, then gives back to you? What if it could add up your bills, sort your address book, backup computer files, or handle your email for you? Those tasks would be more useful to you.</p>
<p>To write simple REBOL scripts to handle these and other tasks, you need to know more of the power inside of REBOL. So letâ€™s look at the REBOL language and define some terms.</p>
<p>In REBOL, any <em>type of data</em> is called a <strong>value</strong> . A <strong>datatype</strong> can be a</p>
<ul>
<li>string ("REBOL World")</li>
<li>date (1-Jan-2000)</li>
<li>integer (1 100 -1000)</li>
<li>decimal (1.25)</li>
<li>tuple (1.0.3 255.355.100)</li>
<li>email address (<a href="mailto:johnny@rebol.com">johnny@rebol.com</a>)</li>
<li>url (<a href="http://www.rebol.com/">http://www.rebol.com/</a>)</li>
<li>block ([11 47 26 999])</li>
<li>file (%rebol.r)</li>
<li>word (when)</li>
</ul>
<p>In fact, REBOL knows and uses dozens of datatypes (defined with examples in <strong><a>Expertâ€™s Guide</a></strong> ). <strong>Datatypes</strong> are simply types of data that REBOL already knows how to handle. For example, it sees an <em>at sign</em> (@) in a string (<a href="mailto:johnny@rebol.com">johnny@rebol.com</a>), REBOL knows that the string is an email address.</p>
<p>REBOL datatypes are <em>smart</em> . Adding an exclamation point after the datatype (date!) tells REBOL to return the result in the standard international date format (day-month-year) â€” even if you type it in another format.</p>
<p>Smart datatypes make writing REBOL scripts easy.</p>
<h3><a name="p-7948-writing-a-rebol-script-6" class="anchor" href="https://forum.rebol.info#p-7948-writing-a-rebol-script-6"></a>Writing a REBOL Script</h3>
<p>Now, letâ€™s put REBOL to work!</p>
<p>First, you want to <strong>make</strong> a tool or <strong>function</strong> that actually does the work. Letâ€™s call it when and define it (<img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> like this:</p>
<pre><code>when: make date! [30 9 1998]
</code></pre>
<p>As you can see, you <strong>make</strong> when a function that changes the given value to a standard date format (!). The block defines what value is used [30 9 1998]. So what else do you have to tell REBOL?</p>
<pre><code>print when
</code></pre>
<p>and REBOLâ€™s result is</p>
<pre><code>30-Sept-1998
</code></pre>
<p>The REBOL script you wrote defined when exactly like the prototype date! using the numbers you put in the block.</p>
<p>A REBOL script is written in expressions. An <strong>expression</strong> is a group of values which REBOL <em>evaluates</em> , then returns a new value. In REBOL, to <strong>evaluate</strong> is to interpret a group of values toward a purpose or result.</p>
<p>For example, when: make date! [30 9 1998] is an expression that is evaluated as you tell REBOL to print when and return the <strong>result</strong> of the evaluation: 30-Sept-1998.</p>
<p>REBOL offers numerous built-in datatypes. One of the most powerful is <em>word</em> . A REBOL <strong>word</strong> is a symbol used literally <em>or</em> as a variable. In the above example, when was a variable that you defined. It was defined with the colon (when: make date!) then evaluated (print when) to produce a result.</p>
<p><em>Note: <strong>All</strong> REBOL words can have a different meaning depending on context, just as English words do. The English word "print," for example, can have different meanings when used in computing, fashion, and graphics. So REBOL words can be recycled. Itâ€™s a powerful feature that you can learn more about in the <strong><a>Userâ€™s Guide</a></strong></em> .</p>
<p>So what actually evaluates these expressions? <strong>Native</strong> functions are built-in REBOL functions that you can use right now. They are native to REBOL. In the above example, print and make are natives. Other REBOL natives include load, send, foreach, save, next, and two hundred others. You can get their definitions in the <strong><a>Expertâ€™s Guide</a></strong> and see them at work in the <strong><a>Userâ€™s Guide</a></strong> .</p>
<p><em>Note: You can also get information on any function by simply typing</em> help <em>followed by the native (</em> help load*). REBOL will print a description of the function on the display screen.*</p>
<p>And hereâ€™s one of the powerful "secrets" of REBOL: you can use natives to design your own functions. Itâ€™s like being able to make up your own words when you speak to people and they know exactly what you mean!</p>
<p>The example REBOL script used the <strong>date</strong> native to make a new function called when with the expression:</p>
<pre><code>when: make date! [30 9 1998]
</code></pre>
<p>Letâ€™s summarize. REBOL is a messaging language that evaluates expressions and returns values. REBOL expressions include values in common datatype formats as well as user-defined words. Does that make sense? If not, please reread the above section.</p>
<p>Congratulations! Youâ€™re now writing REBOL scripts.</p>
<h3><a name="p-7948-using-more-rebol-power-7" class="anchor" href="https://forum.rebol.info#p-7948-using-more-rebol-power-7"></a>Using More REBOL Power</h3>
<p>These simple principles for writing REBOL scripts can easily be expanded to solve problems using a computer. Many practical solutions will be described more fully in <strong><a>Userâ€™s Guide</a></strong> .</p>
<p>Think of writing a REBOL script as you would write anything else. You use words to build phrases (<em>expressions</em> ) and sentences (<em>functions</em> ) until you have a complete paragraph (<em>object</em> ). You may write more paragraphs or simply reuse some youâ€™ve written before until you have a complete document (<em>script</em> ).</p>
<p>REBOL scripts are built in the same way. To show you how, letâ€™s define some more REBOL terms.</p>
<p>First is object, just mentioned. A REBOL <strong>object</strong> has values, functions, and even other objects, grouped together within a context. For example,</p>
<pre><code>headline: make object! [font: "arial" size: 24 color: black]
</code></pre>
<p>makes an <strong>object</strong> that defines what a documentâ€™s headline should look like.</p>
<p>You can then make another object called text with size: 12 type and REBOL wonâ€™t be confused by the two definitions of size.</p>
<p>You can also use REBOL to change the headline size to 18 with</p>
<pre><code>headline/size: 18
</code></pre>
<p>The technique is called <em>accessing an object variable</em> . It makes REBOL easy to modify.</p>
<p>One more tip: REBOL is free form. To enhance readability, you can script the headline example like this (once black is defined):</p>
<pre><code>headline: make object! [ font: "arial" size: 24 color: black ]
</code></pre>
<p>This is the preferred format for writing REBOL scripts.</p>
<p>Letâ€™s expand on some earlier definitions so youâ€™re more fluent in REBOL.</p>
<p>The data within the bracket <code>[]</code> is called an argument. An <strong>argument</strong> is a value that provides a value to an expression. Some natives donâ€™t require an argument while others can handle many. <strong>Expertâ€™s Guide</strong> will tell you the type and number of arguments that each function uses.</p>
<p>Providing an argument to a function is called <strong>passing</strong> the argument. For example,</p>
<pre><code>print "REBOL World"
</code></pre>
<p>passes a "string" to the print function. From another viewpoint, you could say that you are <strong>applying</strong> the print function to the string.</p>
<p>Hereâ€™s a tool that makes REBOL even easier to use. You can make a new function with the native <strong>func.</strong> For example, to make a new function called sum that totals two numbers, designated as a and b:</p>
<pre><code>sum: func [a b] [a + b]
</code></pre>
<p>This expression tells REBOL to define sum by making a new function datatype where a is the first number and b is the second number. Then add (+) the first and second number and give me the result.</p>
<p>To use this function, add the line:</p>
<pre><code>print sum 50 100
</code></pre>
<p>and REBOL returns the value</p>
<pre><code>150
</code></pre>
<p>The length of your script or conversation with REBOL can be just a few lines or a few pages â€” <strong>but it will be easier to write and understand than with other computer languages.</strong></p>
<h3><a name="p-7948-rebol-at-work-8" class="anchor" href="https://forum.rebol.info#p-7948-rebol-at-work-8"></a>REBOL at Work</h3>
<p>Ready for some real-world examples of what REBOL messaging language can do for you? (Youâ€™ll meet the <em>natives</em> used here in the <strong><a>Userâ€™s Guide</a></strong> and the <strong><a>Expertâ€™s Guide</a></strong> .)</p>
<p>To grab an Internet web page and save it as a file (%):</p>
<pre><code>file: read http://www.rebol.com save %rebolpage.html file
</code></pre>
<p>or you can write it in a single line:</p>
<pre><code>save %rebolpage.html read http://www.rebol.com
</code></pre>
<p>To email that web page to a friend:</p>
<pre><code>send friend@domain.com read http://www.rebol.com
</code></pre>
<p>To email all the files in a directory to your friend:</p>
<pre><code>files: load %c:/rebol/* foreach file files [send friend@rebol.com read file]
</code></pre>
<p>To build a calendar database that holds things to do (prioritized):</p>
<pre><code>todo [
    ; PRI TYPE DESCRIPTION
    9 code "Write SAVE function"
    8 fun "Bottle brew for friends"
    8 docs "Write Chapter 1"
    5 yard "Tend the Merlot vines"
    3 code "Parametric search function"
    2 web "Call Microsoft re:problems"
    1 home "Tune-up tractor engine"
    0 yard "Fix the fence near berries"
]

; Type Descriptions
[
    code "write code"
    docs "write docs"
    yard "yard work"
    home "house stuff"
    fun "relaxation"
    web "web related"
]
</code></pre>
<p>To send your stockbroker an important transaction message:</p>
<pre><code>send broker@stockbroker.com [
    Company: "Microsoft"
    Symbol: MSFT
    Shares: 1000
    Action: sell
]
</code></pre>
<p>REBOL makes solutions easier!</p>
<h3><a name="p-7948-whats-next-9" class="anchor" href="https://forum.rebol.info#p-7948-whats-next-9"></a>Whatâ€™s Next?</h3>
<p>Thatâ€™s all you really need to know to use the <em>power of REBOL</em> ! Of course, thereâ€™s much more to know about REBOL to become a <em>power user</em> . The remainder of these guides will add to your knowledge and enjoyment of REBOL.</p>
<p><strong><a>Userâ€™s Guide</a></strong> will show you how to solve specific problems with REBOL.</p>
<p><strong><a>Expertâ€™s Guide</a></strong> is your reference manual for REBOL. It includes a description and examples of more than 200 REBOL words and word groups.</p>
<p>Finally, check the REBOL web site for more information and examples on how others are using REBOL messaging language. Itâ€™s at <a href="http://www.rebol.com/">http://www.rebol.com</a>.</p>
<p>Have fun, REBOL!</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-quick-start-guide/2341#post_1</link>
        <pubDate>Tue, 06 Oct 1998 04:00:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7948</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7945-chapter-6-troubleshooting-rebol-1" class="anchor" href="https://forum.rebol.info#p-7945-chapter-6-troubleshooting-rebol-1"></a>Chapter 6: Troubleshooting REBOL</h1>
<h3><a name="p-7945-about-troublshooting-2" class="anchor" href="https://forum.rebol.info#p-7945-about-troublshooting-2"></a>About Troublshooting</h3>
<p>REBOL is an easy-to-use language. However, errors can occur in REBOL scripts. This chapter offers information on identifying common errors, debugging scripts, and stopping a script as well as how to report any bugs you find so we can continually improve REBOL. Thereâ€™s also information on how to contact us for technical support.</p>
<h3><a name="p-7945-errors-3" class="anchor" href="https://forum.rebol.info#p-7945-errors-3"></a>Errors</h3>
<p>A few of the most common errors are:</p>
<ul>
<li>
<p>No spaces between numbers or words (e.g. 1+2 rather than 1 + 2).</p>
</li>
<li>
<p>Not providing enough arguments to a function.</p>
</li>
<li>
<p>Forgetting to use blocks when needed (such as in <strong>if</strong> , <strong>else</strong> , or <strong>while</strong> ).</p>
</li>
<li>
<p>Referring to a word, rather than its value (when using <strong>first</strong> , <strong>second</strong> , <strong>pick</strong> , etc.)</p>
</li>
<li>
<p>Not using parentheses in expressions (e.g. if 1 + 2 = 3 [...])</p>
</li>
<li>
<p>Forgetting the "!" on proto-datatypes (e.g. function!)</p>
</li>
<li>
<p>Forgetting the preceding colon on argument words that could be functions</p>
</li>
</ul>
<h3><a name="p-7945-debugging-scripts-4" class="anchor" href="https://forum.rebol.info#p-7945-debugging-scripts-4"></a>Debugging Scripts</h3>
<p>For small scripts the most common approach to debugging is to print out values as your script proceeds. Using <strong>print</strong> works well for this, but in many cases you may also want to use the <strong>probe</strong> function which also returns the same value it printed</p>
<pre><code>&gt;&gt; print [1 + 2]
3

&gt;&gt; do probe [1 + 2]
[1 + 2]
3
</code></pre>
<h3><a name="p-7945-stopping-your-script-5" class="anchor" href="https://forum.rebol.info#p-7945-stopping-your-script-5"></a>Stopping Your Script</h3>
<p>Use <strong>quit</strong> to quit REBOL (not <strong>exit</strong> , which will be implemented for exiting a function in future releases)</p>
<p>Use <strong>halt</strong> to stop your script and return to the input prompt.</p>
<p><strong>CTRL-C</strong> can be used to quit your program if it gets stuck in a loop. Some operating systems will not detect the key until I/O has been performed, such as a print.</p>
<p><em>Note: The use of CTRL-C to stop execution is a result of the default environment for the target platform and is not determined by REBOL.</em></p>
<h3><a name="p-7945-reporting-bugs-6" class="anchor" href="https://forum.rebol.info#p-7945-reporting-bugs-6"></a>Reporting Bugs</h3>
<p>REBOL is very interested in the problems (bugs) you may have found. To report a bug or make a comment, send an email message (no HTML or enclosures). Please write a subject line that describes the problem. Write something like "making blocks does not work" rather than just "bug."</p>
<p>Email: <code>bugs@rebol.com</code></p>
<p>We will send an automatic confirmation of each report. If you don't get the confirmation, then we may not have received your email (or your return address is wrong).</p>
<p>For all bug reports, be sure to give us a simple example of the problem. If it occurs in a large script, edit it down to just the bug. Please donâ€™t send large files.</p>
<p>Also, be sure to include the REBOL version number as is printed in the title banner. It indicates not only the version and revision, but also the update number and the platform (OS). Version numbers have the format:</p>
<pre><code>version.revision.update.platform
</code></pre>
<h3><a name="p-7945-rebol-versions-7" class="anchor" href="https://forum.rebol.info#p-7945-rebol-versions-7"></a>REBOL Versions</h3>
<p>The REBOL version number is printed in the title banner. This number should be included in all bug reports and comments. It indicates not only the version and revision, but also the update number and the platform (OS).</p>
<pre><code>REBOL 1.0.1.3
</code></pre>
<p>This indicates that you are running Version 1.0.1 for Windows 95/98/NT.</p>
<p>Version numbers have the format:</p>
<pre><code>version.revision.update.platform
</code></pre>
<p>From a script you can obtain the version number with:</p>
<pre><code>&gt;&gt; print REBOL/version
</code></pre>
<h3><a name="p-7945-contacting-rebol-8" class="anchor" href="https://forum.rebol.info#p-7945-contacting-rebol-8"></a>Contacting REBOL</h3>
<p>You can contact REBOL Technologies in various ways:</p>
<p>Updates and information: <a href="http://www.rebol.com/">http://www.rebol.com</a><br>
Customer support: <a href="mailto:support@rebol.com">support@rebol.com</a><br>
Postal mail: P.O. Box 1510, Ukiah, CA 95482<br>
Telephone: (707) 467-8000<br>
Fax: (707) 467-8005</p>
<h3><a name="p-7945-whats-next-9" class="anchor" href="https://forum.rebol.info#p-7945-whats-next-9"></a>Whatâ€™s Next?</h3>
<p><strong><a>Expertâ€™s Guide</a></strong> is your reference manual for REBOL. It includes a description and examples of all REBOL words.</p>
<p>Finally, check the REBOL web site for additional information and examples on how others are using REBOL messaging language. Itâ€™s at <a href="http://www.rebol.com">http://www.rebol.com</a>.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_7</link>
        <pubDate>Tue, 06 Oct 1998 05:07:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7945</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7944-chapter-5-rebol-context-1" class="anchor" href="https://forum.rebol.info#p-7944-chapter-5-rebol-context-1"></a>Chapter 5: REBOL Context</h1>
<h3><a name="p-7944-about-context-2" class="anchor" href="https://forum.rebol.info#p-7944-about-context-2"></a>About Context</h3>
<p>Words can be used to represent values. In your script you could define the word two:</p>
<pre><code>two: 2
</code></pre>
<p>and then later make use of it:</p>
<pre><code>&gt;&gt; print two
2

&gt;&gt; print 30 + two
32
</code></pre>
<p>At any point during definition the set of all defined words forms the current context. In the above example, the context would include not only the word two, but the words <strong>print</strong>, <strong>+</strong>, and all other words that were previously defined by the script or by REBOL (such as its native functions). All of these words have values at this point of evaluation, and even though you are not using them all, they are part of the context because you could use them.</p>
<p>If the word <strong>two</strong> is used outside this context, for instance in another script or another part of the same script, it could have a different value. The context determines its meaning (its value). Because of this it is crucial for you to know the rules that establish the context of words.</p>
<p>In REBOL, the primary rules of context are:</p>
<ol>
<li>
<p>Every script begins with a predefined context which includes REBOL words for native functions (such as print) and system values.</p>
</li>
<li>
<p>As your script executes, it may define new words in the context.</p>
</li>
<li>
<p>At specific points functions, and objects may modify the context.</p>
</li>
</ol>
<p>It is this last rule that is our next subject.</p>
<h3><a name="p-7944-using-context-3" class="anchor" href="https://forum.rebol.info#p-7944-using-context-3"></a>Using Context</h3>
<p>In a REBOL script, you define various words with specific values. There will be times when you want to use a word that could already be defined elsewhere in your script. If you give that word a new value, you will destroy its previous value. For instance, in your main script the word who could represent a person, such as:</p>
<pre><code>&gt;&gt; who: "Cindy"
&gt;&gt; print who
Cindy
</code></pre>
<p>But what if later in your script you want to use the word <strong>who</strong> again to temporarily refer to the name of a company? You may not want to lose the name of the person, but just "reuse" the word for a short time.</p>
<p>Whenever you begin a new block in REBOL, you can specify what words you want to temporarily redefine within that block. To do this you put the words you want to redefine in a block.</p>
<pre><code>&gt;&gt; use [[who]
       who: "REBOL HQ"
       print who
   ]
REBOL HQ

&gt;&gt; print who
Cindy
</code></pre>
<p>The <strong>use</strong> function tells REBOL that <strong>who</strong> is to be used temporarily within the block, and you don't want to affect the value of who outside the block. It is said to be local to the block. Any number of words can be specified as local words in this manner.</p>
<p>You have changed the context. The word who used prior to the block now has a different meaning in the new block. This ability to change context can be quite handy, and it is applied to functions and objects as well.</p>
<p>Here is an example of how locals can be used in a block context. It will help illustrate a few points. In it a database of contacts is printed in a specified text format:</p>
<pre><code>; A simple database:
&gt;&gt; persons: [
       "John Able" CEO "Digitalla" ja@dig2.com
       "Jane Baker" VP "Netescape" jane@us.gov
       "Mari Conners" COO "Micoroni" maric@mico.com
   ]

; The fields of the database as words:
&gt;&gt; facts: [name title company email]

; The format used to print the info:
&gt;&gt; text: [name "at" company "is at" email]

; The loop which prints the database:
&gt;&gt; use facts [forskip persons 4 [
       set facts persons
       print text
   ]]
John Able of Digitalla is at ja@dig2.com
Jane Baker of Netescape is at jane@us.gov 
Mari Conners of Micoroni is at maric@mico.com
</code></pre>
<p>Notice that within the forskip block the facts word is used to specify the locals. This is valid because facts is a block. Note that the same facts block is used with set which sets each of the words of the block to the values from the current position in the persons database.</p>
<h3><a name="p-7944-functions-4" class="anchor" href="https://forum.rebol.info#p-7944-functions-4"></a>Functions</h3>
<p>The concept of a function comes from expanding on the block context. You only need two additional concepts:</p>
<ol>
<li>
<p>Functions can be evaluated without requiring do (a function's natural value is to evaluate),</p>
</li>
<li>
<p>The initial values of local words can be supplied to the function each time it is evaluated.</p>
</li>
</ol>
<p>For example, you might create a simple function <strong>plen</strong> to print the length of a series:</p>
<pre><code>plen: make function! [series]
[print length? series]
</code></pre>
<p>and then use it in multiple places in your script:</p>
<pre><code>&gt;&gt; plen "now is the time"
15

&gt;&gt; plen [1 2 3 4]
4
</code></pre>
<p>The value which follows the function is an argument. In the example, both a string argument and a block argument are used. This argument corresponds to the word series that was given in the make function! line above.</p>
<p>Let's take a closer look at the definition of <strong>plen</strong>. The REBOL native function <strong>make</strong> was evaluated, and it required three values:</p>
<ol>
<li>
<p>The datatype to be made, in this case a function!</p>
</li>
<li>
<p>A block of words that will be local to the function's block and used for arguments. These appear in the order that they will appear when the function is used.</p>
</li>
<li>
<p>The function block to be evaluated.</p>
</li>
</ol>
<p>The new function is returned from <strong>make</strong> and is set to <strong>plen</strong>. Note that defining <strong>plen</strong> to be a function is no different than defining it to be an integer, date, or any other value. Once it has been defined, it can then be used as in the example above.</p>
<p>A function can also define other local words which are not used as arguments. These are placed at the head of the function's evaluation block using the use function. In the example below, name and date are local to the function, but are not arguments.</p>
<pre><code>example: make function! [arg] [
    use [name date][
        ...
]]
</code></pre>
<p>A function can also return a value as a result of its evaluation. You can do this from any point in your function with the return native:</p>
<pre><code>find-val: make function! [series value] [
    forall series [
       if (first series) = value [return series]
    ]
]

&gt;&gt; print find-val [1 2 3 4] 3
3 4
</code></pre>
<p>If you want to return from a function, but not return a value, use <strong>exit</strong> instead of <strong>return</strong>. It is similar to the <strong>break</strong> function described earlier.</p>
<p>When arguments are supplied to a function, they are evaluated prior to being used in the function. For instance:</p>
<pre><code>&gt;&gt; plen next [1 2 3 4]
3

&gt;&gt; plen skip [1 2 3 4] 3
1
</code></pre>
<p>Finally, sometimes you will write a script that refers to a function before it has been defined. REBOL allows this as long as you do not try to evaluate the word before it is defined.</p>
<h3><a name="p-7944-func-shortcut-5" class="anchor" href="https://forum.rebol.info#p-7944-func-shortcut-5"></a>Func Shortcut</h3>
<p>A function can accept any type of value as an argument. An argument can be an integer, string, date, block, or any other value, even a function or native. Here is an example in which a function is passed as an argument:</p>
<pre><code>do-it: make function! [func value] [
    func value
]
</code></pre>
<p>Here, the word <strong>do-it</strong> will be used as a function which will accept two arguments and return a result. Because the word <strong>do-it</strong> is used as a natural value (not written as <strong>do-it</strong> or <strong>:do-it</strong>) the natural thing to do is to evaluate it.</p>
<pre><code>&gt;&gt; print do-it :length? "test"
4

&gt;&gt; funcs: [length? first print]
&gt;&gt; print do-it second funcs [1 2 3]
1
</code></pre>
<p>The values of the natives passed as arguments required colons. Otherwise they would have been evaluated prior to being passed as arguments, resulting in an error.</p>
<p>A function can return any type of value as a result. You can make a function for creating other functions.</p>
<pre><code>func: make function! [args code] [
    return make function! args code
]
</code></pre>
<p>The <strong>func</strong> word now refers to this function, and when evaluated, it will perform a <strong>make function!</strong> on the arguments you give it.</p>
<pre><code>&gt;&gt; pall: func [series] [
       forall series [print first series]
   ]

&gt;&gt; pall [1 2 3]
1
2
3
</code></pre>
<p>Here, <strong>func</strong> is given two arguments: a block containing the word series and a block containing the <strong>forall</strong>. These are used by <strong>func</strong> as the args and code of the function to make.</p>
<p>As with everything else in REBOL, the arguments to make can be anything that evaluates to a block.</p>
<h3><a name="p-7944-defining-functions-6" class="anchor" href="https://forum.rebol.info#p-7944-defining-functions-6"></a>Defining Functions</h3>
<p>New functions are created by supplying <strong>make</strong> with the prototypical function datatype (function!), a block of argument words, and the function body block. The form is:</p>
<pre><code>make function! arguments body
</code></pre>
<p>For instance, to create a function to add two values you would write:</p>
<pre><code>make function! [a b] [a + b]
</code></pre>
<p>The <strong>make</strong> returns the new function as a value, and it is often set to a word for later use:</p>
<pre><code>sum: make function! [a b] [a + b]
</code></pre>
<p>This new function could then be applied to a set of arguments, as in:</p>
<pre><code>&gt;&gt; print sum 10 2
12
</code></pre>
<p>Note that naming a function is completely optional. You may want to do something else with the function value, such as return it as a result from another function. As an example, take the standard REBOL helper function <strong>func</strong> which is defined as:</p>
<pre><code>func: make function! [args body] [
    make function! args body
]
</code></pre>
<p>The first <strong>make</strong> creates a function which is used for creating functions. Its arguments are the new function's argument and body blocks, and it returns the newly created function as a result. Simple. Powerful. Useful. With it, the sum function above could be written more concisely as:</p>
<pre><code>sum: func [a b] [a + b]
</code></pre>
<h3><a name="p-7944-returning-values-7" class="anchor" href="https://forum.rebol.info#p-7944-returning-values-7"></a>Returning Values</h3>
<p>Similar to a block, a function can return its last value as a result. As shown above, this value can be any datatype, including a function value.</p>
<p>Should you want to return from a function at some other point within it, you can do so with return. It accepts one argument â€” the value to return.</p>
<pre><code>sum-check: func [a b] [
    if a &lt; 0 [return b]
    if b &lt; 0 [return a]
    a + b
]
</code></pre>
<p>If you do not wish to return a result from a function, use <strong>exit</strong>.</p>
<h2><a name="p-7944-objects-8" class="anchor" href="https://forum.rebol.info#p-7944-objects-8"></a>Objects</h2>
<p>An object is a group of words that have predefined values. An object can be referred to as a single value which can be stored in a variable, passed to functions as an argument, or returned from a function as a result.</p>
<h3><a name="p-7944-defining-objects-9" class="anchor" href="https://forum.rebol.info#p-7944-defining-objects-9"></a>Defining Objects</h3>
<p>New objects are created with <strong>make</strong>, the prototypical object datatype (<strong>object!</strong>), and a block defining the words of the object. Making an object is as easy as making a block containing word definitions:</p>
<pre><code>normal-text: make object! [
    font: "times"
    size: 12
    color: black
]
</code></pre>
<p>The new object is returned from make and can be handled as any other value. In the example above, the object is assigned to the word normal-text, but it could just as easily have been returned from a function.</p>
<p>The block which holds the word definition is evaluated, so it may contain complex definitions of values:</p>
<pre><code>normal-text: make object! [
    font: lookup-font 'normal
    size: standard-size + 2
    color: pick color-set 4
]
</code></pre>
<p>For convenience, you can cascade the definition of multiple words:</p>
<pre><code>default-text: make object! [size: color: font: none]
</code></pre>
<p>The words of an object can be defined to be any kind of value, including functions and other objects:</p>
<pre><code>account: make object! [
    balance: 0
    deposit: func [amount] [balance: balance + amount]
    withdraw: func [amount] [balance: balance - amount]
]
</code></pre>
<p>The benefit of doing this is that the functions will evaluate within the context of the object. This allows you to encapsulate (keep together) the values and functions of the object.</p>
<h3><a name="p-7944-accessing-object-variables-10" class="anchor" href="https://forum.rebol.info#p-7944-accessing-object-variables-10"></a>Accessing Object Variables</h3>
<p>Once an object has been created, you can access the variables within it by using paths. (In REBOL, a path is a means of refining a reference to a value.) For instance, to obtain the value for the balance in the account object above, you can write:</p>
<pre><code>print account/balance
</code></pre>
<p>If you want to deposit or withdraw from the account, you can use its defined functions as:</p>
<pre><code>account/deposit 1000
account/withdraw 20
</code></pre>
<p>If so desired, you can even set a word within an object:</p>
<pre><code>account/balance: 2000
</code></pre>
<p>In addition, the <strong>set</strong> and <strong>get</strong> functions can be used to access the values of an object:</p>
<pre><code>print set account 'balance 1000
do get account 'withdraw 100
</code></pre>
<p>These provide a standard function-based approach to access, allowing complex access expressions such as:</p>
<pre><code>do get account (if thrifty ['deposit] else ['withdraw]) 100
</code></pre>
<h3><a name="p-7944-making-instances-11" class="anchor" href="https://forum.rebol.info#p-7944-making-instances-11"></a>Making Instances</h3>
<p>Once an object has been created, you can make another instance (a duplicate) of it with the make function:</p>
<pre><code>my-account: make account []
</code></pre>
<p>If you want to change the value of a word within the account, you can also do so:</p>
<pre><code>my-account: make account [balance: 400]
</code></pre>
<p>Note that the initial values for a new object will be duplicated as well:</p>
<pre><code>&gt;&gt; new-account: make my-account []
&gt;&gt; print new-account/balance
400
</code></pre>
<p>However, for more complex objects, create your own make function. This allows you to consistently initialize the object each time.</p>
<pre><code>&gt;&gt; make-account: func [starting-balance] [
       make account [
           balance: starting-balance + (starting-balance / 20)
       ]
   ]

&gt;&gt; my-account: make-account 400
&gt;&gt; print my-account/balance
420
</code></pre>
<h3><a name="p-7944-extending-objects-12" class="anchor" href="https://forum.rebol.info#p-7944-extending-objects-12"></a>Extending Objects</h3>
<p>You can extend the definition of an object to create new types of objects which are based on the original. Simply define new words within the block of the new object. These words will be added to the others that are already part of the object.</p>
<pre><code>bank-account: make account [
    bank-name: "Mendocino Savings"
    owner: none
]
</code></pre>
<p>Now you can create a new bank account:</p>
<pre><code>&gt;&gt; an-account: make bank-account [
       owner: "Carl"
       balance: 2000
       display: func [] [print [owner "has" balance]]
   ]

&gt;&gt; an-account/deposit 40
&gt;&gt; an-account/display
Carl has 2040
</code></pre>
<h3><a name="p-7944-hidden-variables-13" class="anchor" href="https://forum.rebol.info#p-7944-hidden-variables-13"></a>Hidden Variables</h3>
<p>You can hide specified words from direct access by making them hidden variables when you define the object. This is can be done with either a function definition or the use native.</p>
<pre><code>&gt;&gt; make-bolt: func [size] [
       make object! [
           set-size: func [value] [size: value]
           get-size: func [] [size]
       ]
   ]

&gt;&gt; bolt: make-bolt 10
&gt;&gt; bolt/get-size
10
</code></pre>
<p>This works because REBOL supports extended context. The use of hidden variables is supported by a REBOL helper function called <strong>make-object</strong>. For arguments it takes the parent object, a block of hidden variable words, and the object initialization block.</p>
<pre><code>bolt: make-object object! [size] [
    set-size: func [value] [size: value]
    get-size: func [] [size]
]
</code></pre>
<h3><a name="p-7944-extended-context-14" class="anchor" href="https://forum.rebol.info#p-7944-extended-context-14"></a>Extended Context</h3>
<p>In REBOL, variables have a quality known as indefinite extent. This allows the life of hidden variables and their context to be extended for as long as they might be needed. This is a powerful feature that makes scripting easier. For instance, in the example above, what would happen if the computation returned a block that contained the hidden variables?</p>
<pre><code>result: use [total longest] [
    total: longest: 0
    foreach distance streets [
        total: total + distance
        if distance &gt; longest [longest: distance]
    ]
    [total longest]
]
</code></pre>
<p>The block stored in result refers to the variables total and longest which were local to the block. In many programming languages this would be considered an error. In REBOL, the hidden variables are extended beyond the use block. Accessing their values will produce the correct results.</p>
<pre><code>&gt;&gt; print get first result
278
</code></pre>
<p>These extended variables have some useful qualities. For instance, if you wanted to create two functions which share a common variable, you could write:</p>
<pre><code>use [count] [
    count: 0
    count-add: func [num] [count: count + num]
    count-sub: func [num] [count: count - num]
]

&gt;&gt; count-add 10
&gt;&gt; print (count-sub 1)
9
</code></pre>
<h3><a name="p-7944-binding-into-context-15" class="anchor" href="https://forum.rebol.info#p-7944-binding-into-context-15"></a>Binding Into Context</h3>
<p>Small databases, descriptive content-oriented blocks, and messages sent from other computers may have been created external to the context in which they must be used. As long as all of the words within these blocks are used as symbols, then there will be no problems.</p>
<p>However, you may want to use some of the words as variables. For instance, a user interface description might contain not only the size, color, and text of a button, but also an action block which is to be evaluated when the button is pressed. That block may contain words which only have values within the user-interface handling code. In order to operate correctly, the words must be associated with their correct values in the current context.</p>
<p>The bind native imports a block by binding its words to the current context regardless of where it was first defined. The new block is returned. For instance, a database might contain code that is to be evaluated in the current context:</p>
<pre><code>database: bind operations-database
do select database 'button
</code></pre>
<p>As this chapter illustrates, REBOL is a powerful messaging language. Additional REBOL words and specifics of the REBOL language are included in the Expertâ€™s Guide.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_6</link>
        <pubDate>Tue, 06 Oct 1998 05:05:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7944</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7943-chapter-4-rebol-evaluation-1" class="anchor" href="https://forum.rebol.info#p-7943-chapter-4-rebol-evaluation-1"></a>Chapter 4: REBOL Evaluation</h1>
<h3><a name="p-7943-about-evaluation-2" class="anchor" href="https://forum.rebol.info#p-7943-about-evaluation-2"></a>About Evaluation</h3>
<p>As mentioned earlier in this guide, <em><strong>symbols are used to represent meaning.</strong></em> Humans can interpret the meaning of symbols and act on them. The resulting actions may not be physical. A symbol may in our minds alone invoke a particular thought or image. Nevertheless, <em>the symbols drive the process.</em></p>
<p>Youâ€™ve learned that REBOL supports a number of values such as integers, times, dates, files, strings, blocks and others. The Values Table in Chapter 1 of this guide summarized the types of values that can be <em><strong>directly expressed</strong></em> in the REBOL language.</p>
<p>While these values give you a means of creating data and databases, they do not provide enough capability to do everything. There are other values within REBOL that were not shown in the table because they are not directly expressible. These values are created within REBOL and are represented as words or as series of values. For instance, earlier in this guide you were introduced to the concept of <em>functions</em> which perform actions and produce results. Functions like <strong>print, foreach,</strong> and <strong>first</strong> were thrown in without much explanation.</p>
<p>The table below summarizes these other <em><strong>indirectly expressed</strong></em> values.</p>
<div class="md-table">
<table>
<thead>
<tr>
<th><strong>Value</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>None</strong></td>
<td>A single value which represents the idea of no value. The word <strong>none</strong> is predefined in REBOL to hold this value.</td>
</tr>
<tr>
<td><strong>Logic</strong></td>
<td>The two values which we call true and false (on and off or 1 and 0). These are often called Boolean values. The words <strong>true</strong> , <strong>false</strong> , <strong>on</strong> , <strong>off, yes</strong> , and <strong>no</strong> are defined to hold these values.</td>
</tr>
<tr>
<td><strong>Object</strong></td>
<td>A series of values which exist and evaluate within a defined context.</td>
</tr>
<tr>
<td><strong>Function</strong></td>
<td>A series of values which exist and evaluate within a temporary (momentary or dynamic) context.</td>
</tr>
<tr>
<td><strong>Native</strong></td>
<td>An internal REBOL function that is evaluated directly by the computer. In some languages, these are called native code or primitive functions.</td>
</tr>
</tbody>
</table>
</div><p>Some <em><strong>words</strong></em> have predefined values. Most of these words have been predefined to values that relate to some of the datatypes above. Because they cannot be directly expressed, a <em>word</em> must be used to represent them.</p>
<p>For example, the words <strong>true</strong> and <strong>false</strong> are predefined to the values for the logic states of true and false. They are symbols that stand for the values.</p>
<p>Words like <strong>print</strong> , <strong>repeat</strong> , and <strong>first</strong> are predefined to <em><strong>native</strong></em> function values. They perform various actions, may be given a set of arguments, and may return results. A native function's value cannot be expressed in REBOL, only the word which represents it.</p>
<h3><a name="p-7943-evaluating-blocks-3" class="anchor" href="https://forum.rebol.info#p-7943-evaluating-blocks-3"></a>Evaluating Blocks</h3>
<p>In REBOL, there is no difference between blocks of code and blocks of data. How is it then that one gets evaluated and the other does not?</p>
<p>The answer is the <strong>do</strong> function. This tells REBOL to evaluate a block: traverse its values, relate them to actions, and perform those actions. The <strong>do</strong> below executes the block provided as its argument:</p>
<pre><code>&gt;&gt; do [print 10]
10
</code></pre>
<p>A block is just <em><strong>considered to be data until it is evaluated</strong></em> with <strong>do</strong> or another function. You could have written:</p>
<pre><code>&gt;&gt; todo: [print 10]
&gt;&gt; do todo
10
</code></pre>
<p>In other words, just encountering a block does not evaluate it. The <strong>do</strong> function is needed.</p>
<p>How are the lines of the example evaluated? There is no <strong>do</strong> for them. When REBOL reads input from the user or executes a file, a <strong>do</strong> is provided by REBOL.</p>
<p>The <strong>do</strong> function can also <em><strong>return a value</strong></em> after evaluating a block. For instance, you could write:</p>
<pre><code>&gt;&gt; numbers: [1 12 123]
&gt;&gt; todo: [length? numbers]
&gt;&gt; length: do todo
&gt;&gt; print length
3
</code></pre>
<p>This can be very useful. The following example takes advantage of the value returned from the block:</p>
<pre><code>align-cases: [
    left [0]
    right [page-width - length? text]
    center [(page-width - length? text) / 2]
]

&gt;&gt; text: "Heading"
&gt;&gt; page-width: 80

&gt;&gt; print do select align-cases 'center
36.5
</code></pre>
<p>There are several other useful functions which use <strong>do</strong> to evaluate blocks. They are explained below. You can also define your own functions.</p>
<p><strong>Load</strong> and <strong>save</strong> are also used in evaluation. <strong>Load</strong> analyzes a value to determine the datatype, then converts the value for use by REBOL. <strong>Load</strong> is used for files, URLs, and string datatypes. For example,</p>
<pre><code>load %image.jpg
</code></pre>
<p><strong>Save</strong> converts and saves a value into the appropriate format for the datatype. The save function is used for files and URLs. Hereâ€™s an example:</p>
<pre><code>save %this-file.txt "This file is empty."
</code></pre>
<p>The <strong>do</strong>, <strong>load</strong>, and <strong>save</strong> functions are useful tools as you write REBOL scripts.</p>
<p><strong>Read</strong> and <strong>write</strong> are also useful functions for working with files and urls. For example,</p>
<pre><code>text: read %readme.txt
</code></pre>
<p>will open, read the entire text file, and close it. And:</p>
<pre><code>write %readme.txt "This is a readme file."
</code></pre>
<p>will open, write, and close the file.</p>
<h4><a name="p-7943-conditional-evaluation-4" class="anchor" href="https://forum.rebol.info#p-7943-conditional-evaluation-4"></a>Conditional Evaluation</h4>
<p>To evaluate a block under certain conditions the <strong>if</strong> function is provided. It accepts two arguments, the first is a logic condition and the second is a block to evaluate if the condition is true.</p>
<pre><code>if time &gt; 12:00 [print "past noon"]
</code></pre>
<p>An <strong>if</strong> function can be followed by an optional <strong>else</strong> function which takes a single argument, the block to be evaluated if the condition were false:</p>
<pre><code>if time &gt; 12:00 [print "past noon"]
else [print [12:00 - time "hours until lunch"]]
</code></pre>
<p>The most common mistake in using <strong>if</strong> is forgetting to give a block as the second argument (not remembering the brackets, for instance).</p>
<p>The brackets are not needed if you provide a word that has been defined with a block value:</p>
<pre><code>notice: [print "past noon"]
if time &gt; 12:00 notice
</code></pre>
<p>That's because a block is a block, regardless of whether it is directly expressed (with brackets) or is the value of a word. It can even be the result of a function:</p>
<pre><code>notices: [
    [print "past sunrise"]
    [print "past noon"]
    [print "past sunset"]
]

if time &gt; 12:00 second notices
</code></pre>
<p>Here, the <strong>second</strong> function provides the block to be evaluated (or not evaluated) by <strong>if</strong> . This is possible because <strong>if</strong> is just a function that takes arguments like any other function. It is not a special purpose control symbol of the language (as it is in most languages). REBOL is classified as a <em><strong>functional</strong></em> language, because all of its executable constructs are simply functions.</p>
<p>Two other conditional evaluations for blocks are <strong>any</strong> and <strong>all</strong> . The <strong>any</strong> function evaluates each expression in a block to determine if <em>any</em> are true (according to the arguments). The <strong>all</strong> function checks to see if <em>all</em> the values in the block are true. If there are no values or the result is not true, a <strong>false</strong> is returned.</p>
<h4><a name="p-7943-repeated-evaluation-5" class="anchor" href="https://forum.rebol.info#p-7943-repeated-evaluation-5"></a>Repeated Evaluation</h4>
<p>There are a variety of functions that specialize in the repeated evaluation of a block of values.</p>
<p>The <strong>loop</strong> function is the simplest, evaluating a block a given number of times. In this example, the <strong>prin</strong> function prints its argument without starting a new line:</p>
<pre><code>&gt;&gt; loop 40 [prin "-"]
----------------------------------------
</code></pre>
<p>The <strong>repeat</strong> function extends <strong>loop</strong> by allowing you to keep track of the loop counter. The <strong>repeat</strong> must be followed by a word that will be used to hold the count value.</p>
<pre><code>&gt;&gt; repeat count 3 [print ["count:" count]]
count: 1
count: 2
count: 3
</code></pre>
<p>The <strong>for</strong> function goes beyond <strong>repeat</strong> by letting you specify the starting value, the ending value, and the increment to the value. Any of the values can be positive or negative. In this example , the <strong>prin</strong> function will print its argument followed by a space but not a new line:</p>
<pre><code>&gt;&gt; for count 0 50 10 [prin count]
0 10 20 30 40 50
</code></pre>
<p>You can stop the repeated evaluation of a block with the <strong>break</strong> function. This is handy if you encounter some unusual condition and do not want to continue the loop.</p>
<pre><code>repeat count 10 [
    if (random count) &gt; 5 [break]
    print "repeat"
]
</code></pre>
<p>For repeated evaluation involving series, the <strong>foreach, forall,</strong> and <strong>forskip</strong> functions were covered earlier in this guide.</p>
<p>The <strong>until</strong> function will repeat a block until the block returns the <strong>true</strong> value.</p>
<pre><code>&gt;&gt; numbers: [1 12 1234 12345]

&gt;&gt; until [
       print first numbers
       numbers: next numbers
      (first numbers) &gt; 2000
    ]
1
12
1234
</code></pre>
<p>And finally, the <strong>while</strong> function will repeat the evaluation of two blocks, while the first one returns <strong>true</strong> :</p>
<pre><code>&gt;&gt; colors: ["red" "green" "blue"]

&gt;&gt; while [? next colors] [
       print first colors
       colors: next colors
   ]
red
green
blue
</code></pre>
<h3><a name="p-7943-native-functions-6" class="anchor" href="https://forum.rebol.info#p-7943-native-functions-6"></a>Native Functions</h3>
<p>REBOL includes a number of predefined words called <strong><em>natives</em> .</strong> A native is a function which executes directly on the system processor and requires no further interpretation by REBOL. The words <strong>print, first, loop, do</strong> are all predefined to natives.</p>
<p>Within a script you can create your own <em><strong>functions</strong></em> . These functions evaluate in a similar manner to REBOL natives. They will be discussed later in this guide.</p>
<p>All functions, whether created by you or by REBOL, can accept a number of values as <em><strong>arguments</strong></em> and return a value as a <em><strong>result</strong></em> . Of course, both of these are optional. A function does not need to accept any arguments nor return any result.</p>
<p>Functions can be combined to allow the result of one function to be given as the argument to another. For instance:</p>
<pre><code>print first colors
</code></pre>
<p>The result of <strong>first</strong> would then be passed as the argument to <strong>print</strong> . When multiple functions are cascaded in this fashion, their <em><strong>results move from right to left.</strong></em> The rightmost function (<strong>first</strong> ) returns its result to the function on its left (<strong>print</strong> ).</p>
<p>No restrictions are placed on the datatypes of values that can be accepted as arguments or returned as results. Even values like blocks, objects, functions, and natives can be used as arguments and returned as results.</p>
<p>Normally a function is placed before its arguments. However, it is a common practice for most mathematic and comparison <em><strong>operators</strong></em> to be placed <em>between</em> their arguments. The REBOL words below are operators:</p>
<pre><code>+ - * / // = &lt;&gt; &lt; &lt;= &gt; &gt;= and or xor
</code></pre>
<p>Remember when using an operator that <em><strong>you must include a space before and after the word</strong></em> to separate it from its arguments, otherwise the operator will just be treated like characters of the word.</p>
<p>Unlike many languages, REBOL operators and functions have no preferred ordering or <em>precedence</em> . However, for the convenience of users, <strong>operators will evaluate from left to right:</strong></p>
<pre><code>&gt;&gt; print 5 + 10 * 2
30
</code></pre>
<p>When a series of operations needs to be performed in a particular order <em><strong>you should use parentheses to indicate which is to be evaluated first.</strong></em> This really helps clarify the order of operations:</p>
<pre><code>&gt;&gt; print (5 + 10) * 2
30

&gt;&gt; print 5 + (10 * 2)
25
</code></pre>
<p><em>Note: Ignoring REBOLâ€™s preferred ordering can be a source of errors in your scripts.</em></p>
<p>REBOL also includes prefix operators such as <strong>add</strong> , <strong>subtract</strong> , <strong>multiply</strong> , <strong>divide</strong> , <strong>greater-than</strong> , <strong>less-than</strong> , etc. They can be used as in this example:</p>
<pre><code>&gt;&gt; print add 10 20
30
</code></pre>
<h3><a name="p-7943-paths-7" class="anchor" href="https://forum.rebol.info#p-7943-paths-7"></a>Paths</h3>
<p>In general, <em><strong>paths</strong></em> provide a means of <em><strong>refined specification</strong></em> . They describe a route through a hierarchy, and provide a shorthand technique for referring to sub-elements, positions, or options. They may be used with objects, functions, files, URLs, blocks, strings, and a variety of other datatypes.</p>
<p>Paths are expressed relative to a root value by providing a number of <em><strong>refinements</strong></em> , each separated by a slash (/). These refinements can be words (symbols), numbers, strings, files, and other datatypes. Their specific interpretation will vary depending on the datatype of the root. This is best illustrated with a few examples:</p>
<pre><code>account/deposit ; evaluate an object's function

match/any ; function refinement

src/unix/main.c ; directory path to file

USA/CA/Ukiah/population ; select from multiple blocks

names/12 ; pick the 12th name from a block
</code></pre>
<p>Words supplied as paths are <em><strong>symbolic</strong></em> . This is necessary to allow the most intuitive form for object referencing. To use a variable, an explicit word value reference is required:</p>
<pre><code>src/unix/:filename
</code></pre>
<p>Paths themselves can be used within paths. For instance:</p>
<pre><code>dir: src/unix
data: load dir/main.c
</code></pre>
<p>An advanced feature of the email datatype uses <strong>email-port</strong> and <strong>email-head</strong> objects. You can make a separate object for sending email (using SMTP) like this:</p>
<pre><code>REBOL/email-port: make REBOL/email-port [
    host: "mail.domain.com"
    user: "username"
    pass: "password"
]
</code></pre>
<h3><a name="p-7943-continuation-8" class="anchor" href="https://forum.rebol.info#p-7943-continuation-8"></a>Continuation</h3>
<p>The <strong>catch</strong> function allows you to return to a specified point in a script using a method called <em><strong>continuation</strong></em> . A continuation is a saved point in the flow of execution that can be called and returned to at a later time. Think of it as a bookmark that saves your location and current context. Continuations are first class. They can be stored in variables, passed as arguments, and returned from functions. As such, they provide a powerful mechanism for advanced scripting in REBOL â€” especially for handling operations such as exceptions.</p>
<p>To use catch you provide a symbol and a block:</p>
<pre><code>catch *symbol* *body*
</code></pre>
<p>The symbol is used as the name for a new function which holds the continuation point. This function becomes available within the context of the body block, where it can be called to return to the point just after the catch. Think of it as a throw function if you are familiar with that concept from other languages. It takes one argument: a value which will be returned as the result of the catch.</p>
<pre><code>print catch 'throw [
    loop 100 [
         if (random 10) &gt; 5 [throw "hit"]
    ]
   "miss"
]
</code></pre>
<p>The symbol throw is used here as the name of the continuation function. When it is applied, its argument is used as the return from its associated catch. In the above example, its behavior is identical to a return function.</p>
<h4><a name="p-7943-non-local-return-9" class="anchor" href="https://forum.rebol.info#p-7943-non-local-return-9"></a>Non-local Return</h4>
<p>The function named by catch is local to the block passed to catch. However, there may be times when you want to return from functions called outside the block. To do so, define a word outside the context of the block to hold the continuation function.</p>
<pre><code>rand-it: func [num] [
    loop num [
        if (random num) &gt; (num / 2) [resume "hit"]
    ]
    "miss"
]

print catch 'throw [
    resume: :throw
    rand-it 100
]
</code></pre>
<p>Here the word <strong>resume</strong> is given the function value of <strong>throw</strong> and is used outside the block as a non-local return to the <strong>catch</strong> .</p>
<h4><a name="p-7943-true-continuation-10" class="anchor" href="https://forum.rebol.info#p-7943-true-continuation-10"></a>True Continuation</h4>
<p>With the indefinite extent concept discussed later, continuations can be preserved even beyond the return point of the <strong>catch</strong> . If after the example above, you were to write the line:</p>
<pre><code>resume "test"
</code></pre>
<p>you would return to the same point as before â€” just after the catch â€” and the "test" string would be passed to the <strong>print</strong> function. Note that <em>the entire context of the catch is preserved.</em> Here is another example:</p>
<pre><code>times: func [num] [num * catch 'here [resume-times: :here 1]]
result: times 1
print result
if result &lt; 100 [resume-times (result * 3)]
</code></pre>
<p>In this example, the catch marks the return point within the function <strong>times</strong> . When the <strong>resume-times</strong> function is applied, it passes a new value back to the multiplication. <em><strong>Notice that even the return point from times is preserved!</strong></em> The assignment to <strong>result</strong> and <strong>print result</strong> are all done again, because they follow the initial call to <strong>times</strong> .</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_5</link>
        <pubDate>Tue, 06 Oct 1998 04:46:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7943</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7942-chapter-3-rebol-series-1" class="anchor" href="https://forum.rebol.info#p-7942-chapter-3-rebol-series-1"></a>Chapter 3: REBOL Series</h1>
<h3><a name="p-7942-about-series-2" class="anchor" href="https://forum.rebol.info#p-7942-about-series-2"></a>About Series</h3>
<p>In REBOL, a group of values can form a <em><strong>series</strong></em> . Series are frequently used in computing and REBOL treats them in a consistent manner. For instance, a series could be a:</p>
<ul>
<li>set of values</li>
<li>string of characters</li>
<li>directory of files</li>
<li>mailbox of messages</li>
<li>group of tasks</li>
<li>database of records (as in a checkbook)</li>
<li>sequence of images (as in a movie)</li>
<li>sequence of sounds</li>
<li>array of pixels (as in an image)</li>
<li>array of samples (as in a sound)<br>
<em>and more...</em></li>
</ul>
<p>The essential characteristics of a series are that it <em><strong>contains a set of values that are organized in a particular order</strong></em> .</p>
<p>A movie consists of a number of still images which are placed in the order that they are to be shown. This sentence contains a series of words which you read in the order that they were written.</p>
<p>The order implies a few simple relationships. Something comes <strong>first</strong>, something comes <strong>next</strong>. There is a beginning (<strong>head</strong>) and an end (<strong>tail</strong>). You can skip <strong>forward</strong> or <strong>backward</strong> in the series. You can count its parts (<strong>length</strong>) and you can refer to them by their positions (e.g. the <strong>fifth</strong> word in a sentence).</p>
<p>The following section covers taking advantage of the power of series in REBOL scripts. Refer to the <strong><a>Expertâ€™s Guide</a></strong> for complete descriptions and examples of REBOL series.</p>
<h3><a name="p-7942-blocks-3" class="anchor" href="https://forum.rebol.info#p-7942-blocks-3"></a>Blocks</h3>
<p>Both code and data can be grouped into a type of series called a <em><strong>block</strong></em> . Blocks can be directly expressed in REBOL as a set of values enclosed in square brackets:</p>
<pre><code>[10:42 "write next chapter"]
</code></pre>
<p>Blocks can contain any number of values (up to the limit of memory) or no values at all. They can extend over multiple lines and can include any type of value, even other blocks:</p>
<pre><code>[ ]

[24 37 108]

[REBOL [
    Title: "Test Script"
    Date: 30-Sep-1998
    Author: "Ema User"
]]
</code></pre>
<p>Note that when <em><strong>words</strong></em> are used within a block (like name, work, home), they do not need to be previously defined. Their values may be set later in the script, or in some cases, not at all (as when they are being used symbolically).</p>
<p><strong>There is no difference in REBOL between blocks that hold code and blocks that hold data.</strong> Code is simply a block that is evaluated and whose words when evaluated have meaning in REBOL. Evaluation is further discussed in Chapter 4 of this guide.</p>
<pre><code>if date &gt; 31/Mar/1999 [print "project delayed"]

while [time &lt; 10:00] [
    print time
    time: time + 0:10
]
</code></pre>
<p><strong>Blocks are <em>free form.</em></strong> They are not sensitive to lines, spaces or tabs. You can place lines and spacing anywhere within the block, as long as it does not divide a single value.</p>
<p><em>Note: To make programs easier to read it is helpful to indent lines that fall within a block, as shown above. Note that the closing bracket is often placed on a separate line and is not indented like the content of the block.</em></p>
<h3><a name="p-7942-decomposing-4" class="anchor" href="https://forum.rebol.info#p-7942-decomposing-4"></a>Decomposing</h3>
<p>A series is created so that it can be treated as a whole. However, to be useful, you will need to access the values within it. Because the values of a series have an order, the obvious way to <strong>extract a particular value is by specifying its position.</strong> The REBOL <strong>pick</strong> function does this:</p>
<pre><code>&gt;&gt; colors: ["red" "green" "blue" "yellow" "orange"]

&gt;&gt; print pick colors 3
== blue
</code></pre>
<p>For convenience, REBOL also provides a few <em>shorthand</em> functions for picking values from common positions: <strong>first</strong> , <strong>second</strong> , <strong>third</strong> , <strong>fourth</strong> , <strong>fifth</strong> , and <strong>last</strong> .</p>
<pre><code>&gt;&gt; print third colors
== blue

&gt;&gt; print last colors
== orange
</code></pre>
<h3><a name="p-7942-traversing-5" class="anchor" href="https://forum.rebol.info#p-7942-traversing-5"></a>Traversing</h3>
<p>In REBOL, a common way to access a series is to <strong>traverse</strong> it (to move around inside it). To do anything more than pick out values, you will need to know this.</p>
<p><strong>Traversing is like crossing a creek by stepping on stones.</strong> You start by hopping to the first stone (the head), then hop from one stone to the next until you reach the end (the tail). While you are in the process of moving across the creek your current position is marked by where you are standing. The same ideas apply to traversing a series.</p>
<p>In the previous section, the word <strong>colors</strong> was set to a block with:</p>
<pre><code>colors: ["red" "green" "blue" "yellow" "orange"]
</code></pre>
<p>It is crucial for you to realize that the block exists on its own, and that colors simply refers to the head of the block.</p>
<p>When you traverse this block, you move to other positions within it. The entire block still exists, you are just at a different "stone" (to use the creek metaphor). For instance:</p>
<pre><code>&gt;&gt; print colors
red green blue yellow orange
</code></pre>
<p>You are at the head of the block. The <strong>next</strong> function will "hop" to the next position in the block and return it. You could <strong>print</strong> from the new position or define a new word for it:</p>
<pre><code>&gt;&gt; print next colors
green blue yellow orange

&gt;&gt; newer: next colors
&gt;&gt; print newer
green blue yellow orange
</code></pre>
<p><strong>What is really important here is that <em>you are still referring to the same block</em>, just a different position within it.</strong> If you wanted, you could use the <strong>past</strong> function to move back to the position you just passed:</p>
<pre><code>&gt;&gt; older: past newer
&gt;&gt; print older
red green blue yellow orange
</code></pre>
<p><em><strong>Traversing in this fashion is the same for all series.</strong></em></p>
<p>To obtain a value from a different position in the block, you can use the <strong>pick</strong> function or any of its shorthand functions (<strong>first</strong> , <strong>second</strong> , <strong>third</strong> , etc.):</p>
<pre><code>&gt;&gt; print first newer
green
</code></pre>
<p>If you want to move forward or backward multiple positions, you could string together multiple <strong>next</strong> or <strong>back</strong> functions:</p>
<pre><code>&gt;&gt; print next next next colors
yellow orange
</code></pre>
<p>However, for general cases it is better to use the <strong>skip</strong> function:</p>
<pre><code>&gt;&gt; example: skip colors 3
&gt;&gt; print example
yellow orange
</code></pre>
<p>You can also go backwards in a series by providing a negative skip value.</p>
<p>If you want to skip forward to the tail (the position just after the last value) or back to the head, the <strong>tail</strong> and <strong>head</strong> functions can be used:</p>
<pre><code>&gt;&gt; example: head example
&gt;&gt; print example
red green blue yellow orange

&gt;&gt; print past tail colors
orange
</code></pre>
<p>Notice in the last example you need to move backward one (<strong>past</strong>) before printing. That's because <strong>tail</strong> <strong>always places you <em>just past the last value.</em></strong></p>
<pre><code>&gt;&gt; tail-colors: tail colors
&gt;&gt; print length? tail-colors
0
</code></pre>
<p>As you will learn later, tail is necessary in order to <strong>insert</strong> new values in the block.</p>
<h2><a name="p-7942-length-6" class="anchor" href="https://forum.rebol.info#p-7942-length-6"></a>Length</h2>
<p>The length of a series is the number of values from <em>the current position</em> to its tail. The <strong>length?</strong> function will determine this.</p>
<pre><code>&gt;&gt; print length? [10 20 30 40]
4

&gt;&gt; skipped: skip colors 3
&gt;&gt; print length? skipped
2
</code></pre>
<p>When a block appears as a value within another block, it only counts as one value:</p>
<pre><code>&gt;&gt; values: [new [1 2 3] old [4 5]]
&gt;&gt; print length? values
4

&gt;&gt; print length? second values
3
</code></pre>
<h3><a name="p-7942-position-7" class="anchor" href="https://forum.rebol.info#p-7942-position-7"></a>Position</h3>
<p>When you are traversing a series, there will be times when you want know your position from the head of the series. The <strong>index?</strong> function will provide you with that number.</p>
<pre><code>&gt;&gt; skipped: skip colors 3
&gt;&gt; print index? skipped
4
</code></pre>
<p>You can also check to see if you are at the head or tail positions in a series with the <strong>head?</strong> and <strong>tail?</strong> functions:</p>
<pre><code>&gt;&gt; if head? colors [print "at head"]
at head

&gt;&gt; if tail? colors [print "at tail"] else [print "not tail"]
</code></pre>
<p>not tail</p>
<pre><code>&gt;&gt; while [not tail? colors] [
       print [index? colors "-" first colors]
       colors: next colors
]

1 - red
2 - green
3 - blue
4 - yellow
5 - orange
</code></pre>
<p>Note that <strong>colors</strong> is now at the tail position in the block. To move it back to the head:</p>
<pre><code>&gt;&gt; colors: head colors
</code></pre>
<h3><a name="p-7942-find-and-select-8" class="anchor" href="https://forum.rebol.info#p-7942-find-and-select-8"></a>Find and Select</h3>
<p>With the <strong>find</strong> function you can traverse to a particular value in a series:</p>
<pre><code>&gt;&gt; found: find colors "blue"
&gt;&gt; print found
blue yellow orange

&gt;&gt; print first found
blue
</code></pre>
<p>Additional attributes can be specified to allow you to control the direction (backward or forward) as well as the pattern matching (like case sensitivity and wildcards).</p>
<p>A block is often used to hold related values in a simple "micro database". For instance:</p>
<pre><code>email-book: [
    "John" jd@great.effects.org
    "Richard" rich@photo.edu
   "Joe" walker@yoda.gov
   "Ralph" RMQ@m.falcon.edu
]
</code></pre>
<p>To locate a person in this database:</p>
<pre><code>&gt;&gt; name: find email-book "Joe"
&gt;&gt; print [first name "is at" second name]
Joe is at walker@yoda.gov
</code></pre>
<p>A handy variation of <strong>find</strong> is the <strong>select</strong> function, which will return the <em>value</em> that follows the one that was matched:</p>
<pre><code>&gt;&gt; print select colors "blue"
yellow

&gt;&gt; print select email-book "Richard"
rich@photo.edu
</code></pre>
<p>The <strong>select</strong> function is commonly used for finding a particular block of code to evaluate (somewhat like the switch or case statements in other languages). An example:</p>
<pre><code>cases: [
    10 [print "ten"]
    20 [name: "twenty"]
    30 [quit]
]

&gt;&gt; do select cases 10
ten
</code></pre>
<h3><a name="p-7942-series-helpers-9" class="anchor" href="https://forum.rebol.info#p-7942-series-helpers-9"></a>Series Helpers</h3>
<p>Traversing through an entire series is done often in REBOL. To help minimize the task, a few helper functions are provided.</p>
<p>The <strong>forall</strong> function will evaluate a block for all values from the current position to the tail of the series.</p>
<pre><code>&gt;&gt; forall colors [print first colors]
red
green
blue
yellow
orange
</code></pre>
<p>Note that the first argument to <strong>forall</strong> <em>must be a word</em> that has been set to a series (in this case a block). As the series is traversed, the variable is updated to each position. When the function has finished, the variable is <em><strong>reset to its starting value.</strong></em></p>
<p>The <strong>foreach</strong> function is similar, but is given a word and the series. For each value in the series, the word will be set to that value.</p>
<pre><code>&gt;&gt; foreach color colors [print color]
red
green
blue
yellow
orange
</code></pre>
<p>The <strong>forskip</strong> function is similar to <strong>forall</strong> but skips a given number of values each time:</p>
<pre><code>&gt;&gt; forskip colors 2 [print first colors]
red
blue
orange
</code></pre>
<h3><a name="p-7942-match-10" class="anchor" href="https://forum.rebol.info#p-7942-match-10"></a>Match</h3>
<p>Without attributes, <strong>match</strong> compares to series and returns NONE if they are not the same, and the end position of the match if they are the same (which in the simple cases is usually the tail of the series). The result of a <strong>match</strong> is often passed to control functions such as <strong>if</strong> , <strong>while</strong> , or <strong>until</strong> .</p>
<pre><code>str: "abcde"
if match str "abcde" [...]
</code></pre>
<p>If the <strong>/part</strong> function attribute is used, <strong>match</strong> will only compare the specified number of characters:</p>
<pre><code>if match/part str "abc" 3 [...]
</code></pre>
<p>You can also specify the ending position of the match:</p>
<pre><code>if match/part str "abc" find str "c" [...]
</code></pre>
<p><em>Note: Unlike the series modification functions, the position must be relative to the first series.</em></p>
<p>A match can also be made against wild card patterns. The <strong>/any</strong> attribute is used to indicate that the match can be made with any string that fits the pattern. Essentially, it allows you to use the same pattern matching features that you apply to file directories (as shown above). A '?' matches any character and a '*' matches zero or more chars.</p>
<pre><code>match/any str "a*" ; any string starting with "a"
</code></pre>
<p>You can also use match for files, email, urls, etc.</p>
<pre><code>match/any email-addr *@rebol.com
match/any file %*.r
match/any url http://www.rebol.com/*
</code></pre>
<p>Advanced REBOL users may need to use patterns containing the wild cards as characters. To do this, you can use <strong>/with</strong> to specify alternate wild chars with a string. The first char in the string is used as the char for single char matches (change from '?'), and the second is for any sequence (change from '*').</p>
<h3><a name="p-7942-creating-series-11" class="anchor" href="https://forum.rebol.info#p-7942-creating-series-11"></a><strong>Creating Series</strong></h3>
<p>REBOL allows you to create new series with <strong>make</strong> and <strong>copy</strong> .</p>
<p><strong>make</strong> creates a new series from a "prototype" and a parameter. The parameter can be an integer indicating the length (or additional length) of the series, or it can be the initial contents of the series.</p>
<pre><code>str: make string! 100
file: make file! 10
file: make file! %myfile.txt
</code></pre>
<p><strong>copy</strong> creates a new series by copying another. This is shorthand for make with a zero additional length parameter (make series 0). (The <strong>part</strong> option described below can also be used with this function.)</p>
<pre><code>new-msg: copy message
new-msg-tail: insert (copy message) "Message: "
</code></pre>
<h3><a name="p-7942-modifying-series-12" class="anchor" href="https://forum.rebol.info#p-7942-modifying-series-12"></a>Modifying Series</h3>
<p>REBOL offers a number of powerful functions to modify series. They include <strong>change</strong>, <strong>insert</strong>, <strong>remove</strong>, and <strong>clear</strong>.</p>
<p><strong>change</strong> changes values within a series. If the second argument is a value, it will replace the value at the current position in the first series. If the second argument is a series, then its values will replace those of the first series. (The <strong>part</strong> , <strong>only</strong> , and <strong>dup</strong> options described below can also be used with this function.)</p>
<pre><code>change block 200
change (skip block 5) 200
change tail block http://www.rebol.com
change block [200 "test"]
</code></pre>
<p><strong>insert</strong> inserts values into a series. If the second argument is a value, it will be inserted into the series at the current position. If the second argument is a series, then its values will be inserted into the first series. (The <strong>part</strong>, <strong>only</strong>, and <strong>dup</strong> options described below can also be used with this function.)</p>
<pre><code>insert block "start"
insert (find block 10:30) "time"
insert next block [200 "test"]
</code></pre>
<p><strong>remove</strong> removes a value from a series. (The <strong>part</strong> option described below can also be used with this function.)</p>
<pre><code>remove block ; removes first value from series
remove (find block fred@derf.com)
</code></pre>
<p><strong>clear</strong> removes remaining values from a series.</p>
<pre><code>clear skip block 20
clear find block http://www.microsoft.com
clear change name "sam" ; explained below
</code></pre>
<p>The change, insert, remove, and clear functions directly affect the series provided as the first argument. If you have other variables which refer to the same series, after the operation they may no longer reference the same value within the series.</p>
<p>The <strong>change</strong> , <strong>insert</strong> , and <strong>remove</strong> functions also return a result, which is the series as of the point just past the modification. This can be useful for making additional modifications:</p>
<pre><code>&gt;&gt; start: "now is the time"
&gt;&gt; insert (remove/part find start "is" size? "is") "was"
&gt;&gt; print start
now was the time

; A simple replace function:
replace: make function! [series old new] [
    use [here]
    if (here: find series old) [
       insert (remove here) new
    ] else [
       print "not found"
    ]
]
</code></pre>
<p>In addition, options can be provided to modify functions. This is done by using function attributes (as paths, similar to those used with object references or file names):</p>
<pre><code>change/part name "fred derf" 4
insert/only block [200 fred@derf.com]
change/dup space "*" 50
</code></pre>
<p>The valid options are:</p>
<p><strong>part</strong> changes, inserts, or removes a given number of values (specified as either a count or as an ending series position).</p>
<pre><code>change/part block items 5
insert/part string "new text" 3
remove/part string 5
remove/part string find string "end"
name: copy/part string 10
</code></pre>
<p><strong>only</strong> treats a series value as a single value. Normally used to change or insert a block as a block, rather than as a series of values.</p>
<pre><code>insert/only block ["Freddy" fred@derf.com 
change/only (skip tail block -4) ["fred" 10]
</code></pre>
<p><strong>dup</strong> repeats the change or insert for the number of times specified.</p>
<pre><code>insert/dup block 'none 5
change/dup (find name "fred") "*" 4
change/part/dup name string 4 3
</code></pre>
<h3><a name="p-7942-dealing-with-none-13" class="anchor" href="https://forum.rebol.info#p-7942-dealing-with-none-13"></a>Dealing With None</h3>
<p>If a series function attempts to access a value that is beyond the head or tail of a series, it will return a special value, <strong>none</strong> , to indicate that there was a problem. You can use the <strong>none?</strong> function to check for such a result:</p>
<pre><code>&gt;&gt; color: pick colors 10
&gt;&gt; if none? color [print "no color"] else [print color]
no color

&gt;&gt; color: find colors "purple"
&gt;&gt; if none? color [print "cannot find purple"]
cannot find purple
</code></pre>
<p>Another function that is often used to detect <strong>none</strong> is the <strong>none?</strong> function, which returns <strong>true</strong> if a value exists and <strong>false</strong> if the value is <strong>none</strong> .</p>
<pre><code>&gt;&gt; color: find colors "green"
&gt;&gt; if none? color [print [index? color first color]]
2 green
</code></pre>
<p>If you do not check for <strong>none</strong> and attempt to use it with a series function, an error will occur. In the example below, <strong>next</strong> does not like the <strong>none</strong> returned by the <strong>find</strong> .</p>
<pre><code>&gt;&gt; print next find colors "purple"
** PROGRAM ERROR: no such action (next) for none **
</code></pre>
<p>The functions <strong>first, second, third, fourth, fifth,</strong> and <strong>last</strong> do not return <strong>none</strong> ; they will generate an error instead. This is done for the convenience of using these functions as shorthand. If you would prefer to receive a <strong>none</strong> in such situations, use the <strong>pick</strong> function.</p>
<pre><code>&gt;&gt; sched: [12:30 "Lunch"]
&gt;&gt; print third sched
** PROGRAM ERROR: value is too short **

&gt;&gt; print pick sched 3
NONE
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_4</link>
        <pubDate>Tue, 06 Oct 1998 04:38:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7942</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7941-chapter-2-rebol-words-1" class="anchor" href="https://forum.rebol.info#p-7941-chapter-2-rebol-words-1"></a>Chapter 2: REBOL Words</h1>
<h3><a name="p-7941-about-words-2" class="anchor" href="https://forum.rebol.info#p-7941-about-words-2"></a>About Words</h3>
<p>As you can see, many <em><strong>values</strong></em> can be expressed directly in REBOL. Numbers, times, dates, strings, files and several other types of values were described. These are the primary building blocks of content.</p>
<p>In human and computer languages we use <em><strong>words as symbols</strong></em> . By combining a small set of fundamental symbols (the letters of an alphabet), we can create an endless variety of new words, hence new symbols. Some countries use different alphabets (or even pictograms or icons); nevertheless, the concept is the same. Letters are grouped into words which symbolize our thoughts. They represent meaning.</p>
<p>In REBOL, too, words serve as symbols, and they are created in the same way: by combining letters (<em>characters</em> ). For example,</p>
<pre><code>copy test! WHAT? File-Name A300 space&amp;time
</code></pre>
<p>REBOL does not distinguish between upper and lower case spelling of words (the language is intended for users, not just technicians). <strong>RED</strong> , <strong>red</strong> , and <strong>Red</strong> all refer to the same word.</p>
<p>Words can be of any length, but they can not extend past the end of a line. They may contain alphabetic characters, numbers, and any of the characters:</p>
<pre><code>? ! . ' + - * &amp; | = _ ~
</code></pre>
<p>Words cannot begin with a number, nor should they contain:</p>
<pre><code>, @ % ^ / \ # $ Â£
</code></pre>
<p><em><strong>A space is normally used to end a word</strong></em> , but other types of punctuation also indicate the end of a word (the primary REBOL delimiters):</p>
<pre><code>[ ] ( ) { } " : ;
</code></pre>
<p><em>Note: The current version of REBOL supports the standard 256 extended character set. International 16 bit character sets will be supported in later releases.</em></p>
<p>Refer to the <strong><a>Expertâ€™s Guide</a></strong> for complete descriptions and examples of REBOL words.</p>
<h3><a name="p-7941-using-words-3" class="anchor" href="https://forum.rebol.info#p-7941-using-words-3"></a>Using Words</h3>
<p>In REBOL, simple punctuation is used to indicate how a word is being used:</p>
<div class="md-table">
<table>
<thead>
<tr>
<th>syntax</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>word:</code></td>
<td>Define a word. Give it a value.</td>
</tr>
<tr>
<td><code>word</code></td>
<td>Evaluate a word. If it is data, get the value. If it is a function, apply it.</td>
</tr>
<tr>
<td><code>'word</code></td>
<td>Refer to the word as a symbol. It is <em>literally</em> a value.</td>
</tr>
<tr>
<td><code>:word</code></td>
<td>Get a wordâ€™s value, but donâ€™t apply it. Useful for referring to functions without evaluating them.</td>
</tr>
</tbody>
</table>
</div><p>The first of these <em><strong>defines</strong></em> or <em><strong>sets</strong></em> the word to associate it with a new value. In REBOL, words are defined in this fashion:</p>
<pre><code>age: 72
lunch-time: 12:32
birthday: 20/3/97
town: "Ukiah"
test: %testfile.rebol
</code></pre>
<p>Notice that you can define a word to be any kind of value. For instance, in the example above you defined words to be <strong>integer, time, date, string,</strong> and <strong>file</strong> values. You can also define words to be more complex types of values:</p>
<pre><code>people: ["Dale" "RJ" "Sam"]
code: [if age &gt; 32 [print town]]
say: make function! [item] [print item]
</code></pre>
<p>These words are often called <strong>variables</strong> . However, as you will see, the concept of a word is more general than just that of variables.</p>
<p>To <em><strong>get</strong></em> the value of a word that was previously defined, place the colon at the front of the word. Here are the results if you typed these lines into REBOL:</p>
<pre><code>&gt;&gt; print :age
== 72

&gt;&gt; if :lunch-time &gt; 12:00 [print "hungry"]
== hungry

&gt;&gt; print length? :people
== 3
</code></pre>
<p>This is the most reliable way to get a word's value, but it is rarely done. The most common way to get the value of a word is to <em><strong>evaluate</strong></em> it (execute it or get its value). Because this is done so often, it is also referred to in REBOL as the <em><strong>natural value</strong></em> of a word. For instance, the examples above could be rewritten without the colons (:).</p>
<p>So what is the difference between getting a word's value and evaluating it? For simple values, there is no difference. Both produce the same result. However, for more complex datatypes such as functions, there is a big difference. One way refers to the value (function or object) and the other executes it. For instance, the word for the REBOL function <strong>print</strong> is used both ways here:</p>
<pre><code>&gt;&gt; print "test"
== test

&gt;&gt; drucken: :print
&gt;&gt; drucken "test"
== test
</code></pre>
<p>The first use of <strong>print</strong> evaluates it, which causes the function to be evaluated, and the resulting value is printed. The second use of <strong>print</strong> gets its value (the function itself) and defines a new word with it. Because that word also refers to the same function, it will evaluate the same way.</p>
<p>The final way to use a word is as a <em><strong>literal</strong></em> . This is done when you want to refer to the word as a symbol; that is, you don't want its value nor do you want it to be evaluated. Any word can be used as a literal, regardless of whether it has a value or was never defined. Consider these:</p>
<pre><code>&gt;&gt; print 'print
== print

&gt;&gt; print 'stampa
== stampa

&gt;&gt; prt: 'print
&gt;&gt; print prt
== print
</code></pre>
<p>This concept is similar to what human languages do when referring to a word as "itself". It is distinguished with punctuation (quotes in English).</p>
<p>Literals are often used when getting or evaluating a word would not produce the desired result. In the code below we search a block for a the word <strong>title</strong> . If we do not refer to the word literally, then REBOL will search for whatever <em>value</em> <strong>title</strong> is currently defined to be, which may not produce the desired result.</p>
<pre><code>video: [
    title "Independence Day"
    length 2:25:24
    date 4/7/1996
]

&gt;&gt; print select video 'title
== Independence Day
</code></pre>
<p>If the literal quote was missing from <strong>title</strong> , then you would be using its natural value or an error would be displayed if it has no value.</p>
<h3><a name="p-7941-word-aliasing-4" class="anchor" href="https://forum.rebol.info#p-7941-word-aliasing-4"></a>Word Aliasing</h3>
<p>Words can have alternate spellings and different character casing while referring to the same word or variable. Within REBOL this operates in two ways: identical spelling and alternate spelling.</p>
<h4><a name="p-7941-identical-spelling-5" class="anchor" href="https://forum.rebol.info#p-7941-identical-spelling-5"></a>Identical Spelling</h4>
<p>When symbols are spelled the same way, but differ in character casing, they refer to the same word. For your convenience REBOL will keep track of the casing, even though the symbols are the same.</p>
<pre><code>&gt;&gt; words: [TITLE title]

&gt;&gt; print first words
== TITLE

&gt;&gt; print second words
== title

&gt;&gt; if (first words) = (second words) [print "They're the same"]
== They're the same
</code></pre>
<h4><a name="p-7941-alternate-spelling-6" class="anchor" href="https://forum.rebol.info#p-7941-alternate-spelling-6"></a>Alternate Spelling</h4>
<p>Alternate spellings can provide language localized words within REBOL. For instance, the Italian word "stampa" can be made an alias to the word "print". In REBOL, this operation makes the words equivalent, even though they are spelled differently.</p>
<p>The alias operation is performed at a low level so it will work for literal symbols as well as variables. Therefore, all aliases must be established prior to loading the files which use them. Aliases at the beginning of a file will not affect the remainder of the file.</p>
<p>The best way to initialize aliases is to create a file which is loaded from your user.r file. After that, all files will be able to use the aliased words. To create an alias, use the alias native, followed by the primary word, followed by the new name.</p>
<pre><code>alias 'print "stampa"
</code></pre>
<p>If you have a large list of words, you might prefer to construct a block of aliases:</p>
<pre><code>aliases: [
    print "intpray"
    load "oadlay"
    save "avesay"
    foreach "oreachfay"
]

foreach [word name] aliases [alias word name]
</code></pre>
<p><em>Caution: Word aliasing may cause confusion and be problematic in some cases</em></p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_3</link>
        <pubDate>Tue, 06 Oct 1998 04:22:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7941</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7940-chapter-1-rebol-values-1" class="anchor" href="https://forum.rebol.info#p-7940-chapter-1-rebol-values-1"></a>Chapter 1: REBOL Values</h1>
<h3><a name="p-7940-about-values-2" class="anchor" href="https://forum.rebol.info#p-7940-about-values-2"></a>About Values</h3>
<p>Values are what languages use to represent meaning. Values are information (data) you organize, transfer, and compute. Values are a key component in all REBOL programs.</p>
<p>This section summarizes the values (sometimes called constants or literals) that can be directly expressed in REBOL. They include integer, decimal, money, time, date, string, binary, email, file, url, and logic values as well as none. Refer to the <strong><a>Expertâ€™s Guide</a></strong> for complete descriptions and examples of all REBOL values.</p>
<p>As we communicate, we exchange meaning though a set of notations or values. We must be careful to express our thoughts in a form that the receiver understands. It makes no difference if the communication is between two people, a person and a computer, or two computers. Communication must have common values â€” otherwise the content is lost and the receiver gets a meaningless jumble of data.</p>
<p>In REBOL, most values are written in a common, natural form. Some values have alternate forms to allow for minor variations which are found in some countries. REBOL will accept any of the forms.</p>
<div class="md-table">
<table>
<thead>
<tr>
<th><strong>Value</strong></th>
<th><strong>Example Values as Written in REBOL</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>integer</strong></td>
<td>0 1234 -1234 +1234 1234567890 123â€™456â€™789</td>
</tr>
<tr>
<td><strong>decimal</strong></td>
<td>12.34 +12.34 -12.34 1. 123â€™456â€™789 12,34 -1, 0,0 1.23E4 -1.23E-4 +.1E2 1.E-2 1,23e4 -1,23e-4 1,e2 ,1e2 1,e-2 1e2 1E2</td>
</tr>
<tr>
<td><strong>time</strong></td>
<td>1:22 13:47:52 0:01.5 :5,25</td>
</tr>
<tr>
<td><strong>date</strong></td>
<td>30-Jan-1999 30-June-1957</td>
</tr>
<tr>
<td>30-1-1999 30-6-57 ;always D-M-Y</td>
<td></td>
</tr>
<tr>
<td>30/1/1999 30/6/57</td>
<td></td>
</tr>
<tr>
<td>1999-1-30</td>
<td></td>
</tr>
<tr>
<td><strong>money</strong></td>
<td>$1234.85 $120â€™345 US$12.49 DKM$100â€™200â€™305,65</td>
</tr>
<tr>
<td><strong>string</strong></td>
<td>"This string is only on a single line."</td>
</tr>
<tr>
<td>{ This string spans more than one line</td>
<td></td>
</tr>
<tr>
<td>and also allows "quoted" strings. }</td>
<td></td>
</tr>
<tr>
<td><strong>binary</strong></td>
<td>#{3A18427F 899AEFD8}</td>
</tr>
<tr>
<td>64#{LmNvbSA8yw9CB0aGvXmgUkVCu2Uz93}</td>
<td></td>
</tr>
<tr>
<td><strong>email</strong></td>
<td><a href="mailto:info@rebol.com">info@rebol.com</a></td>
</tr>
<tr>
<td><a href="mailto:president@oval.whitehouse.gov">president@oval.whitehouse.gov</a></td>
<td></td>
</tr>
<tr>
<td><strong>file</strong></td>
<td>%memo.txt</td>
</tr>
<tr>
<td>%script.r</td>
<td></td>
</tr>
<tr>
<td>%System:Prefs/date</td>
<td></td>
</tr>
<tr>
<td><strong>url</strong></td>
<td><a href="http://WWW.REBOL.COM">http://WWW.REBOL.COM</a></td>
</tr>
<tr>
<td><a>ftp://ftp.luth.se/docs/amiga.txt</a></td>
<td></td>
</tr>
<tr>
<td>file://zen/prefs/date</td>
<td></td>
</tr>
<tr>
<td><a href="mailto:info@REBOL.com">mailto:info@REBOL.com</a></td>
<td></td>
</tr>
<tr>
<td><strong>issue</strong></td>
<td><span class="hashtag-raw">#707-467-8000</span> ;telephone number</td>
</tr>
<tr>
<td><span class="hashtag-raw">#1234-5678-9012</span> 12/99 ; credit card number</td>
<td></td>
</tr>
<tr>
<td><span class="hashtag-raw">#0987654321-09876</span> ;serial number</td>
<td></td>
</tr>
<tr>
<td><strong>tuple</strong></td>
<td>1.2.0 (version number)</td>
</tr>
<tr>
<td>199.4.80.1 (network address)</td>
<td></td>
</tr>
<tr>
<td>255.255.127 (RGB color)</td>
<td></td>
</tr>
<tr>
<td><strong>logic</strong></td>
<td>true false on (same as true) off (same as false)</td>
</tr>
<tr>
<td><strong>none</strong></td>
<td>none</td>
</tr>
</tbody>
</table>
</div><h3><a name="p-7940-using-values-3" class="anchor" href="https://forum.rebol.info#p-7940-using-values-3"></a>Using Values</h3>
<p>Within a computer language, the types of fundamental values as summarized above are called its <em>primitive datatypes.</em> Programs are created by combining these datatypes in an endless variety to form more complex data.</p>
<p>The list summarizes the datatypes that can be <strong>directly represented</strong> in the REBOL language, but there are also several other datatypes. <em>Functions</em> and <em>objects</em> , for example, are <strong>constructed during evaluation</strong> using blocks, not through a direct expression. They are <em>constructed datatypes</em> . For instance, the function created by:</p>
<pre><code>add2: func [num] [num + 2]
</code></pre>
<p>does not exist until this line of REBOL script has been evaluated. Before that, this line is only a sequence of values.</p>
<p><em><strong>An entire REBOL script is just a set of values, which when evaluated, produce new values. And evaluation is simply a way of getting a value.</strong></em> This may seem trivially simple, but it is vitally important to understanding the simplicity of REBOL.</p>
<p>Letâ€™s now take a closer look at how to use each of the primitive values.</p>
<h4><a name="p-7940-integer-values-4" class="anchor" href="https://forum.rebol.info#p-7940-integer-values-4"></a>Integer Values</h4>
<p>Integer (also known as whole number) values are represented in as a sequence of numeric digits. No commas or periods are allowed. A minus sign can be used to indicate negative numbers.</p>
<pre><code>0 1 1234 123456789
-1 -1234 -123456789
</code></pre>
<p>Note that there should be <strong>no space</strong> between the minus and the first digit.</p>
<p>Long number cannot be broken up by using commas, because a comma indicates a decimal point in many countries. The same is true with periods. However, REBOL does permit single quotes to separate long integers. The quotes may appear anywhere after the first number.</p>
<pre><code>2'147'483'647
</code></pre>
<h4><a name="p-7940-decimal-values-5" class="anchor" href="https://forum.rebol.info#p-7940-decimal-values-5"></a>Decimal Values</h4>
<p>Decimal values are represented as a sequence of numeric digits, followed by a fraction separator, followed by more digits. The separator may be either a period or a comma.</p>
<pre><code>1.23 123. .321 1234.5678
1,23 123, ,321 1234,5678
</code></pre>
<p>Extra spaces, commas, and periods are not allowed in numbers to designate groups of thousands. Doing so could result in translation errors, evaluation errors, or misinterpretation of a value's datatype. However, REBOL does permit single quotes to separate long integers. The quotes may appear anywhere after the first number.</p>
<pre><code>100'234'562.3782
100'234'562,3782
</code></pre>
<p>Negative decimal values are preceded by a minus sign. Note that there should be no space between the minus and the first digit.</p>
<pre><code>-1.23 -123. -.123 -1234.5678
-1,23 -123, -,123 -1234,5678
</code></pre>
<p>Decimals can also be expressed in scientific notation format, by appending an exponent designated by the letter E or e. The exponent may be positive or negative.</p>
<pre><code>1.23E10 1.2e7 -56.72E3 -.34e-12
1,23E10 1,2e7 -56,72E3 -.34e-12
</code></pre>
<h4><a name="p-7940-time-values-6" class="anchor" href="https://forum.rebol.info#p-7940-time-values-6"></a>Time Values</h4>
<p>A time period (duration) or a time of day is expressed as a numeric digits separated with colons (:). Hours, minutes, and seconds can be written:</p>
<pre><code>10:30 0:00 18:59 23:59:50 8:6:2
</code></pre>
<p>Notice that the last case does not require leading zeros for minutes and seconds. They are optional.</p>
<p>The minutes and seconds fields can contain values greater than <strong>60</strong> . When this is done, the values will be converted automatically. For instance <strong>0:120:00</strong> is the same as <strong>2:00:00</strong> .</p>
<p>Times may be followed by AM or PM with no space in between.</p>
<pre><code>10:20PM 3:32:20AM
</code></pre>
<p>Sometimes, a more precise time is needed, so a fractional second can be appended. As with decimal numbers, either a period or a comma is acceptable:</p>
<pre><code>2:59:29.5 0:00:08.25
2:59:29,5 0:00:08,25
</code></pre>
<p>This last example deserves further attention. There will often be cases when a time period is shorter than a few minutes. These can be abbreviated when the decimal point (the period or the comma) is present. For example:</p>
<pre><code>1:10.25 0:20,1 :10.82 :0,5 :325.2
</code></pre>
<p>Note that in the last case <strong>:325.2</strong> minutes is equivalent to <strong>5:25.2</strong> hours/minutes.</p>
<h4><a name="p-7940-date-values-7" class="anchor" href="https://forum.rebol.info#p-7940-date-values-7"></a>Date Values</h4>
<p>Around the world, dates are written in a variety of formats. Most countries use a <em><strong>day-month-year</strong></em> order. One of the few exceptions is the USA**,** which commonly uses a <em>month-day-year</em> format. If a date is written numerically, such as 2/1/1999, it is ambiguous. The month could be interpreted as either February (in the USA) or January (nearly everyone else). Some countries use dashes (-), some use slashes (/), and others use periods (.) as separators. Finally, computer people often prefer dates in the <em>year-month-day</em> format so they can be easily sorted.</p>
<p>REBOL is flexible, allowing dates to be expressed in a variety of formats. The first day of March would be valid in any of the following common international formats:</p>
<pre><code>1/3/1999
1-3-1999
1999-3-1
1.3.1999 ; see the following note
</code></pre>
<p><em>Note: The last format requires that the year always be expressed in full (four digits). Abbreviating the year will cause the date to be interpreted as a tuple which could cause problems in comparison and sorting operations.</em></p>
<p>To accommodate the USA, the following additional forms are permitted:</p>
<pre><code>1/Mar/1999 1/March/1999
1-Mar-1999 1-March-1999
</code></pre>
<p>It is best to write the year in full. Otherwise, problems will occur with date comparison and sorting operations. Therefore, shortened years (e.g. 99 for 1999) can be used, but their interpretation is relative to the current year. They will span forward and backward a half century from the current year.</p>
<pre><code>28-2-66 ; refers to 1966
12-Mar-20 ; refers to 2020
14-8-46 ; refers to 2046, not 1946
</code></pre>
<p>To represent dates in the first century (which is rarely done because the Gregorian calendar did not exist), you must use leading zeros as in 09-04-0029).</p>
<p>There can be no spaces within the date. For instance: <strong>10 - 5 - 99</strong> would be subtraction between three numbers, not evaluated as a date.</p>
<h4><a name="p-7940-money-values-8" class="anchor" href="https://forum.rebol.info#p-7940-money-values-8"></a>Money Values</h4>
<p>Money values are represented by a currency designator, followed by a $, then numbers. The default currency is U.S. Dollars ($). Numbers are formed in the same format as decimals.</p>
<pre><code>$1234.85
$120â€™345
USD$12.49
DKM$100â€™200â€™305,65
</code></pre>
<p>To prevent errors, be careful when performing mathematical operations between multiple currencies.</p>
<h4><a name="p-7940-string-values-9" class="anchor" href="https://forum.rebol.info#p-7940-string-values-9"></a>String Values</h4>
<p>String values are written as a sequence of characters surrounded by quotes or braces. A <strong><em>quoted</em> string</strong> is restricted to a single line. It may not extend past the end of a line and must not contain unprintable characters.</p>
<pre><code>"This is a short string of characters."
</code></pre>
<p><strong><em>Braced</em> strings</strong> are used for larger sections of text that span multiple lines. All of the characters of the string, including spaces, tabs, quotes, and linefeeds (but not the braces) are part of the string.</p>
<pre><code>{This is a long string of text which will not easily fit
on a single line of source. These are often used for
documentation purposes.}
</code></pre>
<p>Within the string, braces are counted, so a string can include other braces as long as the number of closing braces matches the number of opening braces.</p>
<p>Special characters and operations can be encoded into a string by flagging them with the escape character "^". This character is used rather than the backslash ("") because it avoids conflicts with file paths, which on the PC use a backslash. Special escape-sequence characters include:</p>
<div class="md-table">
<table>
<thead>
<tr>
<th>escape</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^"</code></td>
<td>inserts a "</td>
</tr>
<tr>
<td><code>^}</code></td>
<td>inserts a }</td>
</tr>
<tr>
<td><code>^^</code></td>
<td>inserts a ^</td>
</tr>
<tr>
<td><code>^/</code></td>
<td>starts a new line</td>
</tr>
<tr>
<td><code>^(line)</code></td>
<td>starts a new line</td>
</tr>
<tr>
<td><code>^-</code></td>
<td>inserts a tab</td>
</tr>
<tr>
<td><code>^(tab)</code></td>
<td>inserts a tab</td>
</tr>
<tr>
<td><code>^(page)</code></td>
<td>new page</td>
</tr>
<tr>
<td><code>^C</code></td>
<td>inserts control-C</td>
</tr>
<tr>
<td><code>^[words...]</code></td>
<td>executes a REBOL block</td>
</tr>
</tbody>
</table>
</div><h4><a name="p-7940-binary-values-10" class="anchor" href="https://forum.rebol.info#p-7940-binary-values-10"></a>Binary Values</h4>
<p>Binary data sequences (binary strings) are written as a hash (#) followed by a braced string. The characters within the string are encoded in one of several formats as specified by an optional number prior to the hash. Formats include hex (16), octal (8), binary (2), and base-64 (64). Hex is the default.</p>
<p>Spaces, tabs, linefeeds, and comments within the string are permitted, allowing the data to be formatted in the most convenient manner.</p>
<pre><code>#{3A 18 92 56}
#{3A18427F 899AEFD8}
2#{1001011011001010100101101100101101}
64#{LmNvbSA8yw9CB0aGvXmgUkVCu2Uz93}
</code></pre>
<p>Strings which are missing the proper number of characters are padded on the right.</p>
<h4><a name="p-7940-email-values-11" class="anchor" href="https://forum.rebol.info#p-7940-email-values-11"></a>Email Values</h4>
<p>The standard form of an email address is a name, followed by an @, followed by the domain. The email address may be of any length, but must not include any of the REBOL restricted characters (brackets, quotes, braces, spaces, linefeeds, etc.). These formats are acceptable:</p>
<pre><code>info@REBOL.COM
123@number-mail.org
my-name.here@an.example-domain.com
</code></pre>
<p>Upper and lower casing will be preserved.</p>
<p>Before you can send email from REBOL, you must specify the server you'll be using as well as your email address. Make sure this data is in your user.r file:</p>
<pre><code>REBOL/email-port/host: "mail.yourserver.com"
REBOL/email-head/from: yourname@domain.com
</code></pre>
<p>The host can also be a TCP/IP network address such as:</p>
<pre><code>REBOL/email-port/host: "10.20.30.40"
</code></pre>
<p>Sending email with REBOL is as easy as:</p>
<pre><code>send dem@domain.dom {
    Hello there!
    Yes, I'm still here! Email me when you can!
    Carl
}
</code></pre>
<p>or</p>
<pre><code>send dem@domain.dom read %letter.txt
</code></pre>
<p>More information on the email datatype is included in <strong>Chapter 4 - REBOL Evaluation</strong> .</p>
<h4><a name="p-7940-file-values-12" class="anchor" href="https://forum.rebol.info#p-7940-file-values-12"></a>File Values</h4>
<p>REBOL files are designated with a % followed by a sequence of characters:</p>
<pre><code>load %image.jpg
prog: load %examples.r
save %this-file.txt "This file is empty."
files: load %../programs/
</code></pre>
<p>Unusual characters in file names must be encoded with a % hex number. A file name with a space (hex 20) would look like:</p>
<pre><code>%cool%20movie%20clip
</code></pre>
<p>Even though this is an Internet convention, it isn't very friendly, so another form is to enclose the filename in quotes.</p>
<pre><code>%"cool movie clip"
</code></pre>
<p>REBOL converts the file name to the proper encoded format and does not include the quotes.</p>
<p>The standard, acceptable character for <em><strong>separating directories in a path is the forward slash (/)</strong></em> , not the backslash (). (The backslash was the "creative" contribution of Microsoft in 1982 and has confounded millions of people ever since.) However, because there are millions of people who were innocently led the wrong direction, REBOL automatically converts backslashes found in file names to forward slashes.</p>
<p>The natives <strong>load</strong> , <strong>save</strong> , and <strong>do</strong> will be discussed in <strong>Chapter 4 - REBOL Evaluation</strong> .</p>
<h4><a name="p-7940-url-values-13" class="anchor" href="https://forum.rebol.info#p-7940-url-values-13"></a>URL Values</h4>
<p>The word URL stands for <em>Uniform Resource Locators</em> , an Internet standard used to access resources such as web-pages, images, files, and mail across the network. The best known URL is for web locations (<a href="http://www.rebol.com">http://www.rebol.com</a>).</p>
<p>The first part of a URL indicates its communications protocol, called a <em>scheme</em> . REBOL supports the most common schemes: web pages (<strong>http:</strong> ), file transfer (<strong>ftp:</strong> ), email (<strong>mailto:</strong> ), and files (<strong>file:</strong> ). This is followed by characters that are dependent on which scheme is being used. REBOL knows about:</p>
<pre><code>http://host/path/file
ftp://user:pass@host/path/file
mailto:name@domain
file://host/path/file
</code></pre>
<p>Some fields are optional. For instance, the host can also be followed by a port number, if it differs from the default. An ftp URL will supply a default password if one is not specified.</p>
<p>Characters in a URL must conform to specified standards. Restricted characters must be encoded in hex by preceding them with the escape character %.</p>
<h4><a name="p-7940-issue-values-14" class="anchor" href="https://forum.rebol.info#p-7940-issue-values-14"></a>Issue Values</h4>
<p>An issue is a series of characters used to represent telephone numbers, model numbers, serial numbers, and other number groups. Issues start with a hash (#) and continue until the first delimiting character (such as a space) is reached.</p>
<pre><code>#707-467-8000
#1234-5678-9012 12/99
#0987654321-09876
</code></pre>
<p>Values that are irregularly formatted (contain delimiting characters) should be written as strings rather than issues.</p>
<h4><a name="p-7940-tuple-values-15" class="anchor" href="https://forum.rebol.info#p-7940-tuple-values-15"></a>Tuple Values</h4>
<p>It is common to represent version numbers, Internet addresses, and RGB color values as a sequence of three or four integers. In REBOL, these are called <em>tuples</em> (as in <em>quintuple</em> ) and are represented as a set of integers separated by periods.</p>
<pre><code>1.3.0 2.1.120 1.0.2.32 ; version
199.4.80.250 255.255.255.0 ; net addresses/masks
0.80.255 200.200.60 ; RGB colors
</code></pre>
<p>Each integer field of a tuple may range between 0 and 255. Negative integers will produce an error.</p>
<p>Notice that you can specify three or four integers within a tuple. If only three are given, then the last integer is assumed to be zero. In the case where only two integers are given, you must still have at least two periods, otherwise the value will be treated as a decimal.</p>
<pre><code>1.2. = 1.2.0.0
1.2.3 = 1.2.3.0
</code></pre>
<p>In some countries, the tuple value format is used for dates. <strong>This must be done with great care, because dates are a separate datatype.</strong></p>
<pre><code>8.6.99 is a tuple
18.6.1999 is a date
</code></pre>
<h4><a name="p-7940-logic-values-16" class="anchor" href="https://forum.rebol.info#p-7940-logic-values-16"></a>Logic Values</h4>
<p>A datatype containing two states which represent TRUE and FALSE. They are most frequently returned from comparison functions.</p>
<p>The following <em>words</em> are predefined to hold both logic values:</p>
<pre><code>true
false

on (same as true)
off (same as false)
</code></pre>
<p>Note that <strong>false</strong> is not equivalent to <strong>integer</strong> <strong>zero</strong> or <strong>none</strong> . The intrinsic functions of <strong>logic</strong> are:</p>
<div class="md-table">
<table>
<thead>
<tr>
<th>word</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>logic!</td>
<td>prototypical logic</td>
</tr>
<tr>
<td>logic?</td>
<td>return true</td>
</tr>
<tr>
<td>number?</td>
<td>return false</td>
</tr>
<tr>
<td>make</td>
<td>create an instance of the datatype</td>
</tr>
<tr>
<td>form</td>
<td>format datatype into a string</td>
</tr>
<tr>
<td>mold</td>
<td>mold datatype into a string</td>
</tr>
<tr>
<td>=</td>
<td>equal</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>not equal</td>
</tr>
<tr>
<td>&lt;</td>
<td>purposeful error (see below)</td>
</tr>
<tr>
<td>&lt;=</td>
<td>purposeful error</td>
</tr>
<tr>
<td>&gt;</td>
<td>purposeful error</td>
</tr>
<tr>
<td>&gt;=</td>
<td>purposeful error</td>
</tr>
<tr>
<td>==</td>
<td>equal</td>
</tr>
<tr>
<td>=?</td>
<td>same</td>
</tr>
<tr>
<td>min</td>
<td>purposeful error</td>
</tr>
<tr>
<td>max</td>
<td>purposeful error</td>
</tr>
<tr>
<td>not</td>
<td>complement</td>
</tr>
<tr>
<td>and</td>
<td>and</td>
</tr>
<tr>
<td>or</td>
<td>or</td>
</tr>
<tr>
<td>xor</td>
<td>xor</td>
</tr>
<tr>
<td>random</td>
<td>return random logic</td>
</tr>
<tr>
<td></td>
<td><strong>/seed</strong> set random integer seed</td>
</tr>
<tr>
<td>~</td>
<td>complement</td>
</tr>
</tbody>
</table>
</div><p>A "purposeful error" raises an error in the same manner as an unsupported datatype function. The alternate behavior of the function was considered but discarded for usability reasons (i.e. might create more user problems then help).</p>
<h4><a name="p-7940-none-17" class="anchor" href="https://forum.rebol.info#p-7940-none-17"></a>None</h4>
<p><strong>None</strong> is a datatype containing a single value which represents the state of "no value".</p>
<p>The word <strong>none</strong> is predefined to hold the none value. The value may also be returned from various functions, primarily those involving series (<strong>pick</strong> , <strong>find</strong> , etc.).</p>
<p>Note that none is not equivalent to <strong>integer</strong> <strong>zero</strong> or <strong>false</strong> . The intrinsic functions of <strong>none</strong> are:</p>
<div class="md-table">
<table>
<thead>
<tr>
<th>word</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>none!</td>
<td>prototypical none</td>
</tr>
<tr>
<td>none?</td>
<td>return true</td>
</tr>
<tr>
<td>number?</td>
<td>return false</td>
</tr>
<tr>
<td>make</td>
<td>create an instance of the datatype</td>
</tr>
<tr>
<td>form</td>
<td>format datatype into a string</td>
</tr>
<tr>
<td>mold</td>
<td>mold datatype into a string</td>
</tr>
<tr>
<td>=</td>
<td>equal</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>not equal</td>
</tr>
<tr>
<td>==</td>
<td>equal</td>
</tr>
<tr>
<td>=?</td>
<td>same</td>
</tr>
</tbody>
</table>
</div><p>None is also discussed in <strong>Chapter 3 - REBOL Series</strong> in the section titled <strong>Dealing with None</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_2</link>
        <pubDate>Tue, 06 Oct 1998 04:14:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7940</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p>Discovered at FTP cache: <a href="https://grumbeer.dyndns.org/ftp/www.ibiblio.org/distributions/redhat-5.1/apps-i386/REBOL/">https://grumbeer.dyndns.org/ftp/www.ibiblio.org/</a></p>
<p><em>README.txt says Rebol 1.0.2 was released 6-October-1998</em></p>
<p>See also:</p>
<ul>
<li>
<p><a href="https://forum.rebol.info/t/rebol-1-0-retrospective/1788">Discussion Thread: <strong>Rebol 1.0 Retrospective</strong></a></p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/rebol-1-0-2-quick-start-guide/2341"><strong>Rebol 1.0.2 Quick Start Guide</strong></a></p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344"><strong>The %rebol.r Boot File From Rebol 1.0</strong></a></p>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>Copyright (c)1998 REBOL Technologies. All Rights Reserved.</strong></p>
</blockquote>
<hr>
<h1><a name="p-7939-about-this-guide-1" class="anchor" href="https://forum.rebol.info#p-7939-about-this-guide-1"></a>About This Guide</h1>
<p>This guide is a comprehensive tutorial on how to use REBOL messaging language. REBOL is a user-friendly language and you will soon be writing powerful programs.</p>
<p>This guide includes information about REBOL, writing and running REBOL scripts, and common applications. It then explains the concepts of REBOL values, words, series, evaluation, and context.</p>
<p>Finally, this guide includes useful tips on troubleshooting REBOL scripts.</p>
<p>This guide assumes minimal prior knowledge of computer languages. If needed, read the <strong><a>Quick Start Guide</a></strong> as an introduction to this guide. The <strong><a>Expertâ€™s Guide</a></strong> is a dictionary of REBOL words for your reference. Or, from within REBOL, you can type help followed by the word (<strong><code>help print</code></strong>) to get a description on the display screen.</p>
<h3><a name="p-7939-rebol-history-2" class="anchor" href="https://forum.rebol.info#p-7939-rebol-history-2"></a>REBOL History</h3>
<p>Carl Sassenrath, developer of the Amiga multitasking operating system and other computer tools, has had a vision for more than twenty years. He envisioned a simpler computer language that was also powerful. In addition, he wanted it to work equally well on and pass data between all major operating systems.</p>
<p>Carlâ€™s vision has become a reality in REBOL. Carl, with the help of many other rebellious computer programming and support people, has produced a dynamic messaging language that is simple to learn and use, yet vastly powerful.</p>
<p>People and computers can now freely communicate.</p>
<h3><a name="p-7939-about-rebol-3" class="anchor" href="https://forum.rebol.info#p-7939-about-rebol-3"></a>About REBOL</h3>
<p>REBOL (pronounced REB-ul) is an acronym for <em>relative expression-based object language</em> . REBOL is a messaging language that evaluates <strong>expressions</strong> and returns values. REBOL expressions consist of <strong>words</strong>:</p>
<pre><code>show next computer-name date? today
</code></pre>
<p>and <strong>values</strong> (numbers, times, dates, strings, email addresses, URLs, etc.):</p>
<pre><code>1234 12:45 30-Sep-1998 reb@rebol.com
</code></pre>
<p>grouped into <strong>blocks</strong> :</p>
<pre><code>[sheriff "Bob" 34 bob@prairie.west tough-guy]

if time &gt; 4:00 [send friends "time to REBOL"]
</code></pre>
<p>You can write any combination of words and values into an expression â€” the format is totally up to you, as long as there is a space or other delimiter separating each one.</p>
<p>REBOL gives you the power to define a <strong>series</strong> :</p>
<pre><code>colors: ["red" "green" "blue" "yellow" "orange"]
</code></pre>
<p>then <strong>evaluate</strong> an expression and return a value:</p>
<pre><code>&gt;&gt; print third colors
== blue
</code></pre>
<p><em><strong>In REBOL, everything is a value</strong></em> . The type of value is called the <strong>datatype</strong> . REBOL datatypes are <em>primitive</em> (numbers, date, time, words, files, email) or <em>constructed</em> (built from primitive datatypes). <strong>Functions</strong> and <strong>objects</strong> are constructed datatypes.</p>
<p>A REBOL word gets its meaning from the context in which it is used. For instance, the word time in the above example might be used for different things in various parts of a REBOL script.</p>
<p>Each of these concepts will be developed in this guide with examples.</p>
<h4><a name="p-7939-writing-a-script-4" class="anchor" href="https://forum.rebol.info#p-7939-writing-a-script-4"></a>Writing a Script</h4>
<p>REBOL scripts are written and exchanged as text files, allowing them to be created and modified with any text editor. The script begins with the word REBOL followed by a header block which provides information about the script. The header has many uses for documentation, archiving, revision tracking, script requirements, or other purposes. Hereâ€™s a typical header:</p>
<pre><code>REBOL [
    Title: "Query a Few Friends"
    Author: "Robert Rebol"
    Date: 30-Sep-1998
]
</code></pre>
<p>Text which appears before the header block is ignored. Text appearing after the header is the script itself.</p>
<h4><a name="p-7939-running-a-script-5" class="anchor" href="https://forum.rebol.info#p-7939-running-a-script-5"></a>Running a Script</h4>
<p>Refer to the <strong><a>Quick Start Guide</a></strong> for instructions on how to install REBOL.</p>
<p>To evaluate (execute) a REBOL script and see the results, you have two choices. First, you can start REBOL and type at the &gt;&gt; prompt:</p>
<pre><code>do %filename.r
</code></pre>
<p>The file will be loaded and evaluated. (The % tells REBOL that the value is a file name rather than a word, function, or something else.)</p>
<p>Second option: you can specify a script from the shell or GUI (if your computer platform supports it):</p>
<pre><code>rebol filename.r
</code></pre>
<p>This immediately starts REBOL running with the script.</p>
<p><em>Note: Make sure you run the script from the directory in which rebol.exe was installed.</em></p>
<h3><a name="p-7939-rebol-applications-6" class="anchor" href="https://forum.rebol.info#p-7939-rebol-applications-6"></a>REBOL Applications</h3>
<p>REBOL messaging language can be used to perform a wide variety of tasks on your computer including:</p>
<ul>
<li>
<p>building and managing data (lists, inventory, scheduling, addresses, contacts)</p>
</li>
<li>
<p>transferring data (email, file transfer, file backup)</p>
</li>
<li>
<p>math calculations (checkbook, business statements, trigonometry)</p>
</li>
<li>
<p>sharing data with other computer systems (REBOL files can be read by most operating systems with no conversion)</p>
</li>
<li>
<p>much more â€” REBOL is both a simple and a powerful messaging language.</p>
</li>
</ul> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_1</link>
        <pubDate>Tue, 06 Oct 1998 04:00:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7939</guid>
      </item>
      <item>
        <title>REBOL 1.0 Retrospective</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1788">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/48.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>Will it be possible to share the manual/guide/documentation for REBOL 1 here? It is a piece of history, and it'll be a shame if it just disappears.</p>
</blockquote>
</aside>
<p>Here in 2024, I found <strong><a href="https://grumbeer.dyndns.org/ftp/www.ibiblio.org/distributions/redhat-5.1/apps-i386/REBOL/">a download of Rebol 1.0.2</a></strong>, which I could extract with the following commands on a modern Debian Linux:</p>
<pre><code>$ sudo apt install rpm2cpio

$ rpm2cpio rebol-1.0.4-2.i386.rpm | cpio -idmv
</code></pre>
<p>I can't get it to run at the moment, but there's HTML files in the archive.  Because there's already a sunk cost to backing up the forum, I did some ad-hoc conversion of the HTML to MarkDown and put the Guides up here:</p>
<ul>
<li>
<p><strong><a href="https://forum.rebol.info/t/rebol-1-0-2-quick-start-guide/2341">Rebol 1.0.2 Quick Start Guide</a></strong></p>
</li>
<li>
<p><strong><a href="https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340">Rebol 1.0.2 User's Guide</a></strong></p>
</li>
</ul>
<p>And here's a little bit of analysis of what code we do have:</p>
<ul>
<li><a href="https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344"><strong>The %rebol.r Boot File From Rebol 1.0</strong></a></li>
</ul>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1788">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/48.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>I was reading about some of the design choices in REBOL, and came upon Joe Marshall's writings where he talks about the changes between REBOL 1 and 2 (missing continuations, changed scoping rules, absence of tail recursion, etc.)</p>
</blockquote>
</aside>
<p>Note that I have written some about this here:</p>
<ul>
<li>
<p><strong><a href="https://forum.rebol.info/t/joe-marshall-on-rebol-binding/2074">Joe Marshall on Rebol Binding</a></strong></p>
</li>
<li>
<p><strong><a href="https://forum.rebol.info/t/the-sherman-rebol-to-scheme-compiler/2076">The Sherman Rebol-To-Scheme Compiler</a></strong></p>
</li>
</ul>
<h1><a name="p-7938-quick-impressions-1" class="anchor" href="https://forum.rebol.info#p-7938-quick-impressions-1"></a>Quick Impressions</h1>
<p>Usage-wise, Rebol1 looks closer to Rebol2 than I expected.  I imagined it being weirder...partially because it had vanished and had something of a lore from Joe saying how different Rebol2 was.  But at least from the user's perspective, it looks quite close.</p>
<p>Cynically I'd say: it kind of looks like design of the Rebol language (not counting Ren-C) froze/peaked 26 years ago.  The enduring subsequent work seems to be PARSE and VID, vs. the interpreter itself.</p>
<p>Not a whole lot of surprises, but I'll write a few thoughts.</p>
<ul>
<li>
<p>Biggest observation: it seems like Joe saw functions as the building blocks of most things, including binding.  Remember that Rebol2 trick where COLLECT received a BLOCK!, and inside that block it wanted any references to KEEP to refer to its function that would append to the collected block...so it just said something along the lines of:</p>
<pre><code>keeper: func [item] [append collected item]
do (func [keep] body) :keeper  ; KEEPER becomes KEEP parameter to BODY
</code></pre>
<p>It seems like this is how Rebol1 modeled binding, generally.</p>
<p>That might feel clever, but when the cost of binding is to sequester your structural data away into a black box of a function...then you've lost the currency of the parts that comprise the lists.  The value proposition of Rebol falls off quickly if your solution is made by isolating everything into information-hiding functional parts.  If anything, it's reliant on <em>information-showing</em> and maximizing the value of that.</p>
<p>I can get why Carl wanted to move away from something that was more lambda calculus than it was LEGO.  An alternate way of thinking is needed--in particular regarding binding--but just not a patently naive approach, which is what happened.</p>
</li>
<li>
<p>There don't appear to be any datatype specs in Rebol 1.0.  All arguments accept all types, it seems...and any type checking has to be done inside your function.  That's pretty rough (though it was quite the struggle to <a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">break free of the 64-type limit</a> with a solution that performed at all well).</p>
</li>
<li>
<p>We know that MAKE used to have variable arity, e.g. <strong><code>make function! [spec] [body]</code></strong> vs. <strong><code>make object! [def]</code></strong>.  Rebol2 did something weird with <strong><code>make function! [[spec] [body]]</code></strong> while Ren-C just said <strong><a href="https://forum.rebol.info/t/debunking-the-arity-1-make/1591">"why not have an arity-2 FUNCTION native"</a></strong>?</p>
</li>
<li>
<p>It's strange to find out that the counterpart to NEXT was PAST instead of BACK <em>(though the documentation also mentions BACK, so perhaps they were synonyms?)</em>  The bigger question remains <a href="https://forum.rebol.info/t/de-verbification-noun-of-x-vs-noun-x/1368">whether these should be <strong>next of</strong> and <strong>back of</strong></a>, to let <strong><code>next</code></strong> and <strong><code>back</code></strong> be freed up for variable names.</p>
</li>
<li>
<p>Interesting to see the <strong><code>use [[vars] &lt;code&gt;]</code></strong> syntax instead of <strong><code>use [vars] [&lt;code&gt;]</code></strong>.  I've always been baffled by the lack of discussion of tradeoffs in dialect design--why you would make one choice vs. another...so changes like this are actually much more rare than one would think.</p>
</li>
<li>
<p>To me, it's good to see ELSE in Rebol 1.0... as <a href="https://forum.rebol.info/t/then-and-else-are-essential/1411">I think it's a comfortable and human thing</a> in terms of the rhythm of conditional logic.  The implementation was wrong, but Ren-C has solved that with a generalized evaluative pattern that isn't a "hack".  It's become kind of amusing to me that some devout Redbol people think ELSE is a sin, and everyone should love EITHER for all situations.  <img src="https://forum.rebol.info/images/emoji/twitter/clown_face.png?v=12" title=":clown_face:" class="emoji" alt=":clown_face:" loading="lazy" width="20" height="20"></p>
</li>
<li>
<p>The idea that you pass CATCH the WORD! you want to act as the "throw" is how Ren-C's definitional CATCH works (it defaults to THROW, but you can override it).  It's called a <strong>"continuation"</strong> but I wonder just how generic it is...can these continuations do weird stuff, like goto?</p>
<pre><code>goto: none
catch 'throw [goto: :throw]
print "Will this print twice?"
goto &lt;whatever&gt;
</code></pre>
<p>Ren-C's CATCH is not based on continuations--just throwing up the stack--so it won't do that.  You need to use <strong><a href="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311">GENERATOR and YIELD</a></strong> if you want to do continuations.</p>
</li>
</ul>
<p>Anyway... I may have a test or two to throw at it if someone gets it to run.  But I don't think there's anything particular for Ren-C to learn from it, things are... quite far along the road.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-retrospective/1788#post_5</link>
        <pubDate>Sun, 01 Dec 2024 07:14:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7938</guid>
      </item>
      <item>
        <title>The Probably-False Economy of EVAL Consuming FRAME!</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>The earliest design usages for FRAME! were for things like ENCLOSE.</p>
<p>ENCLOSE builds the frame for the function you're enclosing, then passes the frame to a function that can manipulate the frame, and invoke it with EVAL (or not invoke it at all, if it wishes).</p>
<p>Here's a sort of simple historical example:</p>
<pre><code>/foo: func [a b] [
   let result: a + b
   a: b: ~&lt;whatever&gt;~  ; functions can modify args/locals for any reason
   return result
]

/bar: enclose foo/ (lambda [f [frame!]] [
    let b: f.b
    f.a: f.a * 10
    (eval f) + b
])

&gt;&gt; bar 100 10
== 1020  ; ((a * 10) + b) + b
</code></pre>
<p>You'll notice above that I didn't write:</p>
<pre><code>/bar: enclose foo/ (lambda [f [frame!]] [
    f.a: f.a * 10
    (eval f) + f.b
])
</code></pre>
<p>This is because EVAL of a FRAME! would "consume" the frame, and trying to use <strong><code>f.b</code></strong> after the EVAL would raise an error.  In other words, memory was not allocated as it usually would be for a new frame to do the call...but the fields of the frame were the actual values being used.</p>
<p>I overwrote <strong><code>a</code></strong> and <strong><code>b</code></strong> to make the point that once that EVAL is called, you can't rely on any particular state of a frame's variables.  In the general case, they can be changed to anything.</p>
<h2><a name="p-7936-eval-copy-f-is-easy-and-so-is-saving-variables-right-1" class="anchor" href="https://forum.rebol.info#p-7936-eval-copy-f-is-easy-and-so-is-saving-variables-right-1"></a><code>(eval copy f)</code> is Easy, and So Is Saving Variables, Right?</h2>
<p>The premise I was going on was that it seemed like it would be wasteful...especially in scenarios like an ENCLOSE, to make another copy of the frame's data.</p>
<p>And I figured usually you wouldn't need to refer to anything from the frame's input state after you called it.</p>
<p>So you had two choices: either evaluate a copy of the frame, or save any variables you were interested in as locals.</p>
<h2><a name="p-7936-it-turns-out-to-be-incredibly-common-to-save-variables-2" class="anchor" href="https://forum.rebol.info#p-7936-it-turns-out-to-be-incredibly-common-to-save-variables-2"></a>It Turns Out To Be Incredibly Common To Save Variables</h2>
<p>I didn't know when originally trying to optimize the feature how often an ENCLOSE would need to talk about the input fields after an EVAL call.</p>
<p>But empirically I'd say you need the fields at least half the time.  You actually want it more often than that when you consider debugging--you often want to print some information about the input parameters after you've done the EVAL.</p>
<h2><a name="p-7936-let-b-fb-costs-much-more-than-mallocmemcpy-3" class="anchor" href="https://forum.rebol.info#p-7936-let-b-fb-costs-much-more-than-mallocmemcpy-3"></a><code>(let b: f.b)</code> Costs Much More Than <code>malloc()+memcpy()</code></h2>
<p>When you come down to it, relatively speaking: <em>Evaluator cycles are expensive</em>.  <em>Tuple lookup is expensive</em>.  <em>Assignment is expensive</em>.  <em>LET statements are expensive</em>.</p>
<p>That's because this is an interpreted language, and running code in the interpreter involves pushing and popping entities that represent interpreter stack levels.  There's all kinds of C data structures and layers of C function calls as the gears of the machinery turn...whether your operation be simple or complex.  That's just the name of the game... <strong>a + b</strong> in a generalized evaluator is going to be at least 100x more costly than adding two integers in C, which is basically just a single CPU instruction.</p>
<p>So if you have to do <em>any</em> mitigation of losing the frame data by adding interpreted code, not only are you having to junk up what you're writing...but you're also paying much more than you would have if the system had just gone ahead and made a copy.</p>
<h2><a name="p-7936-explaining-why-you-cant-is-lamer-than-it-just-works-4" class="anchor" href="https://forum.rebol.info#p-7936-explaining-why-you-cant-is-lamer-than-it-just-works-4"></a>Explaining Why You Can't Is Lamer Than <em>"It Just Works"</em></h2>
<p>People understand that if they have a FRAME! for APPEND and they EVAL it, that the series is going to be mutated.</p>
<p>But they're going to understand less that the series field of the frame is not available at all to them after the call.</p>
<p>It's kind of a no-brainer to say that if the two approaches were at all comparable in speed or overall performance, that the more useful behavior should be the default.</p>
<p><em>And I actually believe the more useful behavior is faster in the general case...by avoiding additional intepreter cycles to save frame fields in variables.</em></p>
<h2><a name="p-7936-free-f-could-use-free-as-an-intrinsic-if-you-want-5" class="anchor" href="https://forum.rebol.info#p-7936-free-f-could-use-free-as-an-intrinsic-if-you-want-5"></a><code>(free f)</code> Could Use FREE As An Intrinsic If You Want</h2>
<p><strong><a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">FREE could be trivially made Intrinsic</a>.</strong></p>
<p>If profiling suggested that something like an ENCLOSE on a function with a large frame was affecting your bottom line by not freeing the frame, you could just free it after the EVAL.  That would leave behind nothing but a tiny useless stub (to avoid latent references in other cells from crashing the GC), so you'd get the same end result as the historical EVAL.</p>
<p>I'm betting that having EVAL be able to be intrinsic when it takes one argument, and making FREE intrinsic would be faster than trying to do some weird refinement like <strong><code>eval:free</code></strong> to fold both into one operation...because refinement processing has its own cost, which I <em>think</em> would be greater.</p>
<p>But an optimized <strong><code>eval-free</code></strong> might be worth making, I don't know.  However its mechanic would simply be to natively fold the free in after the EVAL, instead of trying to make EVAL take over the frame and use its memory.</p>
<p>My guess is that using EVAL-FREE won't be a benefit most of the time if you add any evaluator cycles to save a variable because of it.</p>
<h1><a name="p-7936-hence-eval-will-no-longer-consume-frame-6" class="anchor" href="https://forum.rebol.info#p-7936-hence-eval-will-no-longer-consume-frame-6"></a>Hence, EVAL Will No Longer Consume FRAME!</h1>
<p>This makes the "action-is-frame" duality even more solid, because as frames are passed around in the system there won't be "consume frame vs. don't" flags involved.</p>
<p>You'll just either free the frame after you've applied it, or you won't.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p> ]]></description>
        <link>https://forum.rebol.info/t/the-probably-false-economy-of-eval-consuming-frame/2339#post_1</link>
        <pubDate>Sun, 01 Dec 2024 00:50:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7936</guid>
      </item>
      <item>
        <title>Simplifying Refinement Promotion</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>There are two modes of partial specialization which Ren-C has supported.</p>
<p>One form would be like if APPEND takes something like :DUP and fixes it to a value:</p>
<pre><code>&gt;&gt; append2: specialize append/ [dup: 2]

&gt;&gt; append2 [a b c] &lt;d&gt;
== [a b c &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>Then there's a trickier kind of specialization, which is to ask for the parameter but not specify it... thus just increasing the arity:</p>
<pre><code>&gt;&gt; appenddup: append:dup/

&gt;&gt; appenddup [a b c] &lt;d&gt; 4
== [a b c &lt;d&gt; &lt;d&gt; &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>The second form is pretty unusual in the language world.  There doesn't seem to be much prior art in "the conversion of optional parameters to required parameters" (at least I don't know any, and the AIs I asked don't know any).</p>
<p>Since it's pretty different from what what people think of as partial specialization, let's call it <strong>"refinement promotion"</strong>.</p>
<h2><a name="p-7935-refinement-promotion-is-tricky-1" class="anchor" href="https://forum.rebol.info#p-7935-refinement-promotion-is-tricky-1"></a>Refinement Promotion Is <em>Tricky</em></h2>
<p>Something that has been non-negotiable in the design is the straightforward array of parameters and locals that specify a function interface.</p>
<p>Refinements are defined in some order in that array.  But you are not required to use them in that order.</p>
<p>So consider a definition like:</p>
<pre><code> /foo: func [a [integer!] :b [integer!] :c [integer!]] [...]
</code></pre>
<p>Someone might do refinement promotion of this as <strong><code>foo:c:b/</code></strong> - this makes it seem to the caller a function originally written with spec:</p>
<pre><code> [a [integer!] c [integer!] b [integer!]]
</code></pre>
<p>The techniques so far have tried to mimic the way that refinements work.  So <strong><code>get $foo:c:b</code></strong> would produce a function that was accompanied by a <strong><code>[c b]</code></strong> array, that would get pushed when running the promoted function.  The elements in the array would not just have the words, but those words would have binding information to say what index those words were found at in the parameter array.</p>
<p>But since the underlying array is left the same, this means every time you want to know something like "what's the first unspecialized normal argument" you have to mimic the refinement gathering process.  It convoluted the process quite a lot, and really went against the idea of the implementation being "simple".</p>
<h2><a name="p-7935-q-is-this-really-required-to-support-a-yes-2" class="anchor" href="https://forum.rebol.info#p-7935-q-is-this-really-required-to-support-a-yes-2"></a>Q: Is This Really Required To Support?  (A: Yes)</h2>
<p>This may not seem like a super-common need.  But if you're implementing a dialect that wants to support calling functions with refinements, it's pretty important.</p>
<p>Let's say you're implementing something like <a href="https://forum.rebol.info/t/if-action-combinators-dont-impress-what-will/1608">the feature in UPARSE that lets you call functions</a>:</p>
<pre><code>&gt;&gt; data: copy ""

&gt;&gt; parse ["a" "b"] [some [/append:dup (data) text! (2)]]

&gt;&gt; data
== "aabb"
</code></pre>
<p>Basically, if <strong><code>(get $/append:dup)</code></strong> can come back with a function that you can query for its parameters and get answers just like it was any other function, then support for refinements comes basically for free.</p>
<h2><a name="p-7935-should-the-varlist-just-be-rewritten-3" class="anchor" href="https://forum.rebol.info#p-7935-should-the-varlist-just-be-rewritten-3"></a>Should The VarList Just Be Rewritten?</h2>
<p>If you look at what a modern SPECIALIZE followed by AUGMENT can do, they can hide parameters...and then add back parameters with the same name.  Which parameters are visible depend on the "phase" of the frame.</p>
<p>So why couldn't refinement promotion be done just by making a new function interface that removes the argument as a refinement, and adds it back as a regular argument... then has a dispatch phase that moves the argument data to its old position for the subsequent phases?</p>
<p>It's not particularly "cheap" to do that, space-wise.  You'd need a new VarList* and a new Phase*, and the Phase would have to remember the new and old positions to do the rewrite.  But it would make parameter enumeration blunt and simple, because you'd really just be enumerating the parameters in order.</p>
<p>There'd be some cases where the position of the refinement would allow it to just be naturally rewritten to be a regular argument, and that could be optimized for.</p>
<h2><a name="p-7935-what-about-when-you-have-lots-of-local-4" class="anchor" href="https://forum.rebol.info#p-7935-what-about-when-you-have-lots-of-local-4"></a>What About When You Have Lots of <code>&lt;local&gt;</code>?</h2>
<p>This is kind of the dark side of the simple FRAME! model, which is that if you use it to create a lot of local variables, then operations like SPECIALIZE and AUGMENT which do VarList manipulation have to make copies of everything for the new VarList...including a bunch of locals that aren't changing at all in each new form.</p>
<pre><code>/foo: func [x [text!] y [tag!] &lt;local&gt; a b c d e f g h i j k l m n o p] [
    ... 19 frame cells (includes RETURN) ...
]

/bar: augment foo/ [z [integer!]]  ; z is last item in new 20 item frame
</code></pre>
<p>Refinement promotion would become another one of these situations that would do seemingly unnecessary duplication.</p>
<p>It would be possible in cases like this to create smaller frames and then proxy the results into larger ones, essentially simulating what a user might do to manually call FOO from a new function BAR which had a frame with 3 elements.</p>
<pre><code>/bar: lambda [x [text!] y [tag!] z [integer!]] [
    foo x y  ; imagine doing this, but with faster internal mechanics
]
</code></pre>
<p>Some calculation could be done where the size of the frame justified it.  I have a feeling that the frame would have to be reasonably large before a technique like this would be beneficial.</p>
<h2><a name="p-7935-what-about-refinements-at-headhttpsforumrebolinfotrefinement-arguments-at-head-of-args-list-not-tail2331-5" class="anchor" href="https://forum.rebol.info#p-7935-what-about-refinements-at-headhttpsforumrebolinfotrefinement-arguments-at-head-of-args-list-not-tail2331-5"></a>What About <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">Refinements At Head</a>?</h2>
<p>Well, in that case, you would <em>have</em> to build a new VarList* that extracted the arguments, and then proxy them into position for the new interface.</p>
<p>At least one wouldn't be worried about the "bloated copies of locals" situation.</p>
<h2><a name="p-7935-souse-the-auxiliary-array-simulating-refinements-6" class="anchor" href="https://forum.rebol.info#p-7935-souse-the-auxiliary-array-simulating-refinements-6"></a>So...Use The Auxiliary Array Simulating Refinements?</h2>
<p>The code for simulating refinements when asking simple questions like <em>"what's the first unspecialized normal arg"</em> is unappealingly complex. <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=12" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<p>Making it further unappealing is that when you have this array of refinements "off to the side" but still allow people to fill in slots in frames to specialize out arguments, you end up needing to have "reconciliation"...because those frame slots that are referenced by this out-of-band array are no longer part of the refinement promotion.</p>
<pre><code>&gt;&gt; f: make frame! append:dup:part/  ; has auxiliary [dup part]

&gt;&gt; f.dup: 3  ; what cleans up [dup part] to just [part] ?
</code></pre>
<p>I've talked about not knowing about what "moment" to do these kinds of fixes, and I'm increasingly looking for ways to avoid there being any such moment.  If the physical experience of the frame was that DUP and PART were ordinary parameters and not refinements, then it "just works".</p>
<h2><a name="p-7935-the-dumb-mechanical-answer-is-likely-best-7" class="anchor" href="https://forum.rebol.info#p-7935-the-dumb-mechanical-answer-is-likely-best-7"></a>The "Dumb" Mechanical Answer Is Likely Best</h2>
<p>I sometimes forget just how much I take for granted in Ren-C, regarding the ability to compose functions together.</p>
<p>The "inefficient" idea of making a new parameter list and then proxying the arguments into position would be more efficient than having to create and evaluate an interpreted function that had to manually copy the parameters.</p>
<p>There's a huge tax created by having to compose an off-to-the-side parameter reordering list in with the frame variables, and that tax is paid by <em>any code</em> that wants to interpret the list.  It's just too big a tax to pay.</p>
<p>It pains me a bit to delete it, because it was hard to write and seemed clever at the time.  But techniques have advanced...and while the auxiliary list may have seemed somewhat optimal for storage, it's no longer the right choice.</p> ]]></description>
        <link>https://forum.rebol.info/t/simplifying-refinement-promotion/2338#post_1</link>
        <pubDate>Sat, 30 Nov 2024 21:20:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7935</guid>
      </item>
      <item>
        <title>FRAME! / ACTION! Duality Examined</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>It's been a tough week of contemplation, but...</p>
<p>...I think a "bad" idea I had along the way here, is actually turning out to be a good idea.</p>
<h2><a name="p-7934-details-or-varlist-vs-details-varlist-1" class="anchor" href="https://forum.rebol.info#p-7934-details-or-varlist-vs-details-varlist-1"></a><code>(Details* -or- VarList*)</code> vs. <code>(Details* + VarList*)</code></h2>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="1898">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But it's been on my mind... and it's part of what is making me think through this idea of pairing up <code>(Details* + VarList*)</code> with reused phases instead of making a new Phase every time you want to make a specialization/combinatorization.</p>
</blockquote>
</aside>
<p>So at one point, I grafted in the idea that a FRAME! cell's first Node hold something that's simply a superset of <code>Details*</code> and <code>VarList*</code>.  If a function composition creates a new Details, it puts that in the cell and points to the old VarList.  If it creates a new VarList, it puts that in the cell and it points to the old Details.  If it creates both, it can pick either--doesn't matter.</p>
<ul>
<li>
<p>This brings back the notion of a single pointer serving as an action's identity</p>
</li>
<li>
<p>This again frees up the space for the stored symbol <em>(...I hate losing features, so was really struggling with any design that lost that...)</em></p>
</li>
</ul>
<p>It seems like an uncomfortable situation of a new class of Context Cells which have in their Payload's Node1 something that can either be a VarList or a Details.  But I found that when "simplifying" things so that there's never a symbol in the "Phase" slot, and always a VarList in the VarList slot, that I was having to create questions to reverse-engineer the question of <em>"Are you a <code>VarList*</code>-identity Action or a <code>Details*</code>-identity Action?"</em></p>
<p>Previously I'd called this superset of VarList and Details "Action".  That's a bit confusing since actions are a type of Cell (specifically, FRAME! cells in the antiform state), not a type of Stub.  So I think actually calling it <strong><code>Phase</code></strong> is probably better.</p>
<p>What confused me was that it was seeming like introducing this new <code>Phase*</code> was breaking the idea of the "current" <code>Phase*</code> in the Cell, because you could tweak the types of values in a VarList-based FRAME! (or AUGMENT it, etc.) and then be beholden to a "phase" of typechecking that wasn't a Details.  I couldn't square the terminology and nothing seemed to work.</p>
<p>But I think by talking it out here and figuring out the limits of what's possible and not, you always have to create a new Details if you want to introduce new typechecking.  And this concept of having to "harden", plus the viewing through the "lens" of antiform vs. non, answers a bunch of other questions.</p> ]]></description>
        <link>https://forum.rebol.info/t/frame-action-duality-examined/1898#post_4</link>
        <pubDate>Sat, 30 Nov 2024 10:22:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7934</guid>
      </item>
      <item>
        <title>FRAME! / ACTION! Duality Examined</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1898">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I definitely underestimated just how many issues were folded in with the "hardening" process that creating a Details brought about</p>
</blockquote>
</aside>
<p>This goes further... because there are questions that the evaluator has to ask like "what is the first unspecialized parameter" when dealing with an infix function.</p>
<p>So imagine this:</p>
<pre><code>/mp-add: lambda [a b c] [a * b + c]

f: make frame! mp-add/  ; ...some questions here RE: parameter antiforms

f.a: 10

/mp10-add: infix anti f
</code></pre>
<p>The question "what is your first unspecialized parameter" is supposed to operate on a cache that remembers which parameter that is (this shows a relatively simple case, but it's still slow to have to re-figure out it's <code>b</code> every time...it can get a lot trickier).</p>
<p>So when does that calculation get done?</p>
<p>The last possible moment it seems this can happen is when the frame is being executed.  It <em>could</em> happen when you turn a FRAME! into an antiform, but bear in mind you don't have to make a frame an antiform in order to RUN or EVAL it (though that could just claim it "makes an antiform as part of the internal processing", whether it actually does or not)</p>
<h2><a name="p-7933-consequential-question-changing-answers-1" class="anchor" href="https://forum.rebol.info#p-7933-consequential-question-changing-answers-1"></a>Consequential Question: Changing Answers?</h2>
<p>Continuing the above example, you would expect the following, right?</p>
<pre><code>&gt;&gt; /mp-add: lambda [a b c] [a * b + c]

&gt;&gt; f: make frame! mp-add/  ; or whatever "fill 'holes' with nothing" op is

&gt;&gt; map-each key f [key]
== [a b c]
</code></pre>
<p>But if that frame is allowed to just "morph" to be the representation of an action, then if the <code>a</code> has been specialized out you don't want it to be part of the interface.</p>
<pre><code>&gt;&gt; f.a: 10

&gt;&gt; /mp10-add: infix anti f

&gt;&gt; map-each key f [key]
== [b c]   ; ugh, different answer for the same F?
</code></pre>
<p>So it's like the "hardening" moment is fundamentally changing what you had in your hand.</p>
<h2><a name="p-7933-that-doesnt-sit-well-with-me-pouting_cat-2" class="anchor" href="https://forum.rebol.info#p-7933-that-doesnt-sit-well-with-me-pouting_cat-2"></a>That Doesn't Sit Well With Me <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></h2>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1898">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So FRAME!/ACTION! Unification Was A Mistake?</p>
</blockquote>
</aside>
<p>Well, it can't be incoherent.</p>
<p><strong>I'd be happier saying that when you enumerate the antiform, you get the public interface as if it were an action, and when you enumerate the non-antiform you get access to the specialized slots.</strong></p>
<p>So perhaps it is the moment of turning into an antiform that does the hardening... but doesn't change how the non-antiform state behaves.</p>
<pre><code>&gt;&gt; f.a: 10

&gt;&gt; /mp10-add: infix anti f  ; INFIX RUNS F is same but typechecks FRAME!

&gt;&gt; map-each key f [key]
== [a b c]

&gt;&gt; map-each key mp10-add/ [key]
== [b c]
</code></pre>
<p>Better.</p>
<h2><a name="p-7933-giving-antiforms-the-old-action-properties-may-be-it-3" class="anchor" href="https://forum.rebol.info#p-7933-giving-antiforms-the-old-action-properties-may-be-it-3"></a>Giving Antiforms The Old "ACTION!" Properties May Be It</h2>
<p>It may have to be that frames, when viewed through the antiform lens, answer questions differently.</p>
<p>Once you enable that lens, it will have to lock the frame from modification.  But the idea would be that any non-mutating operations that can still work would answer questions of the non-antiform state the same way they would have been answered before the lock.</p>
<ul>
<li>
<p>I have identified that something significant was lost when the "moment of hardening" that occurred when producing ACTION! from FRAME! disappeared.</p>
</li>
<li>
<p>We don't want questions of the same objects to be answered differently before and after hardening.</p>
</li>
<li>
<p>There is no other available distinguishing state besides the antiform state, and antiform FRAME! is ostensibly the surrogate for a separate action type, so...</p>
</li>
</ul>
<p>...I guess I'm going to try to rig this up.  This is all a bit of a mess right now, it's extremely annoying and hard to know where to start.  But very necessary to sort out.</p>
<p>Mechanically what this means is that when FRAME!s are antiforms, they give answers to questions about their interface based on the VarList* they hold in the cell.  Whereas when they are not antiforms, they consider their interface to be that associated with the "Phase" they hold in the cell.  The VarList* in the cell can't answer questions until it has been "hardened", which happens when you create an antiform of a frame, or use an operation like RUN on the plain FRAME! which will implicitly harden it.</p>
<h2><a name="p-7933-ulterior-motive-disclosure-uparse-optimization-4" class="anchor" href="https://forum.rebol.info#p-7933-ulterior-motive-disclosure-uparse-optimization-4"></a>Ulterior Motive Disclosure: UPARSE Optimization</h2>
<p>One reason that I've been trying so hard to drive down the "allocated entity count" and reuse Phases is that when UPARSE combinators are turned into parsers, they are often used just once.</p>
<p>You might write <strong>opt some "a"</strong>, and the "a" combinator could be called 50 times.  But [some "a"] is only called once, by the OPT, and the OPT may well be called only once as well.  If this is so, a native combinator doesn't need a reusable function... it can just take a disposable FRAME! and instead of using it as an archetypal pattern for a call, use its existing allocation for <em>the</em> one call.  <em>(It can even skip typechecking if it's native code and knows what it's doing... poke the input position into the INPUT slot, the parsers into the PARSER slots, and go straight to dispatching the combinated parser.)</em></p>
<p>So my thinking here is that the function spec of combinators could specify whether they want a FRAME! or an ACTION?.  And if it takes a frame, it could be cheap.</p>
<p>It's far out and I don't know how that would interact with debugging, or other forms of combinator wrapping.  It's just an idea.  But it's been on my mind... and it's part of what is making me think through this idea of pairing up <code>(Details* + VarList*)</code> with reused phases instead of making a new Details every time you want to make a specialization/combinatorization.</p> ]]></description>
        <link>https://forum.rebol.info/t/frame-action-duality-examined/1898#post_3</link>
        <pubDate>Thu, 28 Nov 2024 04:11:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7933</guid>
      </item>
      <item>
        <title>UPARSE Combinator Return Conventions: Reviewed</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>UPARSE was an early client of multiple return values, at a time when they worked by assigning variables local to your frame, which were then proxied to items in a SET-BLOCK!:</p>
<pre><code> /multi-returner: func [
     return: [integer!]
     secondary: [integer!]  ; SET-WORD! indicated another return
 ][
     secondary: 20
     return 10
 ]

 &gt;&gt; [ten twenty]: multi-returner
 == 10

 &gt;&gt; ten
 == 10

 &gt;&gt; twenty
 == 20
</code></pre>
<p>This basically made every multi-return function a kind of infix operation, that was able to take a SET-BLOCK! on its left hand side.  <a href="https://forum.rebol.info/t/multiple-return-values-via-infix/1257">(In fact, it was prototyped using infix.)</a></p>
<p>But this method had composability problems, and was defeated by abstraction of any sort, even the most minor forms:</p>
<pre><code> &gt;&gt; [ten twenty]: (multi-returner)
 ** Error: even this wouldn't work
</code></pre>
<p>So the method gave way to returning antiform BLOCK!s.  These represented parameter packs that would "decay" to their first item in most circumstances...but SET-BLOCK!s were one of the cases that could pick them apart (though you could design other operations as well).</p>
<pre><code> /multi-returner: func [
     return: [~[integer! integer!]~]
 ][
     return pack [10 20]
 ]
</code></pre>
<p>You can read all about it in <strong><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">The History of Multi-Return in Ren-C</a></strong></p>
<h2><a name="p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1" class="anchor" href="https://forum.rebol.info#p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1"></a>So Local Proxies Died...But UPARSE Mimicked Them</h2>
<p>Just because the mechanics got rid of local proxies doesn't mean you can't fake them.  All you have to do is hack up its RETURN function to make a PACK using a local variable.</p>
<p>Simplified example:</p>
<pre><code> /proxy-multi-func: adapt func/ [
      body: compose $() inside body '[
          /return: adapt return/ [
             atom: pack [(unmeta atom) secondary]
          ]
          (as group! unbind body)  ; I wish this pattern were simpler
      ]
 ]

 /multi-returner: proxy-multi-func [
     return: [integer!]
     &lt;local&gt; secondary  ; could be specially marked, if spec rewritten
 ][
     secondary: 20
     return 10
 ]
</code></pre>
<p>So when the multi-return-by-antiform-block change happened, this is what COMBINATOR did instead of transition to having every combinator do <strong><code>return pack [synthesized remainder]</code></strong></p>
<p>Instead it worked the same as before: you'd set <strong>remainder</strong> however you wished, do <strong>return synthesized</strong>.  Except now the specialization of RETURN would PACK things up.</p>
<h2><a name="p-7932-why-did-combinator-preserve-proxying-2" class="anchor" href="https://forum.rebol.info#p-7932-why-did-combinator-preserve-proxying-2"></a>Why Did COMBINATOR Preserve Proxying?</h2>
<p>Well... for starters, to show that it could be done.  You <em>should</em> be able to do it.  So having a living test case to hammer through any issues was good.</p>
<p>Also, because some combinators have two return values (synthesized and remainder), while others add a third (pending).  In truth the combinator always needs to return a pack of 3, it's just that some combinators automatically pipe the pending results from successful combinators to the output.  This means even if your combinator returned a pack of 2 in the piped case, that would have to be broken apart and turned into a pack of 3.  Having it in components helps.</p>
<p>But generally, I think it makes the code clearer as well.  Saying <strong><code>(return pack [x y])</code></strong> doesn't have any labeling, while <strong><code>(remainder: y, return x)</code></strong> is somewhat clearer, and you don't need to label the "primary" result because that's understood as what the combinator is synthesizing.</p>
<h2><a name="p-7932-synthesized-cant-be-proxied-unless-meta-3" class="anchor" href="https://forum.rebol.info#p-7932-synthesized-cant-be-proxied-unless-meta-3"></a>Synthesized Can't Be Proxied (unless ^META)</h2>
<p>It's worth pointing out that there's a sort of design constraint here, when you're going to break out multi-return results and have them represented by local variables which are proxied by an adjusted RETURN...</p>
<p>...and that constraint is that you can't put unstable antiforms in variables.  So if you have something you want to return like an antiform pack (as combinators can legitimately synthesize), it has to be the main return result.</p>
<p>So since they use this proxying, combinators kind of break the rule of thumb of "don't make unstable antiforms your primary return in a multi-return situation".  This is because if you do:</p>
<pre><code>return pack [pack [1 2] "a"]
</code></pre>
<p>Then you face some ambiguity in terms of what people might think <strong><code>([x y]: multi-return-func)</code></strong> should mean... or what <strong><code>(x: multi-return-func)</code></strong> should mean.</p>
<p>But really, this is still being worked out.</p>
<h2><a name="p-7932-anyway-just-wanted-to-sum-up-uparse-return-4" class="anchor" href="https://forum.rebol.info#p-7932-anyway-just-wanted-to-sum-up-uparse-return-4"></a>Anyway, Just Wanted To Sum Up UPARSE RETURN</h2>
<p>I was questioning it, and wanted to kind of work through why it is the way it is.  But I think it's right.</p> ]]></description>
        <link>https://forum.rebol.info/t/uparse-combinator-return-conventions-reviewed/2337#post_1</link>
        <pubDate>Thu, 28 Nov 2024 00:35:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7932</guid>
      </item>
      <item>
        <title>Issues With Querying A Function&#39;s &quot;RETURN&quot;</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Each FUNCTION has a local variable named RETURN.  When it's running, the cell for that variable points at an "archetypal return function".  But that cell also holds a reference to that specific function instantiation's frame.  This way it knows how to return specifically from that invocation of that function.</p>
<p>This "definitional return" concept has worked quite well.  But there are some fiddly issues that arise from trying to make RETURN an ordinary local variable.</p>
<h2><a name="p-7931-it-was-hoped-return-would-not-be-special-1" class="anchor" href="https://forum.rebol.info#p-7931-it-was-hoped-return-would-not-be-special-1"></a>It Was Hoped RETURN Would Not Be Special</h2>
<p>The idea is that LAMBDA would be lower-level than FUNCTION, and permit you to have parameters or local variables named RETURN that had nothing to do with returning.</p>
<pre><code>/demo: lambda [return continue] [
    return + continue
]

&gt;&gt; demo 1 2
== 3
</code></pre>
<p>So an aspirational aspect of the design was that a user could create something that operated identically to the FUNCTION abstraction (just a bit slower, due to not being implemented natively).</p>
<p>It would use something like THROW and CATCH, to implement RETURN (or construct(s) in that family) itself, as LAMBDAs synthesized upon instantiation.</p>
<h2><a name="p-7931-return-as-local-hides-its-type-information-2" class="anchor" href="https://forum.rebol.info#p-7931-return-as-local-hides-its-type-information-2"></a>RETURN as Local Hides Its Type Information</h2>
<p>While it's not an argument to the function, RETURN still has associated type information.</p>
<p>Since RETURN is a local that will be filled with an action when the function runs, it isn't using its frame slot until that invocation happens.  That means it can store a PARAMETER! which says what return types are legal.  (It seems like a good use of an otherwise-unused slot otherwise you'd need a slot in the Phase to hold it.)</p>
<p>Functions like HELP want to know those types.  Yet locals and specialized arguments are traditionally considered implementation details, hidden from callers.  They're only visible  when frames are captured during the "phase" of being inside the function call:</p>
<pre><code>&gt;&gt; /foo: function [return: [integer!] x] [
     print mold words of binding of $x
]

&gt;&gt; words of foo/
== [x]

&gt;&gt; foo
== [return x]
</code></pre>
<p>Today's unsatisfying solution is that there's a flag on parameters that represent RETURN.  If you want the type information of that return, you can ask for it:</p>
<pre><code>&gt;&gt; return of foo/
== ~#[parameter! [integer!]]~  ; anti
</code></pre>
<p>But this flag is only applied by the FUNCTION native when its construction the parameter list.  So you wouldn't (for instance) get this behavior on a usermode re-implementation of FUNCTION based on LAMBDA.</p>
<h2><a name="p-7931-how-to-change-return-in-composition-3" class="anchor" href="https://forum.rebol.info#p-7931-how-to-change-return-in-composition-3"></a>How To Change RETURN In Composition?</h2>
<p>Let's say you're going to build a higher-level function with something like ENCLOSE:</p>
<pre><code>&gt;&gt; /bar: enclose foo/ func [return: [tag!] f [frame!]] [
       print "I'm an enclosure!"
       eval f
       return &lt;tag&gt;
   ] 
</code></pre>
<p>The interface of an enclosed function is the same parameter list as the original, and the same returns as the original.  The enclosure is implemented as a function that takes a frame, and it can be given a new return type.  But today that isn't reported as the return type if you asked for HELP of FOO.  It would look at the original parameter list, which in this case says its RETURN is <strong><code>[integer!]</code></strong>.</p>
<p><em>This suggests that the answer to the question <strong><code>return of</code></strong> has to be dispatcher-specific.</em></p>
<p>FUNCTION would say "it's the contents of the RETURN local in the archetype (not overwritten with return function, so still a PARAMETER!)".</p>
<p>ENCLOSE would say "it's the return type of the enclosure function that takes the frame" but then give back the original parameter list for everything else.  (This raises a question of how you would inherit the original function's return... it might be nice if you used a LAMBDA or something that reported no return constraint, that it would default to the constraints of the function you were enclosing.)</p>
<p>In any case, if it was answered by the dispatcher... then if LAMBDA says "I don't have a RETURN", you'd not have HELP information on your RETURN if you were trying to build your own FUNCTION on top of LAMBDA.</p>
<p><strong>The word RETURN may be a distraction, here.</strong>  Because if it's something like a GENERATOR, the products are coming from calls to YIELD.  Maybe <strong><code>(result of ...)</code></strong> or <strong><code>(synthesis of ...)</code></strong> would help stress that this question isn't tied up specifically with RETURN.</p>
<h2><a name="p-7931-lambda-semantics-may-want-result-specification-4" class="anchor" href="https://forum.rebol.info#p-7931-lambda-semantics-may-want-result-specification-4"></a>LAMBDA Semantics May Want Result Specification</h2>
<p>The idea of LAMBDA is that the evaluative product just drops out <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">(see various writings on why FUNCTION does not allow that)</a>.</p>
<p>But just because you want that semantic, doesn't mean you don't want the HELP to not give a return type.</p>
<p>However, LAMBDA doesn't have anywhere to store the type information the way FUNCTION does.  If it has a RETURN it may be using it for unrelated purposes.</p>
<p>Given what I've proposed for the dispatcher-specific RETURN, you could accomplish it with an ENCLOSE:</p>
<pre><code> enclose (lambda [...] [...]) func [return: [&lt;spec&gt;] f] [return eval f]
</code></pre>
<p>But it seems clearly better to have something specific to this purpose:</p>
<pre><code> returns [&lt;spec&gt;] lambda [...] [...]
</code></pre>
<p>Then the Returns_Dispatcher() would simply type check what you gave it.</p>
<p>Perhaps it could even accept a function as a first parameter, and then just say it returns whatever that function returns:</p>
<pre><code>returns add/ lambda [x] [x + 1]
</code></pre>
<p>Though that might be more confusing than writing it out:</p>
<pre><code>returns (return of add/) lambda [x] [x + 1]
</code></pre>
<p>Maybe a refinement should be used to bless that you're doing it on purpose:</p>
<pre><code>returns:same-as add/ lambda [x] [x + 1]
</code></pre>
<p>I guess the big question would be how to get the return's textual description in there.  Maybe it could assume if the format is TEXT! BLOCK! that's what you mean:</p>
<pre><code>/foo: returns [
   "The input plus one"
   [integer!]
] lambda [x] [
    x + 1
]
</code></pre>
<h2><a name="p-7931-well-theres-some-ideas-5" class="anchor" href="https://forum.rebol.info#p-7931-well-theres-some-ideas-5"></a>Well, There's Some Ideas</h2>
<p>I guess the idea here is that mechanics for answering "what do you return" come from the function's dispatcher, and maybe that becomes a chained question where if the dispatcher wraps something else, it has to ask the right parts of that thing.  There may be no user-exposed mechanic for building your own answer to the question beyond something like RETURNS, which is probably good enough.</p> ]]></description>
        <link>https://forum.rebol.info/t/issues-with-querying-a-functions-return/2336#post_1</link>
        <pubDate>Thu, 28 Nov 2024 00:00:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7931</guid>
      </item>
      <item>
        <title>Performance Implications of Antiform-FRAME!-is-Action</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p><a href="https://forum.rebol.info/t/frame-action-duality-examined/1898/2">I've written up some of the issues that have arisen in another thread</a>.</p>
<p>But I wanted to mention something else that's emerged:</p>
<h3><a name="p-7930-antiform-parameter-being-orneryunset-is-a-headache-1" class="anchor" href="https://forum.rebol.info#p-7930-antiform-parameter-being-orneryunset-is-a-headache-1"></a>Antiform PARAMETER! Being Ornery/"unset" is A Headache</h3>
<p>One thing is a good idea: that's the premise of having FRAME! cells with antiform parameters in them be <em>the</em> representation of an unfulfilled parameter (or "Hole").</p>
<p>This means a function's interface can be expressed without having a special hidden "bit" to say what's a parameter description vs. a specialized parameter value <em>("locals" historically were specializations to nothing, but <a href="https://forum.rebol.info/t/dropping-with-in-static/2335">now you can use any value</a> that isn't a parameter antiform)</em>.  The antiform parameter state becomes the "I'm an unfulfilled parameter" bit, which is already a sunk cost in the system for how to deal with it.</p>
<p>It does mean that if you want to actually take an antiform parameter as an argument, it has to be a ^META parameter...even though it's stable.  But that's not such a problem.</p>
<p>What <em>is</em> a headache is having antiform parameters be just as hard to handle as nothings/tripwires.</p>
<p>When you look at what I mention in the other thread about how you can't really "re-skin" actions anyway (at least with trivial mechanics), I think this suggests that whatever the "MAKE FRAME!" operator is needs to go back to filling the unfulfilled arguments with antiform blank.  Antiform parameters need to be friendly when reflecting specs.</p>
<p>The optimization/correctness issues simply need to be addressed some other way.</p> ]]></description>
        <link>https://forum.rebol.info/t/performance-implications-of-antiform-frame-is-action/2083#post_4</link>
        <pubDate>Wed, 27 Nov 2024 22:15:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7930</guid>
      </item>
      <item>
        <title>FRAME! / ACTION! Duality Examined</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <h2><a name="p-7929-its-time-to-revisit-this-1" class="anchor" href="https://forum.rebol.info#p-7929-its-time-to-revisit-this-1"></a>It's Time To Revisit This</h2>
<p>At one point, ACTION! and FRAME! were two different types, whose Cells pointed to two different data structures.</p>
<p>An ACTION! pointed to a <strong><code>DispatchDetails*</code></strong> (or <code>Details*</code> for short).  A Details contained the implementation information for the action... so if it were something like a FUNC, then it would hold the BLOCK! of the body for that specific function.  It also held a pointer to a C function called a <strong><code>Dispatcher*</code></strong> which would know how to interpret those details (e.g. the Func_Dispatcher() would know to run the code in the BLOCK! in the Details array).  Invoking a function could wind up running a chain reaction of Details, that had been composed together to run in the same memory space.</p>
<p>A FRAME! pointed to a <strong><code>VarList*</code></strong> ... which is the same kind of thing that an OBJECT! points to: a list of keys (symbols) and then Cells for each key's value.  However, the cells could either specify an unfulfilled argument (antiform PARAMETER!) or a specialized value...which includes locals.  While this VarList pointed to the specific Details it was for, the FRAME! Cell itself also held another Details* (as the "Phase").  Then, whether you could see the locals or not (or which args and locals) depended on the <strong><code>VarList*</code></strong> of the Phase held in the cell... which is a nuance that made frames quite a bit trickier than objects.</p>
<h2><a name="p-7929-could-frame-be-just-a-details-varlist-pairing-thinking-2" class="anchor" href="https://forum.rebol.info#p-7929-could-frame-be-just-a-details-varlist-pairing-thinking-2"></a>Could FRAME! be Just a (Details*, VarList*) Pairing? <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></h2>
<p>When you are going to add new execution information... you necessarily must create a new Details.  There simply isn't anywhere to put code in a VarList.  However, you can reuse a VarList with that new Details.</p>
<p>e.g. if you were to ADAPT an ACTION! then you'd produce a new <code>Details*</code> which would point to the same <code>VarList*</code> as the thing you were adapting... but just give it a new <code>Adapter_Dispatcher()</code> to with some preamble code in the Phase's array to run.  (It also needs to store the function it is adapting, so it can pass control to it when it's done running the preamble.)</p>
<p>When all ACTION! needed a unique Details, things like SPECIALIZE would create a new Details too, but just a dummy one...since all the information for the specialization exists in a new VarList*.  But ACTION!s had to have a Details, so that's what it did.</p>
<p>A tempting thought is that a FRAME! could just be a Details* and a VarList* paired together in a Cell.  If this were the case, you could create a specialization without making a new Details... which has been a sought-after optimization for some time.</p>
<p>There are a few casualties of such a design.  One is that this breaks the notion of a single pointer being an action's "identity"... you've just got a list of parameters and variables paired up with a compatible implementation...and these are being mixed and matched freely by function composition tools.  The HIJACK capability was only designed for Details pointers, and this would mean you could not hijack a specialization <em>(at least without hijacking all the other specializations of the same function--in practice this is every use case of HIJACK that has come up, but there's nothing in theory saying you wouldn't implement a "unique" service entry point by way of specialization and want to HIJACK that... I can easily imagine it happening, it just hasn't yet.)</em></p>
<p>Another casualty would be the <a href="https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357">storing of a Symbol* inside FRAME! values</a>, which is reliant on a VarList* storing its one-and-only Details* inside it.  If Phases can be mixed with arbitrary Varlists in a FRAME! cell, then there are no free bits for this feature.</p>
<h2><a name="p-7929-elegant-design-fringe-features-3" class="anchor" href="https://forum.rebol.info#p-7929-elegant-design-fringe-features-3"></a>Elegant Design &gt; Fringe Features?</h2>
<p>It's likely that if I were looking at this from scratch--before HIJACK or symbol caching--I would think that the <strong><code>FRAME! Cell =&gt; (VarList* + Details*)</code></strong> made the most sense.</p>
<p>It feels like it decouples things cleanly.  Why <em>would</em> you need to create a new <code>Details*</code> if you're just specializing out values?  If you've made a new <code>VarList*</code> with the updated values, couldn't it be paired up with the old Phase?</p>
<p>It may still be possible to implement HIJACK in such a world.  You could ask the Details* in a FRAME! Cell "what's your VarList*", and if the answer was the same as the VarList* in the Cell then you'd know the Phase was created after the VarList, hence the Details must be the "identity"...so you hijack that.  Otherwise, the VarList* must be the identity...so you'd hijack it <em>(<img src="https://forum.rebol.info/images/emoji/twitter/raised_hand_with_fingers_splayed.png?v=12" title=":raised_hand_with_fingers_splayed:" class="emoji" alt=":raised_hand_with_fingers_splayed:" loading="lazy" width="20" height="20"> hand waving as to how this would work)</em></p>
<p>Additionally, it may be possible to sneak a Symbol* into FRAME! Cells if they aren't using their "Coupling".  (e.g. if they're not a METHOD, or RETURN/CONTINUE/YIELD/BREAK/etc.)  A Symbol* in the coupling slot could just indicate it's uncoupled.  That's...fairly random.  Though to be honest, the feature turned out to be somewhat hard to wield anyway, it was never really clear which assignments should rename the function.</p>
<p>There are a few more glitches, though.</p>
<h2><a name="p-7929-devils-in-the-details-imp-irreducibility-of-typechecking-4" class="anchor" href="https://forum.rebol.info#p-7929-devils-in-the-details-imp-irreducibility-of-typechecking-4"></a>Devil's In The Details <img src="https://forum.rebol.info/images/emoji/twitter/imp.png?v=12" title=":imp:" class="emoji" alt=":imp:" loading="lazy" width="20" height="20">  Irreducibility Of Typechecking</h2>
<p>Before you run a Details, the expectation is that all the unfulfilled slots in a VarList will be filled... with <em>type-correct</em> values.  Calling any function with incorrectly typed cells is bad, but native code actually expects the bit patterns in Cells to be specific to what it asked for...and will crash if it's wrong.</p>
<p>So if a FRAME! is a mix and match of a <code>VarList*</code> and a <code>Details*</code>, when does the <code>VarList*</code> get checked?</p>
<p>There are some weird cases to think about like AUGMENT, which adds to a function's frame.  It only makes an expanded VarList with new keys/cells... there's no implementation code.  So it should be able to reuse whatever Details* was in the FRAME! Cell it augments.  But this means the type checking and argument gathering has to use the VarList* in the cell, not the VarList* that the Details was coupled with.</p>
<p>But wait: the VarList* in the Cell is an arbitrary coupling, with arbitrary tweaked values.  You may have overwritten an argument with a specialized value, that needs checking.  So you can't use that list instead of the VarList* the Phase was coupled with.  <img src="https://forum.rebol.info/images/emoji/twitter/exclamation.png?v=12" title=":exclamation:" class="emoji" alt=":exclamation:" loading="lazy" width="20" height="20"></p>
<p>Exploring this problem further: if PARAMETER! antiforms are indicative of needing to gather that argument, what happens if you tweak it?</p>
<pre><code> &gt;&gt; ap-int: copy meta:lite append/

 &gt;&gt; ap-int.value: anti make parameter! [integer!]  ; or whatever syntax
 == ~#[parameter! [integer!]]~  ; anti

 &gt;&gt; /ap-int: anti ap-int
 == ~#[frame! ...]~  ; anti
</code></pre>
<p>Does this mean you've just created a variant of the APPEND function that only takes integers for the value to append?  Well, not so fast.  APPEND is native code, what would happen if you added a type check which would allow types to pass that weren't legal for APPEND?  You still have to run APPEND's type check.</p>
<p>There's no way to check programmatically if one type constraint is a subset of another.  So if you're allowed to re-type parameters, they have to go through both checks...somehow.</p>
<h2><a name="p-7929-not-so-simple-5" class="anchor" href="https://forum.rebol.info#p-7929-not-so-simple-5"></a>Not So Simple...</h2>
<p>This makes it seem like AUGMENT needs to pay for a trivial Details, in order to get its VarList into a Phase position.  (A trivial Details can be 8 platform-pointers in size, it's not a huge deal, but annoying.)</p>
<p>And it makes it seem like you can't update FRAME! slots that are PARAMETER! antiforms to be new parameter antiforms, without some yet-to-be-designed mechanic... because there's only one type check when slots are filled, and that is that.</p>
<p>Furthermore... if there's no moment of type checking and a specialization is just a Cell that pairs together a VarList* and a Details*, you'd have to type check a specialization every time it's called.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>This shows a feature of the previous creation of a "Specialization Details" when making an ACTION!, that defined a moment where you could check all the VarList slots and make that the Details's new VarList.</p>
<h2><a name="p-7929-so-frameaction-unification-was-a-mistake-6" class="anchor" href="https://forum.rebol.info#p-7929-so-frameaction-unification-was-a-mistake-6"></a>So FRAME!/ACTION! Unification Was A Mistake?</h2>
<p>Well, not so fast.  I'm just mapping out the territory.  <em>(There's actually more to consider when you weigh in things like partial specializations which specify the use of a refinement, but not the specific value for that refinement, which has to encode ordering and other issues.)</em></p>
<p>It may be that when you invoke a FRAME! as if it were an action, then it remembers if the type check passed when the arguments were filled in.  If it does pass for everything, then it knows that it must have passed the specialized portions, and then marks it ok to not have to test the specialized portions the next time.  This means that if you try and call a "fresh" frame function with bad arguments, you won't validate it, but since the call raised an error that extra typechecking is probably not a big issue, and it will just try again next time.</p>
<p>Re-typing a PARAMETER! appears to be more involved than first thought.  Just filling in a FRAME! slot isn't going to do it, you'd need another operation.</p>
<p>Anyway, this has been driving me crazy the last few days so I had to write something down about it.  I definitely underestimated just how many issues were folded in with the "hardening" process that creating a Details brought about...and how many features were tied into Details* being a unique "action identity".  I'm going to have to experiment a bit before I can resolve what's best here.</p> ]]></description>
        <link>https://forum.rebol.info/t/frame-action-duality-examined/1898#post_2</link>
        <pubDate>Wed, 27 Nov 2024 22:08:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7929</guid>
      </item>
  </channel>
</rss>

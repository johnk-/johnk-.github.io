<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So... Why Shouldn't NULL Be Done With <code>~null~</code> isotope ?</p>
</blockquote>
</aside>
<p>I might as well throw in the adjunct question of: <strong>"Why shouldn't VOID be done with ~void~ isotope?"</strong></p>
<p>It's worth noting that regardless of whether NULL is represented as <code>~_~</code> isotopes or <code>~null~</code> isotopes, it used to merely be said as having "no representation".  That's true of isotopes also, but there's been a standard that the interface shows an isotope by printing the quasiform and then commenting it as <em>"oh, it's actually an isotope state"</em></p>
<p>At that time, the console had a special exception for displaying nulls.  And the "quoted" form of null was just a single apostrophe with nothing after it:</p>
<pre><code>&gt;&gt; null
; null

&gt;&gt; quote null
== '

&gt;&gt; '
; null
</code></pre>
<p>This was all conceived before the idea of having a meta state for void, because voids just vanished.  But as things shuffled around, I came to think that this "no representation" made more sense for voids...</p>
<pre><code>&gt;&gt; '
; void

&gt;&gt; quote void
== '

&gt;&gt; meta void
== '

&gt;&gt; 1 + 2 '
== 3
</code></pre>
<p>Having a META state that is quoted vs. quasi puts VOID in a bizarre middle ground of not being isotopic.  Yet void can't be put in a block.  Though I've argued that we might also see it as that you can put infinitely many voids in a block...</p>
<pre><code>&gt;&gt; append [a b c] '
== [a b c]

 &gt;&gt; append [a b c] comment "hi"
 == [a b c]

 &gt;&gt; first []
 == ~null~  ; isotope (new proposal as word isotope vs isotopic blank)

 &gt;&gt; append [a b c] first []
 ** Error: Can't append ~null~ isotope (see MAYBE)

 &gt;&gt; maybe first []
 ; void

 &gt;&gt; append [a b c] maybe first []
 == [a b c]
</code></pre>
<p>Generally speaking I'm pleased with that.  Though it means if you wind up setting a variable to void, it will look kind of slight:</p>
<pre><code> &gt;&gt; make object! [x: comment "hi"]  ; might require a SET/ANY or similar
 == make object! [
     x: '
 ]
</code></pre>
<p>Why not push it the other way, and say that void states are isotopic?</p>
<p><strong>One key value of saying that void states are "ordinary" is that it means they have an isotopic form, and that isotopic form is rendered as just <code>~</code>.</strong></p>
<p>This isotopic void state of <strong><code>~</code></strong> is being used as the "truly unset" state.  An even meaner idea of complete absence of value than void.  I'm of the belief that it's important to have this not be the same thing as void, because the tolerance of void by so many constructs (including things like ANY and ALL to skip them, or opting out of APPENDs, or making SELECTs just return a null).</p>
<p>The design of the system is such that the quote byte of 0 means isotopic status (e.g. "quote level negative 1" is represented by 0), and the void type is a 0 byte.  So you can memset() an area to 0 and get all unset states (typically an optimized operation).  And the operating system clears all memory to 0 before giving it to your application as well.  It's kind of pleasing that such a representation gives you a nice unset state.</p>
<p>It seems to me that the pieces of the puzzle fit together better this way.</p> ]]></description>
        <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/2</link>
        <pubDate>Tue, 25 Oct 2022 13:14:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6494</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Well I told you that my time to work on hobby projects like this is very limited, even when I think I can spend over an hour, it will be likely that some interruption will occur within the next 5 minutes, dragging me away.<br>
Even a git workflow apparently changes over time and given the intervals between when I need to use this, keeping up with that is not worth the trouble and certainly not something I will remember how to do.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think systems development seems to annoy you more than intrigue you.</p>
</blockquote>
</aside>
<p>Well let's say that I do want to spend my time on the real matters, not on the gits, githubs, and other obstacle courses to get to it.</p>
<p>AH, time's up, gotta run! cu later!</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/11</link>
        <pubDate>Tue, 25 Oct 2022 07:21:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6493</guid>
      </item>
      <item>
        <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The concept of having isotopic <strong>~true~</strong> and <strong>~false~</strong> as WORD! isotopes instead of having a distinct LOGIC! type is admittedly somewhat weird.  It means they can't be put in blocks and need some sort of transformation if they're going to be put into blocks.</p>
<ul>
<li>
<p>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</p>
</li>
<li>
<p>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</p>
</li>
<li>
<p>Your circumstance may mean that neither of those choices are what you want when in a situation where the isotopes can't work...maybe it means you have to rethink what you're doing, or maybe you want some other transformation.  It's good to be alerted to the fact that it's dodgy to put what you think of as a "logic" in a reified context.</p>
</li>
</ul>
<p>One should note that Lisp has no false at all, only NIL for false (since everything else is truthy, you could use anything else for true, but they have T predefined).  But their NIL isn't isotopic--so it can appear in lists literally.</p>
<p>And as I've repeatedly pointed out, Redbol's historical choice to render LOGIC! conflated with the words <code>true</code> and <code>false</code> (instead of <code>#[true]</code> and <code>#[false]</code>) shows a desire to avoid the logic literals "escaping" into the reified consciousness of the user.  Making the logic forms actually impossible to put into blocks without a conscious transformation feels like it's good.</p>
<p>I know it's a strange choice, but it's seeming like it fits with the territory.  It's a sort of tradeoff you need when you choose to be firm that TRUE and FALSE are redefinable words and not lexical forms of logic constants.</p>
<h2>So... Why Shouldn't NULL Be Done With <code>~null~</code> isotope ?</h2>
<p>Right now what I call "null" is isotopic BLANK!.  It is not pretty looking:</p>
<pre><code>&gt;&gt; null
== ~_~  ; isotope

&gt;&gt; _
== ~_~  ; isotope
</code></pre>
<p>But what <em>is</em> pretty looking is that if you assign a bunch of variables to null, the fact that blanks evaluate to the null isotope gives a great visibility to where the actual values to pay attention to are:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>If we used a word isotope, then at source level we're writing:</p>
<pre><code>obj: make object! [
    alpha: null
    beta: null
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: null
    omega: 'now
 ]
</code></pre>
<p>And if we view it after evaluation that fetches (<code>null</code> =&gt; <code>~null~  ; isotope</code>), it gets uglier:</p>
<pre><code>make object! [
    alpha: ~null~
    beta: ~null~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~null~
    omega: 'now
 ]
</code></pre>
<p>We can't show it as the WORD! null because there's no guarantee that word always will evaluate back to the null isotope.  But the concept is that since BLANK! can't be redefined, we can put it in an evaluative context as a substitute for <code>~_~</code> if we want.</p>
<p>If we were "more honest" and just META'd the isotopic blank, we'd get renders like:</p>
<pre><code>make object! [
    alpha: ~_~
    beta: ~_~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~_~
    omega: 'now
 ]
</code></pre>
<p>But I might actually like that less than seeing <strong><code>~null~</code></strong> there.</p>
<h2>Things To Weigh In This Consideration</h2>
<p>I'm really torn.  Certainly having people be able to see ~null~ written out as a word corresponds to what we want to refer to the state as.  We aren't going to replace people's vernacular to say "isotopic blank" instead of null.  And trying to teach people "isotopic blank is null" is an uphill battle.</p>
<p>Let's look back at that seemingly beautiful situation with all the blanks-to-nulls at source level:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>But, hmmm.  The <strong><code>~</code></strong> is now an assignable state meaning variable is not set.  How often will you want to set something to NULL...which won't generate an error on access like being unset would, but is falsey and can't be passed to many routines without a MAYBE?</p>
<p><strong>Statistically, we might often have a situation where NULL is the minority initialization, more like this:</strong></p>
<pre><code>obj: make object! [
    alpha: ~
    beta: ~
    delta: true
    epsilon: null
    gamma: "nutty"
    rho: ~
    omega: 'now
 ]
</code></pre>
<p>My point is that intentionally initializing things to null may not be as common as setting to an error-provoking unset state.  And when null happens it may be just as noteworthy to call out as setting something to true or false.</p>
<h2>Are There Technical Barriers To This?</h2>
<p>It has some of the same problems as having to deal with the type checking of LOGIC! actually being an isotopic subclass of two words.  It means <code>&lt;opt&gt;</code> is an isotopic subclass of one word, so there's no specific null datatype.  :-/</p>
<p>I was already saying that TYPE OF NULL was probably an error, and TYPE OF MAYBE NULL would be void... anyway, this fits into some of the same type issues that logic has.</p>
<p>Previously NULL cells held nothing, so I'd put a payload of the file and line that were in effect in the evaluator.  This was supposed to give better errors about where a null originated from.  This could still be done if NULL was a special case of WORD! isotope that said it was null via a flag vs. storing the symbol, but could be complicated.  None of the better error mechanics were done yet.</p>
<p><strong>My general intuition is that from a user's standpoint, it's an uphill battle to teach them isotopic blank is something called "null"... and that the majority of technical problems that are involved in making NULL be a word isotope are problems that have to be tackled anyway with true and false as word isotopes.</strong></p>
<p>Additionally, I've written about my desire for BLANK!s to serve in dialects as spaces.  That gets very screwed by the (<strong><code>_</code></strong> =&gt; <strong><code>~_~</code>  ; isotope</strong>) evaluation.  Recovering blank for space intent would be good.</p>
<p>I'm going to likely give it a shot, when I get some programming time again, hopefully soon.</p> ]]></description>
        <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/1</link>
        <pubDate>Tue, 25 Oct 2022 04:07:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6492</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="iArnold" data-post="5" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>Long time ago I tried building on Ubuntu myself, to find that something happened with the blanks! in the script not being accepted anymore.</p>
</blockquote>
</aside>
<p>That is because there were some changes to the bootstrap to make the older executable act more like the newer executable.  You'd written some extension configuration based on old build system files that needed to be updated.</p>
<p><a href="https://github.com/metaeducation/ren-c/compare/master...r3n:ren-c:gtk3and4">I did those changes in July</a>. And as I mentioned at the time, what was left was a linker error in the automated build related to GTK.  I said that was something you would need to research.</p>
<p>So resolving the linker error would have been a good thing to tackle before merging more things that would restart the situation again of needing me to sync it up.</p>
<p>In fact, the particular blank behavior may even <a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989">wind up being undone</a>, due to new considerations.  :-/</p>
<aside class="quote no-group" data-username="iArnold" data-post="7" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>I had some "fun" with github/git tonight that has cost me my time and energy</p>
</blockquote>
</aside>
<p>I generally do not use merging, but I rebase instead.  This allows you to play back each commit one at a time, and resolve the differences at every step.</p>
<p>If you're merging with 1000 commits--and things are added and removed at each intermediate point which conflict with your changes--then that may sound laborious.  You might find yourself resolving against things that ultimately get deleted, so it could seem like you wasted time.  It could seem that merging the final states together is less work.</p>
<p>But in practice, all those 1000 commits wouldn't conflict.  Just some of them--and I think it's much more sane and educational to resolve the individual commits "as they happen" and make sure you can get a working build each time.</p>
<p>However this requires understanding how to rebase and to have a really comfortable feeling with how branching and staging and "HEAD" and all of those other things work.</p>
<aside class="quote no-group" data-username="iArnold" data-post="9" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>Yes, the odd thing here is how are you supposed to work from the command line if passwords are no longer accepted and my 2FA is not invoked?</p>
</blockquote>
</aside>
<p>These mechanisms do keep changing and evolving.</p>
<p>You can generate a personal access token and use it like a password, but it's not something you get to type and remember... so you have to copy/paste it from some local file you keep... and it expires so you have to keep regenerating it.</p>
<p>It's valid to be frustrated at technology and how the world is.  But... y'know, sometimes you just have to commit yourself to raising your level of understanding.  Git is one of those things where the payoff to mastering it is high.  And it's also a real liability in the software industry to not be fluent.</p>
<p>I go between SmartGit and the command line, and I'm sure that some 1-on-1 screencast tutoring of seeing my workflow for things would be informative for you...but...I'm busy these days.  Maybe there's some kind of online git school that gives you puzzles to sort out, and then shows the kinds of ways to solve them?</p>
<p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></p>
<p><a href="https://ohmygit.org/">https://ohmygit.org/</a></p>
<p><a href="https://github.com/git-game/git-game">https://github.com/git-game/git-game</a></p>
<aside class="quote no-group" data-username="iArnold" data-post="5" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>Sure I know you cannot be bothered by me not being able to build REN-C. But if I can't chances are others also cannot build it. Which is good when "we" do not want too much activity in "our" world. Such a situation I would classify as unfortunate.</p>
</blockquote>
</aside>
<p>I'm bothered by a lot of things, but people not being able to build it isn't really that high on the list.  People familiar with what it takes to build interpreters and compilers would not find it that odd.</p>
<p>I think systems development seems to annoy you more than intrigue you.  It requires a certain kind of patience and willingness to go deep in the mastery of things.  And I can speak to the fact that much of it has gotten more annoying... and the only thing that shines a light on it is stuff that you would probably not enjoy either (e.g. modern C++, Haskell, Rust...)</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/10</link>
        <pubDate>Tue, 25 Oct 2022 02:53:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6491</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Thanks Ingo,</p>
<p>Yes, the odd thing here is how are you supposed to work from the command line if passwords are no longer accepted and my 2FA is not invoked?</p>
<p>Now I had to accept a complete stranger website that happened to be home of a git gui client with my credentials to github, which personally I consider a HUGE LARGER security risk over a well chosen password.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/9</link>
        <pubDate>Fri, 21 Oct 2022 17:17:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6490</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>If I run into problems updating a repo,I normally just delete it, and then clone anew.</p>
<p>Of course hoping I have not made any changes in said repo, which normally holds true.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/8</link>
        <pubDate>Fri, 21 Oct 2022 11:41:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6489</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="6" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>It's not like we would expect a run on ren-c, just because binaries are downloadable.</p>
</blockquote>
</aside>
<p>LoL!<br>
I had some "fun" with github/git tonight that has cost me my time and energy to update my repo's and resulting in a merge mess of differences between HEAD and index and no clue as to which is which and smartgit not telling and not letting me select which version to pick over the other, and finally resulting in a failed build because it was the gtk branch that was probably suffering from a wrongly chosen update. But then again I have no idea what I have done, cause I had a proper script, sequence of instructions, to do my update but git wanted my password and then said "no more passwords accepted for updates". So completely lost again. My solution probably will be to go uninstall git and reinstall, if I could I would probably uninstall github itself <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
<p>Well, git-hell.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/7</link>
        <pubDate>Thu, 20 Oct 2022 21:51:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6488</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>I'm regularly building on Ubuntu and it works like charm. You may need the correct r3 executable for the make process, though.</p>
<p>Being able to download the binaries which are built anyway would be good. It might lead to some additional testing, and yes, these are debug builds and not optimized for speed.</p>
<p>It's not like we would expect a run on ren-c, just because binaries are downloadable.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/6</link>
        <pubDate>Thu, 20 Oct 2022 13:09:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6487</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>To be clear, I build it every day...and there are <a href="https://github.com/metaeducation/ren-c/actions/workflows/windows-msvc-build.yml">GitHub Actions that keep it going</a>, demonstrating 32-bit and 64-bit builds.</p>
</blockquote>
</aside>
<p>Right what happens with the build executables? Are the most recent ones downloadable so nobody actually has to build them, unless they make changes in the sources to experiment / develop new features.</p>
<p>Running in the web/browser is not my cup of tea and certainly given the quirks of FireFox lately with mouseovers over links not even showing the links, and when reporting FF devs go "it is open source, you can fix it yourself" this feeling does nothing good to that. I feel much more like I need a tool in my toolbox and I want the tool to be on my platform of choice, not on the browser on the platform of my choice, if I wanted a tool on the browser platform perhaps I would already have gone with one of the alternatives.</p>
<p>My view is, the tool is available just on the platform (Windows and a Posix) and supporting it on the browser is good for the cases the platform itself is a more exotic one or to be used to prevent users from installing a thing. I should say I see users and developers as two categories, the second is a species that will be in danger of extinction because everything will be shielded off. It is also why I feel the need for a tool on the platform itself.</p>
<p>Long time ago I tried building on Ubuntu myself, to find that something happened with the blanks! in the script not being accepted anymore. I should try to build again, hope I find the time to do so soon, unfortunately my time is always fragmented into tiny chunks, and hope this has been fixed in the meantime.</p>
<p>Sure I know you cannot be bothered by me not being able to build REN-C. But if I can't chances are others also cannot build it. Which is good when "we" do not want too much activity in "our" world. Such a situation I would classify as unfortunate.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/5</link>
        <pubDate>Wed, 19 Oct 2022 12:50:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6486</guid>
      </item>
      <item>
        <title>Default Values And MAKE FRAME!</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1412">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Anyway, long story short, I think the baseline mechanics of FRAME! has to be as-is.</strong> Whatever else is an exception and should be handled specially. If you want a ^META parameter, that should be something that happens after the function starts running. This improves matters greatly.</p>
</blockquote>
</aside>
<p>As is often the case... the old way had right parts, the new way had right parts, and the answer is going to need... nuance.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></p>
<p>The way it works today, frames are initialized to "nihil" (the isotope of void), because <strong><code>~</code></strong> is what denotes the unset state.  For I-believe-to-be-good-reasons, it's no longer a synonym for void itself (the meta/quoted form of void is a single <strong><code>'</code></strong> apostrophe):</p>
<pre><code>&gt;&gt; f: make frame! :append
== make frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]
</code></pre>
<p>While fetching such variables should be an error by default, I've also said that I like the idea of this being an easy, legal assignment... so you can say <strong><code>(var: ~)</code></strong> to unset it.</p>
<p>I've also become attached to saying that true and false are actually WORD! isotopes, and although you can't put isotopes in blocks...you can freely assign these to variables, and retrieve them from variables.</p>
<pre><code>&gt;&gt; flag: true
== ~true~  ; isotope

&gt;&gt; flag
== ~true~  ; isotope

&gt;&gt; reify flag
== true

&gt;&gt; meta flag
== ~true~
</code></pre>
<p><em>It would be annoying if you could not directly assign a ~true~ or ~false~ isotope to a variable in a frame, and had to use some kind of ^META parameter convention to process it.</em></p>
<p>Yet I'm suspicious of being able to put parameter packs (isotopic blocks) or isotopic errors into a variable... <em>ever</em>:</p>
<pre><code>&gt;&gt; ~['10 '20]~
== ~['10 '20]~  ; isotope

&gt;&gt; value: ~['10 '20]~
== 10

&gt;&gt; set/any 'value ~['10 '20]~
== ~['10 '20]~  ; isotope (sketchy!)

&gt;&gt; :value
== ~['10 '20]~  ; isotope (sketchy!)
</code></pre>
<p>It is likely the case that isotopes fit into categories of things that can be assigned to variables literally, and things that cannot.  Keeping with the terminology, these might be called <strong>stable isotopes</strong> and <strong>unstable isotopes</strong>.  And the only way you can capture an unstable isotope is to transform it into some stable form, e.g. with META or REIFY:</p>
<pre><code>&gt;&gt; value: meta ~['10 '20]~
== ~['10 '20]~
</code></pre>
<p>Yet recall that with <strong><code>~</code></strong> and <strong><code>~true~</code></strong> and <strong><code>~false~</code></strong> (and <strong><code>~_~</code></strong> for null), it would seem we have a proof case that stable isotopes <em>exist</em>.</p>
<p>But there are other stable isotopes.  e.g. now ACTION! isotopes are used to be the form of action that runs from a variable reference.  Hence by definition you need to be able to store these in variables, and they are stable also.</p>
<p>How about splices?  Is there any great reason to make them unstable?  The following seems useful...</p>
<pre><code>&gt;&gt; data: spread [d e]
== ~(d e)~  ; isotope

&gt;&gt; append [a b c] data
== [a b c d e]
</code></pre>
<p>And if you're going to specialize a function like APPEND, shouldn't you be able to just write:</p>
<pre><code>apde: specialize :append [value: spread [d e]]
</code></pre>
<p>And this is where I was talking about the hassle of forcing these isotopes to be communicated by the ^META protocol, because if it meant you would sometimes take splices, you would <em>always</em> need to quote values you were appending... that was a headache.  So we want as few of these ^META functions as we can possibly have.</p>
<p>Yet fetching without complaint makes it very easy to unintentionally get effects you weren't intending, like if you didn't realize DATA was a splice isotope and expect exactly two items here:</p>
<pre><code>&gt;&gt; reduce [1 data]
== [1 d e]
</code></pre>
<p>We might say that the table stakes for showing you are aware that something "weird" is going on is on the access side, to use a GET-WORD!</p>
<pre><code>&gt;&gt; reduce [1 :data]
== [1 d e]
</code></pre>
<p>Yet do note that if DATA were bound to a function, that function could return an isotope like SPREAD does, putting you back at the point of being unable to tell from the callsite how many elements will be resolved to.</p>
<p>Hm.  Well, needing to use a GET-WORD! doesn't feel all that oppressive, and it offers some light protection that historical precedent has also offered (if a function in R3-Alpha/Red returns an UNSET! that's not an erroring condition, but if you get an unset out of a variable it will error without a GET-WORD!)</p>
<h2>This Means ^META Arguments Must Be Special</h2>
<p>I suggested this:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1412">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Anyway, long story short, I think the baseline mechanics of FRAME! has to be as-is. Whatever else is an exception and should be handled specially. If you want a ^META parameter, that should be something that happens after the function starts running. This improves matters greatly.</p>
</blockquote>
</aside>
<p>But now I'm saying that really there are just more isotopes in the stable family, communicated "as-is" to functions.</p>
<p>Yet when unstable isotopes are needed to be considered as parameters, the inability to encode them in variables "as is" would necessitate passing them via ^META conventions.</p>
<p>Consider RETURN.  There is a RETURN/FORWARD that if you are returning a pack (isotopic block) actually returns the entire isotopic block, not just the first value.  So this falls under the "can't do it without meta" category.</p>
<p>What about SET?  At first it would seem to not have the problem, because it's setting a variable and everything it can take is representable in a variable (by definition).</p>
<p>But... if we leave <strong><code>~</code></strong> isotopes as the "I didn't specialize that" state of frames, and if <strong>SET</strong> doesn't take its argument as a <strong>^META</strong> parameter, then there's no way to SET something to an unset state... without some mitigation.</p>
<p>Possible mitigations:</p>
<ol>
<li>
<p>just make UNSET a distinct native that's a completely distinct entry point, and argue you don't use SET to unset variables with a function</p>
</li>
<li>
<p>during typechecking, nihil arguments are left as nihil if they're not refinements, vs. being set to null</p>
<ul>
<li>
<p>this means if you're trying to set a variable's state from a refinement instead of a normal argument, you would not get full coverage of all possible variable states</p>
</li>
<li>
<p>this also means that if a normal argument is marked as being optional/nullable, then not acting on it when doing a MAKE FRAME! would not wind up with it being null as default</p>
</li>
</ul>
</li>
<li>
<p>make the parameter ^META...then let SPECIALIZE compensate for it normally.  But when you want to write an UNSET function that is implemented as a specialization over SET, you build the frame directly and pass the value via ^META conventions</p>
<p>3a. Have a more foundational SET* that takes a ^META argument and lets you unset things, but the plain SET takes a normal argument and does not</p>
</li>
</ol>
<p>I'm rather attached to <strong>(var: ~)</strong> to unset things, so I feel (1) would be inconsistent with that mechanic.</p>
<p>With (3a), having SET* feels like a bad precedent.  It may seem like it's making life a little easier for some people who are writing ADAPT...but I don't think the net benefit outweighs making it a ^META argument.</p>
<p>(2) sounds good in theory, if we're just making a frame and DO'ing it:</p>
<pre><code>&gt;&gt; f: make frame! :set
== make frame! [
    target: ~
    value: ~
    groups: ~
]

&gt;&gt; x: 10
&gt;&gt; f.target: 'x
&gt;&gt; do f
&gt;&gt; x
** Error: x is ~ isotope (unset)
</code></pre>
<p>But if you try to turn a frame into an ACTION! and leave fields as <strong>~</strong>, it treats them as unspecialized.  This is designed to make it easier to write custom specialization functions, built on top of frame mechanics.</p>
<p><strong>It's annoying that this is in the vein of exact problems ^META exists to solve...but you're having to shift to the meta convention to get coverage for <em>just one</em> isotopic state, which almost no one will be specializing functions to use!</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>Annoying though it may be, I think it's going to have to be how it's done.  If this is the biggest problem the whole thing has, then it's not really that bad!</p> ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame/1412/7</link>
        <pubDate>Tue, 18 Oct 2022 19:01:07 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6485</guid>
      </item>
      <item>
        <title>October 2022 General Status &amp; Reflection</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1988">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>With so many aspects of isotopes working out, it's unfortunate that the terrible type system is getting in the way. A dissatisfying answer would be just to say that all isotopes report that they are ISOTOPE! and you have to perform operations on them to find out the actual type... but this is what you historically have to do with items in BLOCK! (you can't typecheck for "block that contains one integer!" vs. "block that contains two strings").</p>
</blockquote>
</aside>
<p>When we think about this, it is the programmer that decides that the things an end-user selects get put inside a block to process the given information, it is also to the programmer to check on the validity of the items inside a block! (type! and value).<br>
That is thus okay.<br>
The problem is that even if the rest of the software development world thinks that fewer than 64 datatypes is sufficient, we the Redbol world occupants really want to expand beyond that limit. What you describe is the (non)solution of having ISOTOPE! call out "hey I am different, but you need to find out for yourself how different exactly". Which is surely not what we really want.<br>
Hence we need a way to expand beyond our 64 datatypes limit.<br>
When there is no room anymore, which is the case, I propose to follow some kind of ASCII to UTF extension trick. This will limit the number of primary datatypes (with a 0 in first position) even more, but other type would then make use of a follow up byte to mark the definitive datatype.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1988">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Also, I'm packing up and moving in less than two weeks and there's a lot to do for that.</p>
</blockquote>
</aside>
<p>Take care, hope you have found a great place to stay!</p> ]]></description>
        <link>https://forum.rebol.info/t/october-2022-general-status-reflection/1988/2</link>
        <pubDate>Sun, 16 Oct 2022 10:08:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6484</guid>
      </item>
      <item>
        <title>October 2022 General Status &amp; Reflection</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><em>Having hit up against some pretty deep questions about redesigning datatypes, I've been taking a break.</em>  It's good to clear one's head sometimes.  Also, I'm packing up and moving in less than two weeks and there's a lot to do for that.</p>
<p>I've been poking around some other languages and tools... tinkering with things like the Rust compiler sources... looking at Stable Diffusion and what sorts of trends are on the rise in open-source AI.  Reading a lot of articles and watching YouTube Videos.</p>
<p>Hopefully some of the datatype-related ideas will settle in my head and I'll be able to start making progress on those.  But I thought I'd review some of what's gone on the last months.</p>
<ul>
<li>
<p>It's certainly worth pointing out that the <a href="https://forum.rebol.info/t/stackless-is-here-today-now/1844">system is using "stackless" processing</a>... which is a significant change, that from a practical standpoint has let us get rid of costly workarounds needed for browser interop in the web build.</p>
</li>
<li>
<p>Changes were made to <a href="https://forum.rebol.info/t/ren-c-is-now-on-the-clouds-with-wasi/1854">permit executing in WASI runtimes</a>, enabling a new cross-platform target as well as being used in "serverless" cloud computing scenarios.</p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/visual-parse-on-the-web-has-arrived/1837">Integrating a rich editor and tabbed interface to the web REPL</a> is a big cool thing.</p>
</li>
</ul>
<p>I could go on about every little thing (like updating the crypto, or that web tests now <a href="https://forum.rebol.info/t/js-testing-with-cypress-io/1778">run on cypress.io</a>) but there are posts and git commits for that.</p>
<p>Nearly every other major change worth discussing involves big changes surrounding isotopes.</p>
<h2>Generalized Isotopes Have Changed (Almost) Everything</h2>
<p>From the beginning, Ren-C's goal has been to attack the fundamental weaknesses in how Rebol works as a language.</p>
<p>Integral to attacks on several major problems has been the idea of <em>"generalized isotopes"</em>.  If anyone hasn't had a chance to read the thread describing the rationale, I suggest doing so now (or re-reading it):</p>
<p><strong><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">"A Justification of Generalized Isotopes"</a></strong></p>
<p>This development kind of touches everything in the system:</p>
<ul>
<li>
<p><strong><a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607">It strikes at the heart of the /ONLY issue</a></strong>.  When you see it used with something like REPLACE, you can really have that "A Ha" moment... that splicing intent should never have been carried by a refinement</p>
<pre><code>&gt;&gt; replace/all [[a b] a b a b] [a b] [c d e]
== [[c d e] a b a b] 

&gt;&gt; replace/all [[a b] a b a b] spread [a b] [c d e]
== [[a b] [c d e] [c d e]]

&gt;&gt; replace/all [[a b] a b a b] [a b] spread [c d e]
== [c d e a b a b]

&gt;&gt; replace/all [[a b] a b a b] spread [a b] spread [c d e]
== [[a b] c d e c d e]
</code></pre>
</li>
<li>
<p><strong><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">"Definitional Errors" have arisen</a></strong> as a crucial combination of solutions: one of the earliest Ren-C mechanics (definitional returns) mixes with a new idea (error isotopes), to give an actual viable answer for error handling in the system:</p>
<pre><code>&gt;&gt; attempt [print "Attempting to read file" read %nonexistent-file.txt]
Attempting to read file
; null

&gt;&gt; attempt [print "Attempting but made typos" rread %nonexistent-file.txt]
Attempting but made typos
** Script Error: rread word is attached to a context, but unassigned
** Near: [rread ** %nonexistent-file.txt]
</code></pre>
</li>
<li>
<p>Moving away from a dedicated "LOGIC!" datatype to <strong><a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">~true~ and ~false~ isotopes</a></strong> solves a "top-of-the-page" representational issue... giving an in-between state that can be held in a variable, but must undergo some reification process before being carried in an array:</p>
<pre><code>&gt;&gt; 1 = 2
== ~false~  ; isotope

&gt;&gt; append [a b c] 1 = 2
** Error: Arrays cannot hold ~false~ isotopes, must REIFY or META

&gt;&gt; append [a b c] meta 1 = 2
== [a b c ~false~]

&gt;&gt; append [a b c] reify 1 = 2
== [a b c true]
</code></pre>
</li>
<li>
<p>Treatment of <strong><a href="https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955">BLOCK! isotopes as "packs"</a></strong> gives answers to how to pipe and transform multi-return expressions... and has also been leveraged as a way to tell the difference between "true null" (e.g. should trigger an else) and "packaged null" (a null packed into a block that is "a positive result that just happens to be null").</p>
</li>
<li>
<p>It has reshaped "voidness"--as something <strong><a href="https://forum.rebol.info/t/non-interstitial-invisibles-more-trouble-than-theyre-worth/1582">which only vanishes in interstitial slots</a></strong>, and can be manipulated conveniently in its isotopic form.</p>
<ul>
<li>Being able to pass voids as arguments enables fully functional compositions, <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">like the infamous FOR-BOTH case</a> of writing a loop wrapper that preserves the loop behavior invariants.</li>
</ul>
</li>
<li>
<p>Isotopes are also covering things like being able to tell the difference between <strong><a href="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881/2">passing an ACTION! you want to run and an ACTION! you want to look for literally</a></strong> (by its identity)</p>
</li>
</ul>
<p>In some sense, this "discovery" has pushed a big reset button on the project... because it affects so many things.  Nearly everything has to be revisited.  But the biggest issue is with the type system.</p>
<h2>Isotopes Further Stress Weaknesses Of DATATYPE! / TYPESET!</h2>
<p>Rebol and all of its clones deal with datatypes in the exact same simplistic way, limiting it to 64 datatypes... with a TYPESET! being a 64-bit number with one bit for each type.</p>
<p>Perhaps there are those out there who think this is fine.  They may see it as like the <a href="https://www.danielsen.com/jokes/objecttoaster.txt">engineer and the toaster story</a>... where making a toaster with very few settings is virtuous, and it's unnecessary complexity to have any more complicated type system.</p>
<p>I've laid out some of my beliefs...such as that "kinds" of values (in a coarse sense) are at the very least based on WORD!, so you can add new things like <strong><code>vector</code></strong> and <strong><code>matrix</code></strong> and <strong><code>image</code></strong>...none of which I believe should be mandatory to build into the core...so lighter builds can be made.</p>
<p>Beyond that I have suggested that getting a full "type" description could be a more descriptive structure, telling you not only that something is a matrix but also giving you its dimensions.</p>
<p>The more these kinds of thoughts seem true, it makes TYPESET! seem like a bogus kind of thing... and type checking functions might make more sense.  Why not something like:</p>
<pre><code>foo: func [bar [integer! series? even?]] [...]
</code></pre>
<p>Performance aside, trading off typesets has some dangerous implications...such as what if a function gets specialized with a value that passes, but either the function or something about the value changes so it wouldn't pass?  As it happens, today's specialized values are written in the place where type information for a parameter would usually be--so you can't typecheck after the fact.</p>
<p>With so many aspects of isotopes working out, it's unfortunate that the terrible type system is getting in the way.  A dissatisfying answer would be just to say that all isotopes report that they are ISOTOPE! and you have to perform operations on them to find out the actual type... but this is what you historically have to do with items in BLOCK! (you can't typecheck for "block that contains one integer!" vs. "block that contains two strings").</p>
<p>Anyway: this is a longstanding problem area, that isotopes are now making it more imperative to solve.</p>
<h2>Still...There Are A Lot Of New And Interesting Things</h2>
<p>The biggest takeaway here is that isotopes have added new dimensions that are letting Ren-C bring really advanced capabilities within reach of very novice users.</p>
<p>There are many examples, but some of the most amazing to me are things like hooking the default UPARSE combinators--which have multiple return values--by being able to turn those return values into blocks and transform them.</p>
<p>So I'm still "finding the cool" in new behaviors, so that's motivating.  But maybe with the basics sorted out, it's getting closer to time to start ripping out some unnecessary parts, so that a committed subset can be pushed out to people on the web.  Will see what I can get done in the next couple of months--travels notwithstanding.</p> ]]></description>
        <link>https://forum.rebol.info/t/october-2022-general-status-reflection/1988/1</link>
        <pubDate>Sun, 16 Oct 2022 04:56:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6483</guid>
      </item>
      <item>
        <title>A Justification of Generalized Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h2>If Isotopes Are So Great, Why Don't Other Languages Have Them?</h2>
<p>In a way, Rebol2 had some inkling of isotopic ideas with errors.  Because an ERROR! couldn't be fetched from a WORD! without triggering an exception...you'd have to DISARM it, and that would convert it into an OBJECT!.</p>
<p>Early on when I was looking at the language, I did wonder if functions should have an "armed" vs. "disarmed" state--like errors.  This arose while trying to generate C code which assigned function variables...kind of along these lines:</p>
<pre><code>r3-alpha&gt;&gt; do compose/only [append-alias: (:append)]
; How to stop APPEND from running, by changing *only* inside the (...) ?
; (and still make APPEND-ALIAS act as a synonym for APPEND)
</code></pre>
<p>I talked myself out of it at the time...because I worried about "hidden bits" like the armed state.  But after years of building on incremental ideas like generic quoting, there are answers to such historical problems.  You can put a quasiform in that slot and it can evaluate to the isotope (itself having no representation, and can't be put in blocks, stopping the spread of this "invisibility").</p>
<p>But why didn't a parallel concept evolve in Lisp or other languages?  Here are some thoughts on reasons...</p>
<hr>
<p><strong>Lisp's quoting is a rendering trick on its list structures, there's not an actual place to store a negative quoting level.</strong></p>
<p>Isotopes are tied closely to the concept of generic quoting, and I've kind of said that they're akin to <em>"having a quoting level of negative one"</em>.</p>
<p>One thing that would hold Lisp back from seeing this as a natural possibility is that there isn't actually a "quoted value type".  When you see quotedness, it's just a rendering trick.  Something along these lines:</p>
<pre><code>lisp&gt;&gt; (print "Hi")
"Hi"

lisp&gt;&gt; '(print "Hi")
== (print "Hi")

lisp&gt;&gt; (quote abc)
== abc

lisp&gt;&gt; '(quote abc)
== 'abc

lisp&gt;&gt; '(quote (quote abc))
== ''abc

lisp&gt;&gt; (type-of '(print "hello"))
== cons  ; someting like "group!"

lisp&gt;&gt; (type of '''abc)
== cons
</code></pre>
<p>On the plus side of not building quote levels into the cells themselves, they can use the existing flexibility of lists to get arbitrarily high levels of quoting.  <em>(Right now Ren-C mechanics only allow 127 quote levels.)</em></p>
<p>But you can see how this would create a pretty big barrier to coming up with an idea like "negative quoting"; it would seem to make no sense.</p>
<p>Also: Like in Ren-C, if you evaluate a quoted structure in Lisp you drop one level of quoting.  But <a href="https://stackoverflow.com/questions/18515295/why-isnt-there-an-unquote-lisp-primitive">they didn't think it worth it to put an UNQUOTE in the box</a> as a narrowed form of EVAL that only took quoted structures.  Without that, one wouldn't be likely to think of wilder things like UNMETA.</p>
<hr>
<p><strong>Lisp's focus on compilation means they wouldn't like the idea of things like runtime conversions of normal values into states that would make a variable act undefined.</strong></p>
<p>This kind of fits in with the fact that a lot of things Rebol does would be off the table for many Lisp implementers.</p>
<p>For instance: Lisp <a href="http://web.cs.wpi.edu/~jshutt/kernel.html">dropped the idea of being able to mark a function's arguments as being quoted at the callsite</a>, because of how much that interferes with compilation:</p>
<blockquote>
<p><em>"The idea of first-class <em>operative</em> combiners, i.e., first-class combiners whose operands are never evaluated, has been around a long time. Such creatures were supported by mainstream Lisps through the 1970s, under the traditional name <code>fexprs</code>, but they made a mess out of the language semantics because they were non-orthogonal to the ordinary variety of procedures constructed via lambda  and, more insidiously, because at that time the mainstream Lisps were dynamically scoped (a language feature that causes more problems for fexprs than it does for the less powerful macros)."</em></p>
</blockquote>
<hr>
<p><strong>Most Languages Use Containers</strong></p>
<p>I've done a writeup of Haskell's Either and Rust's Result, showing some of what's similar about them to isotopes:</p>
<p><a href="https://forum.rebol.info/t/haskell-and-rust-error-handling/1987" class="inline-onebox">Haskell and Rust Error Handling</a></p>
<p>There are actually a fair number of nuances, but isotopes <em>kind of</em> like a container that's available system-wide on every variable... but <em>not</em> array slots.</p>
<p>And because it's systemic and built in, you don't have to think about this containership in advance.  Look at what it takes to return an Either from some sample Haskell code:</p>
<pre><code>parseDigit :: Char -&gt; Either ParseDigitError Int
parseDigit c =
  case c of
    '0' -&gt; Right 0
    '1' -&gt; Right 1
    '2' -&gt; Right 2
    '3' -&gt; Right 3
    '4' -&gt; Right 4
    '5' -&gt; Right 5
    '6' -&gt; Right 6
    '7' -&gt; Right 7
    '8' -&gt; Right 8
    '9' -&gt; Right 9
    _ -&gt; Left (NotADigit c)
</code></pre>
<p>The isotope model is more like letting you say <strong>(<code>'0' -&gt; 0</code>)</strong> and <strong>(_ -&gt; raise NotADigit c)</strong>, so you only have to call out the "weird" cases.</p>
<p>Though there's no truly silver bullet: if you're exchanging reified data via arrays, you can't use isotopes there.  So the convention of "containership" has to be decided on in advance for <em>fully</em> generic code.  (If the code isn't fully generic and you aren't using QUASI!-forms for something else, then the QUASI! can serve as a means of tunnel isotopic intent.)</p>
<hr>
<p><strong>It turns out to be actually really hard to tie these concepts together coherently, and people who undertake such challenges usually wouldn't bother with a runtime model as informal as a Redbol's.</strong></p>
<p>Newcomers to non-rigorous languages like JavaScript will often ask questions along the lines of "hey, why does JavaScript need both null and undefined".  This triggers a lot of conversation about the various practical problems that would happen if you only had one or the other, and usually people throw up their hands and say "what's done is done" and get on with their lives.</p>
<p>A much rarer question would be: <em>"might null and undefined be related in some transformative way, where certain basic operations naturally coerce and promote/demote between them in a meaningful pattern"</em>.  Because that's a sophisticated academic way to think, and people who care about that use "better" languages.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_monocle.png?v=9" title=":face_with_monocle:" class="emoji" alt=":face_with_monocle:"></p>
<p>While someone might suggest this means the isotope design is thus a case of polishing a turd, my recent forays into Rust are reminding me of the unusual and distinct strengths that Ren-C has.  I'm withholding my verdict on whether its future is more than a kind of educational video game, but I think it's at least that... so making the design "click" where it can feels worth it.</p> ]]></description>
        <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918/5</link>
        <pubDate>Sun, 16 Oct 2022 03:52:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6482</guid>
      </item>
      <item>
        <title>Haskell and Rust Error Handling</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Ren-C is shoring up Rebol's historically problematic exception-based error handling by blending together two mechanics: definitional returns and isotopic errors.  This gives what I'm calling "definitional failures":</p>
<p><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852" class="inline-onebox">FAIL vs. RETURN RAISE: The New Age of Definitional Failures!</a></p>
<p>Pivoting to this line of thinking has some non-accidental similarity to <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Either.html">Haskell's <code>Either</code></a> and <a href="https://doc.rust-lang.org/std/result/">Rust's <code>Result</code></a>, which I mentioned when first sketching out the motivation for change:</p>
<p><a href="https://forum.rebol.info/t/the-need-to-rethink-error/1371" class="inline-onebox">The Need To Rethink ERROR!</a></p>
<p>I thought it would be worth it to make a thread for pointing out similarities and differences, and if there are libraries they use that might have relevant inspiration.</p>
<h2>An Out-Of-Band State On The Value Is... Like An Isotope?</h2>
<p>Either is fully generic beyond just allowing errors (and <a href="https://docs.rs/either/latest/either/">Rust has its own generic Either</a> as well).  So you can really say whatever you are returning can come in two forms: the left form vs. the right form.</p>
<p>But even Rust's <code>Result</code> container will permit you to make an Error class the "valid" result, as well as the "invalid" result.</p>
<p>So here we see generic way of letting a value carry a bit--independent of what the payload is--saying whether that is a "normal" state or a "weird" state.  Then, the system has an assortment of operations that are designed for directing program flow in different ways reacting to it.</p>
<p>Ren-C embraces this deeply: effectively saying that every variable and expression product has the potential of being in this "weird" state... and <em>no array can contain a value in the weird state</em>.  But you don't have to do anything special to a value that <em>isn't</em> weird to extract it... you just get runtime errors if you use the weird values where they're not expected.</p>
<h2>Rust Tackles Low-Hanging Fruit via <code>unwrap()</code> and <code>?</code>
</h2>
<p>In Ren-C, if you don't have handling at the callsite when a definitional error happens, it's promoted to being more like a throw--and most code should not intercept it.</p>
<p>Being more formal by nature, both Haskell and Rust force <em>some</em> handling at the callsite when an error result is possible.  You have to define a code path to take if there's an error, or a code path to take if there's not.</p>
<p>But Rust has a couple of conveniences.  If you want something like the Ren-C behavior, you can just call the <code>.unwrap()</code> method on the result.  It will give you the ordinary value if the function didn't return, otherwise raise the error as a "panic".</p>
<p>There's also a cool shortcut with a postfix operator of <strong>?</strong> on the call.  This makes it so that if you call a function that returns a <code>Result</code> type from inside another function that returns a <code>Result</code> type, it will automatically propagate the result if it's an error out of the calling function.</p>
<p>Getting this behavior is more laborious in Ren-C:</p>
<pre><code>foo: func [...] [
    x: bar (...) except e -&gt; [return raise e]
    ...
]
</code></pre>
<p>Implementing the feature as postfix raises its own problems, so let's just imagine we were trying it prefix:</p>
<pre><code>foo: func [...] [
    x: ? bar (...)  ; we want this to act the same as above
    ...
]
</code></pre>
<p>For this to work under the current system, each FUNC would have to define its own <strong>?</strong> operator... because much like definitional RETURN, it would have to know what it was returning <em>from</em> in case of a raised error.</p>
<h2>Haskell Has Generic Compositional Smarts</h2>
<p>As mentioned, the strict compile-time typing in Haskell forces you to be explicit about your reaction when a function returns one of these <code>Either</code> values.</p>
<p>But because Either fits in with monadic/applicative/functor stuff, you can have higher-order operations that <a href="https://lhbg-book.link/06-errors_and_files/01-either.html">can compose together</a> failure scenarios...and gather up failures from several functions or cascade the failure through to where you want.</p>
<p>Ren-C can do this kind of thing as well, such as how you can write higher-order functions like ATTEMPT in usermode, or REDUCE a block of values in one pass with META and get the errors, then react to them later.</p>
<p>But in practice, the lack of a static type system makes this more precarious.</p>
<h2>Links To Error Handling Libraries</h2>
<ul>
<li>Rust's ANYHOW!: <a href="https://docs.rs/anyhow/">https://docs.rs/anyhow/</a>
</li>
</ul> ]]></description>
        <link>https://forum.rebol.info/t/haskell-and-rust-error-handling/1987/1</link>
        <pubDate>Sun, 16 Oct 2022 02:17:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6481</guid>
      </item>
      <item>
        <title>Why (or why not) have UNSET! in Rebol-like Languages</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was merged into an existing topic: <a href="/t/a-justification-of-generalized-isotopes/1918/4">A Justification of Generalized Isotopes</a></p> ]]></description>
        <link>https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/6</link>
        <pubDate>Sat, 15 Oct 2022 20:51:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6480</guid>
      </item>
      <item>
        <title>A Justification of Generalized Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Looking back at a <a href="https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/2">quote from Nenad I have historically taken issue with</a>, we may not actually disagree as much as it first seems.  He said:</p>
<blockquote>
<p><em><strong>"Redbol languages are based on denotational semantics, where the meaning of every expression needs to have a representation in the language itself.</strong> Every expression needs to return a value. Without unset! there would be a hole in the language, several fundamental semantic rules would be collapsing, e.g. <code>reduce [1 print ""]</code> =&gt; <code>[1]</code> (reducing 2 expressions would return 1 expression)."</em></p>
</blockquote>
<p>We actually agree on the part in bold.  The twist is that he goes on from what I think is the true part (<em>"needs to have <strong>a</strong> representation"</em>), and conflates it with the idea that the direct use of an expression's result must behave as something you can put in a block.</p>
<p>I'm saying you should always be able to get to a value to put in a block... but you might need an additional step to get it.  That could be an operation like <code>META</code> or <code>^</code>, which gives a "friendly" (reified) value, but can then be reversed to provide an isotope back.</p>
<p>In Ren-C, PRINT returns not an "unset" state (that's a different isotope) but actually an empty parameter pack isotope (e.g. a multi-return with no returns in it)</p>
<pre><code>&gt;&gt; reduce [1 print ""] 
** Error: cannot splice empty pack ~[]~ isotope in REDUCE (0 results in pack)

&gt;&gt; reduce [1 meta print ""] 
== [1 ~[]~]

&gt;&gt; reduce [1 ^ print ""] 
== [1 ~[]~]
</code></pre>
<p>These are the problems that isotopes are designed to solve!  Without formalizing an isotope mechanism in the language, your choices are:</p>
<ul>
<li>
<p>Write your code manipulating Rebol structures in another language (like C or Red/System)...which is inherently "meta" and can handle the oddness of these states.</p>
<ul>
<li><em>(People should be suspicious when problems with the language are addressed by not using the language!)</em></li>
</ul>
</li>
<li>
<p>Make usermode code struggle with refinements like /ONLY that pushes the oddness off of the values and forces generalized code to shift into a different handling mode.</p>
</li>
</ul>
<p>It's a significant enough problem area to be worth attacking with a generalized solution, that keeps the oddness on the value states where it belongs.  People should have an "a ha" moment about that when seeing things like REPLACE:</p>
<pre><code>&gt;&gt; replace/all [[a b] a b a b] [a b] [c d e]
== [[c d e] a b a b] 

&gt;&gt; replace/all [[a b] a b a b] spread [a b] [c d e]
== [[a b] [c d e] [c d e]]

&gt;&gt; replace/all [[a b] a b a b] [a b] spread [c d e]
== [c d e a b a b]

&gt;&gt; replace/all [[a b] a b a b] spread [a b] spread [c d e]
== [[a b] c d e c d e]
</code></pre>
<p>As I say, when Red tries to solve these kinds of problems without isotopes--e.g. claiming UNSET! is "just another type"--it's like they're doing complex math without complex numbers.  You will hit limits when trying to do nontrivial things.</p> ]]></description>
        <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918/4</link>
        <pubDate>Sat, 15 Oct 2022 20:13:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6479</guid>
      </item>
      <item>
        <title>A Justification of Generalized Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>2 posts were merged into an existing topic: <a href="/t/should-reduce-heed-spread/1917/2">Should REDUCE Heed SPREAD?</a></p> ]]></description>
        <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918/3</link>
        <pubDate>Sat, 15 Oct 2022 19:59:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6478</guid>
      </item>
      <item>
        <title>Q: Should ~ Be The Unevaluated Form of VOID ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1915">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Q: Should ~ Be The Unevaluated Form of VOID ?</strong></p>
<p><strong>YES!</strong></p>
</blockquote>
</aside>
<p>Aaarrgh.  <img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji" alt=":man_facepalming:"></p>
<p>So... with isotopes on the rise, GET-WORD!s like <strong>:foo</strong> were changed back to where it allows you to basically GET/ANY value (because it's not just used for ACTION!s, but other isotope forms).</p>
<p>Now if <strong><code>:mispelld</code></strong> references come back too friendly (as void) we wind up in trouble, because voids are accepted a lot of places.</p>
<p>Before I was saying that this was all right, because no variable should ever be able to represent void legitimately.  But representation has been evolving to where voids <em>can</em> be represented in variables, as a legitimate intent, different from being invalid.</p>
<p><strong>The new conception would be that the contents of an unset variable are <em>void isotopes</em>, something that is an ornery form of less than nothing.</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></p>
<p>This would mean <strong>~</strong> isotope could come back for an ornery value (I still don't want to call this "unset"...we could call it something like "nihil"?).  Then voids could be meta'd as just a plain apostrophe instead of NULL.</p>
<pre><code>&gt;&gt; meta void
== '

&gt;&gt; meta null
== _

&gt;&gt; meta nihil
== ~
</code></pre>
<p>This doesn't look too bad on the surface, and gives COMPOSE slightly more coherence...because you're allowed to compose in voids, not nulls.  So if you've got apostrophes on the outside of a GROUP!, you get the answer you expect:</p>
<pre><code>&gt;&gt; compose ['(void)]
== [']

&gt;&gt; compose ['(null)]
** Error: Can't compose nulls
</code></pre>
<p>Not having a meta-form represented via QUASI! suggests voids not being isotopes.</p>
<p>I don't know if this suggests allowing fetching void variables without an error, but... so long as you deliberately assigned a variable to be void... maybe it's... not that bad?</p>
<pre><code> &gt;&gt; x: if 1 &gt; 2 [print "not run"]

 &gt;&gt; 10 + 20 x
 == 30
</code></pre>
<p>I'm not particularly loving that.  I feel like you should at least have to say <strong><code>:x</code></strong> there, because part of the argument for "void-in-null-out" being rigorous is that voids are hard to get accidentally.</p>
<p>But the point would be that this would mean that <strong><code>~</code></strong> isotopes could go back to being ornery again.</p>
<h2>So NULL Would Be BLANK! Isotope... ?</h2>
<p>This is where things have been headed, I guess.  It resolves some edge case issues.</p>
<p>An entirely different direction could leave blanks alone, and say that ~null~ is a word isotope (in a similar way to my suggestion that ~true~ and ~false~ could/should be word isotopes):</p>
<pre><code>&gt;&gt; null
== ~null~  ; isotope

&gt;&gt; ^ null
== ~null~

&gt;&gt; reify null
== null
</code></pre>
<p>This would also make things more in line with what other languages expect from nullness.  It's rocking the boat to take this other path.</p>
<p>But in the same way that <strong>~</strong> is particularly pleasing as a meta-representation for unset things, I feel like <strong>_</strong> is particularly pleasing for being able to null out variables.</p>
<h2>I Think NIHIL and NONE Are Distinct</h2>
<p>Right now, NONE is the return result of things like PRINT, and it's an isotopic block indicating a pack of parameters...but it's empty:</p>
<pre><code>&gt;&gt; none
== ~[]~  ; isotope
</code></pre>
<p>It makes a lot of sense to me that if you are trying to do an assignment, e.g. with a SET-WORD! or SET-BLOCK!, that this be considered to not have any values to use for the assignment, and error.</p>
<p>But it's visually noisier than the very succinct <strong><code>~</code></strong> isotope.  And also, it's nice to be able to unset variables with that single intent:</p>
<pre><code>&gt;&gt; x: ~
== ~  ; isotope
</code></pre>
<p>Which is contrary to the intent of blocking assignment, that is what NONE is trying for.</p> ]]></description>
        <link>https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915/5</link>
        <pubDate>Mon, 03 Oct 2022 12:54:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6477</guid>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>What about some kind of solution like utf-8 where the ascii characters take up 1 unit and more exotic take up more units?</p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300/11</link>
        <pubDate>Tue, 27 Sep 2022 20:41:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6471</guid>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>To recap: It's a real sticking point that Rebol's historical typeset was tied to the idea of a maximum of 64 types, simply checked by a bitset for each of those things.  That is a very limited concept.  Every Rebol clone has lockstep copied this model--despite sometimes making overtures to the existence of extending types.  (and I point out how R3-Alpha's UTYPE! was complete vaporware in every aspect)</p>
<aside class="quote no-group" data-username="IngoHohmann" data-post="6" data-topic="1300">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>By the same token you could stop showing binaries, blocks and strings in the console.</p>
</blockquote>
</aside>
<p>There's some fairly different characteristics in play.  e.g. when you have ANY-VALUE!, if you load another extension datatype, the set of available types <em>should</em> grow.</p>
<p>This is where I've made the suggestion that ANY-VALUE! might need to just be a "typecheck-flavored function".  So some form of function where you know the implicit meaning is to use it to match types.</p>
<p>Hand-waving what that sort of thing might look like:</p>
<pre><code>any-even!: &amp;(even?)

parse [2 4 6] [some any-even!]
</code></pre>
<p>Implicit here is that we presume that just referencing a function without that twist...e.g. <strong>parse [2 4 6] [some even?]</strong> would get you something different (currently, an error).</p>
<h2>Seems Cool, But What's The Catch?</h2>
<p>A problem with this direction comes down to what happens if you're allowed to change what the words you capture look up to.  I cover this in the <strong><a href="https://forum.rebol.info/t/survey-of-redefining-datatype-word-s/1479">Survey of Redefining Datatype Words</a></strong>.</p>
<p>To sum up: Native code fiddles cell bits under the expectation that the type checking has been done correctly.  If you can change what INTEGER! is defined as--and what the typeset consists of is <strong><code>[integer!]</code></strong>--the guarantees the native expected are broken.</p>
<p>We can harden things by reducing them.  So instead of the native storing <strong><code>[integer!]</code></strong> it stores <strong><code>[&amp;[integer]]</code></strong>, which retains <em>some</em> amount of readability.  But it's not what HELP wants to show, so it either has to reverse-engineer INTEGER! back or keep the source block separately.</p>
<p>If "typesets" are actually "typechecker-flavored functions" it's worse, because they become ugly action literals.  Though there's a modern feature that can help with this being not <em>quite</em> as bad as it was: <strong><a href="https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357">ACTION! symbol caching</a></strong>:</p>
<pre><code>&gt;&gt; any-even!: reduce &amp;(:even?)
== &amp;(#[action! {even?} [value]])
</code></pre>
<p>So EVEN? symbol can still be in there.  But again this isn't what HELP wants...it presumably wants to show ANY-EVEN!.</p>
<p>(I'll point the obvious that when using a typecheck function, it has to remove from consideration anything not a candidate in the component function's type checking.  So if EVEN? only takes INTEGER! it wouldn't try to pass non-integers to EVEN?)</p>
<h2>What About Just Locking The WORD!s Used In Natives?</h2>
<p>I've written this up in the survey post as a possibility:</p>
<pre><code>&gt;&gt; test!: integer!

&gt;&gt; foo: func [x [test!]] []

&gt;&gt; test!: tag!
** Error: Cannot modify TEST! word, locked for use in a type spec
</code></pre>
<p>But I pointed out that it's trickier than it sounds:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1479">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/survey-of-redefining-datatype-word-s/1479/1">Survey of Redefining Datatype WORD!s</a>
</div>
<blockquote>
<p>Though it would have to be a "semantically deep lock". For instance, if it were legal to say:</p>
<pre><code> my-types!: [integer! tag!]
 foo: func [x [my-types!]] []
</code></pre>
<p>...if the way types were interpreted was such that it would pull in types that were grouped in a block like that, then it would have to reach through and lock INTEGER! and TAG! too. This same "deep lock" notion would need to apply to any functions that might be used.</p>
</blockquote>
</aside>
<h2>What About Recursive Typechecks?</h2>
<p>People would be able to write things something like:</p>
<pre><code> types-one!: &amp;[integer! types-two!]
 types-two!: &amp;[block! types-one!]
</code></pre>
<p>This is just a case you'd have to catch.  The typechecker would have to color the array nodes as it went.</p>
<p>(Saying this disproves the idea would be like saying you shouldn't make a spreadsheet with formulas because there can be cycles.)</p>
<h2>Time Has Passed And I Haven't Had Any Better Ideas</h2>
<p>Saving a typeset's definition as a list of words offers the desirable property that what's in a typeset is actually useful for HELP, and can be viewed meaningfully as "source".</p>
<p>If we argue that any word used this way has its meaning become locked, that doesn't mean the word can't have its meaning redefined in another context.  LIB can define INTEGER! one way, but you can have your module define it another.  You can call local variables INTEGER!.  etc.</p>
<p>Locking permits optimizations.  If a typeset says <strong><code>[integer! block!]</code></strong> and it can trust that the meanings of those words have been locked in the context, it could make some cache where it didn't have to look up the words.</p>
<p>I've been circumspect about making this jump.  But besides committing to 64 types and a bitset forever, I just don't see another solution.  Guess I'll give it a try.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300/10</link>
        <pubDate>Tue, 27 Sep 2022 02:13:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6467</guid>
      </item>
      <item>
        <title>Should DATATYPE! Be ANY-WORD! (such as @integer)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="10" data-topic="1177">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>To have clean, non overloaded way to describe datatypes, they would need a dedicated symbol for datatypes.</p>
</blockquote>
</aside>
<p>I think this turned out to be inevitable.  So what I'm working with right now is ampersand, as <strong><code>&amp;[xxx]</code></strong>.</p>
<p>At the moment it's not a <a href="https://forum.rebol.info/t/removing-from-legal-word-characters-any-objections/1180/13">full family of ampersand-things</a> (e.g. TYPE-XXX!).  It's just a rendering of datatype to look like a block! class.  But the idea would be to inch toward the whole family.</p>
<aside class="quote no-group" data-username="IngoHohmann" data-post="10" data-topic="1177">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>Actually I've never used "!" in words myself, so I wouldn't have a problem with enforcing that only types can have "!" in their name.</p>
</blockquote>
</aside>
<p>It's technically possible to remove exclamation points from legal ordinary word characters, and introduce it as a terminal sigil...like a SET-WORD!:</p>
<pre><code>type-word!
</code></pre>
<p>That could be generalized to the other types that carry sigils:</p>
<pre><code>[type block]!
(type group)!
type.tuple!
type/path!
</code></pre>
<p>But there seem to be a lot of reasons to be skeptical of this:</p>
<ul>
<li>
<p>Having types be indirectly referenced through WORD!s--as they were historically--allows for convenient aliasing.  In the Rebol2/Red emulation, we can simply say <strong>paren!: group!</strong> and it works.</p>
</li>
<li>
<p>If you're going to make something like ANY-WORD! refer to a typeset, it doesn't have any obvious separation from the way you refer to a single type.  Other things like type constraints (like EVEN!) also don't have the indirection to their underlying mechanic.</p>
</li>
<li>
<p>I've tended to favor creative uses of ! in terms or dialects...like !!WARNING!!.  And I like the idea of !! meaning breakpoint, or things like that.</p>
<ul>
<li>Though in the case of <strong><code>!</code></strong> and <strong><code>!!</code></strong> they could be exceptions as WORD!s, similar to how there's an exception for <strong><code>/</code></strong> not being a PATH!.</li>
</ul>
</li>
</ul>
<p>In any case, I think <code>&amp;</code> is the better move.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-datatype-be-any-word-such-as-integer/1177/13</link>
        <pubDate>Mon, 26 Sep 2022 09:43:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6464</guid>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>2 posts were split to a new topic: <a href="/t/the-typeset-representation-problem/1984">The TYPESET! Representation Problem</a></p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300/2</link>
        <pubDate>Mon, 26 Sep 2022 08:53:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6459</guid>
      </item>
      <item>
        <title>Where Should Isotope Tolerance Begin (and End)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was merged into an existing topic: <a href="/t/what-should-type-of-an-isotope-be/1983/3">What Should TYPE OF an Isotope Be?</a></p> ]]></description>
        <link>https://forum.rebol.info/t/where-should-isotope-tolerance-begin-and-end/1964/3</link>
        <pubDate>Mon, 26 Sep 2022 08:42:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6458</guid>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was merged into an existing topic: <a href="/t/what-should-type-of-an-isotope-be/1983/2">What Should TYPE OF an Isotope Be?</a></p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300/9</link>
        <pubDate>Mon, 26 Sep 2022 08:41:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6457</guid>
      </item>
      <item>
        <title>Where Should Isotope Tolerance Begin (and End)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was split to a new topic: <a href="/t/what-should-type-of-an-isotope-be/1983">What Should TYPE OF an Isotope Be?</a></p> ]]></description>
        <link>https://forum.rebol.info/t/where-should-isotope-tolerance-begin-and-end/1964/2</link>
        <pubDate>Mon, 26 Sep 2022 08:39:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6456</guid>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>2 posts were split to a new topic: <a href="/t/what-if-datatype-was-isotopic-tl-dr-bad-idea/1982">What If "DATATYPE" Was Isotopic (TL;DR: Bad Idea)</a></p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300/7</link>
        <pubDate>Mon, 26 Sep 2022 08:36:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6455</guid>
      </item>
      <item>
        <title>What Should TYPE OF an Isotope Be?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h2>How Might TYPE* Inform TYPE OF VOID and TYPE OF NULL?</h2>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1983">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>OF is a generic operation (the enfix form of REFLECT that quotes the word on its left. It's desirable to honor the VOID-in-NULL out convention for all the other reflectors that aren't TYPE... and it's desirable to error on NULL more generically.</p>
<pre><code>&gt;&gt; label of null
** Error: You didn't give anything

&gt;&gt; label of maybe null  ; MAYBE NULL is VOID 
; null
</code></pre>
<p>So if <strong>type of</strong> follows the same pattern as other <strong>xxx of</strong>, we'd surmise that you don't use TYPE OF to discern NULL and VOID. It errors on NULL input and gives you back NULL if you MAYBE it.</p>
</blockquote>
</aside>
<p>Above I suggest an XXX OF consistency, with TYPE OF NULL as an error and TYPE OF VOID is NULL.</p>
<p>If that were so, and TYPE* OF VOID is <em>not</em> NULL, then it would be the only case where TYPE* OF would change an answer from what the TYPE OF would say.</p>
<p>Does that suggest not allowing plain TYPE OF either NULL or VOID, and requiring you to use TYPE*, to get some kind of reified answer?  (This would introduce <strong><code>null!*</code></strong> and <strong><code>void!*</code></strong>)</p>
<p>Or does it suggest allowing NULL and not VOID?  (This would introduce <strong><code>null!</code></strong> with no <code>*</code>, and <strong><code>void!*</code></strong>)</p>
<pre><code>&gt;&gt; type of null
== &amp;[null]

&gt;&gt; type* of null
== &amp;[null]

&gt;&gt; type of void
** Error: Use TYPE* to take type of isotopes if intentional

&gt;&gt; type* of void
== ~&amp;[null]~
</code></pre>
<h2>But I've Always Been Uncomfortable With NULL!</h2>
<p><a href="https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658">When discussing why I made the <code>&lt;opt&gt;</code> tag instead of null!</a>, I said:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1658">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658/1">Revisiting `&lt;opt&gt;` in the Func Spec Dialect</a>
</div>
<blockquote>
<p>If a TYPE OF operation can make a reified thing spring into existence out of the absence of a thing, I feel like something is out of whack.</p>
<p>There's a clear advantage if you're going to be chaining things.</p>
<pre><code>x: (type of select data item) else [
    fail "A reified NULL! datatype doesn't permit this kind of handling"
]
</code></pre>
<p>Though that's a more modern intuition about it; I wasn't thinking about that when <code>&lt;opt&gt;</code> was made.</p>
<p>I think one angle is that I felt like the optionalness was somehow a "big deal" and needed to jump off the page for the spec more. NULL! just blended in.</p>
<pre><code>foo: func [arg [null! integer! block!]] [...]
bar: func [arg [integer! block! group! path! null! word!]] [...]
</code></pre>
</blockquote>
</aside>
<h2>I Dislike The Idea Of TYPE* Changing Answers</h2>
<p>Imagine you had code like this:</p>
<pre><code> switch type of (...) [
    null [...]
    integer! [...]
 ]
</code></pre>
<p>But one day you realize the input could be a splice or something, and so <code>TYPE*</code> gets swapped in:</p>
<pre><code> switch type* of (...) [
    null [...]
    integer! [...]
    splice!* [...]
 ]
</code></pre>
<p>It seems to me that the meaning of NULL should not change, all things being equal.  But things are probably not equal.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/exploding_head.png?v=9" title=":exploding_head:" class="emoji only-emoji" alt=":exploding_head:"></p>
<h2>This Is Very Aggravating... but...</h2>
<p>I think I like TYPE OF NULL being NULL</p>
<ul>
<li>
<p>I like it even if it breaks a pattern in XXX OF where VOID input means NULL out, and NULL input is an error</p>
</li>
<li>
<p>TYPE feels like a fairly special kind of question, so it's probably okay</p>
</li>
</ul>
<p>Internally we need a way to put nulls and voids into typesets, and I can imagine usermode cases where this is useful as well.</p>
<ul>
<li>
<p>If TYPE* is able to give a reified answer of NULL!* and VOID!* this would provide some uses</p>
</li>
<li>
<p>This would imply that TYPE* OF NULL and TYPE OF NULL would be different answers</p>
</li>
</ul>
<p>It might be best to avoid a symbol in the type, to signify the weirdness of it.  But in the current design, NULL actually isn't an isotope...void is the isotope of NULL:</p>
<pre><code>&gt;&gt; type* of null
== &amp;[]

&gt;&gt; type* of void
== ~&amp;[]~
</code></pre>
<p>I suspect I'm missing something here.  But as with most things, I guess I just have to kind of try things and feel them out.</p>
<p>So what I'm going to try is a world where function parameters are powered by this <code>TYPE*</code> concept, give the same concept to usermode, and see what emerges from that.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983/3</link>
        <pubDate>Mon, 26 Sep 2022 07:31:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6454</guid>
      </item>
      <item>
        <title>Influences On Startup Time And Memory Use</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="WickedSmoke" data-post="2" data-topic="1972">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/wickedsmoke/40/338_2.png" class="avatar"> WickedSmoke:</div>
<blockquote>
<p>I use "valgrind --tool=massif" to collect data.</p>
</blockquote>
</aside>
<p>Thanks.  I occasionally run Valgrind (catches slightly different things than address sanitizer) but was not aware of this particular tool.</p> ]]></description>
        <link>https://forum.rebol.info/t/influences-on-startup-time-and-memory-use/1972/4</link>
        <pubDate>Mon, 26 Sep 2022 02:06:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6451</guid>
      </item>
  </channel>
</rss>

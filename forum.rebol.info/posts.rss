<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>Should END-able constructs all use ^META parameters?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1783">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Killing off <code>&lt;end&gt;</code> as a core parameter flag would simplify things...</p>
</blockquote>
</aside>
<p>Trying to do this creates an unappealing situation, because it means all ^META parameters start accepting end conditions by default.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>That's a bit of an overreach.  Just because you say you want an argument to be passed via meta protocol, having to handle the ~void~ case of there being nothing there becomes a hassle.  Labeling things <code>&lt;end&gt;</code> is much more convenient, otherwise you will end up with a lot of accidental tolerance of ends...producing particularly troublemaking invisibility signals.</p>
<p>Nevertheless, I think we can say that if you care about the difference between an end and an evaluated NULL then we now have an answer: an endable ^META parameter which receives ~void~ can only get that if at an end.  With what I observed about <strong>^(...)</strong> I think we can say there are no "supermeta" parameters... so the only way you will get a ~void~ indication will be if the evaulation reaches an END (or a comma).</p>
<p>So "endish nulls" are dying, which should get rid of bugs like this:</p>
<aside class="onebox githubissue">
  <header class="source">
      <a href="https://github.com/metaeducation/ren-c/issues/1129" target="_blank" rel="noopener">github.com/metaeducation/ren-c</a>
  </header>
  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Issue">
	  <svg width="60" height="60" class="github-icon" viewbox="0 0 14 16" aria-hidden="true"><path d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/metaeducation/ren-c/issues/1129" target="_blank" rel="noopener">END being tolerated when it shouldn't</a>
    </h4>

    <div class="github-info">
      <div class="date">
        opened <span class="discourse-local-date" data-format="ll" data-date="2021-07-06" data-time="03:35:27" data-timezone="UTC">03:35AM - 06 Jul 21 UTC</span>
      </div>


      <div class="user">
        <a href="https://github.com/hostilefork" target="_blank" rel="noopener">
          <img alt="hostilefork" src="https://avatars.githubusercontent.com/u/20440?v=4" class="onebox-avatar-inline" width="20" height="20">
          hostilefork
        </a>
      </div>
    </div>
  </div>
</div>

<div class="github-row">
  <p class="github-content">&gt;&gt; collect [keep/line [a b c] keep/dup/line [d e f]]
== [
 a b c
 d e f
]
Is missing /DUP count, this...</p>
</div>

<div class="labels">
    <span style="display:inline-block;margin-top:2px;background-color: #B8B8B8;padding: 2px;border-radius: 4px;color: #fff;margin-left: 3px;">type.bug</span>
</div>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
 ]]></description>
        <link>https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783/2</link>
        <pubDate>Sun, 20 Feb 2022 17:34:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5779</guid>
      </item>
      <item>
        <title>Pure vs. Impure Invisibility: Do We Need Both?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1782">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Pondering the potential implications of this form of thinking, it would mean there wouldn't be a form of invisibility that could beat a ^META operation:</p>
<pre><code>&gt;&gt; z: ^ comment ["hi"] ~something~
== ~something~  ; isotope

&gt;&gt; z
== ~void~
   ; ^-- the COMMENT was seen by the ^META, instead of bypassed
   ; (today COMMENT's status as a purely invisible construct means you
   ; would get Z as a non-isotope ~something~)
</code></pre>
</blockquote>
</aside>
<p>It occurs to me that <strong><code>^(...)</code></strong> could be leveraged as a defeat for this.</p>
<pre><code>&gt;&gt; z: ^ comment "hi" 1 + 2
== 3

&gt;&gt; z
== 3

&gt;&gt; z: ^(comment "hi") 1 + 2
== 3

&gt;&gt; z
== ~void~
</code></pre>
<p>Additionally, multi-returns with ^META could defeat invisibility, because multi-return is a syntactic convenience that applies to one-and-only-one function.  So if you meta its result, it can't vanish.</p>
<pre><code>&gt;&gt; [^x]: comment "hi" 1 + 2
== 3

&gt;&gt; x
== ~void~
</code></pre>
<p>This might be enough, actually!</p> ]]></description>
        <link>https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782/2</link>
        <pubDate>Sun, 20 Feb 2022 02:58:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5778</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>3 is also dealing with the shortcomings of the alternatives like there are ugly syntax and dependency hells.</p>
<p>Besides there are holes everywhere, they are more hidden or plugged with another library you do not control.<br>
And most important there is no fun and nothing to learn from option 3 and that is also a rectification for following option 2. We need to remember the state original Rebol was at before Red project started, it was not open sourced and it was abandonware.<br>
The effort of Oldes is imo to be placed as making it work for personal use mainly, like the World language and Boron.<br>
Kaj"s Meta is an interesting alternative bringing Rebol back to some computing roots to get the basics right, without need for fixing R3 or Red designs.</p> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/2</link>
        <pubDate>Sat, 19 Feb 2022 22:16:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5777</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I wrote this to someone in a GitHub issue and thought it was pretty salient:</p>
<blockquote>
<p>What has drawn people to Rebol historically has varied. But a large number who praised it and used it were less interested in the language itself, rather the properties of the executable. It was small, and you could run on any OS without installing anything else...it came with a GUI built in.</p>
<p>But when serious language theorists look at Rebol, they notice it is riddled with design holes. The language itself wasn't <em>composable</em> the way one might like languages to be: mixing constructs in new ways that weren't specifically accounted for never worked. It was more like a "scriptable app" that had a few features that pleased its userbase...and had to be extended by the designer every time a new need came up.</p>
<p>So put briefly: If you don't understand what these holes are, then you won't appreciate the many issues that Ren-C is trying to solve. Starting from scratch inevitably makes the same mistakes.</p>
<p>Once you know that historical Rebol was fundamentally broken, there are basically 3 choices:</p>
<ol>
<li>Inventory and address the holes one at a time and try to fix or mitigate them</li>
<li>Ignore the holes and just hope that if you add enough features and integration no one will notice</li>
<li>Turn away and run from the crackpots using it, and work with a more solidly designed language</li>
</ol>
<p>(1) is Ren-C's hard-chosen path. Energy is spent on identifying certain patterns in source that users <em>must</em> be able to write and have work, if the language is to justify its existence at all. While it would be nice if stack traces were beautiful and if building the sources was 100% easy, all of that would be meaningless if the punch line was <em>"oh, and the language this is all supporting doesn't actually work"</em></p>
<p>(2) is chosen by people like Red and <a href="https://github.com/Oldes/Rebol3">Oldes's branch of R3-Alpha</a>, as well as some clones that have popped up over the years.</p>
<p>(3) is probably the most sensible choice, but if I didn't think there was some promise in the language I wouldn't be pursuing (1).</p>
</blockquote> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/1</link>
        <pubDate>Fri, 18 Feb 2022 19:37:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5776</guid>
      </item>
      <item>
        <title>&lt;skip&gt;-able Arguments</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1013">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Skippable parameters have become an important piece of the system</p>
</blockquote>
</aside>
<p>I've certainly become attached to the feature of skippable parameters.  Of course, anything that is going to be "meta" about making function calls has to decide what to do with them.</p>
<p>One example would be APPLY.  Consider that COMPOSE has a first parameter which is the "Label" that can be (for instance) a tag to label the compose slots.</p>
<p>If you don't provide a label, all the GROUP!s are composed.</p>
<pre><code>&gt;&gt; compose [(1 + 2) (&lt;*&gt; 3 + 4)]
== [3 7]
</code></pre>
<p>But if you do provide a label, only the GROUP!s starting with that label get composed:</p>
<pre><code>&gt;&gt; compose &lt;*&gt; [(1 + 2) (&lt;*&gt; 3 + 4)]
== [(1 + 2) 7]
</code></pre>
<p>So when APPLY is processing parameters in order, what should it do about the label?  It's evaluating the arguments in the block, so I don't think that's very compatible with the hard-quote rule of skippability.</p>
<p>Hence I propose that APPLY always skips over the skippable parameters positionally, and they must be provided explicitly by name.</p>
<pre><code>&gt;&gt; apply :compose [[(1 + 2) (&lt;*&gt; 3 + 4)]]
== [3 7]  ; assumed first parameter was the block, not the label

&gt;&gt; apply :compose [[(1 + 2) (&lt;*&gt; 3 + 4)] /label &lt;*&gt;]
== [(1 + 2) 7]  ; you can still provide a label, just by name

&gt;&gt; apply :compose [[(1 + 2) (&lt;*&gt; 3 + 4)] /label second [&lt;x&gt; &lt;*&gt;]]
== [(1 + 2) 7]  ; evaluations are okay, since you explicitly named it
</code></pre>
<p>This seems the most sensible behavior.</p> ]]></description>
        <link>https://forum.rebol.info/t/skip-able-arguments/1013/3</link>
        <pubDate>Fri, 18 Feb 2022 19:25:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5775</guid>
      </item>
      <item>
        <title>Turning a Blind Eye to Evaluator &quot;Abuse&quot;</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I've gotten kind of attached to the current look and behavior of AND and OR, which allow short-circuiting even though one would not think the language could (should?) be able to.</p>
<p>It doesn't require simple variables be in a GROUP! on the right hand side.</p>
<pre><code>&gt;&gt; if true and true [print "True"] else [print "False"]
True
</code></pre>
<p>...but a function call has to be.</p>
<pre><code>&gt;&gt; foo: func [x] [
      print "Calling foo!"
      return x &gt; 1000
   ]

&gt;&gt; if false and foo 1020 [print "True!"] else [print "False"]
** Error: words/tuples can't be ACTION! as right hand of OR, AND, XOR

&gt;&gt; if false and (foo 1020) [print "True"] else [print "False"]
False

&gt;&gt; if true and (foo 1020) [print "True!"] else [print "False"]
Calling foo!
True
</code></pre>
<p><em>Note that if the thing to the left of the AND is false, it does not run the code in the GROUP! on the right.</em>  This requires that the right hand side be a quoted parameter convention.</p>
<p>Alternatively we could not quote it, and require the right hand side be in a block:</p>
<pre><code>&gt;&gt; if true and [true] [print "True"] else [print "False"]
True

&gt;&gt; if false and [foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p><strong>But I don't like that.</strong></p>
<p>Alternatively we could say we don't offer this and you always use ALL...maybe with COMMA! and maybe not:</p>
<pre><code>&gt;&gt; if all [true true] [print "True"] else [print "False"]
True

&gt;&gt; if all [false, foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p>I just don't think that looks as natural.</p>
<h2>It's Like I Said In <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">"Speaking With Tics"</a>...</h2>
<p>If you think seeing a GROUP! on the right of AND and OR that doesn't unconditionally evaluate at the callsite is weird, why are you comfortable with <strong><code>for-each x [1 2 3] [...]</code></strong>?  That didn't unconditionally evaluate x.  Do you expect it to be <strong><code>for-each 'x</code></strong> instead?</p>
<aside class="quote no-group">
<blockquote>
<p>The quoted parameter convention exists to save you the trouble of quoting the callsites. <em>If this isn't what that's for, then what <strong>is</strong> it for?</em></p>
</blockquote>
</aside>
<p>It's just too nice to be able to say things like <strong><code>if var1 and var2 or (a &gt; b) [...]</code></strong>.</p>
<p>To me, part of what makes the language special is the ability to bend the evaluator to how we want to read code, vs bending code to fit the evaluator.  The existence of mechanics like quoted parameters are there to let this happen.</p>
<p><em>You don't have to use it.</em>  And the ability to switch it to where AND is a prefix operator that does bitwise math is the magic of the freedom of choice.  You can choose to change the definition even on a module-by-module basis, or on a function-by-function basis.</p>
<p>Further: if you're not bending the language, you're probably not really using it.</p> ]]></description>
        <link>https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791/1</link>
        <pubDate>Fri, 18 Feb 2022 18:34:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5774</guid>
      </item>
      <item>
        <title>Should TRAP and CATCH return null if no fails/throws?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="940">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I made ENTRAP to address the problem of distinguishing errors from other values, by returning ordinary values enclosed in a block (unless it's null, which can't be put in blocks, so the entrapped thing is just null)</p>
</blockquote>
</aside>
<p>The world has changed, so now not only can NULL not be put in a block but neither can isotopes.</p>
<p>But we have a better solution than putting things in a BLOCK!... generic quoting and ^META!</p>
<p>Remember that ^META turns nulls into nulls, isotopes into BAD-WORD!s, and adds a quote level to everything else (including BAD-WORD!s and things that were already QUOTED!).</p>
<p>So now ENTRAP can be a simple usermode function built on top of the multi-return form of TRAP, that offers you either the raised error (if applicable) or the evaluative product:</p>
<pre><code>entrap: func [
    {If evaluation raises an error, return ERROR!...otherwise the ^META result}

    return: [&lt;opt&gt; any-value!]
    code [block! action!]
][
    let [error result]: trap code
    return any [error ^result]
]
</code></pre>
<p>Note that you could also do that as <strong><code>let [error ^result]: trap code</code></strong> and then <strong><code>return any [error result]</code></strong>.</p>
<p>This handles every possibility:</p>
<pre><code>&gt;&gt; entrap [1 / 0]
; gives you an ERROR! for division by zero

&gt;&gt; entrap [make error! "an error that isn't raised"]
; gives you a QUOTED! error, so you know it is just a value

&gt;&gt; entrap [print "Hello"]
; gives you a non-quoted BAD-WORD! for ~none~, so you know it's an isotope!

&gt;&gt; entrap [first [~none~]]
; gives you a singly-quoted bad-word, so you know it *wasn't* an isotope

&gt;&gt; entrap [first ['abc]]
; gives a doubly-QUOTED! word, so you know result was a singly-quoted WORD!
</code></pre>
<p>So you can just test if the result is an ERROR? and if it is, then an error was raised.  And if it's not, you UNMETA it and you will get the value (or leave null alone, as UNMETA is a no-op on NULL).</p>
<p>Pretty elegant!</p>
<p><em>(I'd actually thought of getting rid of ENTRAP, but it's actually very useful, especially when dealing with the "libRebol" API...since it is only really good at giving one value back in the C code...so I'm glad it doesn't have to be a separate codebase and can just piggy-back on top of TRAP.)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/should-trap-and-catch-return-null-if-no-fails-throws/940/7</link>
        <pubDate>Fri, 18 Feb 2022 07:34:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5773</guid>
      </item>
      <item>
        <title>Shall we CONTINUE?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>At some point I added the ability of CONTINUE to take a parameter.  The idea was that CONTINUE with a parameter would act the same as if the loop body had completed with that value.  One place this is most useful is MAP-EACH:</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 2 [continue &lt;twenty&gt;] else [x * 10]
   ]
== [10 &lt;twenty&gt; 30]
</code></pre>
<p>But what should CONTINUE with no argument do?  In the MAP-EACH case, I think it should pretty obviously not add anything to the output.</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 2 [continue] else [x * 10]
   ]
== [10 30]
</code></pre>
<h2>Nice.  But what about "ordinary" loops?</h2>
<p>How about WHILE or REPEAT or FOR-EACH?  If we wanted it to be novel, it could say "don't change the pending overall result from whatever the last loop iteration would have returned":</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
]
== 20
</code></pre>
<p>Although I like that in theory, it would break the loop composition rules unless loops were allowed to be invisible.  :-/</p>
<p>Think about the <a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/18">code I've previously written down</a> to implement FOR-BOTH:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each var blk1 body
        meta for-each var blk2 body
    ]
]
</code></pre>
<p>That FOR-BOTH could not have a CONTINUE that would run in the body of the second FOR-EACH and carry over a value from the first FOR-EACH.</p>
<p>Given that we'd be setting a standard that would be difficult to follow, I think the answer has to be:</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
   ]
== ~none~  ; isotope
</code></pre>
<h2>What about UNTIL and CONTINUE TRUE?</h2>
<p>I've given a rule that CONTINUE passed a parameter effectively jumps to the end of the loop body as if it had finished with that value.  But in UNTIL, the loop's body also is the condition.  So what about:</p>
<pre><code>&gt;&gt; until [print "A" if true [continue true] else [&lt;unreachable&gt;]] print "B"
A
B
</code></pre>
<p>It seems to make a certain amount of sense.</p> ]]></description>
        <link>https://forum.rebol.info/t/shall-we-continue/1790/1</link>
        <pubDate>Wed, 16 Feb 2022 04:10:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5772</guid>
      </item>
      <item>
        <title>About the Semantics category</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>While the "Internals" discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what <strong>do []</strong> should return.</p> ]]></description>
        <link>https://forum.rebol.info/t/about-the-semantics-category/1789/1</link>
        <pubDate>Wed, 16 Feb 2022 03:48:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5771</guid>
      </item>
      <item>
        <title>Syntactically Significant Newlines</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="918">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>JSON came from a Rebol heritage, yet people found it weak weak in a couple of areas. So odd-little YAML has come in to pick up some of that slack:</p>
<p><a href="https://learnxinyminutes.com/docs/yaml/" class="inline-onebox">Learn yaml in Y Minutes</a></p>
</blockquote>
</aside>
<p>I feel like I had a post talking more about YAML but can't find it now...</p>
<p><strong>I definitely think the things that have driven YAML's success are too important to overlook.</strong></p>
<p>Right now when creating data-ish things I often have to write:</p>
<pre><code>status: &lt;foo&gt;
description: {
    Here is some multi-line stuff.
    I can be free-form with the text.
}
widget: &lt;bar&gt;
</code></pre>
<p>But those braces are a tax.  We could take backslash, for instance:</p>
<pre><code>status: &lt;foo&gt;
description: \
    Here is some multi-line stuff.
    I can be free-form with the text.
widget: &lt;bar&gt;
</code></pre>
<p>Or something along those lines.  When I use YAML I am finding myself often thinking "this would be really ugly in Rebol".</p> ]]></description>
        <link>https://forum.rebol.info/t/syntactically-significant-newlines/918/5</link>
        <pubDate>Tue, 15 Feb 2022 13:47:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5770</guid>
      </item>
      <item>
        <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="Cplus" data-post="3" data-topic="1787">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/c/0ea827/40.png" class="avatar"> Cplus:</div>
<blockquote>
<p>It seems somewhat of a wasted opportunity that the language has drifted so far from its initiating vision.</p>
</blockquote>
</aside>
<p>Rebol had a lot of disparate elements, and people latched onto different ones... based on which parts they wanted to believe were the most important.</p>
<p>To some people, the lack of dependencies and not needing an install program was key.</p>
<p>To some people, it was very important that Rebol was cross-platform so they could deploy the same programs to customers on Windows/Linux/Mac.</p>
<p>To some people, they couldn't write a GUI on modern systems with other tools to save their life.  So having a way to get a button on the screen with minimal code and not having to figure out what graphics libraries to pick for their language was key.  <em>(These are people who could have used Visual Basic, but felt it was just getting too bloated and unpredictable, and found they liked other aspects of Rebol better.)</em></p>
<p>To some people--myself included--the notion of having a language you could really bend to whatever task you were doing via dialecting was the main draw.</p>
<p>Anyway: point being there are a lot of ideas in it, and wound up with a lot of wishful thinking and projection being put on an artifact that was ultimately too simple and under-designed to live up to the hype.  Carl called it his "grand experiment"...and I think of the usage of "experiment" in the sense of "this might not work".  Some things have worked out better than one would expect, and others have shown to be fairly intractable in the medium.</p>
<aside class="quote no-group" data-username="Cplus" data-post="3" data-topic="1787">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/c/0ea827/40.png" class="avatar"> Cplus:</div>
<blockquote>
<p>And now - nearly 25 years on - we can share neither information nor programs between even closely-related descendants of that initial release.</p>
</blockquote>
</aside>
<p>Data representation is tough, because the structure of data is often connected in weird ways...which you need graph databases to do correctly.  Trying to represent graph structures in text is a very narrow and limited idea.</p>
<p><strong>I think that JSON took most of the low-hanging fruit of what Rebol's base format could have offered in data exchange, and <a href="https://forum.rebol.info/t/syntactically-significant-newlines/918">YAML has actually stepped in</a> for a lot of places where JSON isn't a fit and shown to be better still.</strong></p>
<p>The fact that Rebol did not set up a clear way to lexically exchange objects left it in a tough situation where I think it often works out to be inferior to JSON for most tasks...despite having some superficial niceties of knowing how to--say--exchange dates.  <em>(More often than not, people wind up needing <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> dates anyway, which shows that Rebol's peculiarities aren't always all they're cracked up to be when working in a world that Rebol is not a standard.)</em></p>
<p>Carl seems to have wanted to rethink the object issue--to the point of sacrificing braced strings--see his ASON:</p>
<p><a href="https://forum.rebol.info/t/carls-new-projects-altscript-altos/1571" class="inline-onebox">Carl's New Projects (?) AltScript, AltOS</a></p>
<p><em>(I considered this, but ultimately decided I thought the braced strings were too foundational to what makes Rebol good...so we'll have to address that weakness some other way.)</em></p>
<p>As a thought experiment it would be great to see if Rebol-to-Rebol data exchanges could have a start-to-finish story where the whole experience is better than JSON, without this:</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245.jpeg" data-download-href="https://forum.rebol.info/uploads/default/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245_2_297x375.jpeg" alt="image" data-base62-sha1="6VwcMBpWYvNwVAACi6aobDTlK7P" width="297" height="375" srcset="https://forum.rebol.info/uploads/default/optimized/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245_2_297x375.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245_2_445x562.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245_2_594x750.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">850×1073 168 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>I've written some thoughts here and there about directions I think things might be able to go in the representation:</p>
<p><a href="https://forum.rebol.info/t/block-and-object-parity-in-pathing-picking/1086" class="inline-onebox">BLOCK! and OBJECT! Parity in Pathing/Picking</a></p> ]]></description>
        <link>https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787/4</link>
        <pubDate>Tue, 15 Feb 2022 12:04:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5769</guid>
      </item>
      <item>
        <title>REBOL 1 Manual</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But I'd guess unless Carl himself has a copy of the source of his old website somewhere, it's gone.</p>
</blockquote>
</aside>
<p><a class="mention" href="/u/gchiu">@gchiu</a> apparently has a printout... perhaps we can scan it and OCR/HTML-ify it.</p>
<p>But given that the Rebol2 manual was pretty light on binding explanation, it might not provide much insight relative to having executables to poke at.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-manual/1788/3</link>
        <pubDate>Tue, 15 Feb 2022 01:20:30 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5768</guid>
      </item>
      <item>
        <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
        <dc:creator><![CDATA[@Cplus]]></dc:creator>
        <description><![CDATA[ <p>It seems somewhat of a wasted opportunity that the language has drifted so far from its initiating vision.</p>
<p>The earliest copy of the <a href="http://Rebol.com" rel="noopener nofollow ugc">Rebol.com</a> home page on <a href="http://Archive.org" rel="noopener nofollow ugc">Archive.org</a> is from May 1998. It contains the sentence:</p>
<p><em>The Relative Expression-Based Object Language (REBOL, pronounced "reh-bul") is the language of inter-communications. It supports both the exchange and interpretation of information, and offers an easy way to share information and programs between people, applications, and computers.</em></p>
<p>And now - nearly 25 years on - we can share neither information nor programs between even closely-related descendants of that initial release.</p>
<p>Such is progress.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787/3</link>
        <pubDate>Mon, 14 Feb 2022 13:24:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5767</guid>
      </item>
      <item>
        <title>REBOL 1 Manual</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>Will it be possible to share the manual/guide/documentation for REBOL 1 here? It is a piece of history, and it'll be a shame if it just disappears.</p>
</blockquote>
</aside>
<p>It appears that the documentation was HTML files, but Carl didn't make it so you could click through to them without going through a form until version 2.  Hence <a href="http://archive.org">archive.org</a> couldn't scrape it until then:</p>
<p><a href="https://web.archive.org/web/19981212020708/http://rebol.com/">https://web.archive.org/web/19981212020708/http://rebol.com/</a></p>
<p>If it had been a .PDF or something, then someone might have a downloaded a copy and archived it along with the executable.  But I'd guess unless Carl himself has a copy of the source of his old website somewhere, it's gone.</p>
<p>More likely you could find a Rebol 1 executable someone has around.  Though even that might not be as easy to find as one would think.</p>
<blockquote>
<p>I was reading about some of the design choices in REBOL, and came upon Joe Marshall's writings where he talks about the changes between REBOL 1 and 2 (missing continuations, changed scoping rules, absence of tail recursion, etc.)</p>
</blockquote>
<p>If you haven't gotten a chance to read my own most recent thoughts on what binding/scoping can or should be:</p>
<p><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751" class="inline-onebox">Rebol And Scopes: Well, Why Not?</a></p>
<p>That points to the directions I myself want to keep exploring.  <em>(I've been playing hooky for a couple months and not programming.  But have been taking proactive steps like sending my "work" laptop in for its necessary repairs... and am going to arrange for a place to retreat and design/code for a while.)</em></p>
<p>P.S. Please <a href="https://forum.rebol.info/c/introductions/46">feel free to introduce yourself</a>...</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-manual/1788/2</link>
        <pubDate>Mon, 14 Feb 2022 05:17:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5766</guid>
      </item>
      <item>
        <title>REBOL 1 Manual</title>
        <dc:creator><![CDATA[@DefinitionalUsername]]></dc:creator>
        <description><![CDATA[ <p>I was reading about some of the design choices in REBOL, and came upon Joe Marshall's writings where he talks about the changes between REBOL 1 and 2 (missing continuations, changed scoping rules, absence of tail recursion, etc.). This made me curious about the differences between the two version; however, I can't find anything related to REBOL 1 on the internet (save for a Scheme compiler).</p>
<p>Will it be possible to share the manual/guide/documentation for REBOL 1 here? It is a piece of history, and it'll be a shame if it just disappears.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-manual/1788/1</link>
        <pubDate>Mon, 14 Feb 2022 03:29:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5765</guid>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So I had the idea that <strong>do []</strong> would be <em>conceptually</em> nothing, but represented in some "ornery" reified form.  I was going to represent this with a ~void~ isotope.</p>
<p>But the new revelation I had was that <code>~void~</code> isotopes are best if they are so "unstable" that they disintegrate immediately, only visible with the detector of a <strong>^META</strong> step.  Won't rehash the good reasons for that here:</p>
<p><a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782" class="inline-onebox">Pure vs. Impure Invisibility: Do We Need Both?</a></p>
<p><strong>This doesn't have to crush the idea:</strong> ~none~ isotopes can fulfill the role previously theorized for the ~void~ isotope.  Because isn't that essentially what PRINT returning a <code>~none~</code> isotope means?  <em>"I don't have a useful result, I'd be invisible except for the fact that might be confusing...and someday I might want to have a result that means something."</em></p>
<p>But ANY and ALL no longer need to vaporize ~void~ isotopes... they vaporize themselves.  So this needs to be revisited:</p>
<blockquote>
<p>"I think ANY and ALL are the kinds of construct that become more interesting if they vaporize ~void~ isotopes...and if ALL returns a ~void~ isotope itself if its contents all vaporize!"</p>
<p>"The idea this brings back is the concept of having a third option for value-returning functions... so truthy, falsey, and "opt out". But opting out is not conflated with nullness or unsetness, and it doesn't force unsafe "vanishing" semantics."</p>
</blockquote>
<p>It turned out to be a refreshing simplification when I ripped out the weird code in ANY and ALL to try and facilitate treating ~void~ isotopes as invisible.  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:"></p>
<p>If you wish, you could write a version of ANY that actually vanished if it got a block of nothingness.</p>
<pre><code>&gt;&gt; 1 + 2 vanishable-any [1020 null]
== 1020

&gt;&gt; 1 + 2 vanishable-any []
== 3
</code></pre>
<p>But I think we're likely better off making vanishing of ~none~ isotopes explicit, akin to what used to be called "DEVOID" when ~void~ isotopes were reified/ornery:</p>
<pre><code>&gt;&gt; ~none~
== ~none~  ; isotope

&gt;&gt; 1 + 2 ~none~
== ~none~  ; isotope

&gt;&gt; 1 + 2 none-to-void ~none~
== 3

&gt;&gt; any []
== ~none~  ; isotope

&gt;&gt; 1 + 2 none-to-void any [1020 null]
== 1020

&gt;&gt; 1 + 2 any []
== ~none~  ; isotope

&gt;&gt; 1 + 2 none-to-void any []
== 3
</code></pre>
<p><em>(NONE-TO-VOID is not a perfect name...but I'd consider it a better choice than DENONE.  Other ideas welcome.  VANISHABLE?)</em></p>
<p>You could have a corresponding construct which turned ~none~ into NULL.  Notice that Rebol2 and Red both decided that <strong>any []</strong> should be their concept of BLANK! (e.g. legacy "none").  If you wanted something akin to that via a "NONE-TO-NULL", you could have it:</p>
<pre><code>&gt;&gt; any []
== ~none~  ; isotope

&gt;&gt; none-to-null any []
; null
</code></pre>
<h2>What About The "Loop Control Protocol"?</h2>
<p>I think this policy makes reasonable sense for loops that never run:</p>
<pre><code>&gt;&gt; while [false] [1 + 2]
== ~none~  ; isotope
</code></pre>
<p>Though it aliases with loops that return none incidentally from their bodies:</p>
<pre><code>&gt;&gt; repeat 1 [print "Remember PRINT returns ~none~ isotope"]
Remember PRINT returns ~none~ isotope
== ~none~  ; isotope
</code></pre>
<p>If that's a problem for you then you can force some other return result from the loop body:</p>
<pre><code>&gt;&gt; repeat 1 [print "Control your result", true]
Control your result
== #[true]
</code></pre>
<p>NULL is still the unique signal to say the loop encountered a BREAK, which makes it easier to make composite loops that are sequences of other loops.</p>
<p>But there's no unique signal to say the loop never ran...only that the overall loop operation "provided no meaningful result".  This can play well with NONE-TO-VOID and NONE-TO-NULL</p>
<h2>Today's Loop Story Gets Even Better... <img src="https://forum.rebol.info/images/emoji/twitter/heavy_heart_exclamation.png?v=9" title=":heavy_heart_exclamation:" class="emoji" alt=":heavy_heart_exclamation:">
</h2>
<p>Consider my classic example of a composite loop that actually iterates over two collections:</p>
<pre><code> &gt;&gt; for-both x [1 2] [3 4] [print ["x is" x], &lt;result&gt;]
 x is 1
 x is 2
 x is 3
 x is 4
 == &lt;result&gt;

&gt;&gt; for-both x [1 2] [3 4] [print ["x is" x], if x = 2 [break]]
x is 1
; null

&gt;&gt; for-both x [] [] [print ["x is" x], &lt;result&gt;]
== ~none~  ; isotope
</code></pre>
<p><strong>Trying to write something like FOR-BOTH in historical Redbol and get coherent behavior for BREAK for an arbitrary loop body is effectively impossible.</strong>  (If anyone wants to troll Red, ask them how to do it and watch them give you scrambled broken solutions.)  But modern Ren-C has it covered!</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each :var blk1 body
        meta for-each :var blk2 body
    ]
]
</code></pre>
<p><strong>This isn't that hard to understand:</strong> Remember that META leaves NULL as NULL...turns isotopic BAD-WORD!s into plain BAD-WORD!s...and quotes all other values one level.  So here you're getting a pass through of non-null values, with NULL able to skip past the second loop if a break is signaled in the first loop.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_teacher.png?v=9" title=":man_teacher:" class="emoji only-emoji" alt=":man_teacher:"></p>
<p><em>(Actually needs a small tweak because plain BAD-WORD! is neither true nor false at this time and would need to be truthy, but I will make that change given this new obvious indicator they must be truthy...they're ornery enough by not being accepted as an argument to things like APPEND.)</em></p>
<h2>So That Settles It</h2>
<pre><code>&gt;&gt; first [~none~]
== ~none~

&gt;&gt; if (first [~none~]) [print "plain BAD-WORD! now truthy."]
plain BAD-WORD~ now truthy

&gt;&gt; ~none~
== ~none~  ; isotope (not displayed by console)

&gt;&gt; if ~none~ [print "non-meta arguments can't be isotopes"]
** Script Error: if needs condition as ^META for ~none~ isotope

&gt;&gt; print "The die is cast"
The die is cast
== ~none~  ; isotope (not displayed by console)

&gt;&gt; do []
== ~none~  ; isotope (not displayed by console)

&gt;&gt; while [false] [&lt;never-runs&gt;]
== ~none~  ; isotope (not displayed by console)
</code></pre>
<p>We'll have to debate whether it's a good idea for REDUCE to allow ~none~ isotopes to be converted into plain ~none~ BAD-WORD!s without you asking to do so explicitly:</p>
<pre><code>&gt;&gt; reduce [1 + 2 print "Good or bad idea?"]
Good or bad idea?
== [3 ~none~]
</code></pre>
<p>The conservative decision would be to make people use some function like REIFY to get that.</p>
<p><strong>In the end, the sum of the decisions involved in building the solution shows that persistence ultimately pays off... and the pursuit of non-softball problems like building a 100% correct FOR-BOTH out of two FOR-EACH loops has lent Ren-C its true power.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/18</link>
        <pubDate>Fri, 11 Feb 2022 12:42:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5764</guid>
      </item>
      <item>
        <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The term "Ren" (REadable Notation) was an initiative from--I believe--Gregg Irwin and Rebolek, where the idea was to standardize notations between Rebol and Red in a similar way to how JSON was standardized... then allowing other languages (like Python or JavaScript) be able to read the messages as well:</p>
<p><a href="https://pointillistic.com/ren/">https://pointillistic.com/ren/</a></p>
<p>Since that was in the air at the time...and my fork wouldn't/couldn't be called Rebol(tm), the idea was to embrace the idea and call itself "Ren-C" to be the C implementation of that data structure.</p>
<p>That was long ago.  And you won't hear the term "Ren" thrown around by Red much anymore.  And with consensus designs between the projects out the window, it's clear Ren-C is overdue for a name change.  <em>(But you don't get a second chance to make a first impression, so no point in announcing a new name unless there's a bigger announcement to accompany it.)</em></p>
<p>...point of the above being...</p>
<blockquote>
<p>The very basics - MOLD and SAVE are almost in place.</p>
</blockquote>
<p>...I don't know how close we're going to get on this.</p>
<p>Ren-C hopes to be a <em>kind-of-superset</em>.  So far, the superset is an emulation layer I call "Redbol", and that emulation becomes more difficult as we go along.  (Though I have some ideas.)</p>
<blockquote>
<p>The "binary" equivalent with some form of compatible REBBIN is surely not that hard to agree between the two sets of developers.</p>
</blockquote>
<p>I'd say it's very hard if redbin attempts to capture objects and (I think?) binding.  Binding is going to be very different, as summarized in:</p>
<p><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751" class="inline-onebox">Rebol And Scopes: Well, Why Not?</a></p>
<aside class="quote no-group" data-username="Cplus" data-post="1" data-topic="1787">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/c/0ea827/40.png" class="avatar"> Cplus:</div>
<blockquote>
<p>Fuller, fluid, message passing - for example the seamless invoking of functions and continuations within a running instance of the other language would be an important demonstration of the REBOL cousins' languages abilities to do what they have stated is a desired characteristic of their respective dialects of REBOL.</p>
</blockquote>
</aside>
<p>I understand feeling there must be some teachable moment to be found on what essence of shared concepts and syntax both Ren-C and Red find so critical as to not throw out.</p>
<p><em>Despite understanding someone having the feeling that should be true...</em> the reality is that interoperability is likely to get worse and not better.  Less will work in the future than works today.</p>
<p>It may be a subset of what could be called "Ren" could be read and written by both.  Important to note is that JSON is typically parsed and not "LOAD"-ed as code even by JavaScript, so similar premises could apply there.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787/2</link>
        <pubDate>Fri, 11 Feb 2022 11:08:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5763</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was split to a new topic: <a href="/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787">Could Ren-C and Red Interoperate (and if so, <em>should</em> they?)</a></p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/5</link>
        <pubDate>Fri, 11 Feb 2022 05:59:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5762</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="johnk" data-post="6" data-topic="1786">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/johnk/40/229_2.png" class="avatar"> johnk:</div>
<blockquote>
<p>Browsable Archive now located on github pages here:</p>
</blockquote>
</aside>
<p>Wow--thank you!  It's comforting to think that if I get hit by a bus these ideas will still be somewhere out there...  <img src="https://forum.rebol.info/images/emoji/twitter/bus.png?v=9" title=":bus:" class="emoji" alt=":bus:"></p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/7</link>
        <pubDate>Sun, 06 Feb 2022 12:37:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5761</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>Done. Browsable Archive now located on github pages here:<br>
<a href="https://johnk-.github.io/forum.rebol.info/index.html">https://johnk-.github.io/forum.rebol.info/index.html</a><br>
I am just running this from my laptop for the moment on a weekly cron job (and I have added a few delays to reduce the server load).<br>
Not the most robust approach, but it should do for the moment. I think we have moved the risk of losing the forum content a few points down the scale.<br>
-John</p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/6</link>
        <pubDate>Sun, 06 Feb 2022 03:10:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5760</guid>
      </item>
      <item>
        <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
        <dc:creator><![CDATA[@Cplus]]></dc:creator>
        <description><![CDATA[ <p>When this year can we expect to see full "message passing" inter-operability between Ren-C and Red?</p>
<p>The very basics - MOLD and SAVE are almost in place.</p>
<p>The "binary" equivalent with some form of compatible REBBIN is surely not that hard to agree between the two sets of developers.</p>
<p>Fuller, fluid, message passing - for example the seamless invoking of functions and continuations within a running instance of the other language would be an important demonstration of the REBOL cousins' languages abilities to do what they have stated is a desired characteristic of their respective dialects of REBOL.</p>
<p>This would also harness the strengths of both dialects - for each has been focused these last few years on different arenas. Together, they have the makings of a formidable whole.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787/1</link>
        <pubDate>Fri, 04 Feb 2022 19:20:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5759</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>Happy New Year and thanks for the excellent update.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1786">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>(Makes me think of the <a href="https://en.wikipedia.org/wiki/Conservation_status">species extinction risk scale</a>. Sure, the source code is on GitHub, and the topic list of this forum seems to be on the Internet Archive...but if you click through to individual pages there's nothing about the post contents. Should we do a scrape of the data here and put it elsewhere?)</p>
</blockquote>
</aside>
<p>Following this <code>wget</code> suggestion (<a href="https://meta.discourse.org/t/how-to-create-a-read-only-archive-version-of-discourse-content/139256" class="inline-onebox">How to create a read only, archive version of discourse content - support - Discourse Meta</a>) I just quickly did a full scrape of this forum (public posts only). It works very well.<br>
All the best, John</p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/4</link>
        <pubDate>Fri, 04 Feb 2022 01:08:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5758</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Like it is said, "if you do what everyone else is doing, you will get the same as all of them".<br>
The lack of continuity on the posts of the f00 team is legendary, and combined with the prioritised goals it is encouraging many to wander on.<br>
The dynamics of REN-C, changing even core behavior if seen as a promising experiment is on the complete other end of the spectrum. Not suitable for many seeking an alternative to the library madness, where using even for standard functionality refuge is sought in external API's, for their stable project needs.</p>
<p>Fortunately I am very busy with my new career, but as a downside almost no devtime. But still like what I am doing, so must do more now ... <img src="https://forum.rebol.info/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"></p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/3</link>
        <pubDate>Thu, 03 Feb 2022 19:56:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5757</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A little addendum from one of my recent favorite YouTubers, Joel Haver, on doing what you love:</p>
<div class="onebox lazyYT lazyYT-container" data-youtube-id="BizvIhp5clM" data-youtube-title="Some Scattered Thoughts on Doing What You Love" data-parameters="feature=oembed&amp;wmode=opaque">
  <a href="https://www.youtube.com/watch?v=BizvIhp5clM" target="_blank" rel="noopener">
    <img class="ytp-thumbnail-image" src="https://i.ytimg.com/vi/BizvIhp5clM/maxresdefault.jpg" title="Some Scattered Thoughts on Doing What You Love" width="480" height="360">
  </a>
</div>

<p>And I think that is a good meditation on not really deviating from the parts of this that I find interesting, but staying that course...even if it takes time.</p>
<p>So I'll try and promise to keep doing the parts that impress me.  And someday, it might find an audience.</p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/2</link>
        <pubDate>Tue, 01 Feb 2022 07:16:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5756</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h1>Happy 2022!</h1>
<p><strong>...and I Hope Your New Year's Was Better Than Mine...</strong> <img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji" alt=":man_facepalming:"></p>
<p>Though I've spent most of the last few New Years Days (and this last one) traveling and in some hotel...I've usually gotten myself a nice supply of beer, and worked start-to-finish through a post.  I talk about what worked and didn't work, and where things might go next.  Although it generally takes the greater part of a day to write those, it's in some ways kind of a fun thing to write...and I was always pleased to beat Red to the punch with accomplishments I found more impressive.</p>
<p><em>This year felt unfortunately different.</em>  I had a big wave of pessimism for all kinds of reasons--ranging from personal relationships, to my new laptop screen getting cracked when it was in my bag...to just a general feeling that the world is going to hell in a handbasket.</p>
<p><strong><img src="https://forum.rebol.info/images/emoji/twitter/skull.png?v=9" title=":skull:" class="emoji" alt=":skull:"> ...But It's Not As Grim As All That... <img src="https://forum.rebol.info/images/emoji/twitter/potato.png?v=9" title=":potato:" class="emoji" alt=":potato:"></strong></p>
<p>After eating a ridiculous potato from <a href="https://stpeterising.com/home/2021/9/16/a-loaded-baked-potato-restaurant-the-half-baked-potato-is-coming-soon-to-downtown-st-pete">A Hipster Potato Restaurant In St. Petersburg</a>--and inadvisedly drinking 2 Sugar-Free Red Bulls--my stomach and brain weren't going to sleep for a long time.</p>
<p>Though traveling makes retrieving a repaired laptop on an extended warranty difficult, I still had my old laptop with me.  So I dug it out, and found an unfinished post about a seemingly-esoteric point about invisible evaluations and void isotopes.  <a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782">Some deep realizations clicked into place</a>.  Those realizations led to a proud thought:</p>
<p><strong>2021 was the year of invention for BAD-WORD!s, "isotopes", and ^META.  While the older invention of NULL was akin to mathematicians inventing zero to solve previously hard problems... <em>isotopes and meta-transformations are like the invention of imaginary numbers</em>.</strong></p>
<p>Having that energy boost put me on a slight incline toward positive thinking.  Enough so that I'm pushing out a New Year's post before the calendar ticks over to February... here goes:</p>
<h2>UPARSE Is Already a Big Success Story</h2>
<p>Many who use Rebol got addicted because of PARSE.  But people who work with other languages and parser combinators have wondered what the big deal is.  Though Rebol's PARSE is a literate alternative to simple RegEx scenarios, it's weak at building high level structures from smaller simpler parsers--<em>there are too many inconveniences in writing reusable rules</em>.</p>
<p>UPARSE stands for <a href="https://github.com/metaeducation/ren-c/blob/26752e701d9585a7dd5bb1c4cb2e78c901908c5b/src/mezz/uparse.reb"><em>(U)sermode PARSE</em></a> and to me it deals Rebol back in the parsing game:</p>
<ul>
<li>
<p>It keeps the classic feel of PARSE alive, while bringing its power up to the level of combinators in other languages.  Arbitrary values can be synthesized from processing the input, instead of just data captures at the level of the input series.</p>
</li>
<li>
<p>You can come up with "new keywords" without waiting for someone to do so.  These are expressed as ordinary functions with multiple return values, and hence can be optimized as natives.</p>
</li>
<li>
<p>The behavior of values of certain datatypes themselves can be overridden, to bend parsing to entirely different meanings.</p>
</li>
<li>
<p>It has a <a href="https://github.com/metaeducation/ren-c/blob/26752e701d9585a7dd5bb1c4cb2e78c901908c5b/tests/parse/examples/maxmatch.parse.test.reb">generic architecture for rolling back the effects of combinators</a>, with a default behavior that lets the average combinator author avoid the details if they just want any failure to roll back everything in the order it was done.</p>
</li>
<li>
<p>As a proof of its flexibility, a Rebol2/Red-compatible combinator set is defined.</p>
</li>
</ul>
<p><strong>But besides the combinators, the usermode implementation of the UPARSE engine itself that composes and runs them is as much of the story as anything else.</strong>  Rebol has had a shaky history of giving usermode code the same perceptive power as what could be done from C...and that can be as basic as how to tell the difference between <strong>[a b #[none]]</strong> and <strong>[a b]</strong> with looking at the result of THIRD of the block.  All these upgrades come into the mix in UPARSE...from FRAME! mechanics and specializations to ^META and isotopes and generic quoting.</p>
<p>On the downside: it hasn't been optimized much yet, so the performance is abysmal...and a lot of work is left to do on error messages.  But seeing how to build a dialect in this way--where it's not like you have to be a C programmer, but you can wire together the pieces--is the "Minecraft of Programming" I talk about.</p>
<h2>The <a href="https://forum.rebol.info/t/the-new-ren-c-github-action-run-natively-run-on-web/1562">Ren-C GitHub Action</a> Has Been Amazing</h2>
<p>Although it required me gritting my teeth through some JavaScript programming, we now have a turnkey way to install an up to date interpreter with a line of code on a cloud runner for Mac, Linux, and Windows...as well as run automation of the latest web build.</p>
<p>It's a big force multiplier, and it's helped with testing the <a href="https://forum.rebol.info/t/whitespace-interpreter-revisited/1482">Whitespace Interpreter Dialect</a> and the <a href="https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713">USCII Dialect</a>...both of which received major updates this year.  When Redbol examples are given they often risk merely showing the language is capable of generic computation and if you put enough hours into it then you might get something that sort-of-works.  But I feel these are approaching good examples of the form--where they lay out the particular power and composability that Ren-C has been angling for.</p>
<h2>
<a href="https://forum.rebol.info/t/devices-are-gone-but-what-were-they/1692">Devices are Gone</a> and <a href="https://forum.rebol.info/t/libuv-integration-has-started-an-i-o-renaissance/1694">now it's all libUV</a>
</h2>
<p>I think that libUV pretty much represents the objectives of what Carl might have wanted a device layer to be.  Not only is it pure C code that can be built with things like the TinyC compiler, it compiles for esoteric platforms like Haiku.  It's something Rebol might well have used had it been around.</p>
<p>And the web build doesn't use libUV at all--accomplishing its network reads and such through completely different mechanisms.  So it shows the language is staying pure and repurposeable on platforms that don't have threads or whatever dependencies libUV requires.  A simple stripped down version could just offer C stdio (for instance).</p>
<p>There's a long way to go for our usage of libUV to live up to its potential.  But it gives the foundations for doing things like a <a href="https://forum.rebol.info/t/semantics-of-read-and-tcp-streams-past-and-future/1733">good version of async IO, where you code in a synchronous style</a>.  (I've explained that I think the old WAIT/AWAKE model really <a href="https://forum.rebol.info/t/the-weirdness-of-wait/1703">represented a dead end</a>, and so it had to be ripped out).</p>
<h2>
<a href="https://forum.rebol.info/t/the-sea-of-words/1564"><em>Sea of Words</em></a> and Customizable Modularization Arrives</h2>
<p>What was supposed to be unique about Rebol's modules was that the code that processed headers would be like a dialect.  That dialect was processed by usermode code, and you could write your own spin on it if you had some other idea of how you wanted modularization to work.</p>
<p>It's early yet to really say for sure how the mechanics behind this will evolve.  But there have been big steps taken--and the personal success I feel is how the test dialect can create modules out of individual tests.  So the test files are really making thousands upon thousands of isolating contexts, and when the tests are done running the user context is not contaminated at all.  This makes the tests less subject to weird side effects from each other...keeps things tidy...and is overall good for the garbage collector as well.</p>
<p>Disconnecting the use of words from the creation of variables is good for all the reasons I cite.  I've been very happy with that idea, though what "attachment" to a context means has design work to do.  Make no mistake--this is a process of invention--and so it's going to be weird and take time.</p>
<h2>
<a href="https://forum.rebol.info/t/get-set-vs-pick-poke-whats-the-difference/1719">PICK and POKE and Pathing Are Resolved</a> (I Think)</h2>
<p>I've struggled since very early on to tame "path dispatch", which was very oddly shaped.  I'm not going to rehash all of the thought process.  But I'm pleased with the outcome, and I think it will generalize well to extension types.</p>
<h2>First Try At String Binding + Interpolation</h2>
<p>It isn't there yet, but it has been prototyped.  I've written up a post about where I think binding/scoping has to go:</p>
<p><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751" class="inline-onebox">Rebol And Scopes: Well, Why Not?</a></p>
<p>There are still no easy answers.  But there's good news about having so many complex codebases in play (like UPARSE, whitespace dialect, etc.) that are not throwing softballs at the language.  If new binding concepts add functionality but don't break any of that, that's a good sign it may be good.</p>
<h2>...A Lot Of Other Stuff Happened...</h2>
<p>This is just a mini list of some of the things I find most notable to call out. As usual, you can scroll through posts or commit logs to see more.</p>
<p>But I also got the chance to visit <a class="mention" href="/u/blackattr">@BlackATTR</a> and meet his family and dogs, so that was fun.  We got some work done on his QUERY dialect, but more to go.</p>
<p>I managed to get ODBC and webserver bugs fixed for <a class="mention" href="/u/gchiu">@gchiu</a> so he could do a demo, and to put it on GitHub Actions with tests.</p>
<hr>
<h1>What Hangs in the Balance for 2022?</h1>
<p>I mentioned my bad New Years, and reading <a href="https://www.red-lang.org/2021/12/2021-winding-down.html">Red's New Years post</a> did not help, because it felt so incredibly <em>cyclic</em>.  Seeing them start a New Year by long-windedly plagiarizing <a href="https://forum.rebol.info/t/back-to-personal-computing/186">Back to Personal Computing</a>... <em>again</em>... made me fear their man-years of toil without heeding advice or warnings has grown no audience for either their work, nor Ren-C's inventions.  Their formerly active YCombinator group had a collective yawn about it...<a href="https://news.ycombinator.com/item?id=29758024">one comment</a> at time of writing, so they seem to be slipping off the radar...even though they are much less research-oriented and more "give-the-people-what-they-want-right-now" oriented (in theory).</p>
<p>Apologies to Gregg Irwin for ranting at him.  <strong>But we/I sadly can't count on Red to keep an audience alive for Redbols, as the old guard moves on and new people aren't there to replace them.</strong>  And I'm not a marketer, especially since I fundamentally disagree with the way social media power structures work.  So Ren-C's cool creations are at high risk of not even making it to <a class="mention" href="/u/blackattr">@BlackATTR</a>'s "bad"-case outcome of becoming <em>"a museum piece like the Antikythera mechanism."</em></p>
<p><em>(Makes me think of the <a href="https://en.wikipedia.org/wiki/Conservation_status">species extinction risk scale</a>.  Sure, the source code is on GitHub, and the topic list of this forum seems to be on the Internet Archive...but if you click through to individual pages there's nothing about the post contents.  Should we do a scrape of the data here and put it elsewhere?)</em></p>
<p>I have always been able to consider the notion that Rebol's fundamental idea is flawed and it <em>should</em> die out.  In fact: I started out getting involved in Rebol <em>to prove to Reichart that it was bad</em>, and using it for Qtask was misguided.  My attempts to construct that proof ran up against the fact that its odd plasticity and choice to throw out the rulebook on what a computer language is-or-should-be gave it a slippery yet timeless nature...like English itself.</p>
<p><strong>But given the bus-factor-of-one nature of Ren-C, I should probably be thinking more about how to communicate that to new audiences, vs. going too deeply into an engineering project where I try to re-graft Ren-C onto a Go-like runtime model.</strong></p>
<p>So maybe I need to be better about making YouTube videos, packaging demos, and showing off the existing infrastructure.  <strong>When I look at other WebAssembly language projects, we actually still compare favorably.</strong>  And maybe I'm too quiet about it for fear of looking a fool for all the things that I know aren't working right.  Still...my confidence increases as I've been moving the architecture around to try and steer away from the obviously bad ideas, in a way that new people coming in would be able to shore up missing pieces.</p>
<h2>...Predictions Are Hard To Make</h2>
<p>It probably looks as if I've been notoriously bad at predicting what things are going to get accomplished.  I'd wanted 2021 to hopefully be when stacklessness got integrated, and I wanted to see progress on debugging.  And it may seem like none of that happened.</p>
<p>But sometimes progress is subtle.  There were major barriers to making R3-Alpha's PARSE architecture stackless, but the UPARSE design is much more amenable to it.  So I think the answer will just be that we'll skip stackless PARSE3 and just assume UPARSE is the future of PARSE.</p>
<p>And when it comes to debugging, I demonstrated some <a href="https://forum.rebol.info/t/getting-hooks-into-events-during-parse/1640/5">impressive tracing in UPARSE</a> that works today...which is the sort of thing a user can customize.  Understanding how dialect authors are going to be able to hook and trace their dialects ties in a lot to seeing a big picture of how the evaluator itself might be traced, so all of this really does plug together.</p>
<p>Nevertheless, I feel skeptical of making new predictions.  Especially because here in 2022: <em>Realistically speaking, so long as I'm traveling and trying to find a new home base it's hard to get very much done.</em>  I've chosen to travel in Florida because things are open for business despite the existence of coronavirii...and that aligns with my belief that being vaccinated and boostered is enough to have a social life.  That means I am out maskless indoors doing a fair number of things with people...and changing locations every few days.  It may be a while before I can really focus on coding.</p>
<h2>So Let's Put Predictions On Hold, at least until I have a <img src="https://forum.rebol.info/images/emoji/twitter/derelict_house.png?v=9" title=":derelict_house:" class="emoji" alt=":derelict_house:">
</h2>
<p>One thing that's been working so far, it's my mandate on continuous integration and keeping all the things that are supposed to work, working, as new experiments are tried.  This is not a natural habit for the personality type that programs in Rebol.  People drawn to the language are not <em>"correct-by-construction"</em> folks, more like Larry The Cable Guy "Git-R-Done" mentality.</p>
<p>I want to keep developing <a class="mention" href="/u/blackattr">@BlackATTR</a>'s QUERY and make it part of that "everything is kept working" strategy.</p>
<p>All of <a class="mention" href="/u/gchiu">@gchiu</a>'s projects, as well.  And my USCII, Whitespacers, <code>hostilefork.com</code> itself, etc.  Anything I can convince <a class="mention" href="/u/giuliolunati">@giuliolunati</a> to put in a GitHub workflow, as well!</p>
<p>I want to re-commit to <a href="http://rebmu.hostilefork.com/">Rebmu</a>, also, and make it part of the CI tests.  It might seem like I am always putting this off--even though I claim to say it's one of the big motivators, the <em>"great code golf game in the sky"</em> that I say I'm pursuing.  (When have you seen me solve a puzzle or develop it lately?)  But it's actually in the back of my mind, always.</p>
<p>It was nice with Whitespace to actually draw some attention from a curator of <a href="https://github.com/wspace/corpus">collections of implementations of whitespace</a>... <a class="mention" href="/u/aarchi">@aarchi</a>.  He said he found it to be one of the more interesting examples, and that's always been my goal with this.  To build on the novelty of the medium and give people a new tool to think.  (Recently re-watching that movie <a href="https://www.youtube.com/watch?v=8Fc-7SuebTQ">"Arrival"</a> and the "language/weapon/tool" bit.)</p>
<p>I'm a few minutes from February so I'll just close by saying: continue automating, continue examples, and maybe do a bit more YouTube evangelism.  I'll keep frittering with the mechanics.  And get my laptop fixed (!)</p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/1</link>
        <pubDate>Tue, 01 Feb 2022 04:49:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5755</guid>
      </item>
      <item>
        <title>Understanding Definitional Scoping</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Hello there... thanks for your question, and no need to be sorry.  Questions are well warranted.</p>
<p>(Note that I take no responsibility for the madness that is Rebol--I just happen to hack on a derivative of the open source codebase because I have found various interesting aspects about it.  :-P)</p>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1785">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>First, when the code is compiled</p>
</blockquote>
</aside>
<p>Rebol is interpreted--not compiled.  (Red attempts to do some compilation, and I'm unclear on how that works...you will have to ask them.)</p>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1785">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p><strong>Load-time:</strong> When the code is loaded, context <strong>A</strong> is created with those symbols as members.</p>
</blockquote>
</aside>
<p>It's probably dumber than you think.  Not only is there no "compile-time", "load-time" isn't where the binding happens.  It all happens at run time.</p>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1785">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>if <code>a: 2</code> didn't exist, will it still create the slot for <code>a</code> due to <code>a: 3</code> deep inside?</p>
</blockquote>
</aside>
<p>CONTEXT is an alias in historical Rebol for MAKE OBJECT! and the behavior of that is that it only searches one level of depth symbolically for SET-WORD!s to gather.</p>
<p>Deeper walks are possible.  The concept behind R3-Alpha and Red's FUNCTION is that it searches deeply the body for any SET-WORD!s and assumes they should be local variables.  This creates the problems you would expect: a nested function's locals will be picked up as locals in the outer function, and SET-WORD!s used in the body incidentally as object members or for dialect purposes will also be picked up.  This is why Ren-C has LET and does runtime variable instantiation which runs in a wave (virtual binding), you can't sensibly calculate a static concept of what symbols are variables or not.</p>
<p>Ren-C is quite different from Rebol, and so answers will vary significantly, if you find that you care about the difference.</p>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1785">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>Did <code>context</code> bind <code>a</code> in <code>[/local a]</code> too, before <code>func</code> was executed?</p>
</blockquote>
</aside>
<p>No, CONTEXT was merely looking for symbolic SET-WORD! tokens at one level of depth underneath it.  <strong><code>a</code></strong> is a plain WORD!, and it's in a block one level deep, so that's two strikes.</p>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1785">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>Is there a parent-child relationship between contexts, or are they free-standing? Given a context, can I chase some pointer to its parent or child?</p>
</blockquote>
</aside>
<p>Contexts inherit keylists as an implementation detail for efficiency, and it's weaker than v8 hidden classes.</p>
<p><a href="https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html" class="inline-onebox">Javascript Hidden Classes and Inline Caching in V8</a></p>
<p>I have thought hidden classes might be better, at times, but then again that would complicate the code.  And part of the point is to let everyone understand the stack.  It's a thought experiment.</p>
<p>Rebol was written to be a brutishly simple C '89 codebase and a lot of the "interesting" aspects were higher-order studies on top of an interpreter that worked better than you would think for how dumb it was.</p>
<p>My take is to call it "Amish Programming", you may find my talk at the 2019 conference useful if you're getting your bearings.</p>
<p><a href="http://2019.reb4.me/talks" class="inline-onebox">Talks | Rebol [2019]</a></p> ]]></description>
        <link>https://forum.rebol.info/t/understanding-definitional-scoping/1785/2</link>
        <pubDate>Mon, 24 Jan 2022 12:11:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5754</guid>
      </item>
      <item>
        <title>Understanding Definitional Scoping</title>
        <dc:creator><![CDATA[@DefinitionalUsername]]></dc:creator>
        <description><![CDATA[ <p>I just started learning Red/Rebol, and I was having trouble understanding the scoping rules. I did read the <a href="https://stackoverflow.com/a/21964858" rel="noopener nofollow ugc">Stack Overflow</a> and <a href="https://en.wikibooks.org/wiki/Rebol_Programming/Advanced/Bindology" rel="noopener nofollow ugc">Bindology</a>, and I think I somewhat understand, but I'm not sure! I'd be grateful if someone can confirm the my deductions about the following code from the SE post:</p>
<pre><code class="lang-auto">rebol []

a: 1

func-1: func [] [a]

inner: context [
    a: 2
    func-2: func [] [a]
    func-3: func [/local a] [a: 3 func-1]
]

reduce [func-1 inner/func-2 inner/func-3]
</code></pre>
<ol>
<li>
<strong>Compile-time:</strong> First, when the code is compiled, a list of top-level names is created. <em>(<code>a</code>, <code>func-1</code>, <code>inner</code>)</em>
</li>
<li>
<strong>Load-time:</strong> When the code is loaded, context <strong>A</strong> is created with those symbols as members. Also, the entire code is walked through, and every occurrence of those symbols is bound to these entries. <em>(e.g., <code>a</code> inside <code>func-2</code> would be bound to the top-level <code>a</code>)</em>
</li>
<li>
<strong>Run-time:</strong> When <code>a: 1</code> is executed, the value <code>1</code> is stored in the <code>a</code>'s slot in the context.</li>
<li>The <code>func</code> keyword after <code>func-1:</code> creates a new function, and assigns it to <code>func-1</code>. However, it leaves the binding of <code>a</code> intact.</li>
<li>The <code>context</code> keyword after <code>inner:</code> creates a new context <strong>B</strong>, walks over all the block, collecting all new symbols, and inserts those in the new object.</li>
<li>
<code>a: 2</code> assigns value <code>2</code> in <code>a</code>'s slot in the new context.</li>
<li>
<code>func</code> after <code>func-2:</code> creates a function while keeping <code>a</code>'s new binding intact, and assigns it to <code>func-2</code>'s slot.</li>
<li>
<code>func</code> after <code>func-3:</code> creates a function and creates a new context <strong>C</strong> in which <code>a</code> is inserted and bound.</li>
<li>Upon execution of <code>reduce</code>, <code>func-1</code> returns <code>1</code> from context <strong>A</strong>, <code>func-2</code> return <code>2</code> from context <strong>B</strong>, and <code>func-3</code> executes <code>func-1</code> which returns <code>1</code> from context <strong>A</strong> again.</li>
</ol>
<p>So, now,  a few questions:</p>
<ul>
<li>Is the above correct? If it is,</li>
<li>How does the <code>context</code> keyword determine which set-words it should create a slot for? i.e.,
<ul>
<li>if <code>a: 2</code> didn't exist, will it still create the slot for <code>a</code> due to <code>a: 3</code> deep inside?</li>
<li>What about if <code>a:3</code> didn't exist either? Will the new context contain a slot for <code>a</code> just due to <code>a</code> inside <code>func-2</code>'s body?</li>
</ul>
</li>
<li>Did <code>context</code> bind <code>a</code> in <code>[/local a]</code> too, before <code>func</code> was executed?</li>
<li>When a new context is created, does it copy existing symbols or bindings from the older context? If not,</li>
<li>Is there a parent-child relationship between contexts, or are they free-standing? Given a context, can I chase some pointer to its parent or child?</li>
</ul>
<p>Sorry for so many questions, I think I am getting extra confused since I already have programming experience and need to unlearn some stuff before being able to grok Rebol.</p>
<p>Thank you.</p> ]]></description>
        <link>https://forum.rebol.info/t/understanding-definitional-scoping/1785/1</link>
        <pubDate>Sat, 22 Jan 2022 08:13:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5734</guid>
      </item>
      <item>
        <title>Should END-able constructs all use ^META parameters?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>R3-Alpha and Rebol2 could only have functions that were "endable" if the argument they took was quoted.  This feature was added primarily for HELP, so that you could say either:</p>
<pre><code>&gt;&gt; help
; (would display generic HELP usage information)

&gt;&gt; help topic
; (would display help for the given topic)
</code></pre>
<p>It was a <em>very limited form of variadic-ness</em>...generally used only in console-oriented commands (HELP, LS).  You couldn't write a function that was evaluative, like:</p>
<pre><code>redbol&gt;&gt; printer 1 + 2
3

redbol&gt;&gt; printer
You called the PRINTER function with no arguments
    ; ^-- not possible to accomplish with an otherwise evaluative argument!
</code></pre>
<p>Being able to handle getting to the end of input was entwined with taking quoted arguments.</p>
<h2>Ren-C added <code>&lt;end&gt;</code>-able Evaluative Parameters</h2>
<p>To facilitate certain demos in Ren Garden, Ren-C could mark an ordinary parameter as being <code>&lt;end&gt;</code>-able.  This would mean that the argument would show up as being NULL if the end was reached before an argument was seen.</p>
<p>This was--however--ambiguous with if you actually passed an evaluative NULL.</p>
<pre><code>ren-c&gt;&gt; printer 1 + 2
3

ren-c&gt;&gt; printer
You called the PRINTER function with no arguments

ren-c&gt;&gt; printer null  
You called the PRINTER function with no arguments  ; d'oh
</code></pre>
<p><strong>This kind of ambiguity wasn't new...the Redbol version had it.</strong>  The signal for quoted parameters that were endable-and-missing was to make the parameter an UNSET!.  Which meant they couldn't tell the difference between <strong>help #[unset!]</strong> and just-plain-help:</p>
<pre><code>red&gt;&gt; help #[unset!]
To use HELP, supply a word or value as its
argument:

    help insert
    help system
    help system/script

To view all words that...
</code></pre>
<p><strong>Interestingly enough, Ren-C has a solution for this with quoted parameters, because NULL cannot appear literally in source...so it can't be at the callsite.  Thus NULL can represent a missing quoted argument.</strong>  Which is neat.</p>
<h2>^META parameters can do <code>&lt;end&gt;</code> another way...</h2>
<p>A meta parameter is quoted, but will be a plain non-quoted BAD-WORD! if the callsite was passing an isotope.  With the <a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782">recent design concept that suggests ~void~ isotopes are "pure" and equivalent to the full absence of a value</a>, you get evaluative endability without needing a separate feature.</p>
<p>So if our PRINTER took a ^META argument:</p>
<pre><code>&gt;&gt; printer 1 + 2
3
; (it actually received '3, quoted)

&gt;&gt; printer
You called the PRINTER function with no arguments
; (it actually received ~void~, not quoted)
</code></pre>
<p>The ambiguity is still there, though...</p>
<pre><code>&gt;&gt; printer ~void~
You called the PRINTER function with no arguments
; (again, it actually received ~void~, not quoted)
</code></pre>
<p>If you're following the details then I pointed out that supermeta parameters would be necessary to implement something that would know the difference in the suggested model.</p>
<p><strong>But at least you could differentiate NULL from an end.</strong>  The conflation of an invisible argument with the end doesn't seem that troubling to me, as the problem with HELP is fixed since it quotes and can tell when you say <strong>help ~void~</strong> vs. plain <strong>help</strong></p>
<h2>Killing off <code>&lt;end&gt;</code> as a core parameter flag would simplify things...</h2>
<ul>
<li>
<p>If a quoted parameter tolerates NULL as one of its legal types that's sufficient to say it is "endable"</p>
</li>
<li>
<p>If an evaluative parameter needs to detect endability, it could be your job to make it a ^META parameter and look for void, and unquote it to handle other results.</p>
</li>
</ul>
<p>The code and typeset flags for <code>&lt;end&gt;</code> could then be scrapped.</p>
<p>If someone really liked the NULL conflating version of endability they could write something to do it in usermode.</p>
<p><strong>You'd have to see the code to understand why I would think throwing away <strong><code>&lt;end&gt;</code></strong> is worth it.</strong> The way the type checking is done frames have to be filled first, which means if a function doesn't want an actual null but wants just ends to reflect as null... or wants an actual null but doesn't want ends reflected as null... hidden bits need to be grafted onto these nulls at the time of frame fulfillment to say whether it's an "endish" null or a regular null.  Various parts of the system then need to test a NULL for this invisible property.  <strong>^META parameters pull such invisible state into the light.</strong></p>
<p><strong>Basically take my word for it: meta is much cleaner, and offers a way to expose these distinctions to the user--so I think the odds are that <code>&lt;end&gt;</code> and its current mechanics need to die.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783/1</link>
        <pubDate>Fri, 21 Jan 2022 17:01:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5732</guid>
      </item>
      <item>
        <title>Pure vs. Impure Invisibility: Do We Need Both?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>"Invisibles" <a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405">were conceived 4 years ago</a>...long before BAD-WORD!s, isotopes, ^META parameters, etc.</p>
<p>The terminology needs a bit of an update, because I want to make a distinction between two different kinds:</p>
<ul>
<li>
<p><strong>IMPURE INVISIBLITY</strong> is when a special state (like a ~void~ isotope) is discarded in contexts where it's assumed to represent an invisible intent.</p>
<p>Remember that plain BAD-WORD!s (unevaluated) are normal values and can be in blocks.</p>
<pre><code>&gt;&gt; first [~void~]
== ~void~
</code></pre>
<p>But an evaluated ~void~ becomes an isotope, and operations like ALL are willing to tolerate that as a signal of invisible intent it should discard:</p>
<pre><code>&gt;&gt; ~void~
== ~void~  ; isotope

&gt;&gt; all [10 + 20, ~void~]
== 30
</code></pre>
<p>Unfortunately, this is extra work that ALL must do, since ~void~ isotopes are valid evaluative products.  Every construct that wants to integrate impure invisibility bears the burden.</p>
</li>
<li>
<p><strong>PURE INVISIBILITY</strong> is an evaluator feature when a function call can truly erase arbitrary code, such as to the right of a SET-WORD!:</p>
<pre><code>&gt;&gt; y: elide (1 + 2 print "Erased!" 3 + 4) 10 + 20
Erased!
== 30

&gt;&gt; y
== 30
</code></pre>
<p>This can only be done when a function like ELIDE specially says that it is not expected to return any result at all.  Otherwise it's not clear whether <strong>y:</strong> is supposed to get the <code>~void~</code> isotope or something after it.</p>
<p>(Over time I embraced the odd idea that just saying RETURN and not giving it an argument would be the way of being purely invisible...which has the interesting property that <strong><code>(return some-other-function ...)</code></strong> can actually chain cases where the other function is sometimes purely invisible and sometimes not!  This insight arose because of the frustrating fact that C/C++ cannot do such chains... if you say <strong><code>return some_other_function(...);</code></strong> and then change the other function from returning <code>int</code> to <code>void</code>, it will complain that you cannot use <code>return</code> with an argument inside of void functions...even if that function itself returns void.)</p>
</li>
</ul>
<h2>Why Not Make "Impure" Invisibility Act "Pure" ("Semipure?")</h2>
<p>The existence of the ^META types and operators raises an interesting theoretical option...that a ~void~ isotope could be treated as pure by the evaluator, and it's your responsibility to use meta operations if you wanted to see it:</p>
<pre><code>&gt;&gt; 1 + 2 ~void~
== 1 + 2

&gt;&gt; x: ~void~ 1 + 2
== 3

&gt;&gt; x
== 3

&gt;&gt; y: ^ ~void~ 1 + 2
== 3

&gt;&gt; y
== ~void~
    ; ^-- not an isotope
</code></pre>
<p>Pondering the potential implications of this form of thinking, it would mean there wouldn't be a form of invisibility that could beat a ^META operation:</p>
<pre><code>&gt;&gt; z: ^ comment ["hi"] ~something~
== ~something~  ; isotope

&gt;&gt; z
== ~void~
   ; ^-- the COMMENT was seen by the ^META, instead of bypassed
   ; (today COMMENT's status as a purely invisible construct means you
   ; would get Z as a non-isotope ~something~)
</code></pre>
<p><strong>Note that since parameters to functions are allowed to be meta if they need to be, changing a parameter from normal to meta would break commenting constructs.</strong>  This is not too surprising, as if you have <code>my-function comment "hi" 1 + 2</code> and change MY-FUNCTION's argument to be quoted instead of evaluated, that's another kind of parameter change that would break the commenting feature.</p>
<p>Meta parameters should be used very sparingly--far more sparingly than quoted parameters--so this may not be a problem.  I notice that a function like RETURN (which takes its argument meta so it can return isotopes) could still chain an invisible function, as it would receive ~void~ as a measure of what an isotope was.</p>
<h2>If Truly Pure Invisibility Is Not Implemented, Would People Just Reinvent it with Variadics in a Less Efficient Way Than The Current Evaluator Internals Do It?</h2>
<p>Let's say someone writes:</p>
<pre><code>foo: func [] [return comment "hi" 1 + 2]
</code></pre>
<p>Today this returns 3 due to comment's "purely invisible" status, RETURN takes its argument as a ^META parameter.  If we decide meta parameters are allowed to see the "semipure" void isotopes described above, then it would just be like you'd written:</p>
<pre><code>foo: func [] [return comment "hi"]
</code></pre>
<p><strong>That would make it seem like COMMENT is unreliable.</strong>  True, if you take a quoted argument you expect COMMENT to break in such cases as well...but meta parameters are evaluative and so it's a bit different.</p>
<p>Perhaps it should be just the <strong>^</strong> operator at the callsite that has the special vision, and meta parameters are evaluated and discard the void isotopes.  This would mean you only have to learn the rule that <strong>^ comment "hi"</strong> breaks the invisibility.</p>
<p><em>(Here we wind up with <strong>^</strong> either being a built-in thing the user has no way to write themselves, or invent a "supermeta" parameter flag to say "I can see void isotopes, too".)</em></p>
<h2>Either way, "Impure Invisibility" Is MUCH Easier To Work With</h2>
<p>The easy meta-transformations between ~void~ isotopes and plain ~void~ BAD-WORD! allow you to work with an invisible function gracefully...even when you don't know if it's invisible or not.</p>
<p>Early problems cropped up with pure invisible COMMENT like this:</p>
<pre><code>&gt;&gt; f: make frame! :comment
&gt;&gt; f.discarded: "Ignore Me"

&gt;&gt; x: do f   y: 1 + 2
== 3

&gt;&gt; x
== 3  ; this could seem surprising, but maybe not?
</code></pre>
<p>But the new world does have at least <em>an</em> answer, meta your result and you can test for void cases and handle them as you wish.</p>
<pre><code>&gt;&gt; x: ^ do f  y: 1 + 2
== 3

&gt;&gt; x
== ~void~

; alternately could have said `[^x]: do f  y: 1 + 2`
</code></pre>
<p>Yet it's still uncomfortable to imagine that an operation like DO could vanish, which is why DO tried to use void isotopes as a proxy for its return value.  A ~void~ isotope could then be semantically interpreted or converted to pure invisibility on an as-needed basis.</p>
<h2>"If You Don't Know What You're Doing, Then Do It Meta"</h2>
<p>My urge to build safety into the system is driven by wanting to enable people to write generic code.</p>
<p>...but... trying to protect people from <strong><code>do f</code></strong> from vanishing when <strong><code>f</code></strong> is a FRAME! for the COMMENT function may be misguided.  That protection could be breaking the very cool trick they are trying to perform.</p>
<p>And there's a real complexity cost to having a distinction between pure and impure invisibility.  If you allow that distinction then impure invisibility has a meta form (a plain ~void~ BAD-WORD!) while pure invisibility doesn't have one.  The powerful tool of META therefore offers no answers for a purely invisible function.</p>
<p>Maybe things like DO should have a switch to say <strong>do/vanishable</strong> and that's the right protection, otherwise they error if they could vanish.  Same with <strong>unmeta</strong>?</p>
<p>Or maybe there's a better finesse, to say that the evaluator has some generalized protection which notices when you might have meant for an invisible result to be used, and there's generic mitigation for such cases.  Like with <strong><code>x: do f  y: 1 + 2</code></strong>, if it notices the potential for misunderstanding you can say <strong><code>x: vanishable do f y: 1 + 2</code></strong>...and you'd be provoked to decide if you wanted to use VANISHABLE or ^ based on what you were actually trying to accomplish.</p>
<p><em>That actually sounds like a really clever mitigation, if a word or symbol were picked for it!</em></p>
<hr>
<p><strong>This post has been in draft form for a while, as I let it turn over in my head.  But I think I am turning to feeling that void isotopes cannot be stored in variables but are something whose existence can only be philosophically imagined by seeing a meta state register as a plain ~void~ BAD-WORD!.  This is bolstered by the idea that function frames cannot receive isotopes, and parallels to the idea that ~null~ isotopes cannot be stored in variables either (though they decay to ordinary NULL)</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782/1</link>
        <pubDate>Fri, 21 Jan 2022 09:19:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5731</guid>
      </item>
      <item>
        <title>Cggong</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="cggong" data-post="17" data-topic="1776">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/c/71c47a/40.png" class="avatar"> cggong:</div>
<blockquote>
<p>Is there a way to run multiple instances of Ren-C interpreter in the same process?</p>
</blockquote>
</aside>
<p><em>At one time</em> I thought we'd try doing what the JavaScript V8 engine behind Chrome/Node/etc. uses, something called "isolates":</p>
<p><a href="https://stackoverflow.com/questions/29299397/whats-the-role-of-isolate-in-v8-and-how-can-it-be-possible-to-make-isolate" class="inline-onebox">javascript - What's the role of "Isolate" in V8? and how can it be possible to make "Isolate" isolately? - Stack Overflow</a></p>
<p>But the direction I imagine going in now is more like Go, e.g. "green threads" as a more cooperative way of letting the interpreter shuffle state around:</p>
<p><a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" class="inline-onebox">What Color is Your Function? – journal.stuffwithstuff.com</a><br>
<a href="https://forum.rebol.info/t/switching-to-stackless-why-this-why-now/1247" class="inline-onebox">Switching to Stackless: Why this, Why now?</a></p>
<p>So concurrency would be managed within the interpreter "service" itself--not as something that you'd have to do "locks" in native C code to surround on different threads.  This would allow for concurrency...though (probably) only one CPU core would be running the interpreter code; just shuffling between whichever tasks/threads that were requesting to use it.</p>
<p>I'm in constant transit, currently in a search for a new place to live, and that's taking up a lot of time.  So I don't really know what the timetable is on stackless, or much of anything at this point <img src="https://forum.rebol.info/images/emoji/twitter/hourglass_flowing_sand.png?v=9" title=":hourglass_flowing_sand:" class="emoji" alt=":hourglass_flowing_sand:"> <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">  I'll see about getting around to my New Years status post shortly.</p> ]]></description>
        <link>https://forum.rebol.info/t/cggong/1776/18</link>
        <pubDate>Mon, 10 Jan 2022 23:52:13 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5730</guid>
      </item>
  </channel>
</rss>

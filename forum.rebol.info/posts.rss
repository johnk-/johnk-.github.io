<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>Default Values and MAKE FRAME! - 2024 Edition</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p><em>Still paying off technical debt, here...this frame stuff has been agonizing.</em></p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2347">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It would mean sacrificing another value to have to be passed ^META. Though bear in mind, most of the damage is done from having one form: e.g. a function like SET is having to take its value ^META already in order to be able to set things to antiform PARAMETER!.</p>
</blockquote>
</aside>
<p>As part of trying out this "two unspecialized forms" concept, I started tightening the screws so I can better reason about the invariants.  It quickly exposed something fundamental, that I might classify as <em>"genuinely interesting"</em>.</p>
<p>Consider the native for testing if something is an INTEGER?.  Let's say it's able to accept ANY-VALUE?, and it should not return true for PARAMETER! antiforms:</p>
<pre><code>/integer?: native [return: [logic?] value [any-value?]]
</code></pre>
<p>We don't want to be in a situation where a function like this needs to take its argument as ^META, because that's a trap we don't want to fall in... where <em>every</em> parameter has to be meta.  You don't want the edge case to spread like that.</p>
<p>But now we have to ask: what if you have an antiform PARAMETER!, and you ask INTEGER? of it.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<p>The options are limited to basically 2 choices:</p>
<ol>
<li>
<p>Antiform PARAMETER! is removed from the ANY-VALUE? class.  That means testing INTEGER? on an antiform parameter would trigger an abrupt failure.</p>
</li>
<li>
<p>Antiform PARAMETER! is made legal in EVAL frame contexts to mean "itself" (while its meaning in RUN frame contexts is "unspecialized").</p>
</li>
</ol>
<p>When you put it that way, I get bad vibes from (1).</p>
<p>Though (2) has consequences that I've explained.  Any function that takes antiform PARAMETER! which doesn't take it ^META will not be able to create <em>partial specializations</em> that fix arguments as antiform parameters, while still gathering other parameters.  You will only be able to use antiform parameters in <em>full specializations</em>.</p>
<p>But I realized you -could- create partial specializations on functions taking antiform parameters non-META.  You'd just have to get creative: make a variant with the parameter adjusted to be ^META and then, use an ENCLOSE...after all the arguments are fulfilled, unmeta it before passing through to the original function.</p>
<p><em>Having <strong>a</strong> way to do it is good enough for me.</em>  I do not think that partial specializations to antiform parameters is going to be something anyone does frequently (or ever, probably, outside of the test files I'm going to write that prove it can be done.)</p>
<h2><a name="p-7966-down-to-just-one-meta-exception-nothing-1" class="anchor" href="https://forum.rebol.info#p-7966-down-to-just-one-meta-exception-nothing-1"></a>Down To Just One ^META Exception: <em>NOTHING</em> (<code>~</code>)</h2>
<p>A "genuinely interesting" aspect of this is that it brings a renewed motivation to the existence of the unset state.  It has been challenged before:</p>
<p><strong><a href="https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113">Why Have an "Unset State" in Rebol-like Languages?</a></strong></p>
<p>I actually was reflecting on the question of the necessity of "nothing" once I realized that protecting-you-from-typos is no longer one of the reasons, due to binding becoming "strict".  So I had a panicky moment where I wondered if <code>~null~</code> and <code>~</code> antiforms should be merged, after all.  <img src="https://forum.rebol.info/images/emoji/twitter/worried.png?v=12" title=":worried:" class="emoji" alt=":worried:" loading="lazy" width="20" height="20"></p>
<p>Almost certainly not... <em>but</em> with PARAMETER! antiforms now in frames as "themselves", something has to give.  There's a strong incentive to pare that back to as few states as possible... and hence, just one thing: NOTHING.</p>
<p>Note it's thus subject to the limitations of (1) above, and hence <em>you can't call INTEGER? on NOTHING</em>.</p>
<p><strong>So NOTHING becomes (as it was) the one stable antiform state that a variable can hold, which cannot be accepted by functions that don't take ^META parameters.</strong></p>
<p>If we didn't do something special, the error you'd get would look like:</p>
<pre><code>&gt;&gt; integer? ~
** Error: INTEGER?'s VALUE argument is unspecified (~ antiform)
</code></pre>
<p>Maybe that's good enough, though the argument-gathering machinery could pre-empt the FRAME! typechecking layer with a clearer message:</p>
<pre><code>&gt;&gt; integer? ~
** Error: INTEGER?'s VALUE argument can't be NOTHING (~ antiform)
</code></pre>
<p>That may be seem like splitting hairs, but I don't think it is.</p>
<h2><a name="p-7966-casualty-unblocks-eval-of-unspecialized-frames-2" class="anchor" href="https://forum.rebol.info#p-7966-casualty-unblocks-eval-of-unspecialized-frames-2"></a>Casualty: Unblocks EVAL of Unspecialized FRAME!s</h2>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2347">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Antiform ~ would still have to turn into ~null~ if EVAL found it in a refinement slot. But I'm not sure PARAMETER! antiforms would need to do that too. One could argue that you should never be EVAL'ing a frame with antiform parameters in it, so it could be a sort of safety mechanism (?).</p>
</blockquote>
</aside>
<p>So with antiform parameters being treated as-is under EVAL, then when you don't use MAKE FRAME! and get the slots filled with nothing, you get the slots filled with antiform parameters.  And that means this would happen:</p>
<pre><code>&gt;&gt; f: copy unrun parameter?/
== #[frame! [value: ~#[parameter! [any-value?]]~]

&gt;&gt; eval f
== ~okay~  ; anti
</code></pre>
<p>I can live with this.  COPY on an action's FRAME! is something you should do only if you're building something you mean to run as an action, and if you EVAL it instead, that's kind of your fault.</p>
<p>Maybe there could be some kind of prevention of this, but I'd be loathe to see the FRAME! type bifurcate into "EVAL-able frames" and "RUN-able frames".</p>
<p>Anyway, this is <em>far</em> less a concern with MAKE FRAME! unsetting the slots, than it was when those were antiform parameters.</p> ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347#post_2</link>
        <pubDate>Sun, 08 Dec 2024 11:56:28 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7966</guid>
      </item>
      <item>
        <title>Default Values and MAKE FRAME! - 2024 Edition</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p><em><strong>NOTE:</strong> The below summarizes history with some adjustments made for simplification purposes.  See posts in <a href="https://forum.rebol.info/c/archive/61">Archive</a> regarding frames for all the exact detours.</em></p>
</blockquote>
<hr>
<p>Something like this has worked ever since the first FRAME!:</p>
<pre><code>f: make frame! append/
f.series: [a b c]
f.value: 10

&gt;&gt; eval f
== [a b c 10]
</code></pre>
<p>Notice that although APPEND has refinements, you don't have to explicitly go through and set them to NULL.  That was done for you.</p>
<p>That might make you think the result of <strong>(make frame! append/)</strong> looked like this:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [  ; you might think...
    series: ~null~
    value: ~null~
    part: ~null~
    dup: ~null~
    line: ~null~
]]
</code></pre>
<p>e.g. all fields defaulting to null, whether they are refinements or not.</p>
<h2><a name="p-7965-thats-not-what-it-did-here-is-why-1" class="anchor" href="https://forum.rebol.info#p-7965-thats-not-what-it-did-here-is-why-1"></a>That's Not What It Did... Here Is Why</h2>
<p>Even before the full-on unification of ACTION! and FRAME! into one datatype, there was a concept that you could make an action out of a frame.  This meant some state of the frame variables had to represent the idea that an argument was still to be gathered.</p>
<p>The goal was something like this:</p>
<pre><code>f: make frame! append/
f.value: 10
; don't assign f.series, leave it however it was

&gt;&gt; run f [a b c]
== [a b c 10]
</code></pre>
<p>If all the argument slots were eagerly set to <strong><code>~null~</code></strong> then you'd get something like:</p>
<pre><code>&gt;&gt; run f [a b c]
** Error: APPEND doesn't allow ~null~ for its VALUE argument
</code></pre>
<p>So instead, MAKE FRAME! would leave the slots all unset, to indicate they were unspecialized:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]]
</code></pre>
<p>If it got to the point of execution, optional parameters (e.g. refinements) would be turned from NOTHING into NULL implicitly.  But if you didn't set a slot for a required parameter, it would give a helpful error:</p>
<pre><code>f: make frame! append/
f.value: 10

&gt;&gt; eval f
** Error: APPEND's SERIES argument is unspecified
</code></pre>
<h2><a name="p-7965-but-what-if-you-want-to-specialize-to-nothing-2" class="anchor" href="https://forum.rebol.info#p-7965-but-what-if-you-want-to-specialize-to-nothing-2"></a>But What If You Want To Specialize To Nothing?</h2>
<p>It might seem that "nothing" is a rare thing to want to specialize to.  But it's a legitimate value, and represents a valid frame state.</p>
<p>e.g. let's say you wanted to write UNSET as a specialization:</p>
<pre><code>/unset: specialize set/ [value: ~]
</code></pre>
<p>This would wind up making UNSET a synonym for SET.  Because it would think you were saying <em>"specialize SET's value to be unspecialized"</em>...which is what it was by default.</p>
<p>In this sense, using NOTHING as the unspecialized value just pushed the problem around a little bit.  No matter what you pick to represent the unspecialized state, you're going to have a problem.  It just happens that functions which take ~null~ antiforms are relatively common compared to those that take ~ antiforms.</p>
<h2><a name="p-7965-leveraging-meta-on-a-stable-antiform-3" class="anchor" href="https://forum.rebol.info#p-7965-leveraging-meta-on-a-stable-antiform-3"></a>Leveraging ^META On a Stable Antiform</h2>
<p>If you start thinking about being sneaky, you might imagine adding extra hidden bits somewhere to say <em>"no, this is a magic kind of specialized NOTHING"</em>.  But sneaky hidden bits are a tangled web, adding cost in the routines to manipulate them.</p>
<p>So the idea was to use a not-so-hidden bit: any function that could legitimately take "nothing" as an argument had to take it as a ^META parameter.</p>
<pre><code>x: 1020

f: make frame! set/
f.var: $x
f.value: first [~]  ; ~ is meta-NOTHING, aka "quasi-BLANK!", aka "TRASH"

&gt;&gt; eval f
== ~  ; anti

&gt;&gt; x
** Error: X is unset (antiform BLANK!)
</code></pre>
<p>This works, but creates an additional burden: functions that truly want to receive a value that can represent any stable form must take their arguments as ^META... which usually you'd think you only need for unstable forms.</p>
<h2><a name="p-7965-theres-still-an-ambiguity-gather-or-error-4" class="anchor" href="https://forum.rebol.info#p-7965-theres-still-an-ambiguity-gather-or-error-4"></a>There's Still an Ambiguity: Gather, Or Error?</h2>
<p>The above was the status quo for a couple of years: MAKE FRAME! gave you back a frame whose slots were all unset.  Those unset slots represented arguments that were unspecialized.</p>
<p>But still you have a question: should an unspecialized argument be gathered from a callsite, or should it trigger an error?</p>
<p>That decision came from the operation.  If you used EVAL on a FRAME!, it would assume all the frame slots were finalized...and any nothing cells would raise errors.  If you used RUN (or converted the FRAME! into an action) then it assumed the unspecialized slots meant you wanted to gather arguments.</p>
<h2><a name="p-7965-evolution-antiform-parameter-for-unspecialized-slots-5" class="anchor" href="https://forum.rebol.info#p-7965-evolution-antiform-parameter-for-unspecialized-slots-5"></a>Evolution: Antiform PARAMETER! For Unspecialized Slots</h2>
<p>A big change came through with a user exposure of the PARAMETER! type.  With antiform parameters representing unspecialized slots, you had the signal of "this is unspecialized", but also the information required to gather the parameter: what types it checked, whether it was a refinement or not, whether it should be taken literally from a callsite, etc.</p>
<p>This heralded even more exposure of the mechanics of function composition to user mode.  Instead of just specializing a function argument to a value, you could do things like "tweak" the argument's accepted types.</p>
<p>For instance: what if you wanted a version of APPEND that only appended integers?</p>
<pre><code>&gt;&gt; ap-int: make frame! append/

&gt;&gt; ap-int.value: anti make parameter! [integer!]  ; or whatever syntax
== ~#[parameter! [integer!]]~  ; anti

&gt;&gt; /ap-int: anti ap-int
== ~#[frame! ...]~  ; anti

&gt;&gt; ap-int [a b c] 1020
== [a b c 1020]

&gt;&gt; ap-int [a b c] "illegal"
** Error: AP-INT requires [integer!] for its value argument
</code></pre>
<p>This meant that MAKE FRAME! gave back something that looked rather weird:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~#[parameter! [
        ~void~ any-series? port! map! object! module! bitset!]
    ]~
    value: ~#[parameter! [~void~ element? splice?]]~
    part: ~#[parameter! :[any-number? any-series? pair!]]~
    dup: ~#[parameter! :[any-number? pair!]]~
    line: ~#[parameter! :[]]~
]]
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji only-emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<p>Although this gives you a useful and actionable information about the parameters, that's fairly noisy for most purposes.  You haven't done any assignments to the frame, and yet it looks like it's "full".</p>
<p>Let's put a pin in that.</p>
<h2><a name="p-7965-are-meta-exceptions-still-needed-6" class="anchor" href="https://forum.rebol.info#p-7965-are-meta-exceptions-still-needed-6"></a>Are ^META Exceptions Still Needed?</h2>
<p>In this model, there is no way of expressing a specialization of a function to an antiform parameter unless that function defined the parameter as ^META.</p>
<p>That doesn't <em>necessarily</em> mean we'd have to be prescriptive.  I mentioned that EVAL expects all the arguments to be specified to their final values, while RUN accepts some will be unspecialized.  So EVAL <em>could</em> treat antiform parameters as the actual values to pass, while RUN would gather them from the callsite.</p>
<p>This would produce a strange conflation.  You couldn't tell by looking at a frame whether or not an antiform parameter was a legitimate argument, or an unspecialized parameter definition.</p>
<p>As an example, consider the HOLE? function, that tells you whether or not a value is an antiform parameter.  Let's assume it's operating in a world that it doesn't need to take the argument as ^META:</p>
<pre><code>&gt;&gt; f: make frame! hole/
== #[frame! [value: ~#[parameter! [any-value?]]~]
</code></pre>
<p>The interface says it takes ANY-VALUE? as the first parameter to HOLE?  Yet we don't have any mechanical way of telling that <strong><code>f2</code></strong> isn't a completed frame for calling HOLE?.  So if EVAL accepts this:</p>
<pre><code>&gt;&gt; eval f
== ~okay~  ; anti
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>It really seems the best plan is to keep erroring when you try to EVAL frames with antiform PARAMETER! in them, when those parameters are required:</p>
<pre><code>&gt;&gt; eval f2
** Error: HOLE?'s VALUE parameter is unspecified (antiform PARAMETER!)
</code></pre>
<p>It does require the ^META exception: functions which need to accept antiform arguments must take that parameter in a meta form.  A function like HOLE? would fit into this category, and so would SET (which has to take unstable antiforms anyway, e.g. to do SET of a BLOCK! to a PACK)</p>
<p>Under this design, any function that can accept antiform parameters at all, will also able to be specialized with antiform parameters.</p>
<h2><a name="p-7965-denoising-make-frame-different-frame-makers-7" class="anchor" href="https://forum.rebol.info#p-7965-denoising-make-frame-different-frame-makers-7"></a>Denoising MAKE FRAME!: Different Frame Makers?</h2>
<p>I pointed out that having antiform parameters in frame slots is a bit noisy.</p>
<p>So what if there were two ways of making frames: one that gives you the parameter antiforms (suitable for tweaking and writing your own specialization operations), and another that clears the fields out?</p>
<p>For instance, keeping the old behavior for MAKE FRAME!:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]]
</code></pre>
<p>But if you wanted antiform parameters, you could just copy the non-antiform version of the FRAME!:</p>
<pre><code>&gt;&gt; copy unrun append/
== #[frame! [
    series: ~#[parameter! [
        ~void~ any-series? port! map! object! module! bitset!]
    ]~
    value: ~#[parameter! [~void~ element? splice?]]~
    part: ~#[parameter! :[any-number? any-series? pair!]]~
    dup: ~#[parameter! :[any-number? pair!]]~
    line: ~#[parameter! :[]]~
]]
</code></pre>
<p>In this design, you'd have <em>two</em> stable forms which you'd have to use ^META conventions to take as an argument.</p>
<p>Antiform ~ would still have to turn into ~null~ if EVAL found it in a refinement slot.  But I'm not sure PARAMETER! antiforms would need to do that too.  One could argue that you should never be EVAL'ing a frame with antiform parameters in it, so it could be a sort of safety mechanism (?).  I'm not sure if it's necessary to enable, so I'd probably just raise an error until I saw a compelling case.</p>
<h2><a name="p-7965-is-the-added-nuance-worth-it-8" class="anchor" href="https://forum.rebol.info#p-7965-is-the-added-nuance-worth-it-8"></a>Is The Added Nuance Worth It?</h2>
<p>Continuing to handle unset variables as placeholders is not strictly necessary, given that antiform parameters are the more fundamental "unspecialized" slot representation.</p>
<p>But it's definitely a lot better than something I tried that <em>sucked</em>: which was trying to make variables holding antiform PARAMETER! act like they were unset.  This made manipulating function interfaces programmatically <em>very</em> painful.</p>
<p>It would mean sacrificing another value to have to be passed ^META.  Though bear in mind, most of the damage is done from having one form: e.g. a function like SET is having to take its value ^META already in order to be able to set things to antiform PARAMETER!.  So it isn't like you'd be able to specialize SET with antiform <code>~</code> to get UNSET if this wasn't done... it would affect the NOTHING? function (and probably not a lot else).</p>
<p><strong>Having used MAKE FRAME! a fair bit, I am inclined to believe it's worth it.</strong>  It's a clear indicator of whether you've assigned fields or not, with some teeth by actually making the variables unset (erroring on use before assignment, and reacting to things like DEFAULT).</p> ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347#post_1</link>
        <pubDate>Sat, 07 Dec 2024 20:48:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7965</guid>
      </item>
      <item>
        <title>BINARY! Dialected Encoding/Decoding instead of TO conversions?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1270">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; encode [LE + 2] 32
== #{2000}  ; little-endian, 2 byte, unsigned

&gt;&gt; encode [LE +/- 3] -2
== #{FEFFFF}  ; little-endian, 3 byte, signed
</code></pre>
</blockquote>
</aside>
<p>I got to wondering "why isn't there a numeric encoding for just negative numbers"?</p>
<p>Then I thought "uh, duh...no such representation is needed, as you just would negate the all-positive representation".</p>
<pre><code>&gt;&gt; negate decode [BE +] #{FF}
== -255
</code></pre>
<p>But with these encoders/decoders... why not build it in as an option?</p>
<pre><code>&gt;&gt; decode [BE -] #{FF}
== -255
</code></pre>
<p>And on encoding, you can ensure the input value is negative:</p>
<pre><code>&gt;&gt; encode [BE -] -255
== #{FF}

&gt;&gt; decode [BE -] 255
** Error: DECODE [BE -] requires input value to be negative
</code></pre>
<p>Not sure how often it would be used... I just like the completeness of it.</p>
<p>There's another axis of potential feature here, which is offset encoding.  So if you're trying to encode a range of numbers between 128 and 383, you can do that in a byte... just consider it to be offset by 128.  I can see it being kind of convenient if that offset were part of the dialected block, and could be reused on the encode and decode side.</p>
<p>Far from being any kind of priority, but, have to stay entertained somehow.</p> ]]></description>
        <link>https://forum.rebol.info/t/binary-dialected-encoding-decoding-instead-of-to-conversions/1270#post_3</link>
        <pubDate>Fri, 06 Dec 2024 16:52:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7964</guid>
      </item>
      <item>
        <title>Should (1 + #A) Equal (#A + 1) ?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I ran across this peculiarity:</p>
<pre><code>rebol2&gt;&gt; 1 + #"A"
== 66

rebol2&gt;&gt; #"A" + 1
== #"B"
</code></pre>
<p>Red and R3-Alpha do this too.</p>
<p>Loosely speaking, there's an internal policy which is something along the lines of <em>"if the types don't match, convert the second operand into the type of the first, and then do the add"</em>.</p>
<p>Because of this, it's necessary to support the addition of characters to each other to get <strong>(<span class="hashtag-raw">#A</span> + 1)</strong> to work:</p>
<pre><code>red&gt;&gt; #"A" + #"B"
== #"^(83)"  ; only useful in implementation of old coercion rule
</code></pre>
<p>...which seems nonsensical to me.</p>
<h2><a name="p-7963-what-do-other-languages-do-1" class="anchor" href="https://forum.rebol.info#p-7963-what-do-other-languages-do-1"></a>What Do Other Languages Do?</h2>
<p>If "implicit type promotion" is supported, many languages, including C, C++, and Java, use a system where the "smaller" type is converted to the "larger" type (<a href="https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap02/exp-2.html">e.g., int to float</a>).  Having an idea of what's bigger and what's smaller helps avoid the commutativity problem.</p>
<p>And in the specific case of adding characters to integers, Rebol is weird to give a different answer depending on order.</p>
<ul>
<li>
<p><strong>Python:</strong> In Python, adding an integer to a character (or vice versa) would raise a TypeError. Python doesn't implicitly convert between these types.</p>
</li>
<li>
<p><strong>JavaScript:</strong> JavaScript would convert the character to its ASCII value and perform integer addition in both cases, resulting in a number.</p>
</li>
<li>
<p><strong>Ruby:</strong> Similar to Python, Ruby would raise a TypeError when trying to add an integer to a character.</p>
</li>
<li>
<p><strong>Java:</strong> Java doesn't allow direct addition between char and int types without explicit casting.</p>
</li>
</ul>
<p>I think adding integers to characters and wanting a character back is the more common operation, so if it's legal, I'd advocate for:</p>
<pre><code>&gt;&gt; 1 + #A
== #B

&gt;&gt; #A + 1
== #B
</code></pre>
<p>But if we want to rule out addition of characters to characters (which I do) this commutative behavior doesn't fall out from a system of implicit conversion with an ordering on "bigger" types... since characters are smaller.</p>
<p>I don't see an obvious "rule" besides hardcoding it.</p>
<h2><a name="p-7963-what-about-commutativity-in-general-2" class="anchor" href="https://forum.rebol.info#p-7963-what-about-commutativity-in-general-2"></a>What About Commutativity In General?</h2>
<p>We can imagine decisions on what you would make <strong><code>+</code></strong> mean that would not be commutative.  For instance, if you were allowed to make it mean "join strings":</p>
<pre><code>&gt;&gt; "abc" + "def"
== "abcdef"

&gt;&gt; "def" + "abc"
== "defabc"
</code></pre>
<p>So you might try and argue that the rules for <strong>add</strong> are different than the rules for <strong>+</strong>, and it's only when + is acting as ADD that it enforces commutativity.  However... even in the domain of math, you have exceptions... e.g. matrix multiplication is not commutative.</p>
<p>The more general question of commutativity seems to be that there aren't any popular languages that do it automatically.  e.g. in C++ you have to overload <strong><code>operator+(T1,T2)</code></strong> and <strong><code>operator+(T2,T1)</code></strong> separately...one of them can call the other, but that never happens automatically.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-1-a-equal-a-1/2346#post_1</link>
        <pubDate>Fri, 06 Dec 2024 12:30:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7963</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Wanting to move refinements is actually a pretty big thinking point at the moment, if you saw this:</p>
</blockquote>
</aside>
<p>Sure, but that isn’t relevant to the order of the mandatory parameters, which is what you’re talking about here… right?</p> ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_10</link>
        <pubDate>Tue, 03 Dec 2024 02:55:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7962</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="8" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>But maybe there’s some other part of the language which is affected by parameter order. (Refinements? Not sure…)</p>
</blockquote>
</aside>
<p>Wanting to move refinements is actually a pretty big thinking point at the moment, if you saw this:</p>
<aside class="quote quote-modified" data-post="1" data-topic="2331">
  <div class="title">
    <div class="quote-controls"></div>
    <img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar">
    <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">Refinement Arguments at Head of Args List, Not Tail</a> <a class="badge-category__wrapper " href="https://forum.rebol.info/c/development/functions/59"><span data-category-id="59" style="--category-badge-color: #25AAE2; --category-badge-text-color: #FFFFFF; --parent-category-badge-color: #25AAE2;" data-parent-category-id="8" data-drop-close="true" class="badge-category --has-parent" title="Discussions of Functions and Generators, e.g. how things like RETURN work... or the mechanics of generators and composers like ADAPT, SPECIALIZE, ENCLOSE, HIJACK, etc."><span class="badge-category__name">Functions</span></span></a>
  </div>
  <blockquote>
    In the corpus of code we have so far, it seems to me that when a refinement adds an argument to a function that it would be preferable if that argument would become the first parameter... not tacked onto the end. 
Some cases might not be completely obvious one way or another: 
&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append:dup [a b c] [d e] 2  ; old way
== [a b c [d e] [d e]] 

&gt;&gt; append:dup 2 [a b c] [d e]  ; new idea
== [a b c [d e] [d e]]

I think it's better if it's first, but it's not …
  </blockquote>
</aside>
 ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_9</link>
        <pubDate>Tue, 03 Dec 2024 02:41:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7961</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It's really hard, though, to see this systemically with fresh eyes.</p>
</blockquote>
</aside>
<p>I think that considerations of parameter order in Haskell go more or less like this:</p>
<ol>
<li>If there’s an obviously intuitive ordering, use that.</li>
<li>Otherwise, if there’s an ordering which simplifies the definition, use that.</li>
<li>Otherwise, if there’s no other deciding factor, order them according to what is most useful for partial application.</li>
</ol>
<p>I think to some extent these criteria are less helpful for Ren-C, because it doesn’t make as much use of eta-reduction, currying or partial application. But maybe there’s some other part of the language which is affected by parameter order. (Refinements? Not sure…)</p> ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_8</link>
        <pubDate>Tue, 03 Dec 2024 02:39:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7960</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>If someone wants to specify the second parameter first they can always write <code>flip cons</code> or <code>flip snoc</code>.</p>
</blockquote>
</aside>
<p><a href="https://forum.rebol.info/t/design-for-something-like-flip-to-reverse-arguments/2345/1">Some thoughts here</a></p>
<aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>So really this parameter order is so intuitive that it overrides considerations of ‘less/more important’.</p>
</blockquote>
</aside>
<p>It's really hard, though, to see this systemically with fresh eyes.</p>
<p>Today for instance REPLACE takes the thing to do the replacement in first:</p>
<pre><code>&gt;&gt; replace [a b b a] 'b 'c
== [a c c a]
</code></pre>
<p>But if this philosophy were extended that would become either of:</p>
<pre><code>&gt;&gt; replace 'c 'b [a b b a]
== [a c c a]

&gt;&gt; replace 'b 'c [a b b a]
== [a c c a]
</code></pre>
<p>It's hard to say which makes more sense.  If the "how you would write it out in English" argument comes up,  it seems briefest as:</p>
<pre><code>replace 'b &lt;with&gt; 'c &lt;in&gt; [a b b a]
</code></pre>
<p>I'm not sure how that would hammer out in the other case:</p>
<pre><code>replace 'c &lt;wherever you find&gt; 'b &lt;in&gt; [a b b a]
</code></pre>
<p>But once you move away from the "obvious-seeming" cases, the whole thing stops seeming obvious.  There's a lot of inertia behind the historical choices...this is tough to reason about.</p> ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_7</link>
        <pubDate>Mon, 02 Dec 2024 14:45:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7959</guid>
      </item>
      <item>
        <title>Design for Something Like FLIP To Reverse Arguments</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238/6">Parameter Order in Rebol</a></div>
<blockquote>
<p>If someone wants to specify the second parameter first they can always write <code>flip cons</code> or <code>flip snoc</code>.</p>
</blockquote>
</aside>
<p>The design of a FLIP-like operation raises some questions.</p>
<p>If it were an operator that acted on functions, it wouldn't retrigger them.  You'd have to say:</p>
<pre><code>&gt;&gt; append 'd [a b c]
== [a b c d]

&gt;&gt; run flip append/ [a b c] 'd
== [a b c d]
</code></pre>
<p>Alternately, I guess you could use slash to run a GROUP!, but then you'd have a disabling slash and a running slash:</p>
<pre><code>&gt;&gt; /(flip append/) [a b c] 'd
== [a b c d]
</code></pre>
<p>If it were instead something along the lines of RUN, where applying the flipped function was implicit, you could write:</p>
<pre><code>&gt;&gt; flip append/ [a b c] 'd
== [a b c d]
</code></pre>
<p>I don't think <strong><code>flip/append</code></strong> being a synonym for <strong><code>/(flip append/)</code></strong> is a generically useful idea, compared to the likes of <strong><code>not/even?/</code></strong> for cascading.</p>
<p>But if the <a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">weird idea of dialected CHAIN!</a> ever came to pass, FLIP could go into a distinct mode based on receiving a function in the place other functions have refinements...</p>
<pre><code>&gt;&gt; append/
== ~#[frame! [value series]]~

&gt;&gt; flip append/
== ~#[frame! [series value]]~

&gt;&gt; flip:append [a b c] 'd
== [a b c d]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/design-for-something-like-flip-to-reverse-arguments/2345#post_1</link>
        <pubDate>Mon, 02 Dec 2024 14:41:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7958</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>In Haskell, a lot of collection libraries define two operations, such as these ones from <code>text</code>:</p>
<pre data-code-wrap="hs"><code class="lang-hs">cons :: Char -&gt; Text -&gt; Text
snoc :: Text -&gt; Char -&gt; Text
</code></pre>
<p>(The name <code>snoc</code> comes from being the reverse of <code>cons</code>… geddit?)</p>
<p>So really this parameter order is so intuitive that it overrides considerations of ‘less/more important’. If someone wants to specify the second parameter first they can always write <code>flip cons</code> or <code>flip snoc</code>.</p> ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_6</link>
        <pubDate>Mon, 02 Dec 2024 01:24:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7957</guid>
      </item>
      <item>
        <title>Parameter Order in Rebol</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Most-or-Least Important Thing First</p>
</blockquote>
</aside>
<h2><a name="p-7956-i-formulated-this-question-1" class="anchor" href="https://forum.rebol.info#p-7956-i-formulated-this-question-1"></a>I Formulated This Question</h2>
<p>If you were to look at it with fresh eyes, as someone who had never programmed before (but spoke English), how different would you perceive these orderings of parameters to some array mutation operations... would one seem preferable over the other?</p>
<pre><code>&gt;&gt; append 'd [a b c]
== [a b c d]

&gt;&gt; append [a b c] 'd
== [a b c d]

&gt;&gt; insert 'a [b c d]
== [a b c d]

&gt;&gt; insert [b c d] 'a
== [a b c d]
</code></pre>
<hr>
<h2><a name="p-7956-claudeai-says-2" class="anchor" href="https://forum.rebol.info#p-7956-claudeai-says-2"></a>Claude.AI Says...</h2>
<blockquote>
<p>Let me analyze these parameter orderings from a fresh, beginner's perspective.</p>
<p>The first thing I notice is there's a subtle but important pattern in these operations. If we look at the append and insert examples, there are two variations:</p>
<ol>
<li><code>append 'd [a b c]</code> and <code>insert 'a [b c d]</code></li>
<li><code>append [a b c] 'd</code> and <code>insert [b c d] 'a</code></li>
</ol>
<p>From a newcomer's perspective, I'd argue that the first set (1) feels more intuitive and readable. Here's why:</p>
<ul>
<li>The target collection (the array/list) comes <em>after</em> the element being added</li>
<li>This reads more like natural language: "append 'd to [a b c]"</li>
<li>It feels like you're specifying "what" first (the element), then "where" second (the collection)</li>
</ul>
<p>The alternative ordering (2) requires a bit more mental gymnastics. When you say <code>append [a b c] 'd</code>, you're essentially saying "append this whole list to this single item", which feels counterintuitive.</p>
<p>The same logic applies to the <code>insert</code> operations. <code>insert 'a [b c d]</code> reads more naturally as "insert 'a into [b c d]" compared to <code>insert [b c d] 'a</code>.</p>
<p>So if I were completely new to programming, I would find the first set of orderings (<code>append 'd [a b c]</code> and <code>insert 'a [b c d]</code>) more:</p>
<ul>
<li>Readable</li>
<li>Predictable</li>
<li>Aligned with how I might describe the operation in spoken language</li>
</ul>
<p>This suggests the design prioritizes clarity and cognitive ease for the programmer, which is crucial when learning a new programming language or concept.</p>
</blockquote>
<hr>
<p>I'm wondering if we didn't have our preconceptions, would it be obviously the case that the reverse order was more natural...or not?  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<p>It is true that it takes some gymnastics to write it out:</p>
<pre><code>append [a b c] 'd
=&gt;
append to [a b c] the value 'd

vs.

append 'd [a b c]
=&gt;
append 'd to [a b c]
</code></pre>
<p>But along with that, this idea of the "lesser important" (configuring) parameters being first, is something that's really gotten into my head...the reverse-OOP argument from Haskell.  I've made it possible now for generics to dispatch on any parameter, so it's technically not an issue any longer to choose a different dispatch.</p> ]]></description>
        <link>https://forum.rebol.info/t/parameter-order-in-rebol/1238#post_5</link>
        <pubDate>Sun, 01 Dec 2024 16:03:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7956</guid>
      </item>
      <item>
        <title>Module Startup and Shutdown (Constructors, Destructors?)</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="960">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I noticed something in Go related to this, <a href="https://blog.golang.org/defer-panic-and-recover">which is their <code>defer</code> keyword</a>:</p>
</blockquote>
</aside>
<p>In <a href="https://forum.rebol.info/t/rebol-1-0-retrospective/1788/5">Rebol 1.0</a>, there's something called SHIELD:</p>
<blockquote>
<p><strong><code>shield before-block main-block after-block</code></strong></p>
<p>Shield a block from catch and other types of exception handling, allowing it to take the necessary steps to initialize and finalize its state.</p>
<pre><code>print catch 'throw [
    shield [
        print "entering"
    ][
        repeat n 10 [if n &gt; 5 [throw "thrown out"]]
    ][
        print "exiting"
    ]
]
</code></pre>
<p>This will output:</p>
<pre><code>entering
exiting
thrown out
</code></pre>
</blockquote>
<p>It might seem unclear as to why you would need to have a "before-block" instead of just writing your code before the call to SHIELD.  But Rebol 1.0 is very function-driven.  So:</p>
<pre><code>(before-code shield main-block after-block)
</code></pre>
<p>...would be a GROUP! instead of a single function call, and I believe the thinking was more that if it was a function that it would "fit in more slots" where a GROUP! would complicate things.  (?)</p>
<p>Anyway...this category of things is still a functionality gap in Ren-C, because all you can do is trap and rescue and catch things...and you have to care about whether you're catching or trapping, and you have to rethrow or re-fail.  Things like SHIELD and DEFER are all trivial to implement, but it's just not certain what the right way to get constructor/destructor type behaviors is in this language.</p> ]]></description>
        <link>https://forum.rebol.info/t/module-startup-and-shutdown-constructors-destructors/960#post_5</link>
        <pubDate>Sun, 01 Dec 2024 15:38:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7955</guid>
      </item>
      <item>
        <title>The %rebol.r Boot File From Rebol 1.0</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <h2><a name="p-7954-exception-handling-1" class="anchor" href="https://forum.rebol.info#p-7954-exception-handling-1"></a>Exception Handling</h2>
<pre><code>do-with-exception-handler: make function! [handler body] [
    do make function! [outside-value inside-value] [
        shield [outside-value: :exception-handler-stack
                exception-handler-stack: :inside-value]
               :body
               [inside-value: :exception-handler-stack
                exception-handler-stack: :outside-value]
        ] :exception-handler-stack 
          stack-push :exception-handler-stack :handler
    ]
</code></pre>
<p>So DO-WITH-EXCEPTION-HANDLER is defined in <code>%rebol.r</code>, but not used by it (e.g. it's not how the REPL traps errors).  Hence we don't see any usages of the exception handling functions.</p>
<p>But what we do see is that it depends on a native called SHIELD, which is in the user guide:</p>
<pre><code>shield before-block main-block after-block
</code></pre>
<p>This appears to be a convenience of some kind, to let you register a handler to keep you from having to go around SHIELD-ing all your individual calls.</p>
<h2><a name="p-7954-readevalprint-loop-repl-2" class="anchor" href="https://forum.rebol.info#p-7954-readevalprint-loop-repl-2"></a>Read/Eval/Print Loop (REPL)</h2>
<p>The REPL is initialized by a call to INIT-REPL, which passes in some messages and ports, and a context to do evaluations in:</p>
<pre><code>init-repl
    [linefeed prin "REBOL top level."]         ; start-message
    [linefeed prin "Returning to top level."]  ; resume-message
    "&gt;&gt; "                                      ; prompt
    user-context                               ; repl-context
    input-port                                 ; repl-input-port
    output-port                                ; repl-output-port
</code></pre>
<p>The meat of INIT-REPL is in this code that it passes to PUSH-REPL, which I've</p>
<pre><code>do make function! [form] [
     write-block-or-element :repl-output-port (
         shield [&amp;trace repl-trace nearest-repl]  ; before-block
                [eval-reduce :form :repl-context]  ; main-block
                [&amp;trace false]  ; after-block
     )
] (port-read :repl-input-port)
</code></pre>
<p>If we were to make this a bit less obtuse:</p>
<pre><code>form: port-read :repl-input-port  ; READ

result: shield [&amp;trace repl-trace nearest-repl] 
               [eval-reduce :form :repl-context]  ; EVAL
               [&amp;trace false]

write-block-or-element :repl-output-port :result  ; PRINT
</code></pre>
<p>So I gather the SHIELD is there to make sure that if code was being traced and there was an error, you don't wind up tracing the REPL itself.  It doesn't actually catch errors or throws, it just seems to make sure your AFTER-BLOCK code runs.  <img src="https://forum.rebol.info/images/emoji/twitter/confused.png?v=12" title=":confused:" class="emoji" alt=":confused:" loading="lazy" width="20" height="20"></p>
<p><strong>I don't see anything about printing error messages, and there's nothing in the user's guide about an ERROR! type, so it seems like errors aren't values.</strong></p>
<p>So what probably happens when there's an error is that the interpreter just prints it.  I don't know what the SHIELD's result is... NONE?</p>
<p>It would be easier to understand the situation with errors or uncaught throws with a working interpreter.</p>
<h2><a name="p-7954-ctrl-c-handling-3" class="anchor" href="https://forum.rebol.info#p-7954-ctrl-c-handling-3"></a>Ctrl-C Handling</h2>
<pre><code>;;; The repl-driver drives the console interaction.  The argument
;;; 'once' is assumed to do a single interaction.  We capture a return 
;;; continuation and then turn on the interrupts before calling
;;; 'once'.  If an error or control C happens, control is transfered
;;; to the captured continuation.  Since this continuation is captured 
;;; in a (dynamic) context with interrupts turned off, the interrupts
;;; are disabled while iterating around the loop (so the loop cannot
;;; be broken by a lucky interrupt).
</code></pre>
<p>So at least this has something in common with Ren-C, which is the implementation of the REPL in usermode...and being sensitive to questions like not wanting you to be able to Ctrl-C the REPL implementation itself.  Ren-C also disables the Ctrl-C while inside the console's implementation.</p>
<p><em>(Though interestingly, you can Ctrl-C if you're in console <em>skin</em> code...a misbehaving skin where you've customized your I/O can be canceled, and it will fall back on the default skin.)</em></p>
<p>There's a definition exported to the user context:</p>
<pre><code> halt: func [] [top-level-continuation none]
</code></pre>
<p>Which this does the same thing as Ctrl-C.  I still kind of want to understand the limits of what is possible with these "throws" that are being called continuations, and just how arbitrarily you can throw the program around.</p>
<p>Anyway, it's still a bit murky what some of it is doing, but by-and-large I pretty much understand it.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344#post_2</link>
        <pubDate>Sun, 01 Dec 2024 12:44:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7954</guid>
      </item>
      <item>
        <title>The %rebol.r Boot File From Rebol 1.0</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>While we don't have the C source code for Rebol 1.0, we do have the <code>%rebol.r</code> initialization file:</p>
<p><a href="https://gist.github.com/hostilefork/d6cfac90141688bd41b1b38a9a203b02" class="inline-onebox">Rebol 1.0.2 Initialization File (October 7, 1998) · GitHub</a></p>
<p>It would seem that if there were an ability to pack source code in with the executable, they would have done it...given that the Quick Start says <em>"do not modify <code>rebol.r</code>. If you accidentally do modify <code>rebol.r</code>, reinstall it."</em></p>
<p><em><strong>Hence this is probably the entire portion of Rebol 1.0 that's written in Rebol, e.g. the whole "Mezzanine".</strong></em></p>
<p>It says:</p>
<pre><code>;;; Note: Code in rebol.r runs in the system context.  The system
;;; context [has] all the built in bindings of the user context, but also
;;; has extra bindings to allow rebol to be bootstrapped.  Many of the 
;;; rebol functions available in user code are actually written in
;;; terms of simpler rebol natives, or in terms of special
;;; system natives.

;;; REBOL reserves the right to change the system natives at any time, 
;;; so you shouldn't depend on them for portable code.
</code></pre>
<h1><a name="p-7953-remarks-on-contents-in-no-particular-order-1" class="anchor" href="https://forum.rebol.info#p-7953-remarks-on-contents-in-no-particular-order-1"></a>Remarks On Contents, In No Particular Order</h1>
<h2><a name="p-7953-func-definition-2" class="anchor" href="https://forum.rebol.info#p-7953-func-definition-2"></a>FUNC Definition</h2>
<pre><code>func: make function! [args body] [make function! :args :body]
</code></pre>
<p>I found it a bit interesting that the <a href="https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340/6#p-7944-func-shortcut-5">User Guide talked about how FUNC was defined</a>, as an illustrative example, of an important thing for users to know about.  (It turns out there's a <a href="https://www.rebol.com/docs/core23/rebolcore-9.html">brief mention in the Rebol2 User's Guide</a>, but the Rebol 1.0 Guide writes it up twice, probably on accident.)</p>
<p>It's worth pointing out that there's big questions even in this seemingly simple definition.  Such as, should a function copy its arguments or body?  What should this do?</p>
<pre><code> body: [print "Hello"]
 foo: func [] body
 append body [print "Goodbye"]
 bar: func [] body
</code></pre>
<p>Does <strong>foo</strong> print just "Hello", or does it print "Hello" and "Goodbye"?</p>
<p>I don't yet know what Rebol1 did, but Rebol2's MAKE FUNCTION! would <em>not</em> copy the body.  So FUNC would do a deep copy as the "higher level" operator, before passing it to MAKE FUNCTION!.</p>
<p>But during bootstrap, it used a definition of FUNC that <em>didn't</em> copy the body, for performance reasons...which it switched over to the copying implementation at the end of boot.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p>Some version of these crazy optimizations are on the table for future Ren-C.</p>
<h2><a name="p-7953-print-prin-probe-3" class="anchor" href="https://forum.rebol.info#p-7953-print-prin-probe-3"></a>PRINT, PRIN, PROBE</h2>
<pre><code>write-block-or-element:
    make function! [port element] [
             do
                if block? :element [:write-block] else [:form-to-port]
                :port
                :element]

write-block: func [port block] [    ; !!! needs work
    foreach element :block [form-to-port :port :element form-to-port :port " "]
]

prin: func [value] [
    if block? :value [write-block output-port reduce :value]
    else [form-to-port output-port :value]
    exit
]

print: func [value] [
    prin :value
    linefeed-port output-port
    exit
]

probe: func [value] [
     prin " PROBE --&gt; "
     send output-port :value
     linefeed-port output-port
     :value
 ]
</code></pre>
<p>Weird.  (and prints a space after every element, so you get a space at the end of the line vs. just delimited between, etc.)</p>
<p>At least one interesting aspect of this is to see the rigid "EXIT" at the end to make sure that PRIN and PRINT don't leak a result on accident.  Things like this feel like a vindication of Ren-C's <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">requirement to use a RETURN</a> in order to give back a result from FUNC (but not LAMBDA).</p>
<h2><a name="p-7953-is-as-to-logic-4" class="anchor" href="https://forum.rebol.info#p-7953-is-as-to-logic-4"></a>IS? as TO-LOGIC</h2>
<pre><code>is?: func [value] [not not :value]
</code></pre>
<p>This was called TRUE? in Rebol2, and I very much disliked the ambiguity of that vs. testing to see if a value was <code>= #[true]</code> the LOGIC! literal.</p>
<p>I wrote something up about <a href="http://blog.hostilefork.com/did-programming-opposite-of-not/">how DID could be the opposite of NOT</a> (which even goes together as DIDN'T for DID NOT).  But due to some various shades of meaning the current state is that it means THEN? and DIDN'T means ELSE? as prefix tests for the trigger conditions that would run THEN or ELSE.  It needs thought.</p>
<p>Anyway, interesting to see the choice of <code>IS?</code> here.</p>
<h2><a name="p-7953-a-recursive-folding-any-and-all-interrobang-5" class="anchor" href="https://forum.rebol.info#p-7953-a-recursive-folding-any-and-all-interrobang-5"></a>A Recursive Folding ANY and ALL <img src="https://forum.rebol.info/images/emoji/twitter/interrobang.png?v=12" title=":interrobang:" class="emoji" alt=":interrobang:" loading="lazy" width="20" height="20"></h2>
<pre><code>any: func [block] [
    eval-one block
        make function! [value rest] [
            if not value [any rest]
            else [value]
        ]
        make function! [value] [value]
]

all: func [block] [
    eval-one block
        make function! [value rest] [
            if is? value [all rest]
            else [false]
        ]
        make function! [value] [value]
]
</code></pre>
<p>So this is based on a function called EVAL-ONE, that takes a list and two functions.  It isn't defined in %rebol.r and isn't in the reference guide either.  But it's a right fold with early termination.</p>
<p>One can definitely imagine the Joe Marshall and Carl friction on this (<em>"why all you making all these these usermode functions and calls, why not just use a loop?"</em>).</p>
<p>While there's a time and a place for this, I do think that if you are starting to push out into the usermode layers and finding this mentality is driving it...you're going to end up with something that isn't hitting the mark that Rebol was aiming at.</p>
<h2><a name="p-7953-why-is-pick-so-weird-6" class="anchor" href="https://forum.rebol.info#p-7953-why-is-pick-so-weird-6"></a>Why Is PICK So Weird?</h2>
<pre><code>pick: func [series index] [
  do make function! [offset] [
    if (:offset + index? :series) &lt;= 1
        [none]
    else [do make function! [disp] [
            if (length? :disp) = 0 
               [none]
            else
               [&amp;peek :disp 0]
            ] skip :series if :offset &lt; 0 [:offset] else [:offset - 1]
         ]
    ] if logic? :index [if :index [1] else [2]] else [:index]
]
</code></pre>
<p>My guess here is that the pattern:</p>
<pre><code>do make function! [arg] [...code with arg...] value-for-arg
</code></pre>
<p>...is probably some holdover from before USE existed.  Or maybe USE is just an abstraction built on functions, and so it's done this way for optimization.  I dunno.</p>
<h2><a name="p-7953-poor-mans-export-7" class="anchor" href="https://forum.rebol.info#p-7953-poor-mans-export-7"></a>Poor-Man's EXPORT</h2>
<pre><code>;;; These functions can be defined in terms of system natives that are
;;; not available in the user context.  Since we made the functions in 
;;; this context, the values of the words in the body are relative to
;;; this context.  But we place the functions in the user context so
;;; that the users can call them.  This allows the user to call the
;;; system natives through a defined API in a controlled manner.

user-functions: [
    dir? [file] [do func [info] [info/dir?] info? :file]
    size? [file] [do func [info] [info/size] info? :file]
    ...
]

foreach [name args body] user-functions [
    context-set user-context name func args body
]
</code></pre>
<p>So the comment says what's going on here, it's the attempt to push functions out into the user context when they're implemented in terms of functions that aren't available in the user context.  I'm not sure what's not available <em>(these implementations of DIR? and FILE? are based on INFO?, is that not exported to the user context?)</em></p>
<p>As far as I know, there's nothing like this in Rebol2 (there's no separate <code>user-context</code> from a <code>system-context</code>, is there?)  Interesting if that was something that disappeared in Rebol2 and came back in Rebol3.</p>
<h2><a name="p-7953-more-modularization-eval-reduce-takes-context-8" class="anchor" href="https://forum.rebol.info#p-7953-more-modularization-eval-reduce-takes-context-8"></a>More Modularization: EVAL-REDUCE Takes Context</h2>
<pre><code>if not none? REBOL/script [
    if exists? REBOL/script [
        do make function! [] [
                top-level-continuation: :return
                if not REBOL/silent [
                        linefeed
                        prin "Loading script "
                        print REBOL/script]
                eval-reduce [do REBOL/script] user-context
                ]
        ]
    ]
</code></pre>
<p>Rebol1 seems to have been working with modularization ideas, because even during startup, the script you pass on the command line is run via something called EVAL-REDUCE that takes a parameter of where to do the evaluation.</p>
<p>So definitely a shame that Rebol2 seems to have moved away from the idea that evaluations needed to be done in a context.</p>
<h2><a name="p-7953-catch-is-defined-in-terms-of-catch-func-9" class="anchor" href="https://forum.rebol.info#p-7953-catch-is-defined-in-terms-of-catch-func-9"></a>CATCH is defined in terms of CATCH-FUNC</h2>
<p>We know from the <code>user-functions</code> exporting that this:</p>
<pre><code>catch [word block] [catch-func func reduce [word] :block]
</code></pre>
<p>Is actually:</p>
<pre><code>catch: func [word block] [catch-func func reduce [word] :block]
</code></pre>
<p>Since there's no type checking, there's a <code>:BLOCK</code> GET-WORD! just to be sure it's not a function, I guess?  And then it's FUNC's job to do a check in its implementation.  But then, why not <code>:WORD</code> just to be sure WORD! isn't a function you're calling?  <em>(I like pointing this out, due to Ren-C's better answers to this issue...avoiding the "pox of documenting what you <strong>don't</strong> know")</em></p>
<p>So the idea of using functions as proxies for "virtual binding" is the <em>old way</em>.  What's going on here is that the block contains code that wants to be bound to whatever the throw construct is, and so that block is made the body of a function, that you call and pass the thing you want bound to that name as the argument.  (COLLECT+KEEP worked this way).  But it's undesirable, because it means you've lost the fluidity of having the currency of a structural BLOCK!...replaced with the black box of a function just because you wanted to bind something.</p>
<p>I'm pretty sure this CATCH mechanic (being called a "continuation") is stackful and can't do anything too bizarre, but I'd like an executable to try and ensure that.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344#post_1</link>
        <pubDate>Sun, 01 Dec 2024 12:40:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7953</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 Quick Start Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p>Discovered at FTP cache: <a href="https://grumbeer.dyndns.org/ftp/www.ibiblio.org/distributions/redhat-5.1/apps-i386/REBOL/">https://grumbeer.dyndns.org/ftp/www.ibiblio.org/</a></p>
<p><em>README.txt says Rebol 1.0.2 was released 6-October-1998</em></p>
<p>See also:</p>
<ul>
<li>
<p><a href="https://forum.rebol.info/t/rebol-1-0-retrospective/1788">Discussion Thread: <strong>Rebol 1.0 Retrospective</strong></a></p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340"><strong>Rebol 1.0.2 User's Guide</strong></a></p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344"><strong>The %rebol.r Boot File From Rebol 1.0</strong></a></p>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>Copyright (c)1998 REBOL Technologies. All Rights Reserved.</strong></p>
</blockquote>
<hr>
<h1><a name="p-7948-rebolcore-quick-start-guide-1" class="anchor" href="https://forum.rebol.info#p-7948-rebolcore-quick-start-guide-1"></a>REBOL/Core Quick Start Guide</h1>
<h3><a name="p-7948-about-this-guide-2" class="anchor" href="https://forum.rebol.info#p-7948-about-this-guide-2"></a>About This Guide</h3>
<p>This guide includes the facts you need to start using REBOL (pronounced REB-ul) quickly. It offers concise information for installing REBOL on any of numerous computer operating systems. This guide then summarizes the spirit of REBOL: what it is, how it functions, and how to put it to work for you quickly. Finally, this guide offers steps for learning more about the power of REBOL.</p>
<p>No prior knowledge of computer languages is needed to use REBOL. In fact, if you have used other languages, forget what you know because REBOL’s approach to computer language is refreshingly unique. It’s simple.</p>
<h3><a name="p-7948-how-to-install-rebol-3" class="anchor" href="https://forum.rebol.info#p-7948-how-to-install-rebol-3"></a>How to Install REBOL</h3>
<p>Here are the procedures for installing REBOL on your computer:</p>
<ol>
<li>
<p>Make a new directory for the files, typically named REBOL.</p>
</li>
<li>
<p>Uncompress the distribution file using the standard method for the operating system.</p>
</li>
<li>
<p>Move the uncompressed files to the new directory.</p>
</li>
</ol>
<p>That’s it. The three REBOL files are <strong>rebol.exe</strong> (executable program), <strong>rebol.r</strong> (initialization file), and <strong>user.r</strong> (your definitions file). You can customize your copy of REBOL using <strong>user.r</strong>, but do not modify <strong>rebol.r</strong>. If you accidentally do modify <strong>rebol.r</strong>, reinstall it.</p>
<p>Also included in the release are documentation files in HTML format: <strong>quick.html</strong>, <strong>users.html</strong>, and <strong>experts.html</strong>. They can be read with a web browser program.</p>
<p>To uninstall REBOL, simply delete the directory and files.</p>
<h3><a name="p-7948-the-rebol-spirit-4" class="anchor" href="https://forum.rebol.info#p-7948-the-rebol-spirit-4"></a>The REBOL Spirit</h3>
<p>Computers are designed to solve problems for people (though it may not always seem that way). The problems are defined using a computer <em>language</em> .</p>
<p>REBOL is an acronym for <strong>relative expression-based object language</strong> . That means it’s a language that uses clear expressions rather than cryptic codes to instruct a computer.</p>
<p>A <em>programming language</em> communicates between computers and programs. You must understand how computers function to write programs for them. For example, instructing a computer to print the phrase "REBOL World" on the screen would look like this in Java programming language:</p>
<pre><code>class REBOLWorldApp {
    public static void main(String[] args) {
        System.out.println("REBOL World!")
    }
}
</code></pre>
<p>Most computer languages require that you think like a computer rather than a human to communicate with it. REBOL communicates in human terms. The REBOL instruction for "REBOL World" looks like this:</p>
<pre><code>print "REBOL World"
</code></pre>
<p>Much simpler!</p>
<p>Simplicity is power. REBOL can do much more than display phrases on your computer. It can do mathematical calculations, filter and respond to your email, send files to other computers, manage databases, and more. And information isn’t lost if moved to another computer. REBOL is system independent.</p>
<p>That’s because REBOL is a messaging language. A <em>messaging language</em> communicates information between applications running on other computers. Unfortunately, most computers don’t communicate well with other computers. Some data from Windows applications, for example, can’t be read on Linux or Macintosh computers, and vise versa. REBOL passes useable data and messages between otherwise incompatible computer systems.</p>
<p>English and other human languages are messaging languages between people. REBOL is a messaging language between computer applications. That makes REBOL easier and more natural to use than other computer languages.</p>
<p>Let’s get started using REBOL!</p>
<h3><a name="p-7948-getting-started-in-rebol-5" class="anchor" href="https://forum.rebol.info#p-7948-getting-started-in-rebol-5"></a>Getting Started in REBOL</h3>
<p>You write REBOL instructions as a <strong>script</strong> . Think of a REBOL script as the first half of a conversation with REBOL. The second half is the answer that REBOL gives you, called the <strong>result</strong> .</p>
<p>You’ve learned from the "REBOL World" example that <strong>print</strong> requests an output and that <strong>""</strong> encloses a <strong>string</strong> of characters. Easy enough, but not very useful yet.</p>
<p>What if you could give REBOL data that it works on, then gives back to you? What if it could add up your bills, sort your address book, backup computer files, or handle your email for you? Those tasks would be more useful to you.</p>
<p>To write simple REBOL scripts to handle these and other tasks, you need to know more of the power inside of REBOL. So let’s look at the REBOL language and define some terms.</p>
<p>In REBOL, any <em>type of data</em> is called a <strong>value</strong> . A <strong>datatype</strong> can be a</p>
<ul>
<li>string ("REBOL World")</li>
<li>date (1-Jan-2000)</li>
<li>integer (1 100 -1000)</li>
<li>decimal (1.25)</li>
<li>tuple (1.0.3 255.355.100)</li>
<li>email address (<a href="mailto:johnny@rebol.com">johnny@rebol.com</a>)</li>
<li>url (<a href="http://www.rebol.com/">http://www.rebol.com/</a>)</li>
<li>block ([11 47 26 999])</li>
<li>file (%rebol.r)</li>
<li>word (when)</li>
</ul>
<p>In fact, REBOL knows and uses dozens of datatypes (defined with examples in <strong><a>Expert’s Guide</a></strong> ). <strong>Datatypes</strong> are simply types of data that REBOL already knows how to handle. For example, it sees an <em>at sign</em> (@) in a string (<a href="mailto:johnny@rebol.com">johnny@rebol.com</a>), REBOL knows that the string is an email address.</p>
<p>REBOL datatypes are <em>smart</em> . Adding an exclamation point after the datatype (date!) tells REBOL to return the result in the standard international date format (day-month-year) — even if you type it in another format.</p>
<p>Smart datatypes make writing REBOL scripts easy.</p>
<h3><a name="p-7948-writing-a-rebol-script-6" class="anchor" href="https://forum.rebol.info#p-7948-writing-a-rebol-script-6"></a>Writing a REBOL Script</h3>
<p>Now, let’s put REBOL to work!</p>
<p>First, you want to <strong>make</strong> a tool or <strong>function</strong> that actually does the work. Let’s call it when and define it (<img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"> like this:</p>
<pre><code>when: make date! [30 9 1998]
</code></pre>
<p>As you can see, you <strong>make</strong> when a function that changes the given value to a standard date format (!). The block defines what value is used [30 9 1998]. So what else do you have to tell REBOL?</p>
<pre><code>print when
</code></pre>
<p>and REBOL’s result is</p>
<pre><code>30-Sept-1998
</code></pre>
<p>The REBOL script you wrote defined when exactly like the prototype date! using the numbers you put in the block.</p>
<p>A REBOL script is written in expressions. An <strong>expression</strong> is a group of values which REBOL <em>evaluates</em> , then returns a new value. In REBOL, to <strong>evaluate</strong> is to interpret a group of values toward a purpose or result.</p>
<p>For example, when: make date! [30 9 1998] is an expression that is evaluated as you tell REBOL to print when and return the <strong>result</strong> of the evaluation: 30-Sept-1998.</p>
<p>REBOL offers numerous built-in datatypes. One of the most powerful is <em>word</em> . A REBOL <strong>word</strong> is a symbol used literally <em>or</em> as a variable. In the above example, when was a variable that you defined. It was defined with the colon (when: make date!) then evaluated (print when) to produce a result.</p>
<p><em>Note: <strong>All</strong> REBOL words can have a different meaning depending on context, just as English words do. The English word "print," for example, can have different meanings when used in computing, fashion, and graphics. So REBOL words can be recycled. It’s a powerful feature that you can learn more about in the <strong><a>User’s Guide</a></strong></em> .</p>
<p>So what actually evaluates these expressions? <strong>Native</strong> functions are built-in REBOL functions that you can use right now. They are native to REBOL. In the above example, print and make are natives. Other REBOL natives include load, send, foreach, save, next, and two hundred others. You can get their definitions in the <strong><a>Expert’s Guide</a></strong> and see them at work in the <strong><a>User’s Guide</a></strong> .</p>
<p><em>Note: You can also get information on any function by simply typing</em> help <em>followed by the native (</em> help load*). REBOL will print a description of the function on the display screen.*</p>
<p>And here’s one of the powerful "secrets" of REBOL: you can use natives to design your own functions. It’s like being able to make up your own words when you speak to people and they know exactly what you mean!</p>
<p>The example REBOL script used the <strong>date</strong> native to make a new function called when with the expression:</p>
<pre><code>when: make date! [30 9 1998]
</code></pre>
<p>Let’s summarize. REBOL is a messaging language that evaluates expressions and returns values. REBOL expressions include values in common datatype formats as well as user-defined words. Does that make sense? If not, please reread the above section.</p>
<p>Congratulations! You’re now writing REBOL scripts.</p>
<h3><a name="p-7948-using-more-rebol-power-7" class="anchor" href="https://forum.rebol.info#p-7948-using-more-rebol-power-7"></a>Using More REBOL Power</h3>
<p>These simple principles for writing REBOL scripts can easily be expanded to solve problems using a computer. Many practical solutions will be described more fully in <strong><a>User’s Guide</a></strong> .</p>
<p>Think of writing a REBOL script as you would write anything else. You use words to build phrases (<em>expressions</em> ) and sentences (<em>functions</em> ) until you have a complete paragraph (<em>object</em> ). You may write more paragraphs or simply reuse some you’ve written before until you have a complete document (<em>script</em> ).</p>
<p>REBOL scripts are built in the same way. To show you how, let’s define some more REBOL terms.</p>
<p>First is object, just mentioned. A REBOL <strong>object</strong> has values, functions, and even other objects, grouped together within a context. For example,</p>
<pre><code>headline: make object! [font: "arial" size: 24 color: black]
</code></pre>
<p>makes an <strong>object</strong> that defines what a document’s headline should look like.</p>
<p>You can then make another object called text with size: 12 type and REBOL won’t be confused by the two definitions of size.</p>
<p>You can also use REBOL to change the headline size to 18 with</p>
<pre><code>headline/size: 18
</code></pre>
<p>The technique is called <em>accessing an object variable</em> . It makes REBOL easy to modify.</p>
<p>One more tip: REBOL is free form. To enhance readability, you can script the headline example like this (once black is defined):</p>
<pre><code>headline: make object! [ font: "arial" size: 24 color: black ]
</code></pre>
<p>This is the preferred format for writing REBOL scripts.</p>
<p>Let’s expand on some earlier definitions so you’re more fluent in REBOL.</p>
<p>The data within the bracket <code>[]</code> is called an argument. An <strong>argument</strong> is a value that provides a value to an expression. Some natives don’t require an argument while others can handle many. <strong>Expert’s Guide</strong> will tell you the type and number of arguments that each function uses.</p>
<p>Providing an argument to a function is called <strong>passing</strong> the argument. For example,</p>
<pre><code>print "REBOL World"
</code></pre>
<p>passes a "string" to the print function. From another viewpoint, you could say that you are <strong>applying</strong> the print function to the string.</p>
<p>Here’s a tool that makes REBOL even easier to use. You can make a new function with the native <strong>func.</strong> For example, to make a new function called sum that totals two numbers, designated as a and b:</p>
<pre><code>sum: func [a b] [a + b]
</code></pre>
<p>This expression tells REBOL to define sum by making a new function datatype where a is the first number and b is the second number. Then add (+) the first and second number and give me the result.</p>
<p>To use this function, add the line:</p>
<pre><code>print sum 50 100
</code></pre>
<p>and REBOL returns the value</p>
<pre><code>150
</code></pre>
<p>The length of your script or conversation with REBOL can be just a few lines or a few pages — <strong>but it will be easier to write and understand than with other computer languages.</strong></p>
<h3><a name="p-7948-rebol-at-work-8" class="anchor" href="https://forum.rebol.info#p-7948-rebol-at-work-8"></a>REBOL at Work</h3>
<p>Ready for some real-world examples of what REBOL messaging language can do for you? (You’ll meet the <em>natives</em> used here in the <strong><a>User’s Guide</a></strong> and the <strong><a>Expert’s Guide</a></strong> .)</p>
<p>To grab an Internet web page and save it as a file (%):</p>
<pre><code>file: read http://www.rebol.com save %rebolpage.html file
</code></pre>
<p>or you can write it in a single line:</p>
<pre><code>save %rebolpage.html read http://www.rebol.com
</code></pre>
<p>To email that web page to a friend:</p>
<pre><code>send friend@domain.com read http://www.rebol.com
</code></pre>
<p>To email all the files in a directory to your friend:</p>
<pre><code>files: load %c:/rebol/* foreach file files [send friend@rebol.com read file]
</code></pre>
<p>To build a calendar database that holds things to do (prioritized):</p>
<pre><code>todo [
    ; PRI TYPE DESCRIPTION
    9 code "Write SAVE function"
    8 fun "Bottle brew for friends"
    8 docs "Write Chapter 1"
    5 yard "Tend the Merlot vines"
    3 code "Parametric search function"
    2 web "Call Microsoft re:problems"
    1 home "Tune-up tractor engine"
    0 yard "Fix the fence near berries"
]

; Type Descriptions
[
    code "write code"
    docs "write docs"
    yard "yard work"
    home "house stuff"
    fun "relaxation"
    web "web related"
]
</code></pre>
<p>To send your stockbroker an important transaction message:</p>
<pre><code>send broker@stockbroker.com [
    Company: "Microsoft"
    Symbol: MSFT
    Shares: 1000
    Action: sell
]
</code></pre>
<p>REBOL makes solutions easier!</p>
<h3><a name="p-7948-whats-next-9" class="anchor" href="https://forum.rebol.info#p-7948-whats-next-9"></a>What’s Next?</h3>
<p>That’s all you really need to know to use the <em>power of REBOL</em> ! Of course, there’s much more to know about REBOL to become a <em>power user</em> . The remainder of these guides will add to your knowledge and enjoyment of REBOL.</p>
<p><strong><a>User’s Guide</a></strong> will show you how to solve specific problems with REBOL.</p>
<p><strong><a>Expert’s Guide</a></strong> is your reference manual for REBOL. It includes a description and examples of more than 200 REBOL words and word groups.</p>
<p>Finally, check the REBOL web site for more information and examples on how others are using REBOL messaging language. It’s at <a href="http://www.rebol.com/">http://www.rebol.com</a>.</p>
<p>Have fun, REBOL!</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-quick-start-guide/2341#post_1</link>
        <pubDate>Tue, 06 Oct 1998 04:00:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7948</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7945-chapter-6-troubleshooting-rebol-1" class="anchor" href="https://forum.rebol.info#p-7945-chapter-6-troubleshooting-rebol-1"></a>Chapter 6: Troubleshooting REBOL</h1>
<h3><a name="p-7945-about-troublshooting-2" class="anchor" href="https://forum.rebol.info#p-7945-about-troublshooting-2"></a>About Troublshooting</h3>
<p>REBOL is an easy-to-use language. However, errors can occur in REBOL scripts. This chapter offers information on identifying common errors, debugging scripts, and stopping a script as well as how to report any bugs you find so we can continually improve REBOL. There’s also information on how to contact us for technical support.</p>
<h3><a name="p-7945-errors-3" class="anchor" href="https://forum.rebol.info#p-7945-errors-3"></a>Errors</h3>
<p>A few of the most common errors are:</p>
<ul>
<li>
<p>No spaces between numbers or words (e.g. 1+2 rather than 1 + 2).</p>
</li>
<li>
<p>Not providing enough arguments to a function.</p>
</li>
<li>
<p>Forgetting to use blocks when needed (such as in <strong>if</strong> , <strong>else</strong> , or <strong>while</strong> ).</p>
</li>
<li>
<p>Referring to a word, rather than its value (when using <strong>first</strong> , <strong>second</strong> , <strong>pick</strong> , etc.)</p>
</li>
<li>
<p>Not using parentheses in expressions (e.g. if 1 + 2 = 3 [...])</p>
</li>
<li>
<p>Forgetting the "!" on proto-datatypes (e.g. function!)</p>
</li>
<li>
<p>Forgetting the preceding colon on argument words that could be functions</p>
</li>
</ul>
<h3><a name="p-7945-debugging-scripts-4" class="anchor" href="https://forum.rebol.info#p-7945-debugging-scripts-4"></a>Debugging Scripts</h3>
<p>For small scripts the most common approach to debugging is to print out values as your script proceeds. Using <strong>print</strong> works well for this, but in many cases you may also want to use the <strong>probe</strong> function which also returns the same value it printed</p>
<pre><code>&gt;&gt; print [1 + 2]
3

&gt;&gt; do probe [1 + 2]
[1 + 2]
3
</code></pre>
<h3><a name="p-7945-stopping-your-script-5" class="anchor" href="https://forum.rebol.info#p-7945-stopping-your-script-5"></a>Stopping Your Script</h3>
<p>Use <strong>quit</strong> to quit REBOL (not <strong>exit</strong> , which will be implemented for exiting a function in future releases)</p>
<p>Use <strong>halt</strong> to stop your script and return to the input prompt.</p>
<p><strong>CTRL-C</strong> can be used to quit your program if it gets stuck in a loop. Some operating systems will not detect the key until I/O has been performed, such as a print.</p>
<p><em>Note: The use of CTRL-C to stop execution is a result of the default environment for the target platform and is not determined by REBOL.</em></p>
<h3><a name="p-7945-reporting-bugs-6" class="anchor" href="https://forum.rebol.info#p-7945-reporting-bugs-6"></a>Reporting Bugs</h3>
<p>REBOL is very interested in the problems (bugs) you may have found. To report a bug or make a comment, send an email message (no HTML or enclosures). Please write a subject line that describes the problem. Write something like "making blocks does not work" rather than just "bug."</p>
<p>Email: <code>bugs@rebol.com</code></p>
<p>We will send an automatic confirmation of each report. If you don't get the confirmation, then we may not have received your email (or your return address is wrong).</p>
<p>For all bug reports, be sure to give us a simple example of the problem. If it occurs in a large script, edit it down to just the bug. Please don’t send large files.</p>
<p>Also, be sure to include the REBOL version number as is printed in the title banner. It indicates not only the version and revision, but also the update number and the platform (OS). Version numbers have the format:</p>
<pre><code>version.revision.update.platform
</code></pre>
<h3><a name="p-7945-rebol-versions-7" class="anchor" href="https://forum.rebol.info#p-7945-rebol-versions-7"></a>REBOL Versions</h3>
<p>The REBOL version number is printed in the title banner. This number should be included in all bug reports and comments. It indicates not only the version and revision, but also the update number and the platform (OS).</p>
<pre><code>REBOL 1.0.1.3
</code></pre>
<p>This indicates that you are running Version 1.0.1 for Windows 95/98/NT.</p>
<p>Version numbers have the format:</p>
<pre><code>version.revision.update.platform
</code></pre>
<p>From a script you can obtain the version number with:</p>
<pre><code>&gt;&gt; print REBOL/version
</code></pre>
<h3><a name="p-7945-contacting-rebol-8" class="anchor" href="https://forum.rebol.info#p-7945-contacting-rebol-8"></a>Contacting REBOL</h3>
<p>You can contact REBOL Technologies in various ways:</p>
<p>Updates and information: <a href="http://www.rebol.com/">http://www.rebol.com</a><br>
Customer support: <a href="mailto:support@rebol.com">support@rebol.com</a><br>
Postal mail: P.O. Box 1510, Ukiah, CA 95482<br>
Telephone: (707) 467-8000<br>
Fax: (707) 467-8005</p>
<h3><a name="p-7945-whats-next-9" class="anchor" href="https://forum.rebol.info#p-7945-whats-next-9"></a>What’s Next?</h3>
<p><strong><a>Expert’s Guide</a></strong> is your reference manual for REBOL. It includes a description and examples of all REBOL words.</p>
<p>Finally, check the REBOL web site for additional information and examples on how others are using REBOL messaging language. It’s at <a href="http://www.rebol.com">http://www.rebol.com</a>.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_7</link>
        <pubDate>Tue, 06 Oct 1998 05:07:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7945</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7944-chapter-5-rebol-context-1" class="anchor" href="https://forum.rebol.info#p-7944-chapter-5-rebol-context-1"></a>Chapter 5: REBOL Context</h1>
<h3><a name="p-7944-about-context-2" class="anchor" href="https://forum.rebol.info#p-7944-about-context-2"></a>About Context</h3>
<p>Words can be used to represent values. In your script you could define the word two:</p>
<pre><code>two: 2
</code></pre>
<p>and then later make use of it:</p>
<pre><code>&gt;&gt; print two
2

&gt;&gt; print 30 + two
32
</code></pre>
<p>At any point during definition the set of all defined words forms the current context. In the above example, the context would include not only the word two, but the words <strong>print</strong>, <strong>+</strong>, and all other words that were previously defined by the script or by REBOL (such as its native functions). All of these words have values at this point of evaluation, and even though you are not using them all, they are part of the context because you could use them.</p>
<p>If the word <strong>two</strong> is used outside this context, for instance in another script or another part of the same script, it could have a different value. The context determines its meaning (its value). Because of this it is crucial for you to know the rules that establish the context of words.</p>
<p>In REBOL, the primary rules of context are:</p>
<ol>
<li>
<p>Every script begins with a predefined context which includes REBOL words for native functions (such as print) and system values.</p>
</li>
<li>
<p>As your script executes, it may define new words in the context.</p>
</li>
<li>
<p>At specific points functions, and objects may modify the context.</p>
</li>
</ol>
<p>It is this last rule that is our next subject.</p>
<h3><a name="p-7944-using-context-3" class="anchor" href="https://forum.rebol.info#p-7944-using-context-3"></a>Using Context</h3>
<p>In a REBOL script, you define various words with specific values. There will be times when you want to use a word that could already be defined elsewhere in your script. If you give that word a new value, you will destroy its previous value. For instance, in your main script the word who could represent a person, such as:</p>
<pre><code>&gt;&gt; who: "Cindy"
&gt;&gt; print who
Cindy
</code></pre>
<p>But what if later in your script you want to use the word <strong>who</strong> again to temporarily refer to the name of a company? You may not want to lose the name of the person, but just "reuse" the word for a short time.</p>
<p>Whenever you begin a new block in REBOL, you can specify what words you want to temporarily redefine within that block. To do this you put the words you want to redefine in a block.</p>
<pre><code>&gt;&gt; use [[who]
       who: "REBOL HQ"
       print who
   ]
REBOL HQ

&gt;&gt; print who
Cindy
</code></pre>
<p>The <strong>use</strong> function tells REBOL that <strong>who</strong> is to be used temporarily within the block, and you don't want to affect the value of who outside the block. It is said to be local to the block. Any number of words can be specified as local words in this manner.</p>
<p>You have changed the context. The word who used prior to the block now has a different meaning in the new block. This ability to change context can be quite handy, and it is applied to functions and objects as well.</p>
<p>Here is an example of how locals can be used in a block context. It will help illustrate a few points. In it a database of contacts is printed in a specified text format:</p>
<pre><code>; A simple database:
&gt;&gt; persons: [
       "John Able" CEO "Digitalla" ja@dig2.com
       "Jane Baker" VP "Netescape" jane@us.gov
       "Mari Conners" COO "Micoroni" maric@mico.com
   ]

; The fields of the database as words:
&gt;&gt; facts: [name title company email]

; The format used to print the info:
&gt;&gt; text: [name "at" company "is at" email]

; The loop which prints the database:
&gt;&gt; use facts [forskip persons 4 [
       set facts persons
       print text
   ]]
John Able of Digitalla is at ja@dig2.com
Jane Baker of Netescape is at jane@us.gov 
Mari Conners of Micoroni is at maric@mico.com
</code></pre>
<p>Notice that within the forskip block the facts word is used to specify the locals. This is valid because facts is a block. Note that the same facts block is used with set which sets each of the words of the block to the values from the current position in the persons database.</p>
<h3><a name="p-7944-functions-4" class="anchor" href="https://forum.rebol.info#p-7944-functions-4"></a>Functions</h3>
<p>The concept of a function comes from expanding on the block context. You only need two additional concepts:</p>
<ol>
<li>
<p>Functions can be evaluated without requiring do (a function's natural value is to evaluate),</p>
</li>
<li>
<p>The initial values of local words can be supplied to the function each time it is evaluated.</p>
</li>
</ol>
<p>For example, you might create a simple function <strong>plen</strong> to print the length of a series:</p>
<pre><code>plen: make function! [series]
[print length? series]
</code></pre>
<p>and then use it in multiple places in your script:</p>
<pre><code>&gt;&gt; plen "now is the time"
15

&gt;&gt; plen [1 2 3 4]
4
</code></pre>
<p>The value which follows the function is an argument. In the example, both a string argument and a block argument are used. This argument corresponds to the word series that was given in the make function! line above.</p>
<p>Let's take a closer look at the definition of <strong>plen</strong>. The REBOL native function <strong>make</strong> was evaluated, and it required three values:</p>
<ol>
<li>
<p>The datatype to be made, in this case a function!</p>
</li>
<li>
<p>A block of words that will be local to the function's block and used for arguments. These appear in the order that they will appear when the function is used.</p>
</li>
<li>
<p>The function block to be evaluated.</p>
</li>
</ol>
<p>The new function is returned from <strong>make</strong> and is set to <strong>plen</strong>. Note that defining <strong>plen</strong> to be a function is no different than defining it to be an integer, date, or any other value. Once it has been defined, it can then be used as in the example above.</p>
<p>A function can also define other local words which are not used as arguments. These are placed at the head of the function's evaluation block using the use function. In the example below, name and date are local to the function, but are not arguments.</p>
<pre><code>example: make function! [arg] [
    use [name date][
        ...
]]
</code></pre>
<p>A function can also return a value as a result of its evaluation. You can do this from any point in your function with the return native:</p>
<pre><code>find-val: make function! [series value] [
    forall series [
       if (first series) = value [return series]
    ]
]

&gt;&gt; print find-val [1 2 3 4] 3
3 4
</code></pre>
<p>If you want to return from a function, but not return a value, use <strong>exit</strong> instead of <strong>return</strong>. It is similar to the <strong>break</strong> function described earlier.</p>
<p>When arguments are supplied to a function, they are evaluated prior to being used in the function. For instance:</p>
<pre><code>&gt;&gt; plen next [1 2 3 4]
3

&gt;&gt; plen skip [1 2 3 4] 3
1
</code></pre>
<p>Finally, sometimes you will write a script that refers to a function before it has been defined. REBOL allows this as long as you do not try to evaluate the word before it is defined.</p>
<h3><a name="p-7944-func-shortcut-5" class="anchor" href="https://forum.rebol.info#p-7944-func-shortcut-5"></a>Func Shortcut</h3>
<p>A function can accept any type of value as an argument. An argument can be an integer, string, date, block, or any other value, even a function or native. Here is an example in which a function is passed as an argument:</p>
<pre><code>do-it: make function! [func value] [
    func value
]
</code></pre>
<p>Here, the word <strong>do-it</strong> will be used as a function which will accept two arguments and return a result. Because the word <strong>do-it</strong> is used as a natural value (not written as <strong>do-it</strong> or <strong>:do-it</strong>) the natural thing to do is to evaluate it.</p>
<pre><code>&gt;&gt; print do-it :length? "test"
4

&gt;&gt; funcs: [length? first print]
&gt;&gt; print do-it second funcs [1 2 3]
1
</code></pre>
<p>The values of the natives passed as arguments required colons. Otherwise they would have been evaluated prior to being passed as arguments, resulting in an error.</p>
<p>A function can return any type of value as a result. You can make a function for creating other functions.</p>
<pre><code>func: make function! [args code] [
    return make function! args code
]
</code></pre>
<p>The <strong>func</strong> word now refers to this function, and when evaluated, it will perform a <strong>make function!</strong> on the arguments you give it.</p>
<pre><code>&gt;&gt; pall: func [series] [
       forall series [print first series]
   ]

&gt;&gt; pall [1 2 3]
1
2
3
</code></pre>
<p>Here, <strong>func</strong> is given two arguments: a block containing the word series and a block containing the <strong>forall</strong>. These are used by <strong>func</strong> as the args and code of the function to make.</p>
<p>As with everything else in REBOL, the arguments to make can be anything that evaluates to a block.</p>
<h3><a name="p-7944-defining-functions-6" class="anchor" href="https://forum.rebol.info#p-7944-defining-functions-6"></a>Defining Functions</h3>
<p>New functions are created by supplying <strong>make</strong> with the prototypical function datatype (function!), a block of argument words, and the function body block. The form is:</p>
<pre><code>make function! arguments body
</code></pre>
<p>For instance, to create a function to add two values you would write:</p>
<pre><code>make function! [a b] [a + b]
</code></pre>
<p>The <strong>make</strong> returns the new function as a value, and it is often set to a word for later use:</p>
<pre><code>sum: make function! [a b] [a + b]
</code></pre>
<p>This new function could then be applied to a set of arguments, as in:</p>
<pre><code>&gt;&gt; print sum 10 2
12
</code></pre>
<p>Note that naming a function is completely optional. You may want to do something else with the function value, such as return it as a result from another function. As an example, take the standard REBOL helper function <strong>func</strong> which is defined as:</p>
<pre><code>func: make function! [args body] [
    make function! args body
]
</code></pre>
<p>The first <strong>make</strong> creates a function which is used for creating functions. Its arguments are the new function's argument and body blocks, and it returns the newly created function as a result. Simple. Powerful. Useful. With it, the sum function above could be written more concisely as:</p>
<pre><code>sum: func [a b] [a + b]
</code></pre>
<h3><a name="p-7944-returning-values-7" class="anchor" href="https://forum.rebol.info#p-7944-returning-values-7"></a>Returning Values</h3>
<p>Similar to a block, a function can return its last value as a result. As shown above, this value can be any datatype, including a function value.</p>
<p>Should you want to return from a function at some other point within it, you can do so with return. It accepts one argument — the value to return.</p>
<pre><code>sum-check: func [a b] [
    if a &lt; 0 [return b]
    if b &lt; 0 [return a]
    a + b
]
</code></pre>
<p>If you do not wish to return a result from a function, use <strong>exit</strong>.</p>
<h2><a name="p-7944-objects-8" class="anchor" href="https://forum.rebol.info#p-7944-objects-8"></a>Objects</h2>
<p>An object is a group of words that have predefined values. An object can be referred to as a single value which can be stored in a variable, passed to functions as an argument, or returned from a function as a result.</p>
<h3><a name="p-7944-defining-objects-9" class="anchor" href="https://forum.rebol.info#p-7944-defining-objects-9"></a>Defining Objects</h3>
<p>New objects are created with <strong>make</strong>, the prototypical object datatype (<strong>object!</strong>), and a block defining the words of the object. Making an object is as easy as making a block containing word definitions:</p>
<pre><code>normal-text: make object! [
    font: "times"
    size: 12
    color: black
]
</code></pre>
<p>The new object is returned from make and can be handled as any other value. In the example above, the object is assigned to the word normal-text, but it could just as easily have been returned from a function.</p>
<p>The block which holds the word definition is evaluated, so it may contain complex definitions of values:</p>
<pre><code>normal-text: make object! [
    font: lookup-font 'normal
    size: standard-size + 2
    color: pick color-set 4
]
</code></pre>
<p>For convenience, you can cascade the definition of multiple words:</p>
<pre><code>default-text: make object! [size: color: font: none]
</code></pre>
<p>The words of an object can be defined to be any kind of value, including functions and other objects:</p>
<pre><code>account: make object! [
    balance: 0
    deposit: func [amount] [balance: balance + amount]
    withdraw: func [amount] [balance: balance - amount]
]
</code></pre>
<p>The benefit of doing this is that the functions will evaluate within the context of the object. This allows you to encapsulate (keep together) the values and functions of the object.</p>
<h3><a name="p-7944-accessing-object-variables-10" class="anchor" href="https://forum.rebol.info#p-7944-accessing-object-variables-10"></a>Accessing Object Variables</h3>
<p>Once an object has been created, you can access the variables within it by using paths. (In REBOL, a path is a means of refining a reference to a value.) For instance, to obtain the value for the balance in the account object above, you can write:</p>
<pre><code>print account/balance
</code></pre>
<p>If you want to deposit or withdraw from the account, you can use its defined functions as:</p>
<pre><code>account/deposit 1000
account/withdraw 20
</code></pre>
<p>If so desired, you can even set a word within an object:</p>
<pre><code>account/balance: 2000
</code></pre>
<p>In addition, the <strong>set</strong> and <strong>get</strong> functions can be used to access the values of an object:</p>
<pre><code>print set account 'balance 1000
do get account 'withdraw 100
</code></pre>
<p>These provide a standard function-based approach to access, allowing complex access expressions such as:</p>
<pre><code>do get account (if thrifty ['deposit] else ['withdraw]) 100
</code></pre>
<h3><a name="p-7944-making-instances-11" class="anchor" href="https://forum.rebol.info#p-7944-making-instances-11"></a>Making Instances</h3>
<p>Once an object has been created, you can make another instance (a duplicate) of it with the make function:</p>
<pre><code>my-account: make account []
</code></pre>
<p>If you want to change the value of a word within the account, you can also do so:</p>
<pre><code>my-account: make account [balance: 400]
</code></pre>
<p>Note that the initial values for a new object will be duplicated as well:</p>
<pre><code>&gt;&gt; new-account: make my-account []
&gt;&gt; print new-account/balance
400
</code></pre>
<p>However, for more complex objects, create your own make function. This allows you to consistently initialize the object each time.</p>
<pre><code>&gt;&gt; make-account: func [starting-balance] [
       make account [
           balance: starting-balance + (starting-balance / 20)
       ]
   ]

&gt;&gt; my-account: make-account 400
&gt;&gt; print my-account/balance
420
</code></pre>
<h3><a name="p-7944-extending-objects-12" class="anchor" href="https://forum.rebol.info#p-7944-extending-objects-12"></a>Extending Objects</h3>
<p>You can extend the definition of an object to create new types of objects which are based on the original. Simply define new words within the block of the new object. These words will be added to the others that are already part of the object.</p>
<pre><code>bank-account: make account [
    bank-name: "Mendocino Savings"
    owner: none
]
</code></pre>
<p>Now you can create a new bank account:</p>
<pre><code>&gt;&gt; an-account: make bank-account [
       owner: "Carl"
       balance: 2000
       display: func [] [print [owner "has" balance]]
   ]

&gt;&gt; an-account/deposit 40
&gt;&gt; an-account/display
Carl has 2040
</code></pre>
<h3><a name="p-7944-hidden-variables-13" class="anchor" href="https://forum.rebol.info#p-7944-hidden-variables-13"></a>Hidden Variables</h3>
<p>You can hide specified words from direct access by making them hidden variables when you define the object. This is can be done with either a function definition or the use native.</p>
<pre><code>&gt;&gt; make-bolt: func [size] [
       make object! [
           set-size: func [value] [size: value]
           get-size: func [] [size]
       ]
   ]

&gt;&gt; bolt: make-bolt 10
&gt;&gt; bolt/get-size
10
</code></pre>
<p>This works because REBOL supports extended context. The use of hidden variables is supported by a REBOL helper function called <strong>make-object</strong>. For arguments it takes the parent object, a block of hidden variable words, and the object initialization block.</p>
<pre><code>bolt: make-object object! [size] [
    set-size: func [value] [size: value]
    get-size: func [] [size]
]
</code></pre>
<h3><a name="p-7944-extended-context-14" class="anchor" href="https://forum.rebol.info#p-7944-extended-context-14"></a>Extended Context</h3>
<p>In REBOL, variables have a quality known as indefinite extent. This allows the life of hidden variables and their context to be extended for as long as they might be needed. This is a powerful feature that makes scripting easier. For instance, in the example above, what would happen if the computation returned a block that contained the hidden variables?</p>
<pre><code>result: use [total longest] [
    total: longest: 0
    foreach distance streets [
        total: total + distance
        if distance &gt; longest [longest: distance]
    ]
    [total longest]
]
</code></pre>
<p>The block stored in result refers to the variables total and longest which were local to the block. In many programming languages this would be considered an error. In REBOL, the hidden variables are extended beyond the use block. Accessing their values will produce the correct results.</p>
<pre><code>&gt;&gt; print get first result
278
</code></pre>
<p>These extended variables have some useful qualities. For instance, if you wanted to create two functions which share a common variable, you could write:</p>
<pre><code>use [count] [
    count: 0
    count-add: func [num] [count: count + num]
    count-sub: func [num] [count: count - num]
]

&gt;&gt; count-add 10
&gt;&gt; print (count-sub 1)
9
</code></pre>
<h3><a name="p-7944-binding-into-context-15" class="anchor" href="https://forum.rebol.info#p-7944-binding-into-context-15"></a>Binding Into Context</h3>
<p>Small databases, descriptive content-oriented blocks, and messages sent from other computers may have been created external to the context in which they must be used. As long as all of the words within these blocks are used as symbols, then there will be no problems.</p>
<p>However, you may want to use some of the words as variables. For instance, a user interface description might contain not only the size, color, and text of a button, but also an action block which is to be evaluated when the button is pressed. That block may contain words which only have values within the user-interface handling code. In order to operate correctly, the words must be associated with their correct values in the current context.</p>
<p>The bind native imports a block by binding its words to the current context regardless of where it was first defined. The new block is returned. For instance, a database might contain code that is to be evaluated in the current context:</p>
<pre><code>database: bind operations-database
do select database 'button
</code></pre>
<p>As this chapter illustrates, REBOL is a powerful messaging language. Additional REBOL words and specifics of the REBOL language are included in the Expert’s Guide.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_6</link>
        <pubDate>Tue, 06 Oct 1998 05:05:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7944</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7943-chapter-4-rebol-evaluation-1" class="anchor" href="https://forum.rebol.info#p-7943-chapter-4-rebol-evaluation-1"></a>Chapter 4: REBOL Evaluation</h1>
<h3><a name="p-7943-about-evaluation-2" class="anchor" href="https://forum.rebol.info#p-7943-about-evaluation-2"></a>About Evaluation</h3>
<p>As mentioned earlier in this guide, <em><strong>symbols are used to represent meaning.</strong></em> Humans can interpret the meaning of symbols and act on them. The resulting actions may not be physical. A symbol may in our minds alone invoke a particular thought or image. Nevertheless, <em>the symbols drive the process.</em></p>
<p>You’ve learned that REBOL supports a number of values such as integers, times, dates, files, strings, blocks and others. The Values Table in Chapter 1 of this guide summarized the types of values that can be <em><strong>directly expressed</strong></em> in the REBOL language.</p>
<p>While these values give you a means of creating data and databases, they do not provide enough capability to do everything. There are other values within REBOL that were not shown in the table because they are not directly expressible. These values are created within REBOL and are represented as words or as series of values. For instance, earlier in this guide you were introduced to the concept of <em>functions</em> which perform actions and produce results. Functions like <strong>print, foreach,</strong> and <strong>first</strong> were thrown in without much explanation.</p>
<p>The table below summarizes these other <em><strong>indirectly expressed</strong></em> values.</p>
<div class="md-table">
<table>
<thead>
<tr>
<th><strong>Value</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>None</strong></td>
<td>A single value which represents the idea of no value. The word <strong>none</strong> is predefined in REBOL to hold this value.</td>
</tr>
<tr>
<td><strong>Logic</strong></td>
<td>The two values which we call true and false (on and off or 1 and 0). These are often called Boolean values. The words <strong>true</strong> , <strong>false</strong> , <strong>on</strong> , <strong>off, yes</strong> , and <strong>no</strong> are defined to hold these values.</td>
</tr>
<tr>
<td><strong>Object</strong></td>
<td>A series of values which exist and evaluate within a defined context.</td>
</tr>
<tr>
<td><strong>Function</strong></td>
<td>A series of values which exist and evaluate within a temporary (momentary or dynamic) context.</td>
</tr>
<tr>
<td><strong>Native</strong></td>
<td>An internal REBOL function that is evaluated directly by the computer. In some languages, these are called native code or primitive functions.</td>
</tr>
</tbody>
</table>
</div><p>Some <em><strong>words</strong></em> have predefined values. Most of these words have been predefined to values that relate to some of the datatypes above. Because they cannot be directly expressed, a <em>word</em> must be used to represent them.</p>
<p>For example, the words <strong>true</strong> and <strong>false</strong> are predefined to the values for the logic states of true and false. They are symbols that stand for the values.</p>
<p>Words like <strong>print</strong> , <strong>repeat</strong> , and <strong>first</strong> are predefined to <em><strong>native</strong></em> function values. They perform various actions, may be given a set of arguments, and may return results. A native function's value cannot be expressed in REBOL, only the word which represents it.</p>
<h3><a name="p-7943-evaluating-blocks-3" class="anchor" href="https://forum.rebol.info#p-7943-evaluating-blocks-3"></a>Evaluating Blocks</h3>
<p>In REBOL, there is no difference between blocks of code and blocks of data. How is it then that one gets evaluated and the other does not?</p>
<p>The answer is the <strong>do</strong> function. This tells REBOL to evaluate a block: traverse its values, relate them to actions, and perform those actions. The <strong>do</strong> below executes the block provided as its argument:</p>
<pre><code>&gt;&gt; do [print 10]
10
</code></pre>
<p>A block is just <em><strong>considered to be data until it is evaluated</strong></em> with <strong>do</strong> or another function. You could have written:</p>
<pre><code>&gt;&gt; todo: [print 10]
&gt;&gt; do todo
10
</code></pre>
<p>In other words, just encountering a block does not evaluate it. The <strong>do</strong> function is needed.</p>
<p>How are the lines of the example evaluated? There is no <strong>do</strong> for them. When REBOL reads input from the user or executes a file, a <strong>do</strong> is provided by REBOL.</p>
<p>The <strong>do</strong> function can also <em><strong>return a value</strong></em> after evaluating a block. For instance, you could write:</p>
<pre><code>&gt;&gt; numbers: [1 12 123]
&gt;&gt; todo: [length? numbers]
&gt;&gt; length: do todo
&gt;&gt; print length
3
</code></pre>
<p>This can be very useful. The following example takes advantage of the value returned from the block:</p>
<pre><code>align-cases: [
    left [0]
    right [page-width - length? text]
    center [(page-width - length? text) / 2]
]

&gt;&gt; text: "Heading"
&gt;&gt; page-width: 80

&gt;&gt; print do select align-cases 'center
36.5
</code></pre>
<p>There are several other useful functions which use <strong>do</strong> to evaluate blocks. They are explained below. You can also define your own functions.</p>
<p><strong>Load</strong> and <strong>save</strong> are also used in evaluation. <strong>Load</strong> analyzes a value to determine the datatype, then converts the value for use by REBOL. <strong>Load</strong> is used for files, URLs, and string datatypes. For example,</p>
<pre><code>load %image.jpg
</code></pre>
<p><strong>Save</strong> converts and saves a value into the appropriate format for the datatype. The save function is used for files and URLs. Here’s an example:</p>
<pre><code>save %this-file.txt "This file is empty."
</code></pre>
<p>The <strong>do</strong>, <strong>load</strong>, and <strong>save</strong> functions are useful tools as you write REBOL scripts.</p>
<p><strong>Read</strong> and <strong>write</strong> are also useful functions for working with files and urls. For example,</p>
<pre><code>text: read %readme.txt
</code></pre>
<p>will open, read the entire text file, and close it. And:</p>
<pre><code>write %readme.txt "This is a readme file."
</code></pre>
<p>will open, write, and close the file.</p>
<h4><a name="p-7943-conditional-evaluation-4" class="anchor" href="https://forum.rebol.info#p-7943-conditional-evaluation-4"></a>Conditional Evaluation</h4>
<p>To evaluate a block under certain conditions the <strong>if</strong> function is provided. It accepts two arguments, the first is a logic condition and the second is a block to evaluate if the condition is true.</p>
<pre><code>if time &gt; 12:00 [print "past noon"]
</code></pre>
<p>An <strong>if</strong> function can be followed by an optional <strong>else</strong> function which takes a single argument, the block to be evaluated if the condition were false:</p>
<pre><code>if time &gt; 12:00 [print "past noon"]
else [print [12:00 - time "hours until lunch"]]
</code></pre>
<p>The most common mistake in using <strong>if</strong> is forgetting to give a block as the second argument (not remembering the brackets, for instance).</p>
<p>The brackets are not needed if you provide a word that has been defined with a block value:</p>
<pre><code>notice: [print "past noon"]
if time &gt; 12:00 notice
</code></pre>
<p>That's because a block is a block, regardless of whether it is directly expressed (with brackets) or is the value of a word. It can even be the result of a function:</p>
<pre><code>notices: [
    [print "past sunrise"]
    [print "past noon"]
    [print "past sunset"]
]

if time &gt; 12:00 second notices
</code></pre>
<p>Here, the <strong>second</strong> function provides the block to be evaluated (or not evaluated) by <strong>if</strong> . This is possible because <strong>if</strong> is just a function that takes arguments like any other function. It is not a special purpose control symbol of the language (as it is in most languages). REBOL is classified as a <em><strong>functional</strong></em> language, because all of its executable constructs are simply functions.</p>
<p>Two other conditional evaluations for blocks are <strong>any</strong> and <strong>all</strong> . The <strong>any</strong> function evaluates each expression in a block to determine if <em>any</em> are true (according to the arguments). The <strong>all</strong> function checks to see if <em>all</em> the values in the block are true. If there are no values or the result is not true, a <strong>false</strong> is returned.</p>
<h4><a name="p-7943-repeated-evaluation-5" class="anchor" href="https://forum.rebol.info#p-7943-repeated-evaluation-5"></a>Repeated Evaluation</h4>
<p>There are a variety of functions that specialize in the repeated evaluation of a block of values.</p>
<p>The <strong>loop</strong> function is the simplest, evaluating a block a given number of times. In this example, the <strong>prin</strong> function prints its argument without starting a new line:</p>
<pre><code>&gt;&gt; loop 40 [prin "-"]
----------------------------------------
</code></pre>
<p>The <strong>repeat</strong> function extends <strong>loop</strong> by allowing you to keep track of the loop counter. The <strong>repeat</strong> must be followed by a word that will be used to hold the count value.</p>
<pre><code>&gt;&gt; repeat count 3 [print ["count:" count]]
count: 1
count: 2
count: 3
</code></pre>
<p>The <strong>for</strong> function goes beyond <strong>repeat</strong> by letting you specify the starting value, the ending value, and the increment to the value. Any of the values can be positive or negative. In this example , the <strong>prin</strong> function will print its argument followed by a space but not a new line:</p>
<pre><code>&gt;&gt; for count 0 50 10 [prin count]
0 10 20 30 40 50
</code></pre>
<p>You can stop the repeated evaluation of a block with the <strong>break</strong> function. This is handy if you encounter some unusual condition and do not want to continue the loop.</p>
<pre><code>repeat count 10 [
    if (random count) &gt; 5 [break]
    print "repeat"
]
</code></pre>
<p>For repeated evaluation involving series, the <strong>foreach, forall,</strong> and <strong>forskip</strong> functions were covered earlier in this guide.</p>
<p>The <strong>until</strong> function will repeat a block until the block returns the <strong>true</strong> value.</p>
<pre><code>&gt;&gt; numbers: [1 12 1234 12345]

&gt;&gt; until [
       print first numbers
       numbers: next numbers
      (first numbers) &gt; 2000
    ]
1
12
1234
</code></pre>
<p>And finally, the <strong>while</strong> function will repeat the evaluation of two blocks, while the first one returns <strong>true</strong> :</p>
<pre><code>&gt;&gt; colors: ["red" "green" "blue"]

&gt;&gt; while [? next colors] [
       print first colors
       colors: next colors
   ]
red
green
blue
</code></pre>
<h3><a name="p-7943-native-functions-6" class="anchor" href="https://forum.rebol.info#p-7943-native-functions-6"></a>Native Functions</h3>
<p>REBOL includes a number of predefined words called <strong><em>natives</em> .</strong> A native is a function which executes directly on the system processor and requires no further interpretation by REBOL. The words <strong>print, first, loop, do</strong> are all predefined to natives.</p>
<p>Within a script you can create your own <em><strong>functions</strong></em> . These functions evaluate in a similar manner to REBOL natives. They will be discussed later in this guide.</p>
<p>All functions, whether created by you or by REBOL, can accept a number of values as <em><strong>arguments</strong></em> and return a value as a <em><strong>result</strong></em> . Of course, both of these are optional. A function does not need to accept any arguments nor return any result.</p>
<p>Functions can be combined to allow the result of one function to be given as the argument to another. For instance:</p>
<pre><code>print first colors
</code></pre>
<p>The result of <strong>first</strong> would then be passed as the argument to <strong>print</strong> . When multiple functions are cascaded in this fashion, their <em><strong>results move from right to left.</strong></em> The rightmost function (<strong>first</strong> ) returns its result to the function on its left (<strong>print</strong> ).</p>
<p>No restrictions are placed on the datatypes of values that can be accepted as arguments or returned as results. Even values like blocks, objects, functions, and natives can be used as arguments and returned as results.</p>
<p>Normally a function is placed before its arguments. However, it is a common practice for most mathematic and comparison <em><strong>operators</strong></em> to be placed <em>between</em> their arguments. The REBOL words below are operators:</p>
<pre><code>+ - * / // = &lt;&gt; &lt; &lt;= &gt; &gt;= and or xor
</code></pre>
<p>Remember when using an operator that <em><strong>you must include a space before and after the word</strong></em> to separate it from its arguments, otherwise the operator will just be treated like characters of the word.</p>
<p>Unlike many languages, REBOL operators and functions have no preferred ordering or <em>precedence</em> . However, for the convenience of users, <strong>operators will evaluate from left to right:</strong></p>
<pre><code>&gt;&gt; print 5 + 10 * 2
30
</code></pre>
<p>When a series of operations needs to be performed in a particular order <em><strong>you should use parentheses to indicate which is to be evaluated first.</strong></em> This really helps clarify the order of operations:</p>
<pre><code>&gt;&gt; print (5 + 10) * 2
30

&gt;&gt; print 5 + (10 * 2)
25
</code></pre>
<p><em>Note: Ignoring REBOL’s preferred ordering can be a source of errors in your scripts.</em></p>
<p>REBOL also includes prefix operators such as <strong>add</strong> , <strong>subtract</strong> , <strong>multiply</strong> , <strong>divide</strong> , <strong>greater-than</strong> , <strong>less-than</strong> , etc. They can be used as in this example:</p>
<pre><code>&gt;&gt; print add 10 20
30
</code></pre>
<h3><a name="p-7943-paths-7" class="anchor" href="https://forum.rebol.info#p-7943-paths-7"></a>Paths</h3>
<p>In general, <em><strong>paths</strong></em> provide a means of <em><strong>refined specification</strong></em> . They describe a route through a hierarchy, and provide a shorthand technique for referring to sub-elements, positions, or options. They may be used with objects, functions, files, URLs, blocks, strings, and a variety of other datatypes.</p>
<p>Paths are expressed relative to a root value by providing a number of <em><strong>refinements</strong></em> , each separated by a slash (/). These refinements can be words (symbols), numbers, strings, files, and other datatypes. Their specific interpretation will vary depending on the datatype of the root. This is best illustrated with a few examples:</p>
<pre><code>account/deposit ; evaluate an object's function

match/any ; function refinement

src/unix/main.c ; directory path to file

USA/CA/Ukiah/population ; select from multiple blocks

names/12 ; pick the 12th name from a block
</code></pre>
<p>Words supplied as paths are <em><strong>symbolic</strong></em> . This is necessary to allow the most intuitive form for object referencing. To use a variable, an explicit word value reference is required:</p>
<pre><code>src/unix/:filename
</code></pre>
<p>Paths themselves can be used within paths. For instance:</p>
<pre><code>dir: src/unix
data: load dir/main.c
</code></pre>
<p>An advanced feature of the email datatype uses <strong>email-port</strong> and <strong>email-head</strong> objects. You can make a separate object for sending email (using SMTP) like this:</p>
<pre><code>REBOL/email-port: make REBOL/email-port [
    host: "mail.domain.com"
    user: "username"
    pass: "password"
]
</code></pre>
<h3><a name="p-7943-continuation-8" class="anchor" href="https://forum.rebol.info#p-7943-continuation-8"></a>Continuation</h3>
<p>The <strong>catch</strong> function allows you to return to a specified point in a script using a method called <em><strong>continuation</strong></em> . A continuation is a saved point in the flow of execution that can be called and returned to at a later time. Think of it as a bookmark that saves your location and current context. Continuations are first class. They can be stored in variables, passed as arguments, and returned from functions. As such, they provide a powerful mechanism for advanced scripting in REBOL — especially for handling operations such as exceptions.</p>
<p>To use catch you provide a symbol and a block:</p>
<pre><code>catch *symbol* *body*
</code></pre>
<p>The symbol is used as the name for a new function which holds the continuation point. This function becomes available within the context of the body block, where it can be called to return to the point just after the catch. Think of it as a throw function if you are familiar with that concept from other languages. It takes one argument: a value which will be returned as the result of the catch.</p>
<pre><code>print catch 'throw [
    loop 100 [
         if (random 10) &gt; 5 [throw "hit"]
    ]
   "miss"
]
</code></pre>
<p>The symbol throw is used here as the name of the continuation function. When it is applied, its argument is used as the return from its associated catch. In the above example, its behavior is identical to a return function.</p>
<h4><a name="p-7943-non-local-return-9" class="anchor" href="https://forum.rebol.info#p-7943-non-local-return-9"></a>Non-local Return</h4>
<p>The function named by catch is local to the block passed to catch. However, there may be times when you want to return from functions called outside the block. To do so, define a word outside the context of the block to hold the continuation function.</p>
<pre><code>rand-it: func [num] [
    loop num [
        if (random num) &gt; (num / 2) [resume "hit"]
    ]
    "miss"
]

print catch 'throw [
    resume: :throw
    rand-it 100
]
</code></pre>
<p>Here the word <strong>resume</strong> is given the function value of <strong>throw</strong> and is used outside the block as a non-local return to the <strong>catch</strong> .</p>
<h4><a name="p-7943-true-continuation-10" class="anchor" href="https://forum.rebol.info#p-7943-true-continuation-10"></a>True Continuation</h4>
<p>With the indefinite extent concept discussed later, continuations can be preserved even beyond the return point of the <strong>catch</strong> . If after the example above, you were to write the line:</p>
<pre><code>resume "test"
</code></pre>
<p>you would return to the same point as before — just after the catch — and the "test" string would be passed to the <strong>print</strong> function. Note that <em>the entire context of the catch is preserved.</em> Here is another example:</p>
<pre><code>times: func [num] [num * catch 'here [resume-times: :here 1]]
result: times 1
print result
if result &lt; 100 [resume-times (result * 3)]
</code></pre>
<p>In this example, the catch marks the return point within the function <strong>times</strong> . When the <strong>resume-times</strong> function is applied, it passes a new value back to the multiplication. <em><strong>Notice that even the return point from times is preserved!</strong></em> The assignment to <strong>result</strong> and <strong>print result</strong> are all done again, because they follow the initial call to <strong>times</strong> .</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_5</link>
        <pubDate>Tue, 06 Oct 1998 04:46:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7943</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7942-chapter-3-rebol-series-1" class="anchor" href="https://forum.rebol.info#p-7942-chapter-3-rebol-series-1"></a>Chapter 3: REBOL Series</h1>
<h3><a name="p-7942-about-series-2" class="anchor" href="https://forum.rebol.info#p-7942-about-series-2"></a>About Series</h3>
<p>In REBOL, a group of values can form a <em><strong>series</strong></em> . Series are frequently used in computing and REBOL treats them in a consistent manner. For instance, a series could be a:</p>
<ul>
<li>set of values</li>
<li>string of characters</li>
<li>directory of files</li>
<li>mailbox of messages</li>
<li>group of tasks</li>
<li>database of records (as in a checkbook)</li>
<li>sequence of images (as in a movie)</li>
<li>sequence of sounds</li>
<li>array of pixels (as in an image)</li>
<li>array of samples (as in a sound)<br>
<em>and more...</em></li>
</ul>
<p>The essential characteristics of a series are that it <em><strong>contains a set of values that are organized in a particular order</strong></em> .</p>
<p>A movie consists of a number of still images which are placed in the order that they are to be shown. This sentence contains a series of words which you read in the order that they were written.</p>
<p>The order implies a few simple relationships. Something comes <strong>first</strong>, something comes <strong>next</strong>. There is a beginning (<strong>head</strong>) and an end (<strong>tail</strong>). You can skip <strong>forward</strong> or <strong>backward</strong> in the series. You can count its parts (<strong>length</strong>) and you can refer to them by their positions (e.g. the <strong>fifth</strong> word in a sentence).</p>
<p>The following section covers taking advantage of the power of series in REBOL scripts. Refer to the <strong><a>Expert’s Guide</a></strong> for complete descriptions and examples of REBOL series.</p>
<h3><a name="p-7942-blocks-3" class="anchor" href="https://forum.rebol.info#p-7942-blocks-3"></a>Blocks</h3>
<p>Both code and data can be grouped into a type of series called a <em><strong>block</strong></em> . Blocks can be directly expressed in REBOL as a set of values enclosed in square brackets:</p>
<pre><code>[10:42 "write next chapter"]
</code></pre>
<p>Blocks can contain any number of values (up to the limit of memory) or no values at all. They can extend over multiple lines and can include any type of value, even other blocks:</p>
<pre><code>[ ]

[24 37 108]

[REBOL [
    Title: "Test Script"
    Date: 30-Sep-1998
    Author: "Ema User"
]]
</code></pre>
<p>Note that when <em><strong>words</strong></em> are used within a block (like name, work, home), they do not need to be previously defined. Their values may be set later in the script, or in some cases, not at all (as when they are being used symbolically).</p>
<p><strong>There is no difference in REBOL between blocks that hold code and blocks that hold data.</strong> Code is simply a block that is evaluated and whose words when evaluated have meaning in REBOL. Evaluation is further discussed in Chapter 4 of this guide.</p>
<pre><code>if date &gt; 31/Mar/1999 [print "project delayed"]

while [time &lt; 10:00] [
    print time
    time: time + 0:10
]
</code></pre>
<p><strong>Blocks are <em>free form.</em></strong> They are not sensitive to lines, spaces or tabs. You can place lines and spacing anywhere within the block, as long as it does not divide a single value.</p>
<p><em>Note: To make programs easier to read it is helpful to indent lines that fall within a block, as shown above. Note that the closing bracket is often placed on a separate line and is not indented like the content of the block.</em></p>
<h3><a name="p-7942-decomposing-4" class="anchor" href="https://forum.rebol.info#p-7942-decomposing-4"></a>Decomposing</h3>
<p>A series is created so that it can be treated as a whole. However, to be useful, you will need to access the values within it. Because the values of a series have an order, the obvious way to <strong>extract a particular value is by specifying its position.</strong> The REBOL <strong>pick</strong> function does this:</p>
<pre><code>&gt;&gt; colors: ["red" "green" "blue" "yellow" "orange"]

&gt;&gt; print pick colors 3
== blue
</code></pre>
<p>For convenience, REBOL also provides a few <em>shorthand</em> functions for picking values from common positions: <strong>first</strong> , <strong>second</strong> , <strong>third</strong> , <strong>fourth</strong> , <strong>fifth</strong> , and <strong>last</strong> .</p>
<pre><code>&gt;&gt; print third colors
== blue

&gt;&gt; print last colors
== orange
</code></pre>
<h3><a name="p-7942-traversing-5" class="anchor" href="https://forum.rebol.info#p-7942-traversing-5"></a>Traversing</h3>
<p>In REBOL, a common way to access a series is to <strong>traverse</strong> it (to move around inside it). To do anything more than pick out values, you will need to know this.</p>
<p><strong>Traversing is like crossing a creek by stepping on stones.</strong> You start by hopping to the first stone (the head), then hop from one stone to the next until you reach the end (the tail). While you are in the process of moving across the creek your current position is marked by where you are standing. The same ideas apply to traversing a series.</p>
<p>In the previous section, the word <strong>colors</strong> was set to a block with:</p>
<pre><code>colors: ["red" "green" "blue" "yellow" "orange"]
</code></pre>
<p>It is crucial for you to realize that the block exists on its own, and that colors simply refers to the head of the block.</p>
<p>When you traverse this block, you move to other positions within it. The entire block still exists, you are just at a different "stone" (to use the creek metaphor). For instance:</p>
<pre><code>&gt;&gt; print colors
red green blue yellow orange
</code></pre>
<p>You are at the head of the block. The <strong>next</strong> function will "hop" to the next position in the block and return it. You could <strong>print</strong> from the new position or define a new word for it:</p>
<pre><code>&gt;&gt; print next colors
green blue yellow orange

&gt;&gt; newer: next colors
&gt;&gt; print newer
green blue yellow orange
</code></pre>
<p><strong>What is really important here is that <em>you are still referring to the same block</em>, just a different position within it.</strong> If you wanted, you could use the <strong>past</strong> function to move back to the position you just passed:</p>
<pre><code>&gt;&gt; older: past newer
&gt;&gt; print older
red green blue yellow orange
</code></pre>
<p><em><strong>Traversing in this fashion is the same for all series.</strong></em></p>
<p>To obtain a value from a different position in the block, you can use the <strong>pick</strong> function or any of its shorthand functions (<strong>first</strong> , <strong>second</strong> , <strong>third</strong> , etc.):</p>
<pre><code>&gt;&gt; print first newer
green
</code></pre>
<p>If you want to move forward or backward multiple positions, you could string together multiple <strong>next</strong> or <strong>back</strong> functions:</p>
<pre><code>&gt;&gt; print next next next colors
yellow orange
</code></pre>
<p>However, for general cases it is better to use the <strong>skip</strong> function:</p>
<pre><code>&gt;&gt; example: skip colors 3
&gt;&gt; print example
yellow orange
</code></pre>
<p>You can also go backwards in a series by providing a negative skip value.</p>
<p>If you want to skip forward to the tail (the position just after the last value) or back to the head, the <strong>tail</strong> and <strong>head</strong> functions can be used:</p>
<pre><code>&gt;&gt; example: head example
&gt;&gt; print example
red green blue yellow orange

&gt;&gt; print past tail colors
orange
</code></pre>
<p>Notice in the last example you need to move backward one (<strong>past</strong>) before printing. That's because <strong>tail</strong> <strong>always places you <em>just past the last value.</em></strong></p>
<pre><code>&gt;&gt; tail-colors: tail colors
&gt;&gt; print length? tail-colors
0
</code></pre>
<p>As you will learn later, tail is necessary in order to <strong>insert</strong> new values in the block.</p>
<h2><a name="p-7942-length-6" class="anchor" href="https://forum.rebol.info#p-7942-length-6"></a>Length</h2>
<p>The length of a series is the number of values from <em>the current position</em> to its tail. The <strong>length?</strong> function will determine this.</p>
<pre><code>&gt;&gt; print length? [10 20 30 40]
4

&gt;&gt; skipped: skip colors 3
&gt;&gt; print length? skipped
2
</code></pre>
<p>When a block appears as a value within another block, it only counts as one value:</p>
<pre><code>&gt;&gt; values: [new [1 2 3] old [4 5]]
&gt;&gt; print length? values
4

&gt;&gt; print length? second values
3
</code></pre>
<h3><a name="p-7942-position-7" class="anchor" href="https://forum.rebol.info#p-7942-position-7"></a>Position</h3>
<p>When you are traversing a series, there will be times when you want know your position from the head of the series. The <strong>index?</strong> function will provide you with that number.</p>
<pre><code>&gt;&gt; skipped: skip colors 3
&gt;&gt; print index? skipped
4
</code></pre>
<p>You can also check to see if you are at the head or tail positions in a series with the <strong>head?</strong> and <strong>tail?</strong> functions:</p>
<pre><code>&gt;&gt; if head? colors [print "at head"]
at head

&gt;&gt; if tail? colors [print "at tail"] else [print "not tail"]
</code></pre>
<p>not tail</p>
<pre><code>&gt;&gt; while [not tail? colors] [
       print [index? colors "-" first colors]
       colors: next colors
]

1 - red
2 - green
3 - blue
4 - yellow
5 - orange
</code></pre>
<p>Note that <strong>colors</strong> is now at the tail position in the block. To move it back to the head:</p>
<pre><code>&gt;&gt; colors: head colors
</code></pre>
<h3><a name="p-7942-find-and-select-8" class="anchor" href="https://forum.rebol.info#p-7942-find-and-select-8"></a>Find and Select</h3>
<p>With the <strong>find</strong> function you can traverse to a particular value in a series:</p>
<pre><code>&gt;&gt; found: find colors "blue"
&gt;&gt; print found
blue yellow orange

&gt;&gt; print first found
blue
</code></pre>
<p>Additional attributes can be specified to allow you to control the direction (backward or forward) as well as the pattern matching (like case sensitivity and wildcards).</p>
<p>A block is often used to hold related values in a simple "micro database". For instance:</p>
<pre><code>email-book: [
    "John" jd@great.effects.org
    "Richard" rich@photo.edu
   "Joe" walker@yoda.gov
   "Ralph" RMQ@m.falcon.edu
]
</code></pre>
<p>To locate a person in this database:</p>
<pre><code>&gt;&gt; name: find email-book "Joe"
&gt;&gt; print [first name "is at" second name]
Joe is at walker@yoda.gov
</code></pre>
<p>A handy variation of <strong>find</strong> is the <strong>select</strong> function, which will return the <em>value</em> that follows the one that was matched:</p>
<pre><code>&gt;&gt; print select colors "blue"
yellow

&gt;&gt; print select email-book "Richard"
rich@photo.edu
</code></pre>
<p>The <strong>select</strong> function is commonly used for finding a particular block of code to evaluate (somewhat like the switch or case statements in other languages). An example:</p>
<pre><code>cases: [
    10 [print "ten"]
    20 [name: "twenty"]
    30 [quit]
]

&gt;&gt; do select cases 10
ten
</code></pre>
<h3><a name="p-7942-series-helpers-9" class="anchor" href="https://forum.rebol.info#p-7942-series-helpers-9"></a>Series Helpers</h3>
<p>Traversing through an entire series is done often in REBOL. To help minimize the task, a few helper functions are provided.</p>
<p>The <strong>forall</strong> function will evaluate a block for all values from the current position to the tail of the series.</p>
<pre><code>&gt;&gt; forall colors [print first colors]
red
green
blue
yellow
orange
</code></pre>
<p>Note that the first argument to <strong>forall</strong> <em>must be a word</em> that has been set to a series (in this case a block). As the series is traversed, the variable is updated to each position. When the function has finished, the variable is <em><strong>reset to its starting value.</strong></em></p>
<p>The <strong>foreach</strong> function is similar, but is given a word and the series. For each value in the series, the word will be set to that value.</p>
<pre><code>&gt;&gt; foreach color colors [print color]
red
green
blue
yellow
orange
</code></pre>
<p>The <strong>forskip</strong> function is similar to <strong>forall</strong> but skips a given number of values each time:</p>
<pre><code>&gt;&gt; forskip colors 2 [print first colors]
red
blue
orange
</code></pre>
<h3><a name="p-7942-match-10" class="anchor" href="https://forum.rebol.info#p-7942-match-10"></a>Match</h3>
<p>Without attributes, <strong>match</strong> compares to series and returns NONE if they are not the same, and the end position of the match if they are the same (which in the simple cases is usually the tail of the series). The result of a <strong>match</strong> is often passed to control functions such as <strong>if</strong> , <strong>while</strong> , or <strong>until</strong> .</p>
<pre><code>str: "abcde"
if match str "abcde" [...]
</code></pre>
<p>If the <strong>/part</strong> function attribute is used, <strong>match</strong> will only compare the specified number of characters:</p>
<pre><code>if match/part str "abc" 3 [...]
</code></pre>
<p>You can also specify the ending position of the match:</p>
<pre><code>if match/part str "abc" find str "c" [...]
</code></pre>
<p><em>Note: Unlike the series modification functions, the position must be relative to the first series.</em></p>
<p>A match can also be made against wild card patterns. The <strong>/any</strong> attribute is used to indicate that the match can be made with any string that fits the pattern. Essentially, it allows you to use the same pattern matching features that you apply to file directories (as shown above). A '?' matches any character and a '*' matches zero or more chars.</p>
<pre><code>match/any str "a*" ; any string starting with "a"
</code></pre>
<p>You can also use match for files, email, urls, etc.</p>
<pre><code>match/any email-addr *@rebol.com
match/any file %*.r
match/any url http://www.rebol.com/*
</code></pre>
<p>Advanced REBOL users may need to use patterns containing the wild cards as characters. To do this, you can use <strong>/with</strong> to specify alternate wild chars with a string. The first char in the string is used as the char for single char matches (change from '?'), and the second is for any sequence (change from '*').</p>
<h3><a name="p-7942-creating-series-11" class="anchor" href="https://forum.rebol.info#p-7942-creating-series-11"></a><strong>Creating Series</strong></h3>
<p>REBOL allows you to create new series with <strong>make</strong> and <strong>copy</strong> .</p>
<p><strong>make</strong> creates a new series from a "prototype" and a parameter. The parameter can be an integer indicating the length (or additional length) of the series, or it can be the initial contents of the series.</p>
<pre><code>str: make string! 100
file: make file! 10
file: make file! %myfile.txt
</code></pre>
<p><strong>copy</strong> creates a new series by copying another. This is shorthand for make with a zero additional length parameter (make series 0). (The <strong>part</strong> option described below can also be used with this function.)</p>
<pre><code>new-msg: copy message
new-msg-tail: insert (copy message) "Message: "
</code></pre>
<h3><a name="p-7942-modifying-series-12" class="anchor" href="https://forum.rebol.info#p-7942-modifying-series-12"></a>Modifying Series</h3>
<p>REBOL offers a number of powerful functions to modify series. They include <strong>change</strong>, <strong>insert</strong>, <strong>remove</strong>, and <strong>clear</strong>.</p>
<p><strong>change</strong> changes values within a series. If the second argument is a value, it will replace the value at the current position in the first series. If the second argument is a series, then its values will replace those of the first series. (The <strong>part</strong> , <strong>only</strong> , and <strong>dup</strong> options described below can also be used with this function.)</p>
<pre><code>change block 200
change (skip block 5) 200
change tail block http://www.rebol.com
change block [200 "test"]
</code></pre>
<p><strong>insert</strong> inserts values into a series. If the second argument is a value, it will be inserted into the series at the current position. If the second argument is a series, then its values will be inserted into the first series. (The <strong>part</strong>, <strong>only</strong>, and <strong>dup</strong> options described below can also be used with this function.)</p>
<pre><code>insert block "start"
insert (find block 10:30) "time"
insert next block [200 "test"]
</code></pre>
<p><strong>remove</strong> removes a value from a series. (The <strong>part</strong> option described below can also be used with this function.)</p>
<pre><code>remove block ; removes first value from series
remove (find block fred@derf.com)
</code></pre>
<p><strong>clear</strong> removes remaining values from a series.</p>
<pre><code>clear skip block 20
clear find block http://www.microsoft.com
clear change name "sam" ; explained below
</code></pre>
<p>The change, insert, remove, and clear functions directly affect the series provided as the first argument. If you have other variables which refer to the same series, after the operation they may no longer reference the same value within the series.</p>
<p>The <strong>change</strong> , <strong>insert</strong> , and <strong>remove</strong> functions also return a result, which is the series as of the point just past the modification. This can be useful for making additional modifications:</p>
<pre><code>&gt;&gt; start: "now is the time"
&gt;&gt; insert (remove/part find start "is" size? "is") "was"
&gt;&gt; print start
now was the time

; A simple replace function:
replace: make function! [series old new] [
    use [here]
    if (here: find series old) [
       insert (remove here) new
    ] else [
       print "not found"
    ]
]
</code></pre>
<p>In addition, options can be provided to modify functions. This is done by using function attributes (as paths, similar to those used with object references or file names):</p>
<pre><code>change/part name "fred derf" 4
insert/only block [200 fred@derf.com]
change/dup space "*" 50
</code></pre>
<p>The valid options are:</p>
<p><strong>part</strong> changes, inserts, or removes a given number of values (specified as either a count or as an ending series position).</p>
<pre><code>change/part block items 5
insert/part string "new text" 3
remove/part string 5
remove/part string find string "end"
name: copy/part string 10
</code></pre>
<p><strong>only</strong> treats a series value as a single value. Normally used to change or insert a block as a block, rather than as a series of values.</p>
<pre><code>insert/only block ["Freddy" fred@derf.com 
change/only (skip tail block -4) ["fred" 10]
</code></pre>
<p><strong>dup</strong> repeats the change or insert for the number of times specified.</p>
<pre><code>insert/dup block 'none 5
change/dup (find name "fred") "*" 4
change/part/dup name string 4 3
</code></pre>
<h3><a name="p-7942-dealing-with-none-13" class="anchor" href="https://forum.rebol.info#p-7942-dealing-with-none-13"></a>Dealing With None</h3>
<p>If a series function attempts to access a value that is beyond the head or tail of a series, it will return a special value, <strong>none</strong> , to indicate that there was a problem. You can use the <strong>none?</strong> function to check for such a result:</p>
<pre><code>&gt;&gt; color: pick colors 10
&gt;&gt; if none? color [print "no color"] else [print color]
no color

&gt;&gt; color: find colors "purple"
&gt;&gt; if none? color [print "cannot find purple"]
cannot find purple
</code></pre>
<p>Another function that is often used to detect <strong>none</strong> is the <strong>none?</strong> function, which returns <strong>true</strong> if a value exists and <strong>false</strong> if the value is <strong>none</strong> .</p>
<pre><code>&gt;&gt; color: find colors "green"
&gt;&gt; if none? color [print [index? color first color]]
2 green
</code></pre>
<p>If you do not check for <strong>none</strong> and attempt to use it with a series function, an error will occur. In the example below, <strong>next</strong> does not like the <strong>none</strong> returned by the <strong>find</strong> .</p>
<pre><code>&gt;&gt; print next find colors "purple"
** PROGRAM ERROR: no such action (next) for none **
</code></pre>
<p>The functions <strong>first, second, third, fourth, fifth,</strong> and <strong>last</strong> do not return <strong>none</strong> ; they will generate an error instead. This is done for the convenience of using these functions as shorthand. If you would prefer to receive a <strong>none</strong> in such situations, use the <strong>pick</strong> function.</p>
<pre><code>&gt;&gt; sched: [12:30 "Lunch"]
&gt;&gt; print third sched
** PROGRAM ERROR: value is too short **

&gt;&gt; print pick sched 3
NONE
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_4</link>
        <pubDate>Tue, 06 Oct 1998 04:38:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7942</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7941-chapter-2-rebol-words-1" class="anchor" href="https://forum.rebol.info#p-7941-chapter-2-rebol-words-1"></a>Chapter 2: REBOL Words</h1>
<h3><a name="p-7941-about-words-2" class="anchor" href="https://forum.rebol.info#p-7941-about-words-2"></a>About Words</h3>
<p>As you can see, many <em><strong>values</strong></em> can be expressed directly in REBOL. Numbers, times, dates, strings, files and several other types of values were described. These are the primary building blocks of content.</p>
<p>In human and computer languages we use <em><strong>words as symbols</strong></em> . By combining a small set of fundamental symbols (the letters of an alphabet), we can create an endless variety of new words, hence new symbols. Some countries use different alphabets (or even pictograms or icons); nevertheless, the concept is the same. Letters are grouped into words which symbolize our thoughts. They represent meaning.</p>
<p>In REBOL, too, words serve as symbols, and they are created in the same way: by combining letters (<em>characters</em> ). For example,</p>
<pre><code>copy test! WHAT? File-Name A300 space&amp;time
</code></pre>
<p>REBOL does not distinguish between upper and lower case spelling of words (the language is intended for users, not just technicians). <strong>RED</strong> , <strong>red</strong> , and <strong>Red</strong> all refer to the same word.</p>
<p>Words can be of any length, but they can not extend past the end of a line. They may contain alphabetic characters, numbers, and any of the characters:</p>
<pre><code>? ! . ' + - * &amp; | = _ ~
</code></pre>
<p>Words cannot begin with a number, nor should they contain:</p>
<pre><code>, @ % ^ / \ # $ £
</code></pre>
<p><em><strong>A space is normally used to end a word</strong></em> , but other types of punctuation also indicate the end of a word (the primary REBOL delimiters):</p>
<pre><code>[ ] ( ) { } " : ;
</code></pre>
<p><em>Note: The current version of REBOL supports the standard 256 extended character set. International 16 bit character sets will be supported in later releases.</em></p>
<p>Refer to the <strong><a>Expert’s Guide</a></strong> for complete descriptions and examples of REBOL words.</p>
<h3><a name="p-7941-using-words-3" class="anchor" href="https://forum.rebol.info#p-7941-using-words-3"></a>Using Words</h3>
<p>In REBOL, simple punctuation is used to indicate how a word is being used:</p>
<div class="md-table">
<table>
<thead>
<tr>
<th>syntax</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>word:</code></td>
<td>Define a word. Give it a value.</td>
</tr>
<tr>
<td><code>word</code></td>
<td>Evaluate a word. If it is data, get the value. If it is a function, apply it.</td>
</tr>
<tr>
<td><code>'word</code></td>
<td>Refer to the word as a symbol. It is <em>literally</em> a value.</td>
</tr>
<tr>
<td><code>:word</code></td>
<td>Get a word’s value, but don’t apply it. Useful for referring to functions without evaluating them.</td>
</tr>
</tbody>
</table>
</div><p>The first of these <em><strong>defines</strong></em> or <em><strong>sets</strong></em> the word to associate it with a new value. In REBOL, words are defined in this fashion:</p>
<pre><code>age: 72
lunch-time: 12:32
birthday: 20/3/97
town: "Ukiah"
test: %testfile.rebol
</code></pre>
<p>Notice that you can define a word to be any kind of value. For instance, in the example above you defined words to be <strong>integer, time, date, string,</strong> and <strong>file</strong> values. You can also define words to be more complex types of values:</p>
<pre><code>people: ["Dale" "RJ" "Sam"]
code: [if age &gt; 32 [print town]]
say: make function! [item] [print item]
</code></pre>
<p>These words are often called <strong>variables</strong> . However, as you will see, the concept of a word is more general than just that of variables.</p>
<p>To <em><strong>get</strong></em> the value of a word that was previously defined, place the colon at the front of the word. Here are the results if you typed these lines into REBOL:</p>
<pre><code>&gt;&gt; print :age
== 72

&gt;&gt; if :lunch-time &gt; 12:00 [print "hungry"]
== hungry

&gt;&gt; print length? :people
== 3
</code></pre>
<p>This is the most reliable way to get a word's value, but it is rarely done. The most common way to get the value of a word is to <em><strong>evaluate</strong></em> it (execute it or get its value). Because this is done so often, it is also referred to in REBOL as the <em><strong>natural value</strong></em> of a word. For instance, the examples above could be rewritten without the colons (:).</p>
<p>So what is the difference between getting a word's value and evaluating it? For simple values, there is no difference. Both produce the same result. However, for more complex datatypes such as functions, there is a big difference. One way refers to the value (function or object) and the other executes it. For instance, the word for the REBOL function <strong>print</strong> is used both ways here:</p>
<pre><code>&gt;&gt; print "test"
== test

&gt;&gt; drucken: :print
&gt;&gt; drucken "test"
== test
</code></pre>
<p>The first use of <strong>print</strong> evaluates it, which causes the function to be evaluated, and the resulting value is printed. The second use of <strong>print</strong> gets its value (the function itself) and defines a new word with it. Because that word also refers to the same function, it will evaluate the same way.</p>
<p>The final way to use a word is as a <em><strong>literal</strong></em> . This is done when you want to refer to the word as a symbol; that is, you don't want its value nor do you want it to be evaluated. Any word can be used as a literal, regardless of whether it has a value or was never defined. Consider these:</p>
<pre><code>&gt;&gt; print 'print
== print

&gt;&gt; print 'stampa
== stampa

&gt;&gt; prt: 'print
&gt;&gt; print prt
== print
</code></pre>
<p>This concept is similar to what human languages do when referring to a word as "itself". It is distinguished with punctuation (quotes in English).</p>
<p>Literals are often used when getting or evaluating a word would not produce the desired result. In the code below we search a block for a the word <strong>title</strong> . If we do not refer to the word literally, then REBOL will search for whatever <em>value</em> <strong>title</strong> is currently defined to be, which may not produce the desired result.</p>
<pre><code>video: [
    title "Independence Day"
    length 2:25:24
    date 4/7/1996
]

&gt;&gt; print select video 'title
== Independence Day
</code></pre>
<p>If the literal quote was missing from <strong>title</strong> , then you would be using its natural value or an error would be displayed if it has no value.</p>
<h3><a name="p-7941-word-aliasing-4" class="anchor" href="https://forum.rebol.info#p-7941-word-aliasing-4"></a>Word Aliasing</h3>
<p>Words can have alternate spellings and different character casing while referring to the same word or variable. Within REBOL this operates in two ways: identical spelling and alternate spelling.</p>
<h4><a name="p-7941-identical-spelling-5" class="anchor" href="https://forum.rebol.info#p-7941-identical-spelling-5"></a>Identical Spelling</h4>
<p>When symbols are spelled the same way, but differ in character casing, they refer to the same word. For your convenience REBOL will keep track of the casing, even though the symbols are the same.</p>
<pre><code>&gt;&gt; words: [TITLE title]

&gt;&gt; print first words
== TITLE

&gt;&gt; print second words
== title

&gt;&gt; if (first words) = (second words) [print "They're the same"]
== They're the same
</code></pre>
<h4><a name="p-7941-alternate-spelling-6" class="anchor" href="https://forum.rebol.info#p-7941-alternate-spelling-6"></a>Alternate Spelling</h4>
<p>Alternate spellings can provide language localized words within REBOL. For instance, the Italian word "stampa" can be made an alias to the word "print". In REBOL, this operation makes the words equivalent, even though they are spelled differently.</p>
<p>The alias operation is performed at a low level so it will work for literal symbols as well as variables. Therefore, all aliases must be established prior to loading the files which use them. Aliases at the beginning of a file will not affect the remainder of the file.</p>
<p>The best way to initialize aliases is to create a file which is loaded from your user.r file. After that, all files will be able to use the aliased words. To create an alias, use the alias native, followed by the primary word, followed by the new name.</p>
<pre><code>alias 'print "stampa"
</code></pre>
<p>If you have a large list of words, you might prefer to construct a block of aliases:</p>
<pre><code>aliases: [
    print "intpray"
    load "oadlay"
    save "avesay"
    foreach "oreachfay"
]

foreach [word name] aliases [alias word name]
</code></pre>
<p><em>Caution: Word aliasing may cause confusion and be problematic in some cases</em></p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_3</link>
        <pubDate>Tue, 06 Oct 1998 04:22:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7941</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <h1><a name="p-7940-chapter-1-rebol-values-1" class="anchor" href="https://forum.rebol.info#p-7940-chapter-1-rebol-values-1"></a>Chapter 1: REBOL Values</h1>
<h3><a name="p-7940-about-values-2" class="anchor" href="https://forum.rebol.info#p-7940-about-values-2"></a>About Values</h3>
<p>Values are what languages use to represent meaning. Values are information (data) you organize, transfer, and compute. Values are a key component in all REBOL programs.</p>
<p>This section summarizes the values (sometimes called constants or literals) that can be directly expressed in REBOL. They include integer, decimal, money, time, date, string, binary, email, file, url, and logic values as well as none. Refer to the <strong><a>Expert’s Guide</a></strong> for complete descriptions and examples of all REBOL values.</p>
<p>As we communicate, we exchange meaning though a set of notations or values. We must be careful to express our thoughts in a form that the receiver understands. It makes no difference if the communication is between two people, a person and a computer, or two computers. Communication must have common values — otherwise the content is lost and the receiver gets a meaningless jumble of data.</p>
<p>In REBOL, most values are written in a common, natural form. Some values have alternate forms to allow for minor variations which are found in some countries. REBOL will accept any of the forms.</p>
<div class="md-table">
<table>
<thead>
<tr>
<th><strong>Value</strong></th>
<th><strong>Example Values as Written in REBOL</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>integer</strong></td>
<td>0 1234 -1234 +1234 1234567890 123’456’789</td>
</tr>
<tr>
<td><strong>decimal</strong></td>
<td>12.34 +12.34 -12.34 1. 123’456’789 12,34 -1, 0,0 1.23E4 -1.23E-4 +.1E2 1.E-2 1,23e4 -1,23e-4 1,e2 ,1e2 1,e-2 1e2 1E2</td>
</tr>
<tr>
<td><strong>time</strong></td>
<td>1:22 13:47:52 0:01.5 :5,25</td>
</tr>
<tr>
<td><strong>date</strong></td>
<td>30-Jan-1999 30-June-1957</td>
</tr>
<tr>
<td>30-1-1999 30-6-57 ;always D-M-Y</td>
<td></td>
</tr>
<tr>
<td>30/1/1999 30/6/57</td>
<td></td>
</tr>
<tr>
<td>1999-1-30</td>
<td></td>
</tr>
<tr>
<td><strong>money</strong></td>
<td>$1234.85 $120’345 US$12.49 DKM$100’200’305,65</td>
</tr>
<tr>
<td><strong>string</strong></td>
<td>"This string is only on a single line."</td>
</tr>
<tr>
<td>{ This string spans more than one line</td>
<td></td>
</tr>
<tr>
<td>and also allows "quoted" strings. }</td>
<td></td>
</tr>
<tr>
<td><strong>binary</strong></td>
<td>#{3A18427F 899AEFD8}</td>
</tr>
<tr>
<td>64#{LmNvbSA8yw9CB0aGvXmgUkVCu2Uz93}</td>
<td></td>
</tr>
<tr>
<td><strong>email</strong></td>
<td><a href="mailto:info@rebol.com">info@rebol.com</a></td>
</tr>
<tr>
<td><a href="mailto:president@oval.whitehouse.gov">president@oval.whitehouse.gov</a></td>
<td></td>
</tr>
<tr>
<td><strong>file</strong></td>
<td>%memo.txt</td>
</tr>
<tr>
<td>%script.r</td>
<td></td>
</tr>
<tr>
<td>%System:Prefs/date</td>
<td></td>
</tr>
<tr>
<td><strong>url</strong></td>
<td><a href="http://WWW.REBOL.COM">http://WWW.REBOL.COM</a></td>
</tr>
<tr>
<td><a>ftp://ftp.luth.se/docs/amiga.txt</a></td>
<td></td>
</tr>
<tr>
<td>file://zen/prefs/date</td>
<td></td>
</tr>
<tr>
<td><a href="mailto:info@REBOL.com">mailto:info@REBOL.com</a></td>
<td></td>
</tr>
<tr>
<td><strong>issue</strong></td>
<td><span class="hashtag-raw">#707-467-8000</span> ;telephone number</td>
</tr>
<tr>
<td><span class="hashtag-raw">#1234-5678-9012</span> 12/99 ; credit card number</td>
<td></td>
</tr>
<tr>
<td><span class="hashtag-raw">#0987654321-09876</span> ;serial number</td>
<td></td>
</tr>
<tr>
<td><strong>tuple</strong></td>
<td>1.2.0 (version number)</td>
</tr>
<tr>
<td>199.4.80.1 (network address)</td>
<td></td>
</tr>
<tr>
<td>255.255.127 (RGB color)</td>
<td></td>
</tr>
<tr>
<td><strong>logic</strong></td>
<td>true false on (same as true) off (same as false)</td>
</tr>
<tr>
<td><strong>none</strong></td>
<td>none</td>
</tr>
</tbody>
</table>
</div><h3><a name="p-7940-using-values-3" class="anchor" href="https://forum.rebol.info#p-7940-using-values-3"></a>Using Values</h3>
<p>Within a computer language, the types of fundamental values as summarized above are called its <em>primitive datatypes.</em> Programs are created by combining these datatypes in an endless variety to form more complex data.</p>
<p>The list summarizes the datatypes that can be <strong>directly represented</strong> in the REBOL language, but there are also several other datatypes. <em>Functions</em> and <em>objects</em> , for example, are <strong>constructed during evaluation</strong> using blocks, not through a direct expression. They are <em>constructed datatypes</em> . For instance, the function created by:</p>
<pre><code>add2: func [num] [num + 2]
</code></pre>
<p>does not exist until this line of REBOL script has been evaluated. Before that, this line is only a sequence of values.</p>
<p><em><strong>An entire REBOL script is just a set of values, which when evaluated, produce new values. And evaluation is simply a way of getting a value.</strong></em> This may seem trivially simple, but it is vitally important to understanding the simplicity of REBOL.</p>
<p>Let’s now take a closer look at how to use each of the primitive values.</p>
<h4><a name="p-7940-integer-values-4" class="anchor" href="https://forum.rebol.info#p-7940-integer-values-4"></a>Integer Values</h4>
<p>Integer (also known as whole number) values are represented in as a sequence of numeric digits. No commas or periods are allowed. A minus sign can be used to indicate negative numbers.</p>
<pre><code>0 1 1234 123456789
-1 -1234 -123456789
</code></pre>
<p>Note that there should be <strong>no space</strong> between the minus and the first digit.</p>
<p>Long number cannot be broken up by using commas, because a comma indicates a decimal point in many countries. The same is true with periods. However, REBOL does permit single quotes to separate long integers. The quotes may appear anywhere after the first number.</p>
<pre><code>2'147'483'647
</code></pre>
<h4><a name="p-7940-decimal-values-5" class="anchor" href="https://forum.rebol.info#p-7940-decimal-values-5"></a>Decimal Values</h4>
<p>Decimal values are represented as a sequence of numeric digits, followed by a fraction separator, followed by more digits. The separator may be either a period or a comma.</p>
<pre><code>1.23 123. .321 1234.5678
1,23 123, ,321 1234,5678
</code></pre>
<p>Extra spaces, commas, and periods are not allowed in numbers to designate groups of thousands. Doing so could result in translation errors, evaluation errors, or misinterpretation of a value's datatype. However, REBOL does permit single quotes to separate long integers. The quotes may appear anywhere after the first number.</p>
<pre><code>100'234'562.3782
100'234'562,3782
</code></pre>
<p>Negative decimal values are preceded by a minus sign. Note that there should be no space between the minus and the first digit.</p>
<pre><code>-1.23 -123. -.123 -1234.5678
-1,23 -123, -,123 -1234,5678
</code></pre>
<p>Decimals can also be expressed in scientific notation format, by appending an exponent designated by the letter E or e. The exponent may be positive or negative.</p>
<pre><code>1.23E10 1.2e7 -56.72E3 -.34e-12
1,23E10 1,2e7 -56,72E3 -.34e-12
</code></pre>
<h4><a name="p-7940-time-values-6" class="anchor" href="https://forum.rebol.info#p-7940-time-values-6"></a>Time Values</h4>
<p>A time period (duration) or a time of day is expressed as a numeric digits separated with colons (:). Hours, minutes, and seconds can be written:</p>
<pre><code>10:30 0:00 18:59 23:59:50 8:6:2
</code></pre>
<p>Notice that the last case does not require leading zeros for minutes and seconds. They are optional.</p>
<p>The minutes and seconds fields can contain values greater than <strong>60</strong> . When this is done, the values will be converted automatically. For instance <strong>0:120:00</strong> is the same as <strong>2:00:00</strong> .</p>
<p>Times may be followed by AM or PM with no space in between.</p>
<pre><code>10:20PM 3:32:20AM
</code></pre>
<p>Sometimes, a more precise time is needed, so a fractional second can be appended. As with decimal numbers, either a period or a comma is acceptable:</p>
<pre><code>2:59:29.5 0:00:08.25
2:59:29,5 0:00:08,25
</code></pre>
<p>This last example deserves further attention. There will often be cases when a time period is shorter than a few minutes. These can be abbreviated when the decimal point (the period or the comma) is present. For example:</p>
<pre><code>1:10.25 0:20,1 :10.82 :0,5 :325.2
</code></pre>
<p>Note that in the last case <strong>:325.2</strong> minutes is equivalent to <strong>5:25.2</strong> hours/minutes.</p>
<h4><a name="p-7940-date-values-7" class="anchor" href="https://forum.rebol.info#p-7940-date-values-7"></a>Date Values</h4>
<p>Around the world, dates are written in a variety of formats. Most countries use a <em><strong>day-month-year</strong></em> order. One of the few exceptions is the USA**,** which commonly uses a <em>month-day-year</em> format. If a date is written numerically, such as 2/1/1999, it is ambiguous. The month could be interpreted as either February (in the USA) or January (nearly everyone else). Some countries use dashes (-), some use slashes (/), and others use periods (.) as separators. Finally, computer people often prefer dates in the <em>year-month-day</em> format so they can be easily sorted.</p>
<p>REBOL is flexible, allowing dates to be expressed in a variety of formats. The first day of March would be valid in any of the following common international formats:</p>
<pre><code>1/3/1999
1-3-1999
1999-3-1
1.3.1999 ; see the following note
</code></pre>
<p><em>Note: The last format requires that the year always be expressed in full (four digits). Abbreviating the year will cause the date to be interpreted as a tuple which could cause problems in comparison and sorting operations.</em></p>
<p>To accommodate the USA, the following additional forms are permitted:</p>
<pre><code>1/Mar/1999 1/March/1999
1-Mar-1999 1-March-1999
</code></pre>
<p>It is best to write the year in full. Otherwise, problems will occur with date comparison and sorting operations. Therefore, shortened years (e.g. 99 for 1999) can be used, but their interpretation is relative to the current year. They will span forward and backward a half century from the current year.</p>
<pre><code>28-2-66 ; refers to 1966
12-Mar-20 ; refers to 2020
14-8-46 ; refers to 2046, not 1946
</code></pre>
<p>To represent dates in the first century (which is rarely done because the Gregorian calendar did not exist), you must use leading zeros as in 09-04-0029).</p>
<p>There can be no spaces within the date. For instance: <strong>10 - 5 - 99</strong> would be subtraction between three numbers, not evaluated as a date.</p>
<h4><a name="p-7940-money-values-8" class="anchor" href="https://forum.rebol.info#p-7940-money-values-8"></a>Money Values</h4>
<p>Money values are represented by a currency designator, followed by a $, then numbers. The default currency is U.S. Dollars ($). Numbers are formed in the same format as decimals.</p>
<pre><code>$1234.85
$120’345
USD$12.49
DKM$100’200’305,65
</code></pre>
<p>To prevent errors, be careful when performing mathematical operations between multiple currencies.</p>
<h4><a name="p-7940-string-values-9" class="anchor" href="https://forum.rebol.info#p-7940-string-values-9"></a>String Values</h4>
<p>String values are written as a sequence of characters surrounded by quotes or braces. A <strong><em>quoted</em> string</strong> is restricted to a single line. It may not extend past the end of a line and must not contain unprintable characters.</p>
<pre><code>"This is a short string of characters."
</code></pre>
<p><strong><em>Braced</em> strings</strong> are used for larger sections of text that span multiple lines. All of the characters of the string, including spaces, tabs, quotes, and linefeeds (but not the braces) are part of the string.</p>
<pre><code>{This is a long string of text which will not easily fit
on a single line of source. These are often used for
documentation purposes.}
</code></pre>
<p>Within the string, braces are counted, so a string can include other braces as long as the number of closing braces matches the number of opening braces.</p>
<p>Special characters and operations can be encoded into a string by flagging them with the escape character "^". This character is used rather than the backslash ("") because it avoids conflicts with file paths, which on the PC use a backslash. Special escape-sequence characters include:</p>
<div class="md-table">
<table>
<thead>
<tr>
<th>escape</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^"</code></td>
<td>inserts a "</td>
</tr>
<tr>
<td><code>^}</code></td>
<td>inserts a }</td>
</tr>
<tr>
<td><code>^^</code></td>
<td>inserts a ^</td>
</tr>
<tr>
<td><code>^/</code></td>
<td>starts a new line</td>
</tr>
<tr>
<td><code>^(line)</code></td>
<td>starts a new line</td>
</tr>
<tr>
<td><code>^-</code></td>
<td>inserts a tab</td>
</tr>
<tr>
<td><code>^(tab)</code></td>
<td>inserts a tab</td>
</tr>
<tr>
<td><code>^(page)</code></td>
<td>new page</td>
</tr>
<tr>
<td><code>^C</code></td>
<td>inserts control-C</td>
</tr>
<tr>
<td><code>^[words...]</code></td>
<td>executes a REBOL block</td>
</tr>
</tbody>
</table>
</div><h4><a name="p-7940-binary-values-10" class="anchor" href="https://forum.rebol.info#p-7940-binary-values-10"></a>Binary Values</h4>
<p>Binary data sequences (binary strings) are written as a hash (#) followed by a braced string. The characters within the string are encoded in one of several formats as specified by an optional number prior to the hash. Formats include hex (16), octal (8), binary (2), and base-64 (64). Hex is the default.</p>
<p>Spaces, tabs, linefeeds, and comments within the string are permitted, allowing the data to be formatted in the most convenient manner.</p>
<pre><code>#{3A 18 92 56}
#{3A18427F 899AEFD8}
2#{1001011011001010100101101100101101}
64#{LmNvbSA8yw9CB0aGvXmgUkVCu2Uz93}
</code></pre>
<p>Strings which are missing the proper number of characters are padded on the right.</p>
<h4><a name="p-7940-email-values-11" class="anchor" href="https://forum.rebol.info#p-7940-email-values-11"></a>Email Values</h4>
<p>The standard form of an email address is a name, followed by an @, followed by the domain. The email address may be of any length, but must not include any of the REBOL restricted characters (brackets, quotes, braces, spaces, linefeeds, etc.). These formats are acceptable:</p>
<pre><code>info@REBOL.COM
123@number-mail.org
my-name.here@an.example-domain.com
</code></pre>
<p>Upper and lower casing will be preserved.</p>
<p>Before you can send email from REBOL, you must specify the server you'll be using as well as your email address. Make sure this data is in your user.r file:</p>
<pre><code>REBOL/email-port/host: "mail.yourserver.com"
REBOL/email-head/from: yourname@domain.com
</code></pre>
<p>The host can also be a TCP/IP network address such as:</p>
<pre><code>REBOL/email-port/host: "10.20.30.40"
</code></pre>
<p>Sending email with REBOL is as easy as:</p>
<pre><code>send dem@domain.dom {
    Hello there!
    Yes, I'm still here! Email me when you can!
    Carl
}
</code></pre>
<p>or</p>
<pre><code>send dem@domain.dom read %letter.txt
</code></pre>
<p>More information on the email datatype is included in <strong>Chapter 4 - REBOL Evaluation</strong> .</p>
<h4><a name="p-7940-file-values-12" class="anchor" href="https://forum.rebol.info#p-7940-file-values-12"></a>File Values</h4>
<p>REBOL files are designated with a % followed by a sequence of characters:</p>
<pre><code>load %image.jpg
prog: load %examples.r
save %this-file.txt "This file is empty."
files: load %../programs/
</code></pre>
<p>Unusual characters in file names must be encoded with a % hex number. A file name with a space (hex 20) would look like:</p>
<pre><code>%cool%20movie%20clip
</code></pre>
<p>Even though this is an Internet convention, it isn't very friendly, so another form is to enclose the filename in quotes.</p>
<pre><code>%"cool movie clip"
</code></pre>
<p>REBOL converts the file name to the proper encoded format and does not include the quotes.</p>
<p>The standard, acceptable character for <em><strong>separating directories in a path is the forward slash (/)</strong></em> , not the backslash (). (The backslash was the "creative" contribution of Microsoft in 1982 and has confounded millions of people ever since.) However, because there are millions of people who were innocently led the wrong direction, REBOL automatically converts backslashes found in file names to forward slashes.</p>
<p>The natives <strong>load</strong> , <strong>save</strong> , and <strong>do</strong> will be discussed in <strong>Chapter 4 - REBOL Evaluation</strong> .</p>
<h4><a name="p-7940-url-values-13" class="anchor" href="https://forum.rebol.info#p-7940-url-values-13"></a>URL Values</h4>
<p>The word URL stands for <em>Uniform Resource Locators</em> , an Internet standard used to access resources such as web-pages, images, files, and mail across the network. The best known URL is for web locations (<a href="http://www.rebol.com">http://www.rebol.com</a>).</p>
<p>The first part of a URL indicates its communications protocol, called a <em>scheme</em> . REBOL supports the most common schemes: web pages (<strong>http:</strong> ), file transfer (<strong>ftp:</strong> ), email (<strong>mailto:</strong> ), and files (<strong>file:</strong> ). This is followed by characters that are dependent on which scheme is being used. REBOL knows about:</p>
<pre><code>http://host/path/file
ftp://user:pass@host/path/file
mailto:name@domain
file://host/path/file
</code></pre>
<p>Some fields are optional. For instance, the host can also be followed by a port number, if it differs from the default. An ftp URL will supply a default password if one is not specified.</p>
<p>Characters in a URL must conform to specified standards. Restricted characters must be encoded in hex by preceding them with the escape character %.</p>
<h4><a name="p-7940-issue-values-14" class="anchor" href="https://forum.rebol.info#p-7940-issue-values-14"></a>Issue Values</h4>
<p>An issue is a series of characters used to represent telephone numbers, model numbers, serial numbers, and other number groups. Issues start with a hash (#) and continue until the first delimiting character (such as a space) is reached.</p>
<pre><code>#707-467-8000
#1234-5678-9012 12/99
#0987654321-09876
</code></pre>
<p>Values that are irregularly formatted (contain delimiting characters) should be written as strings rather than issues.</p>
<h4><a name="p-7940-tuple-values-15" class="anchor" href="https://forum.rebol.info#p-7940-tuple-values-15"></a>Tuple Values</h4>
<p>It is common to represent version numbers, Internet addresses, and RGB color values as a sequence of three or four integers. In REBOL, these are called <em>tuples</em> (as in <em>quintuple</em> ) and are represented as a set of integers separated by periods.</p>
<pre><code>1.3.0 2.1.120 1.0.2.32 ; version
199.4.80.250 255.255.255.0 ; net addresses/masks
0.80.255 200.200.60 ; RGB colors
</code></pre>
<p>Each integer field of a tuple may range between 0 and 255. Negative integers will produce an error.</p>
<p>Notice that you can specify three or four integers within a tuple. If only three are given, then the last integer is assumed to be zero. In the case where only two integers are given, you must still have at least two periods, otherwise the value will be treated as a decimal.</p>
<pre><code>1.2. = 1.2.0.0
1.2.3 = 1.2.3.0
</code></pre>
<p>In some countries, the tuple value format is used for dates. <strong>This must be done with great care, because dates are a separate datatype.</strong></p>
<pre><code>8.6.99 is a tuple
18.6.1999 is a date
</code></pre>
<h4><a name="p-7940-logic-values-16" class="anchor" href="https://forum.rebol.info#p-7940-logic-values-16"></a>Logic Values</h4>
<p>A datatype containing two states which represent TRUE and FALSE. They are most frequently returned from comparison functions.</p>
<p>The following <em>words</em> are predefined to hold both logic values:</p>
<pre><code>true
false

on (same as true)
off (same as false)
</code></pre>
<p>Note that <strong>false</strong> is not equivalent to <strong>integer</strong> <strong>zero</strong> or <strong>none</strong> . The intrinsic functions of <strong>logic</strong> are:</p>
<div class="md-table">
<table>
<thead>
<tr>
<th>word</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>logic!</td>
<td>prototypical logic</td>
</tr>
<tr>
<td>logic?</td>
<td>return true</td>
</tr>
<tr>
<td>number?</td>
<td>return false</td>
</tr>
<tr>
<td>make</td>
<td>create an instance of the datatype</td>
</tr>
<tr>
<td>form</td>
<td>format datatype into a string</td>
</tr>
<tr>
<td>mold</td>
<td>mold datatype into a string</td>
</tr>
<tr>
<td>=</td>
<td>equal</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>not equal</td>
</tr>
<tr>
<td>&lt;</td>
<td>purposeful error (see below)</td>
</tr>
<tr>
<td>&lt;=</td>
<td>purposeful error</td>
</tr>
<tr>
<td>&gt;</td>
<td>purposeful error</td>
</tr>
<tr>
<td>&gt;=</td>
<td>purposeful error</td>
</tr>
<tr>
<td>==</td>
<td>equal</td>
</tr>
<tr>
<td>=?</td>
<td>same</td>
</tr>
<tr>
<td>min</td>
<td>purposeful error</td>
</tr>
<tr>
<td>max</td>
<td>purposeful error</td>
</tr>
<tr>
<td>not</td>
<td>complement</td>
</tr>
<tr>
<td>and</td>
<td>and</td>
</tr>
<tr>
<td>or</td>
<td>or</td>
</tr>
<tr>
<td>xor</td>
<td>xor</td>
</tr>
<tr>
<td>random</td>
<td>return random logic</td>
</tr>
<tr>
<td></td>
<td><strong>/seed</strong> set random integer seed</td>
</tr>
<tr>
<td>~</td>
<td>complement</td>
</tr>
</tbody>
</table>
</div><p>A "purposeful error" raises an error in the same manner as an unsupported datatype function. The alternate behavior of the function was considered but discarded for usability reasons (i.e. might create more user problems then help).</p>
<h4><a name="p-7940-none-17" class="anchor" href="https://forum.rebol.info#p-7940-none-17"></a>None</h4>
<p><strong>None</strong> is a datatype containing a single value which represents the state of "no value".</p>
<p>The word <strong>none</strong> is predefined to hold the none value. The value may also be returned from various functions, primarily those involving series (<strong>pick</strong> , <strong>find</strong> , etc.).</p>
<p>Note that none is not equivalent to <strong>integer</strong> <strong>zero</strong> or <strong>false</strong> . The intrinsic functions of <strong>none</strong> are:</p>
<div class="md-table">
<table>
<thead>
<tr>
<th>word</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>none!</td>
<td>prototypical none</td>
</tr>
<tr>
<td>none?</td>
<td>return true</td>
</tr>
<tr>
<td>number?</td>
<td>return false</td>
</tr>
<tr>
<td>make</td>
<td>create an instance of the datatype</td>
</tr>
<tr>
<td>form</td>
<td>format datatype into a string</td>
</tr>
<tr>
<td>mold</td>
<td>mold datatype into a string</td>
</tr>
<tr>
<td>=</td>
<td>equal</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>not equal</td>
</tr>
<tr>
<td>==</td>
<td>equal</td>
</tr>
<tr>
<td>=?</td>
<td>same</td>
</tr>
</tbody>
</table>
</div><p>None is also discussed in <strong>Chapter 3 - REBOL Series</strong> in the section titled <strong>Dealing with None</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_2</link>
        <pubDate>Tue, 06 Oct 1998 04:14:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7940</guid>
      </item>
      <item>
        <title>Rebol 1.0.2 User&#39;s Guide</title>
        <dc:creator><![CDATA[@rebolbot compkarori_bot]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p>Discovered at FTP cache: <a href="https://grumbeer.dyndns.org/ftp/www.ibiblio.org/distributions/redhat-5.1/apps-i386/REBOL/">https://grumbeer.dyndns.org/ftp/www.ibiblio.org/</a></p>
<p><em>README.txt says Rebol 1.0.2 was released 6-October-1998</em></p>
<p>See also:</p>
<ul>
<li>
<p><a href="https://forum.rebol.info/t/rebol-1-0-retrospective/1788">Discussion Thread: <strong>Rebol 1.0 Retrospective</strong></a></p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/rebol-1-0-2-quick-start-guide/2341"><strong>Rebol 1.0.2 Quick Start Guide</strong></a></p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344"><strong>The %rebol.r Boot File From Rebol 1.0</strong></a></p>
</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>Copyright (c)1998 REBOL Technologies. All Rights Reserved.</strong></p>
</blockquote>
<hr>
<h1><a name="p-7939-about-this-guide-1" class="anchor" href="https://forum.rebol.info#p-7939-about-this-guide-1"></a>About This Guide</h1>
<p>This guide is a comprehensive tutorial on how to use REBOL messaging language. REBOL is a user-friendly language and you will soon be writing powerful programs.</p>
<p>This guide includes information about REBOL, writing and running REBOL scripts, and common applications. It then explains the concepts of REBOL values, words, series, evaluation, and context.</p>
<p>Finally, this guide includes useful tips on troubleshooting REBOL scripts.</p>
<p>This guide assumes minimal prior knowledge of computer languages. If needed, read the <strong><a>Quick Start Guide</a></strong> as an introduction to this guide. The <strong><a>Expert’s Guide</a></strong> is a dictionary of REBOL words for your reference. Or, from within REBOL, you can type help followed by the word (<strong><code>help print</code></strong>) to get a description on the display screen.</p>
<h3><a name="p-7939-rebol-history-2" class="anchor" href="https://forum.rebol.info#p-7939-rebol-history-2"></a>REBOL History</h3>
<p>Carl Sassenrath, developer of the Amiga multitasking operating system and other computer tools, has had a vision for more than twenty years. He envisioned a simpler computer language that was also powerful. In addition, he wanted it to work equally well on and pass data between all major operating systems.</p>
<p>Carl’s vision has become a reality in REBOL. Carl, with the help of many other rebellious computer programming and support people, has produced a dynamic messaging language that is simple to learn and use, yet vastly powerful.</p>
<p>People and computers can now freely communicate.</p>
<h3><a name="p-7939-about-rebol-3" class="anchor" href="https://forum.rebol.info#p-7939-about-rebol-3"></a>About REBOL</h3>
<p>REBOL (pronounced REB-ul) is an acronym for <em>relative expression-based object language</em> . REBOL is a messaging language that evaluates <strong>expressions</strong> and returns values. REBOL expressions consist of <strong>words</strong>:</p>
<pre><code>show next computer-name date? today
</code></pre>
<p>and <strong>values</strong> (numbers, times, dates, strings, email addresses, URLs, etc.):</p>
<pre><code>1234 12:45 30-Sep-1998 reb@rebol.com
</code></pre>
<p>grouped into <strong>blocks</strong> :</p>
<pre><code>[sheriff "Bob" 34 bob@prairie.west tough-guy]

if time &gt; 4:00 [send friends "time to REBOL"]
</code></pre>
<p>You can write any combination of words and values into an expression — the format is totally up to you, as long as there is a space or other delimiter separating each one.</p>
<p>REBOL gives you the power to define a <strong>series</strong> :</p>
<pre><code>colors: ["red" "green" "blue" "yellow" "orange"]
</code></pre>
<p>then <strong>evaluate</strong> an expression and return a value:</p>
<pre><code>&gt;&gt; print third colors
== blue
</code></pre>
<p><em><strong>In REBOL, everything is a value</strong></em> . The type of value is called the <strong>datatype</strong> . REBOL datatypes are <em>primitive</em> (numbers, date, time, words, files, email) or <em>constructed</em> (built from primitive datatypes). <strong>Functions</strong> and <strong>objects</strong> are constructed datatypes.</p>
<p>A REBOL word gets its meaning from the context in which it is used. For instance, the word time in the above example might be used for different things in various parts of a REBOL script.</p>
<p>Each of these concepts will be developed in this guide with examples.</p>
<h4><a name="p-7939-writing-a-script-4" class="anchor" href="https://forum.rebol.info#p-7939-writing-a-script-4"></a>Writing a Script</h4>
<p>REBOL scripts are written and exchanged as text files, allowing them to be created and modified with any text editor. The script begins with the word REBOL followed by a header block which provides information about the script. The header has many uses for documentation, archiving, revision tracking, script requirements, or other purposes. Here’s a typical header:</p>
<pre><code>REBOL [
    Title: "Query a Few Friends"
    Author: "Robert Rebol"
    Date: 30-Sep-1998
]
</code></pre>
<p>Text which appears before the header block is ignored. Text appearing after the header is the script itself.</p>
<h4><a name="p-7939-running-a-script-5" class="anchor" href="https://forum.rebol.info#p-7939-running-a-script-5"></a>Running a Script</h4>
<p>Refer to the <strong><a>Quick Start Guide</a></strong> for instructions on how to install REBOL.</p>
<p>To evaluate (execute) a REBOL script and see the results, you have two choices. First, you can start REBOL and type at the &gt;&gt; prompt:</p>
<pre><code>do %filename.r
</code></pre>
<p>The file will be loaded and evaluated. (The % tells REBOL that the value is a file name rather than a word, function, or something else.)</p>
<p>Second option: you can specify a script from the shell or GUI (if your computer platform supports it):</p>
<pre><code>rebol filename.r
</code></pre>
<p>This immediately starts REBOL running with the script.</p>
<p><em>Note: Make sure you run the script from the directory in which rebol.exe was installed.</em></p>
<h3><a name="p-7939-rebol-applications-6" class="anchor" href="https://forum.rebol.info#p-7939-rebol-applications-6"></a>REBOL Applications</h3>
<p>REBOL messaging language can be used to perform a wide variety of tasks on your computer including:</p>
<ul>
<li>
<p>building and managing data (lists, inventory, scheduling, addresses, contacts)</p>
</li>
<li>
<p>transferring data (email, file transfer, file backup)</p>
</li>
<li>
<p>math calculations (checkbook, business statements, trigonometry)</p>
</li>
<li>
<p>sharing data with other computer systems (REBOL files can be read by most operating systems with no conversion)</p>
</li>
<li>
<p>much more — REBOL is both a simple and a powerful messaging language.</p>
</li>
</ul> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340#post_1</link>
        <pubDate>Tue, 06 Oct 1998 04:00:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7939</guid>
      </item>
      <item>
        <title>REBOL 1.0 Retrospective</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1788">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/48.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>Will it be possible to share the manual/guide/documentation for REBOL 1 here? It is a piece of history, and it'll be a shame if it just disappears.</p>
</blockquote>
</aside>
<p>Here in 2024, I found <strong><a href="https://grumbeer.dyndns.org/ftp/www.ibiblio.org/distributions/redhat-5.1/apps-i386/REBOL/">a download of Rebol 1.0.2</a></strong>, which I could extract with the following commands on a modern Debian Linux:</p>
<pre><code>$ sudo apt install rpm2cpio

$ rpm2cpio rebol-1.0.4-2.i386.rpm | cpio -idmv
</code></pre>
<p>I can't get it to run at the moment, but there's HTML files in the archive.  Because there's already a sunk cost to backing up the forum, I did some ad-hoc conversion of the HTML to MarkDown and put the Guides up here:</p>
<ul>
<li>
<p><strong><a href="https://forum.rebol.info/t/rebol-1-0-2-quick-start-guide/2341">Rebol 1.0.2 Quick Start Guide</a></strong></p>
</li>
<li>
<p><strong><a href="https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340">Rebol 1.0.2 User's Guide</a></strong></p>
</li>
</ul>
<p>And here's a little bit of analysis of what code we do have:</p>
<ul>
<li><a href="https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344"><strong>The %rebol.r Boot File From Rebol 1.0</strong></a></li>
</ul>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1788">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/48.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>I was reading about some of the design choices in REBOL, and came upon Joe Marshall's writings where he talks about the changes between REBOL 1 and 2 (missing continuations, changed scoping rules, absence of tail recursion, etc.)</p>
</blockquote>
</aside>
<p>Note that I have written some about this here:</p>
<ul>
<li>
<p><strong><a href="https://forum.rebol.info/t/joe-marshall-on-rebol-binding/2074">Joe Marshall on Rebol Binding</a></strong></p>
</li>
<li>
<p><strong><a href="https://forum.rebol.info/t/the-sherman-rebol-to-scheme-compiler/2076">The Sherman Rebol-To-Scheme Compiler</a></strong></p>
</li>
</ul>
<h1><a name="p-7938-quick-impressions-1" class="anchor" href="https://forum.rebol.info#p-7938-quick-impressions-1"></a>Quick Impressions</h1>
<p>Usage-wise, Rebol1 looks closer to Rebol2 than I expected.  I imagined it being weirder...partially because it had vanished and had something of a lore from Joe saying how different Rebol2 was.  But at least from the user's perspective, it looks quite close.</p>
<p>Cynically I'd say: it kind of looks like design of the Rebol language (not counting Ren-C) froze/peaked 26 years ago.  The enduring subsequent work seems to be PARSE and VID, vs. the interpreter itself.</p>
<p>Not a whole lot of surprises, but I'll write a few thoughts.</p>
<ul>
<li>
<p>Biggest observation: it seems like Joe saw functions as the building blocks of most things, including binding.  Remember that Rebol2 trick where COLLECT received a BLOCK!, and inside that block it wanted any references to KEEP to refer to its function that would append to the collected block...so it just said something along the lines of:</p>
<pre><code>keeper: func [item] [append collected item]
do (func [keep] body) :keeper  ; KEEPER becomes KEEP parameter to BODY
</code></pre>
<p>It seems like this is how Rebol1 modeled binding, generally.</p>
<p>That might feel clever, but when the cost of binding is to sequester your structural data away into a black box of a function...then you've lost the currency of the parts that comprise the lists.  The value proposition of Rebol falls off quickly if your solution is made by isolating everything into information-hiding functional parts.  If anything, it's reliant on <em>information-showing</em> and maximizing the value of that.</p>
<p>I can get why Carl wanted to move away from something that was more lambda calculus than it was LEGO.  An alternate way of thinking is needed--in particular regarding binding--but just not a patently naive approach, which is what happened.</p>
</li>
<li>
<p>There don't appear to be any datatype specs in Rebol 1.0.  All arguments accept all types, it seems...and any type checking has to be done inside your function.  That's pretty rough (though it was quite the struggle to <a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">break free of the 64-type limit</a> with a solution that performed at all well).</p>
</li>
<li>
<p>We know that MAKE used to have variable arity, e.g. <strong><code>make function! [spec] [body]</code></strong> vs. <strong><code>make object! [def]</code></strong>.  Rebol2 did something weird with <strong><code>make function! [[spec] [body]]</code></strong> while Ren-C just said <strong><a href="https://forum.rebol.info/t/debunking-the-arity-1-make/1591">"why not have an arity-2 FUNCTION native"</a></strong>?</p>
</li>
<li>
<p>It's strange to find out that the counterpart to NEXT was PAST instead of BACK <em>(though the documentation also mentions BACK, so perhaps they were synonyms?)</em>  The bigger question remains <a href="https://forum.rebol.info/t/de-verbification-noun-of-x-vs-noun-x/1368">whether these should be <strong>next of</strong> and <strong>back of</strong></a>, to let <strong><code>next</code></strong> and <strong><code>back</code></strong> be freed up for variable names.</p>
</li>
<li>
<p>Interesting to see the <strong><code>use [[vars] &lt;code&gt;]</code></strong> syntax instead of <strong><code>use [vars] [&lt;code&gt;]</code></strong>.  I've always been baffled by the lack of discussion of tradeoffs in dialect design--why you would make one choice vs. another...so changes like this are actually much more rare than one would think.</p>
</li>
<li>
<p>To me, it's good to see ELSE in Rebol 1.0... as <a href="https://forum.rebol.info/t/then-and-else-are-essential/1411">I think it's a comfortable and human thing</a> in terms of the rhythm of conditional logic.  The implementation was wrong, but Ren-C has solved that with a generalized evaluative pattern that isn't a "hack".  It's become kind of amusing to me that some devout Redbol people think ELSE is a sin, and everyone should love EITHER for all situations.  <img src="https://forum.rebol.info/images/emoji/twitter/clown_face.png?v=12" title=":clown_face:" class="emoji" alt=":clown_face:" loading="lazy" width="20" height="20"></p>
</li>
<li>
<p>The idea that you pass CATCH the WORD! you want to act as the "throw" is how Ren-C's definitional CATCH works (it defaults to THROW, but you can override it).  It's called a <strong>"continuation"</strong> but I wonder just how generic it is...can these continuations do weird stuff, like goto?</p>
<pre><code>goto: none
catch 'throw [goto: :throw]
print "Will this print twice?"
goto &lt;whatever&gt;
</code></pre>
<p>Ren-C's CATCH is not based on continuations--just throwing up the stack--so it won't do that.  You need to use <strong><a href="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311">GENERATOR and YIELD</a></strong> if you want to do continuations.</p>
</li>
</ul>
<p>Anyway... I may have a test or two to throw at it if someone gets it to run.  But I don't think there's anything particular for Ren-C to learn from it, things are... quite far along the road.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-0-retrospective/1788#post_5</link>
        <pubDate>Sun, 01 Dec 2024 07:14:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7938</guid>
      </item>
      <item>
        <title>The Probably-False Economy of EVAL Consuming FRAME!</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>The earliest design usages for FRAME! were for things like ENCLOSE.</p>
<p>ENCLOSE builds the frame for the function you're enclosing, then passes the frame to a function that can manipulate the frame, and invoke it with EVAL (or not invoke it at all, if it wishes).</p>
<p>Here's a sort of simple historical example:</p>
<pre><code>/foo: func [a b] [
   let result: a + b
   a: b: ~&lt;whatever&gt;~  ; functions can modify args/locals for any reason
   return result
]

/bar: enclose foo/ (lambda [f [frame!]] [
    let b: f.b
    f.a: f.a * 10
    (eval f) + b
])

&gt;&gt; bar 100 10
== 1020  ; ((a * 10) + b) + b
</code></pre>
<p>You'll notice above that I didn't write:</p>
<pre><code>/bar: enclose foo/ (lambda [f [frame!]] [
    f.a: f.a * 10
    (eval f) + f.b
])
</code></pre>
<p>This is because EVAL of a FRAME! would "consume" the frame, and trying to use <strong><code>f.b</code></strong> after the EVAL would raise an error.  In other words, memory was not allocated as it usually would be for a new frame to do the call...but the fields of the frame were the actual values being used.</p>
<p>I overwrote <strong><code>a</code></strong> and <strong><code>b</code></strong> to make the point that once that EVAL is called, you can't rely on any particular state of a frame's variables.  In the general case, they can be changed to anything.</p>
<h2><a name="p-7936-eval-copy-f-is-easy-and-so-is-saving-variables-right-1" class="anchor" href="https://forum.rebol.info#p-7936-eval-copy-f-is-easy-and-so-is-saving-variables-right-1"></a><code>(eval copy f)</code> is Easy, and So Is Saving Variables, Right?</h2>
<p>The premise I was going on was that it seemed like it would be wasteful...especially in scenarios like an ENCLOSE, to make another copy of the frame's data.</p>
<p>And I figured usually you wouldn't need to refer to anything from the frame's input state after you called it.</p>
<p>So you had two choices: either evaluate a copy of the frame, or save any variables you were interested in as locals.</p>
<h2><a name="p-7936-it-turns-out-to-be-incredibly-common-to-save-variables-2" class="anchor" href="https://forum.rebol.info#p-7936-it-turns-out-to-be-incredibly-common-to-save-variables-2"></a>It Turns Out To Be Incredibly Common To Save Variables</h2>
<p>I didn't know when originally trying to optimize the feature how often an ENCLOSE would need to talk about the input fields after an EVAL call.</p>
<p>But empirically I'd say you need the fields at least half the time.  You actually want it more often than that when you consider debugging--you often want to print some information about the input parameters after you've done the EVAL.</p>
<h2><a name="p-7936-let-b-fb-costs-much-more-than-mallocmemcpy-3" class="anchor" href="https://forum.rebol.info#p-7936-let-b-fb-costs-much-more-than-mallocmemcpy-3"></a><code>(let b: f.b)</code> Costs Much More Than <code>malloc()+memcpy()</code></h2>
<p>When you come down to it, relatively speaking: <em>Evaluator cycles are expensive</em>.  <em>Tuple lookup is expensive</em>.  <em>Assignment is expensive</em>.  <em>LET statements are expensive</em>.</p>
<p>That's because this is an interpreted language, and running code in the interpreter involves pushing and popping entities that represent interpreter stack levels.  There's all kinds of C data structures and layers of C function calls as the gears of the machinery turn...whether your operation be simple or complex.  That's just the name of the game... <strong>a + b</strong> in a generalized evaluator is going to be at least 100x more costly than adding two integers in C, which is basically just a single CPU instruction.</p>
<p>So if you have to do <em>any</em> mitigation of losing the frame data by adding interpreted code, not only are you having to junk up what you're writing...but you're also paying much more than you would have if the system had just gone ahead and made a copy.</p>
<h2><a name="p-7936-explaining-why-you-cant-is-lamer-than-it-just-works-4" class="anchor" href="https://forum.rebol.info#p-7936-explaining-why-you-cant-is-lamer-than-it-just-works-4"></a>Explaining Why You Can't Is Lamer Than <em>"It Just Works"</em></h2>
<p>People understand that if they have a FRAME! for APPEND and they EVAL it, that the series is going to be mutated.</p>
<p>But they're going to understand less that the series field of the frame is not available at all to them after the call.</p>
<p>It's kind of a no-brainer to say that if the two approaches were at all comparable in speed or overall performance, that the more useful behavior should be the default.</p>
<p><em>And I actually believe the more useful behavior is faster in the general case...by avoiding additional intepreter cycles to save frame fields in variables.</em></p>
<h2><a name="p-7936-free-f-could-use-free-as-an-intrinsic-if-you-want-5" class="anchor" href="https://forum.rebol.info#p-7936-free-f-could-use-free-as-an-intrinsic-if-you-want-5"></a><code>(free f)</code> Could Use FREE As An Intrinsic If You Want</h2>
<p><strong><a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">FREE could be trivially made Intrinsic</a>.</strong></p>
<p>If profiling suggested that something like an ENCLOSE on a function with a large frame was affecting your bottom line by not freeing the frame, you could just free it after the EVAL.  That would leave behind nothing but a tiny useless stub (to avoid latent references in other cells from crashing the GC), so you'd get the same end result as the historical EVAL.</p>
<p>I'm betting that having EVAL be able to be intrinsic when it takes one argument, and making FREE intrinsic would be faster than trying to do some weird refinement like <strong><code>eval:free</code></strong> to fold both into one operation...because refinement processing has its own cost, which I <em>think</em> would be greater.</p>
<p>But an optimized <strong><code>eval-free</code></strong> might be worth making, I don't know.  However its mechanic would simply be to natively fold the free in after the EVAL, instead of trying to make EVAL take over the frame and use its memory.</p>
<p>My guess is that using EVAL-FREE won't be a benefit most of the time if you add any evaluator cycles to save a variable because of it.</p>
<h1><a name="p-7936-hence-eval-will-no-longer-consume-frame-6" class="anchor" href="https://forum.rebol.info#p-7936-hence-eval-will-no-longer-consume-frame-6"></a>Hence, EVAL Will No Longer Consume FRAME!</h1>
<p>This makes the "action-is-frame" duality even more solid, because as frames are passed around in the system there won't be "consume frame vs. don't" flags involved.</p>
<p>You'll just either free the frame after you've applied it, or you won't.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p> ]]></description>
        <link>https://forum.rebol.info/t/the-probably-false-economy-of-eval-consuming-frame/2339#post_1</link>
        <pubDate>Sun, 01 Dec 2024 00:50:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7936</guid>
      </item>
      <item>
        <title>Simplifying Refinement Promotion</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>There are two modes of partial specialization which Ren-C has supported.</p>
<p>One form would be like if APPEND takes something like :DUP and fixes it to a value:</p>
<pre><code>&gt;&gt; append2: specialize append/ [dup: 2]

&gt;&gt; append2 [a b c] &lt;d&gt;
== [a b c &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>Then there's a trickier kind of specialization, which is to ask for the parameter but not specify it... thus just increasing the arity:</p>
<pre><code>&gt;&gt; appenddup: append:dup/

&gt;&gt; appenddup [a b c] &lt;d&gt; 4
== [a b c &lt;d&gt; &lt;d&gt; &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>The second form is pretty unusual in the language world.  There doesn't seem to be much prior art in "the conversion of optional parameters to required parameters" (at least I don't know any, and the AIs I asked don't know any).</p>
<p>Since it's pretty different from what what people think of as partial specialization, let's call it <strong>"refinement promotion"</strong>.</p>
<h2><a name="p-7935-refinement-promotion-is-tricky-1" class="anchor" href="https://forum.rebol.info#p-7935-refinement-promotion-is-tricky-1"></a>Refinement Promotion Is <em>Tricky</em></h2>
<p>Something that has been non-negotiable in the design is the straightforward array of parameters and locals that specify a function interface.</p>
<p>Refinements are defined in some order in that array.  But you are not required to use them in that order.</p>
<p>So consider a definition like:</p>
<pre><code> /foo: func [a [integer!] :b [integer!] :c [integer!]] [...]
</code></pre>
<p>Someone might do refinement promotion of this as <strong><code>foo:c:b/</code></strong> - this makes it seem to the caller a function originally written with spec:</p>
<pre><code> [a [integer!] c [integer!] b [integer!]]
</code></pre>
<p>The techniques so far have tried to mimic the way that refinements work.  So <strong><code>get $foo:c:b</code></strong> would produce a function that was accompanied by a <strong><code>[c b]</code></strong> array, that would get pushed when running the promoted function.  The elements in the array would not just have the words, but those words would have binding information to say what index those words were found at in the parameter array.</p>
<p>But since the underlying array is left the same, this means every time you want to know something like "what's the first unspecialized normal argument" you have to mimic the refinement gathering process.  It convoluted the process quite a lot, and really went against the idea of the implementation being "simple".</p>
<h2><a name="p-7935-q-is-this-really-required-to-support-a-yes-2" class="anchor" href="https://forum.rebol.info#p-7935-q-is-this-really-required-to-support-a-yes-2"></a>Q: Is This Really Required To Support?  (A: Yes)</h2>
<p>This may not seem like a super-common need.  But if you're implementing a dialect that wants to support calling functions with refinements, it's pretty important.</p>
<p>Let's say you're implementing something like <a href="https://forum.rebol.info/t/if-action-combinators-dont-impress-what-will/1608">the feature in UPARSE that lets you call functions</a>:</p>
<pre><code>&gt;&gt; data: copy ""

&gt;&gt; parse ["a" "b"] [some [/append:dup (data) text! (2)]]

&gt;&gt; data
== "aabb"
</code></pre>
<p>Basically, if <strong><code>(get $/append:dup)</code></strong> can come back with a function that you can query for its parameters and get answers just like it was any other function, then support for refinements comes basically for free.</p>
<h2><a name="p-7935-should-the-varlist-just-be-rewritten-3" class="anchor" href="https://forum.rebol.info#p-7935-should-the-varlist-just-be-rewritten-3"></a>Should The VarList Just Be Rewritten?</h2>
<p>If you look at what a modern SPECIALIZE followed by AUGMENT can do, they can hide parameters...and then add back parameters with the same name.  Which parameters are visible depend on the "phase" of the frame.</p>
<p>So why couldn't refinement promotion be done just by making a new function interface that removes the argument as a refinement, and adds it back as a regular argument... then has a dispatch phase that moves the argument data to its old position for the subsequent phases?</p>
<p>It's not particularly "cheap" to do that, space-wise.  You'd need a new VarList* and a new Phase*, and the Phase would have to remember the new and old positions to do the rewrite.  But it would make parameter enumeration blunt and simple, because you'd really just be enumerating the parameters in order.</p>
<p>There'd be some cases where the position of the refinement would allow it to just be naturally rewritten to be a regular argument, and that could be optimized for.</p>
<h2><a name="p-7935-what-about-when-you-have-lots-of-local-4" class="anchor" href="https://forum.rebol.info#p-7935-what-about-when-you-have-lots-of-local-4"></a>What About When You Have Lots of <code>&lt;local&gt;</code>?</h2>
<p>This is kind of the dark side of the simple FRAME! model, which is that if you use it to create a lot of local variables, then operations like SPECIALIZE and AUGMENT which do VarList manipulation have to make copies of everything for the new VarList...including a bunch of locals that aren't changing at all in each new form.</p>
<pre><code>/foo: func [x [text!] y [tag!] &lt;local&gt; a b c d e f g h i j k l m n o p] [
    ... 19 frame cells (includes RETURN) ...
]

/bar: augment foo/ [z [integer!]]  ; z is last item in new 20 item frame
</code></pre>
<p>Refinement promotion would become another one of these situations that would do seemingly unnecessary duplication.</p>
<p>It would be possible in cases like this to create smaller frames and then proxy the results into larger ones, essentially simulating what a user might do to manually call FOO from a new function BAR which had a frame with 3 elements.</p>
<pre><code>/bar: lambda [x [text!] y [tag!] z [integer!]] [
    foo x y  ; imagine doing this, but with faster internal mechanics
]
</code></pre>
<p>Some calculation could be done where the size of the frame justified it.  I have a feeling that the frame would have to be reasonably large before a technique like this would be beneficial.</p>
<h2><a name="p-7935-what-about-refinements-at-headhttpsforumrebolinfotrefinement-arguments-at-head-of-args-list-not-tail2331-5" class="anchor" href="https://forum.rebol.info#p-7935-what-about-refinements-at-headhttpsforumrebolinfotrefinement-arguments-at-head-of-args-list-not-tail2331-5"></a>What About <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">Refinements At Head</a>?</h2>
<p>Well, in that case, you would <em>have</em> to build a new VarList* that extracted the arguments, and then proxy them into position for the new interface.</p>
<p>At least one wouldn't be worried about the "bloated copies of locals" situation.</p>
<h2><a name="p-7935-souse-the-auxiliary-array-simulating-refinements-6" class="anchor" href="https://forum.rebol.info#p-7935-souse-the-auxiliary-array-simulating-refinements-6"></a>So...Use The Auxiliary Array Simulating Refinements?</h2>
<p>The code for simulating refinements when asking simple questions like <em>"what's the first unspecialized normal arg"</em> is unappealingly complex. <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=12" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<p>Making it further unappealing is that when you have this array of refinements "off to the side" but still allow people to fill in slots in frames to specialize out arguments, you end up needing to have "reconciliation"...because those frame slots that are referenced by this out-of-band array are no longer part of the refinement promotion.</p>
<pre><code>&gt;&gt; f: make frame! append:dup:part/  ; has auxiliary [dup part]

&gt;&gt; f.dup: 3  ; what cleans up [dup part] to just [part] ?
</code></pre>
<p>I've talked about not knowing about what "moment" to do these kinds of fixes, and I'm increasingly looking for ways to avoid there being any such moment.  If the physical experience of the frame was that DUP and PART were ordinary parameters and not refinements, then it "just works".</p>
<h2><a name="p-7935-the-dumb-mechanical-answer-is-likely-best-7" class="anchor" href="https://forum.rebol.info#p-7935-the-dumb-mechanical-answer-is-likely-best-7"></a>The "Dumb" Mechanical Answer Is Likely Best</h2>
<p>I sometimes forget just how much I take for granted in Ren-C, regarding the ability to compose functions together.</p>
<p>The "inefficient" idea of making a new parameter list and then proxying the arguments into position would be more efficient than having to create and evaluate an interpreted function that had to manually copy the parameters.</p>
<p>There's a huge tax created by having to compose an off-to-the-side parameter reordering list in with the frame variables, and that tax is paid by <em>any code</em> that wants to interpret the list.  It's just too big a tax to pay.</p>
<p>It pains me a bit to delete it, because it was hard to write and seemed clever at the time.  But techniques have advanced...and while the auxiliary list may have seemed somewhat optimal for storage, it's no longer the right choice.</p> ]]></description>
        <link>https://forum.rebol.info/t/simplifying-refinement-promotion/2338#post_1</link>
        <pubDate>Sat, 30 Nov 2024 21:20:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7935</guid>
      </item>
      <item>
        <title>FRAME! / ACTION! Duality Examined</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>It's been a tough week of contemplation, but...</p>
<p>...I think a "bad" idea I had along the way here, is actually turning out to be a good idea.</p>
<h2><a name="p-7934-details-or-varlist-vs-details-varlist-1" class="anchor" href="https://forum.rebol.info#p-7934-details-or-varlist-vs-details-varlist-1"></a><code>(Details* -or- VarList*)</code> vs. <code>(Details* + VarList*)</code></h2>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="1898">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But it's been on my mind... and it's part of what is making me think through this idea of pairing up <code>(Details* + VarList*)</code> with reused phases instead of making a new Phase every time you want to make a specialization/combinatorization.</p>
</blockquote>
</aside>
<p>So at one point, I grafted in the idea that a FRAME! cell's first Node hold something that's simply a superset of <code>Details*</code> and <code>VarList*</code>.  If a function composition creates a new Details, it puts that in the cell and points to the old VarList.  If it creates a new VarList, it puts that in the cell and it points to the old Details.  If it creates both, it can pick either--doesn't matter.</p>
<ul>
<li>
<p>This brings back the notion of a single pointer serving as an action's identity</p>
</li>
<li>
<p>This again frees up the space for the stored symbol <em>(...I hate losing features, so was really struggling with any design that lost that...)</em></p>
</li>
</ul>
<p>It seems like an uncomfortable situation of a new class of Context Cells which have in their Payload's Node1 something that can either be a VarList or a Details.  But I found that when "simplifying" things so that there's never a symbol in the "Phase" slot, and always a VarList in the VarList slot, that I was having to create questions to reverse-engineer the question of <em>"Are you a <code>VarList*</code>-identity Action or a <code>Details*</code>-identity Action?"</em></p>
<p>Previously I'd called this superset of VarList and Details "Action".  That's a bit confusing since actions are a type of Cell (specifically, FRAME! cells in the antiform state), not a type of Stub.  So I think actually calling it <strong><code>Phase</code></strong> is probably better.</p>
<p>What confused me was that it was seeming like introducing this new <code>Phase*</code> was breaking the idea of the "current" <code>Phase*</code> in the Cell, because you could tweak the types of values in a VarList-based FRAME! (or AUGMENT it, etc.) and then be beholden to a "phase" of typechecking that wasn't a Details.  I couldn't square the terminology and nothing seemed to work.</p>
<p>But I think by talking it out here and figuring out the limits of what's possible and not, you always have to create a new Details if you want to introduce new typechecking.  And this concept of having to "harden", plus the viewing through the "lens" of antiform vs. non, answers a bunch of other questions.</p> ]]></description>
        <link>https://forum.rebol.info/t/frame-action-duality-examined/1898#post_4</link>
        <pubDate>Sat, 30 Nov 2024 10:22:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7934</guid>
      </item>
      <item>
        <title>FRAME! / ACTION! Duality Examined</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1898">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I definitely underestimated just how many issues were folded in with the "hardening" process that creating a Details brought about</p>
</blockquote>
</aside>
<p>This goes further... because there are questions that the evaluator has to ask like "what is the first unspecialized parameter" when dealing with an infix function.</p>
<p>So imagine this:</p>
<pre><code>/mp-add: lambda [a b c] [a * b + c]

f: make frame! mp-add/  ; ...some questions here RE: parameter antiforms

f.a: 10

/mp10-add: infix anti f
</code></pre>
<p>The question "what is your first unspecialized parameter" is supposed to operate on a cache that remembers which parameter that is (this shows a relatively simple case, but it's still slow to have to re-figure out it's <code>b</code> every time...it can get a lot trickier).</p>
<p>So when does that calculation get done?</p>
<p>The last possible moment it seems this can happen is when the frame is being executed.  It <em>could</em> happen when you turn a FRAME! into an antiform, but bear in mind you don't have to make a frame an antiform in order to RUN or EVAL it (though that could just claim it "makes an antiform as part of the internal processing", whether it actually does or not)</p>
<h2><a name="p-7933-consequential-question-changing-answers-1" class="anchor" href="https://forum.rebol.info#p-7933-consequential-question-changing-answers-1"></a>Consequential Question: Changing Answers?</h2>
<p>Continuing the above example, you would expect the following, right?</p>
<pre><code>&gt;&gt; /mp-add: lambda [a b c] [a * b + c]

&gt;&gt; f: make frame! mp-add/  ; or whatever "fill 'holes' with nothing" op is

&gt;&gt; map-each key f [key]
== [a b c]
</code></pre>
<p>But if that frame is allowed to just "morph" to be the representation of an action, then if the <code>a</code> has been specialized out you don't want it to be part of the interface.</p>
<pre><code>&gt;&gt; f.a: 10

&gt;&gt; /mp10-add: infix anti f

&gt;&gt; map-each key f [key]
== [b c]   ; ugh, different answer for the same F?
</code></pre>
<p>So it's like the "hardening" moment is fundamentally changing what you had in your hand.</p>
<h2><a name="p-7933-that-doesnt-sit-well-with-me-pouting_cat-2" class="anchor" href="https://forum.rebol.info#p-7933-that-doesnt-sit-well-with-me-pouting_cat-2"></a>That Doesn't Sit Well With Me <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></h2>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1898">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So FRAME!/ACTION! Unification Was A Mistake?</p>
</blockquote>
</aside>
<p>Well, it can't be incoherent.</p>
<p><strong>I'd be happier saying that when you enumerate the antiform, you get the public interface as if it were an action, and when you enumerate the non-antiform you get access to the specialized slots.</strong></p>
<p>So perhaps it is the moment of turning into an antiform that does the hardening... but doesn't change how the non-antiform state behaves.</p>
<pre><code>&gt;&gt; f.a: 10

&gt;&gt; /mp10-add: infix anti f  ; INFIX RUNS F is same but typechecks FRAME!

&gt;&gt; map-each key f [key]
== [a b c]

&gt;&gt; map-each key mp10-add/ [key]
== [b c]
</code></pre>
<p>Better.</p>
<h2><a name="p-7933-giving-antiforms-the-old-action-properties-may-be-it-3" class="anchor" href="https://forum.rebol.info#p-7933-giving-antiforms-the-old-action-properties-may-be-it-3"></a>Giving Antiforms The Old "ACTION!" Properties May Be It</h2>
<p>It may have to be that frames, when viewed through the antiform lens, answer questions differently.</p>
<p>Once you enable that lens, it will have to lock the frame from modification.  But the idea would be that any non-mutating operations that can still work would answer questions of the non-antiform state the same way they would have been answered before the lock.</p>
<ul>
<li>
<p>I have identified that something significant was lost when the "moment of hardening" that occurred when producing ACTION! from FRAME! disappeared.</p>
</li>
<li>
<p>We don't want questions of the same objects to be answered differently before and after hardening.</p>
</li>
<li>
<p>There is no other available distinguishing state besides the antiform state, and antiform FRAME! is ostensibly the surrogate for a separate action type, so...</p>
</li>
</ul>
<p>...I guess I'm going to try to rig this up.  This is all a bit of a mess right now, it's extremely annoying and hard to know where to start.  But very necessary to sort out.</p>
<p>Mechanically what this means is that when FRAME!s are antiforms, they give answers to questions about their interface based on the VarList* they hold in the cell.  Whereas when they are not antiforms, they consider their interface to be that associated with the "Phase" they hold in the cell.  The VarList* in the cell can't answer questions until it has been "hardened", which happens when you create an antiform of a frame, or use an operation like RUN on the plain FRAME! which will implicitly harden it.</p>
<h2><a name="p-7933-ulterior-motive-disclosure-uparse-optimization-4" class="anchor" href="https://forum.rebol.info#p-7933-ulterior-motive-disclosure-uparse-optimization-4"></a>Ulterior Motive Disclosure: UPARSE Optimization</h2>
<p>One reason that I've been trying so hard to drive down the "allocated entity count" and reuse Phases is that when UPARSE combinators are turned into parsers, they are often used just once.</p>
<p>You might write <strong>opt some "a"</strong>, and the "a" combinator could be called 50 times.  But [some "a"] is only called once, by the OPT, and the OPT may well be called only once as well.  If this is so, a native combinator doesn't need a reusable function... it can just take a disposable FRAME! and instead of using it as an archetypal pattern for a call, use its existing allocation for <em>the</em> one call.  <em>(It can even skip typechecking if it's native code and knows what it's doing... poke the input position into the INPUT slot, the parsers into the PARSER slots, and go straight to dispatching the combinated parser.)</em></p>
<p>So my thinking here is that the function spec of combinators could specify whether they want a FRAME! or an ACTION?.  And if it takes a frame, it could be cheap.</p>
<p>It's far out and I don't know how that would interact with debugging, or other forms of combinator wrapping.  It's just an idea.  But it's been on my mind... and it's part of what is making me think through this idea of pairing up <code>(Details* + VarList*)</code> with reused phases instead of making a new Details every time you want to make a specialization/combinatorization.</p> ]]></description>
        <link>https://forum.rebol.info/t/frame-action-duality-examined/1898#post_3</link>
        <pubDate>Thu, 28 Nov 2024 04:11:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7933</guid>
      </item>
      <item>
        <title>UPARSE Combinator Return Conventions: Reviewed</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>UPARSE was an early client of multiple return values, at a time when they worked by assigning variables local to your frame, which were then proxied to items in a SET-BLOCK!:</p>
<pre><code> /multi-returner: func [
     return: [integer!]
     secondary: [integer!]  ; SET-WORD! indicated another return
 ][
     secondary: 20
     return 10
 ]

 &gt;&gt; [ten twenty]: multi-returner
 == 10

 &gt;&gt; ten
 == 10

 &gt;&gt; twenty
 == 20
</code></pre>
<p>This basically made every multi-return function a kind of infix operation, that was able to take a SET-BLOCK! on its left hand side.  <a href="https://forum.rebol.info/t/multiple-return-values-via-infix/1257">(In fact, it was prototyped using infix.)</a></p>
<p>But this method had composability problems, and was defeated by abstraction of any sort, even the most minor forms:</p>
<pre><code> &gt;&gt; [ten twenty]: (multi-returner)
 ** Error: even this wouldn't work
</code></pre>
<p>So the method gave way to returning antiform BLOCK!s.  These represented parameter packs that would "decay" to their first item in most circumstances...but SET-BLOCK!s were one of the cases that could pick them apart (though you could design other operations as well).</p>
<pre><code> /multi-returner: func [
     return: [~[integer! integer!]~]
 ][
     return pack [10 20]
 ]
</code></pre>
<p>You can read all about it in <strong><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">The History of Multi-Return in Ren-C</a></strong></p>
<h2><a name="p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1" class="anchor" href="https://forum.rebol.info#p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1"></a>So Local Proxies Died...But UPARSE Mimicked Them</h2>
<p>Just because the mechanics got rid of local proxies doesn't mean you can't fake them.  All you have to do is hack up its RETURN function to make a PACK using a local variable.</p>
<p>Simplified example:</p>
<pre><code> /proxy-multi-func: adapt func/ [
      body: compose $() inside body '[
          /return: adapt return/ [
             atom: pack [(unmeta atom) secondary]
          ]
          (as group! unbind body)  ; I wish this pattern were simpler
      ]
 ]

 /multi-returner: proxy-multi-func [
     return: [integer!]
     &lt;local&gt; secondary  ; could be specially marked, if spec rewritten
 ][
     secondary: 20
     return 10
 ]
</code></pre>
<p>So when the multi-return-by-antiform-block change happened, this is what COMBINATOR did instead of transition to having every combinator do <strong><code>return pack [synthesized remainder]</code></strong></p>
<p>Instead it worked the same as before: you'd set <strong>remainder</strong> however you wished, do <strong>return synthesized</strong>.  Except now the specialization of RETURN would PACK things up.</p>
<h2><a name="p-7932-why-did-combinator-preserve-proxying-2" class="anchor" href="https://forum.rebol.info#p-7932-why-did-combinator-preserve-proxying-2"></a>Why Did COMBINATOR Preserve Proxying?</h2>
<p>Well... for starters, to show that it could be done.  You <em>should</em> be able to do it.  So having a living test case to hammer through any issues was good.</p>
<p>Also, because some combinators have two return values (synthesized and remainder), while others add a third (pending).  In truth the combinator always needs to return a pack of 3, it's just that some combinators automatically pipe the pending results from successful combinators to the output.  This means even if your combinator returned a pack of 2 in the piped case, that would have to be broken apart and turned into a pack of 3.  Having it in components helps.</p>
<p>But generally, I think it makes the code clearer as well.  Saying <strong><code>(return pack [x y])</code></strong> doesn't have any labeling, while <strong><code>(remainder: y, return x)</code></strong> is somewhat clearer, and you don't need to label the "primary" result because that's understood as what the combinator is synthesizing.</p>
<h2><a name="p-7932-synthesized-cant-be-proxied-unless-meta-3" class="anchor" href="https://forum.rebol.info#p-7932-synthesized-cant-be-proxied-unless-meta-3"></a>Synthesized Can't Be Proxied (unless ^META)</h2>
<p>It's worth pointing out that there's a sort of design constraint here, when you're going to break out multi-return results and have them represented by local variables which are proxied by an adjusted RETURN...</p>
<p>...and that constraint is that you can't put unstable antiforms in variables.  So if you have something you want to return like an antiform pack (as combinators can legitimately synthesize), it has to be the main return result.</p>
<p>So since they use this proxying, combinators kind of break the rule of thumb of "don't make unstable antiforms your primary return in a multi-return situation".  This is because if you do:</p>
<pre><code>return pack [pack [1 2] "a"]
</code></pre>
<p>Then you face some ambiguity in terms of what people might think <strong><code>([x y]: multi-return-func)</code></strong> should mean... or what <strong><code>(x: multi-return-func)</code></strong> should mean.</p>
<p>But really, this is still being worked out.</p>
<h2><a name="p-7932-anyway-just-wanted-to-sum-up-uparse-return-4" class="anchor" href="https://forum.rebol.info#p-7932-anyway-just-wanted-to-sum-up-uparse-return-4"></a>Anyway, Just Wanted To Sum Up UPARSE RETURN</h2>
<p>I was questioning it, and wanted to kind of work through why it is the way it is.  But I think it's right.</p> ]]></description>
        <link>https://forum.rebol.info/t/uparse-combinator-return-conventions-reviewed/2337#post_1</link>
        <pubDate>Thu, 28 Nov 2024 00:35:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7932</guid>
      </item>
      <item>
        <title>Issues With Querying A Function&#39;s &quot;RETURN&quot;</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Each FUNCTION has a local variable named RETURN.  When it's running, the cell for that variable points at an "archetypal return function".  But that cell also holds a reference to that specific function instantiation's frame.  This way it knows how to return specifically from that invocation of that function.</p>
<p>This "definitional return" concept has worked quite well.  But there are some fiddly issues that arise from trying to make RETURN an ordinary local variable.</p>
<h2><a name="p-7931-it-was-hoped-return-would-not-be-special-1" class="anchor" href="https://forum.rebol.info#p-7931-it-was-hoped-return-would-not-be-special-1"></a>It Was Hoped RETURN Would Not Be Special</h2>
<p>The idea is that LAMBDA would be lower-level than FUNCTION, and permit you to have parameters or local variables named RETURN that had nothing to do with returning.</p>
<pre><code>/demo: lambda [return continue] [
    return + continue
]

&gt;&gt; demo 1 2
== 3
</code></pre>
<p>So an aspirational aspect of the design was that a user could create something that operated identically to the FUNCTION abstraction (just a bit slower, due to not being implemented natively).</p>
<p>It would use something like THROW and CATCH, to implement RETURN (or construct(s) in that family) itself, as LAMBDAs synthesized upon instantiation.</p>
<h2><a name="p-7931-return-as-local-hides-its-type-information-2" class="anchor" href="https://forum.rebol.info#p-7931-return-as-local-hides-its-type-information-2"></a>RETURN as Local Hides Its Type Information</h2>
<p>While it's not an argument to the function, RETURN still has associated type information.</p>
<p>Since RETURN is a local that will be filled with an action when the function runs, it isn't using its frame slot until that invocation happens.  That means it can store a PARAMETER! which says what return types are legal.  (It seems like a good use of an otherwise-unused slot otherwise you'd need a slot in the Phase to hold it.)</p>
<p>Functions like HELP want to know those types.  Yet locals and specialized arguments are traditionally considered implementation details, hidden from callers.  They're only visible  when frames are captured during the "phase" of being inside the function call:</p>
<pre><code>&gt;&gt; /foo: function [return: [integer!] x] [
     print mold words of binding of $x
]

&gt;&gt; words of foo/
== [x]

&gt;&gt; foo
== [return x]
</code></pre>
<p>Today's unsatisfying solution is that there's a flag on parameters that represent RETURN.  If you want the type information of that return, you can ask for it:</p>
<pre><code>&gt;&gt; return of foo/
== ~#[parameter! [integer!]]~  ; anti
</code></pre>
<p>But this flag is only applied by the FUNCTION native when its construction the parameter list.  So you wouldn't (for instance) get this behavior on a usermode re-implementation of FUNCTION based on LAMBDA.</p>
<h2><a name="p-7931-how-to-change-return-in-composition-3" class="anchor" href="https://forum.rebol.info#p-7931-how-to-change-return-in-composition-3"></a>How To Change RETURN In Composition?</h2>
<p>Let's say you're going to build a higher-level function with something like ENCLOSE:</p>
<pre><code>&gt;&gt; /bar: enclose foo/ func [return: [tag!] f [frame!]] [
       print "I'm an enclosure!"
       eval f
       return &lt;tag&gt;
   ] 
</code></pre>
<p>The interface of an enclosed function is the same parameter list as the original, and the same returns as the original.  The enclosure is implemented as a function that takes a frame, and it can be given a new return type.  But today that isn't reported as the return type if you asked for HELP of FOO.  It would look at the original parameter list, which in this case says its RETURN is <strong><code>[integer!]</code></strong>.</p>
<p><em>This suggests that the answer to the question <strong><code>return of</code></strong> has to be dispatcher-specific.</em></p>
<p>FUNCTION would say "it's the contents of the RETURN local in the archetype (not overwritten with return function, so still a PARAMETER!)".</p>
<p>ENCLOSE would say "it's the return type of the enclosure function that takes the frame" but then give back the original parameter list for everything else.  (This raises a question of how you would inherit the original function's return... it might be nice if you used a LAMBDA or something that reported no return constraint, that it would default to the constraints of the function you were enclosing.)</p>
<p>In any case, if it was answered by the dispatcher... then if LAMBDA says "I don't have a RETURN", you'd not have HELP information on your RETURN if you were trying to build your own FUNCTION on top of LAMBDA.</p>
<p><strong>The word RETURN may be a distraction, here.</strong>  Because if it's something like a GENERATOR, the products are coming from calls to YIELD.  Maybe <strong><code>(result of ...)</code></strong> or <strong><code>(synthesis of ...)</code></strong> would help stress that this question isn't tied up specifically with RETURN.</p>
<h2><a name="p-7931-lambda-semantics-may-want-result-specification-4" class="anchor" href="https://forum.rebol.info#p-7931-lambda-semantics-may-want-result-specification-4"></a>LAMBDA Semantics May Want Result Specification</h2>
<p>The idea of LAMBDA is that the evaluative product just drops out <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">(see various writings on why FUNCTION does not allow that)</a>.</p>
<p>But just because you want that semantic, doesn't mean you don't want the HELP to not give a return type.</p>
<p>However, LAMBDA doesn't have anywhere to store the type information the way FUNCTION does.  If it has a RETURN it may be using it for unrelated purposes.</p>
<p>Given what I've proposed for the dispatcher-specific RETURN, you could accomplish it with an ENCLOSE:</p>
<pre><code> enclose (lambda [...] [...]) func [return: [&lt;spec&gt;] f] [return eval f]
</code></pre>
<p>But it seems clearly better to have something specific to this purpose:</p>
<pre><code> returns [&lt;spec&gt;] lambda [...] [...]
</code></pre>
<p>Then the Returns_Dispatcher() would simply type check what you gave it.</p>
<p>Perhaps it could even accept a function as a first parameter, and then just say it returns whatever that function returns:</p>
<pre><code>returns add/ lambda [x] [x + 1]
</code></pre>
<p>Though that might be more confusing than writing it out:</p>
<pre><code>returns (return of add/) lambda [x] [x + 1]
</code></pre>
<p>Maybe a refinement should be used to bless that you're doing it on purpose:</p>
<pre><code>returns:same-as add/ lambda [x] [x + 1]
</code></pre>
<p>I guess the big question would be how to get the return's textual description in there.  Maybe it could assume if the format is TEXT! BLOCK! that's what you mean:</p>
<pre><code>/foo: returns [
   "The input plus one"
   [integer!]
] lambda [x] [
    x + 1
]
</code></pre>
<h2><a name="p-7931-well-theres-some-ideas-5" class="anchor" href="https://forum.rebol.info#p-7931-well-theres-some-ideas-5"></a>Well, There's Some Ideas</h2>
<p>I guess the idea here is that mechanics for answering "what do you return" come from the function's dispatcher, and maybe that becomes a chained question where if the dispatcher wraps something else, it has to ask the right parts of that thing.  There may be no user-exposed mechanic for building your own answer to the question beyond something like RETURNS, which is probably good enough.</p> ]]></description>
        <link>https://forum.rebol.info/t/issues-with-querying-a-functions-return/2336#post_1</link>
        <pubDate>Thu, 28 Nov 2024 00:00:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7931</guid>
      </item>
      <item>
        <title>Performance Implications of Antiform-FRAME!-is-Action</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p><a href="https://forum.rebol.info/t/frame-action-duality-examined/1898/2">I've written up some of the issues that have arisen in another thread</a>.</p>
<p>But I wanted to mention something else that's emerged:</p>
<h3><a name="p-7930-antiform-parameter-being-orneryunset-is-a-headache-1" class="anchor" href="https://forum.rebol.info#p-7930-antiform-parameter-being-orneryunset-is-a-headache-1"></a>Antiform PARAMETER! Being Ornery/"unset" is A Headache</h3>
<p>One thing is a good idea: that's the premise of having FRAME! cells with antiform parameters in them be <em>the</em> representation of an unfulfilled parameter (or "Hole").</p>
<p>This means a function's interface can be expressed without having a special hidden "bit" to say what's a parameter description vs. a specialized parameter value <em>("locals" historically were specializations to nothing, but <a href="https://forum.rebol.info/t/dropping-with-in-static/2335">now you can use any value</a> that isn't a parameter antiform)</em>.  The antiform parameter state becomes the "I'm an unfulfilled parameter" bit, which is already a sunk cost in the system for how to deal with it.</p>
<p>It does mean that if you want to actually take an antiform parameter as an argument, it has to be a ^META parameter...even though it's stable.  But that's not such a problem.</p>
<p>What <em>is</em> a headache is having antiform parameters be just as hard to handle as nothings/tripwires.</p>
<p>When you look at what I mention in the other thread about how you can't really "re-skin" actions anyway (at least with trivial mechanics), I think this suggests that whatever the "MAKE FRAME!" operator is needs to go back to filling the unfulfilled arguments with antiform blank.  Antiform parameters need to be friendly when reflecting specs.</p>
<p>The optimization/correctness issues simply need to be addressed some other way.</p> ]]></description>
        <link>https://forum.rebol.info/t/performance-implications-of-antiform-frame-is-action/2083#post_4</link>
        <pubDate>Wed, 27 Nov 2024 22:15:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7930</guid>
      </item>
      <item>
        <title>FRAME! / ACTION! Duality Examined</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <h2><a name="p-7929-its-time-to-revisit-this-1" class="anchor" href="https://forum.rebol.info#p-7929-its-time-to-revisit-this-1"></a>It's Time To Revisit This</h2>
<p>At one point, ACTION! and FRAME! were two different types, whose Cells pointed to two different data structures.</p>
<p>An ACTION! pointed to a <strong><code>DispatchDetails*</code></strong> (or <code>Details*</code> for short).  A Details contained the implementation information for the action... so if it were something like a FUNC, then it would hold the BLOCK! of the body for that specific function.  It also held a pointer to a C function called a <strong><code>Dispatcher*</code></strong> which would know how to interpret those details (e.g. the Func_Dispatcher() would know to run the code in the BLOCK! in the Details array).  Invoking a function could wind up running a chain reaction of Details, that had been composed together to run in the same memory space.</p>
<p>A FRAME! pointed to a <strong><code>VarList*</code></strong> ... which is the same kind of thing that an OBJECT! points to: a list of keys (symbols) and then Cells for each key's value.  However, the cells could either specify an unfulfilled argument (antiform PARAMETER!) or a specialized value...which includes locals.  While this VarList pointed to the specific Details it was for, the FRAME! Cell itself also held another Details* (as the "Phase").  Then, whether you could see the locals or not (or which args and locals) depended on the <strong><code>VarList*</code></strong> of the Phase held in the cell... which is a nuance that made frames quite a bit trickier than objects.</p>
<h2><a name="p-7929-could-frame-be-just-a-details-varlist-pairing-thinking-2" class="anchor" href="https://forum.rebol.info#p-7929-could-frame-be-just-a-details-varlist-pairing-thinking-2"></a>Could FRAME! be Just a (Details*, VarList*) Pairing? <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></h2>
<p>When you are going to add new execution information... you necessarily must create a new Details.  There simply isn't anywhere to put code in a VarList.  However, you can reuse a VarList with that new Details.</p>
<p>e.g. if you were to ADAPT an ACTION! then you'd produce a new <code>Details*</code> which would point to the same <code>VarList*</code> as the thing you were adapting... but just give it a new <code>Adapter_Dispatcher()</code> to with some preamble code in the Phase's array to run.  (It also needs to store the function it is adapting, so it can pass control to it when it's done running the preamble.)</p>
<p>When all ACTION! needed a unique Details, things like SPECIALIZE would create a new Details too, but just a dummy one...since all the information for the specialization exists in a new VarList*.  But ACTION!s had to have a Details, so that's what it did.</p>
<p>A tempting thought is that a FRAME! could just be a Details* and a VarList* paired together in a Cell.  If this were the case, you could create a specialization without making a new Details... which has been a sought-after optimization for some time.</p>
<p>There are a few casualties of such a design.  One is that this breaks the notion of a single pointer being an action's "identity"... you've just got a list of parameters and variables paired up with a compatible implementation...and these are being mixed and matched freely by function composition tools.  The HIJACK capability was only designed for Details pointers, and this would mean you could not hijack a specialization <em>(at least without hijacking all the other specializations of the same function--in practice this is every use case of HIJACK that has come up, but there's nothing in theory saying you wouldn't implement a "unique" service entry point by way of specialization and want to HIJACK that... I can easily imagine it happening, it just hasn't yet.)</em></p>
<p>Another casualty would be the <a href="https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357">storing of a Symbol* inside FRAME! values</a>, which is reliant on a VarList* storing its one-and-only Details* inside it.  If Phases can be mixed with arbitrary Varlists in a FRAME! cell, then there are no free bits for this feature.</p>
<h2><a name="p-7929-elegant-design-fringe-features-3" class="anchor" href="https://forum.rebol.info#p-7929-elegant-design-fringe-features-3"></a>Elegant Design &gt; Fringe Features?</h2>
<p>It's likely that if I were looking at this from scratch--before HIJACK or symbol caching--I would think that the <strong><code>FRAME! Cell =&gt; (VarList* + Details*)</code></strong> made the most sense.</p>
<p>It feels like it decouples things cleanly.  Why <em>would</em> you need to create a new <code>Details*</code> if you're just specializing out values?  If you've made a new <code>VarList*</code> with the updated values, couldn't it be paired up with the old Phase?</p>
<p>It may still be possible to implement HIJACK in such a world.  You could ask the Details* in a FRAME! Cell "what's your VarList*", and if the answer was the same as the VarList* in the Cell then you'd know the Phase was created after the VarList, hence the Details must be the "identity"...so you hijack that.  Otherwise, the VarList* must be the identity...so you'd hijack it <em>(<img src="https://forum.rebol.info/images/emoji/twitter/raised_hand_with_fingers_splayed.png?v=12" title=":raised_hand_with_fingers_splayed:" class="emoji" alt=":raised_hand_with_fingers_splayed:" loading="lazy" width="20" height="20"> hand waving as to how this would work)</em></p>
<p>Additionally, it may be possible to sneak a Symbol* into FRAME! Cells if they aren't using their "Coupling".  (e.g. if they're not a METHOD, or RETURN/CONTINUE/YIELD/BREAK/etc.)  A Symbol* in the coupling slot could just indicate it's uncoupled.  That's...fairly random.  Though to be honest, the feature turned out to be somewhat hard to wield anyway, it was never really clear which assignments should rename the function.</p>
<p>There are a few more glitches, though.</p>
<h2><a name="p-7929-devils-in-the-details-imp-irreducibility-of-typechecking-4" class="anchor" href="https://forum.rebol.info#p-7929-devils-in-the-details-imp-irreducibility-of-typechecking-4"></a>Devil's In The Details <img src="https://forum.rebol.info/images/emoji/twitter/imp.png?v=12" title=":imp:" class="emoji" alt=":imp:" loading="lazy" width="20" height="20">  Irreducibility Of Typechecking</h2>
<p>Before you run a Details, the expectation is that all the unfulfilled slots in a VarList will be filled... with <em>type-correct</em> values.  Calling any function with incorrectly typed cells is bad, but native code actually expects the bit patterns in Cells to be specific to what it asked for...and will crash if it's wrong.</p>
<p>So if a FRAME! is a mix and match of a <code>VarList*</code> and a <code>Details*</code>, when does the <code>VarList*</code> get checked?</p>
<p>There are some weird cases to think about like AUGMENT, which adds to a function's frame.  It only makes an expanded VarList with new keys/cells... there's no implementation code.  So it should be able to reuse whatever Details* was in the FRAME! Cell it augments.  But this means the type checking and argument gathering has to use the VarList* in the cell, not the VarList* that the Details was coupled with.</p>
<p>But wait: the VarList* in the Cell is an arbitrary coupling, with arbitrary tweaked values.  You may have overwritten an argument with a specialized value, that needs checking.  So you can't use that list instead of the VarList* the Phase was coupled with.  <img src="https://forum.rebol.info/images/emoji/twitter/exclamation.png?v=12" title=":exclamation:" class="emoji" alt=":exclamation:" loading="lazy" width="20" height="20"></p>
<p>Exploring this problem further: if PARAMETER! antiforms are indicative of needing to gather that argument, what happens if you tweak it?</p>
<pre><code> &gt;&gt; ap-int: copy meta:lite append/

 &gt;&gt; ap-int.value: anti make parameter! [integer!]  ; or whatever syntax
 == ~#[parameter! [integer!]]~  ; anti

 &gt;&gt; /ap-int: anti ap-int
 == ~#[frame! ...]~  ; anti
</code></pre>
<p>Does this mean you've just created a variant of the APPEND function that only takes integers for the value to append?  Well, not so fast.  APPEND is native code, what would happen if you added a type check which would allow types to pass that weren't legal for APPEND?  You still have to run APPEND's type check.</p>
<p>There's no way to check programmatically if one type constraint is a subset of another.  So if you're allowed to re-type parameters, they have to go through both checks...somehow.</p>
<h2><a name="p-7929-not-so-simple-5" class="anchor" href="https://forum.rebol.info#p-7929-not-so-simple-5"></a>Not So Simple...</h2>
<p>This makes it seem like AUGMENT needs to pay for a trivial Details, in order to get its VarList into a Phase position.  (A trivial Details can be 8 platform-pointers in size, it's not a huge deal, but annoying.)</p>
<p>And it makes it seem like you can't update FRAME! slots that are PARAMETER! antiforms to be new parameter antiforms, without some yet-to-be-designed mechanic... because there's only one type check when slots are filled, and that is that.</p>
<p>Furthermore... if there's no moment of type checking and a specialization is just a Cell that pairs together a VarList* and a Details*, you'd have to type check a specialization every time it's called.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>This shows a feature of the previous creation of a "Specialization Details" when making an ACTION!, that defined a moment where you could check all the VarList slots and make that the Details's new VarList.</p>
<h2><a name="p-7929-so-frameaction-unification-was-a-mistake-6" class="anchor" href="https://forum.rebol.info#p-7929-so-frameaction-unification-was-a-mistake-6"></a>So FRAME!/ACTION! Unification Was A Mistake?</h2>
<p>Well, not so fast.  I'm just mapping out the territory.  <em>(There's actually more to consider when you weigh in things like partial specializations which specify the use of a refinement, but not the specific value for that refinement, which has to encode ordering and other issues.)</em></p>
<p>It may be that when you invoke a FRAME! as if it were an action, then it remembers if the type check passed when the arguments were filled in.  If it does pass for everything, then it knows that it must have passed the specialized portions, and then marks it ok to not have to test the specialized portions the next time.  This means that if you try and call a "fresh" frame function with bad arguments, you won't validate it, but since the call raised an error that extra typechecking is probably not a big issue, and it will just try again next time.</p>
<p>Re-typing a PARAMETER! appears to be more involved than first thought.  Just filling in a FRAME! slot isn't going to do it, you'd need another operation.</p>
<p>Anyway, this has been driving me crazy the last few days so I had to write something down about it.  I definitely underestimated just how many issues were folded in with the "hardening" process that creating a Details brought about...and how many features were tied into Details* being a unique "action identity".  I'm going to have to experiment a bit before I can resolve what's best here.</p> ]]></description>
        <link>https://forum.rebol.info/t/frame-action-duality-examined/1898#post_2</link>
        <pubDate>Wed, 27 Nov 2024 22:08:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7929</guid>
      </item>
      <item>
        <title>ENHEX and DEHEX testing, another &quot;Micro-Dialect&quot;</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Sometimes it's the small examples that I think drive home what the project is about most clearly.  And this is pretty darn close to the essential complexity of the problem being addressed.</p>
<p>So I thought maybe it would be good to look at the impact of a decision like arity-2 COMPOSE here, just to see it "in context".</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">parse compose $() [
    "a%20b" &lt;-&gt; "a b"
    "a%25b" &lt;-&gt; "a%b"
    "a%ce%b2c" -&gt; "aβc" -&gt; "a%CE%B2c"  [1]
    "%2b%2b" -&gt; "++" -&gt; "++"  [2]
    "a%2Bb" -&gt; "a+b" -&gt; "a+b"  [2]
    "a%62c" -&gt; "abc" -&gt; "abc"  [2]
    "a%CE%B2c" &lt;-&gt; "aβc"
    (as text! #{2F666F726D3F763D254335253939}) -&gt; "/form?v=ř"
][ some [
    let encoded: text!
    let arrow: ['&lt;-&gt; | '-&gt;]
    let decoded: text!
    let re-encoded: [when (arrow = '-&gt;) ['-&gt; text!] | (encoded)]
    optional block!  ; headnote comment
    (
        let de: dehex encoded
        if de != decoded [
            fail ["Decode of" @encoded "gave" @de "expected" @decoded]
        ]
        let en: enhex decoded
        if en != re-encoded [
            fail ["Encode of" @decoded "gave" @en "expected" @re-encoded]
        ]
    )
]]
</code></pre>
<p>So the question I might ask is: <em>try and compare it with fresh eyes...what does that adjustment feel like?</em></p>
<p>Does it feel like a "wart" appeared?  Does it feel like a "missing parameter" showed up?</p>
<p>I'll stress again that COMPOSE on a string can't work unless it either takes this parameter to draw a binding from, or unless COMPOSE "sneakily" captures the binding environment in which it is executing.</p>
<p>I've suggested that the sneaky form use <code>compose*</code>, so let's look at that as well:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">parse compose* [
    "a%20b" &lt;-&gt; "a b"
    "a%25b" &lt;-&gt; "a%b"
    "a%ce%b2c" -&gt; "aβc" -&gt; "a%CE%B2c"  [1]
    "%2b%2b" -&gt; "++" -&gt; "++"  [2]
    "a%2Bb" -&gt; "a+b" -&gt; "a+b"  [2]
    "a%62c" -&gt; "abc" -&gt; "abc"  [2]
    "a%CE%B2c" &lt;-&gt; "aβc"
    (as text! #{2F666F726D3F763D254335253939}) -&gt; "/form?v=ř"
][ some [
    let encoded: text!
    let arrow: ['&lt;-&gt; | '-&gt;]
    let decoded: text!
    let re-encoded: [when (arrow = '-&gt;) ['-&gt; text!] | (encoded)]
    optional block!  ; headnote comment
    (
        let de: dehex encoded
        if de != decoded [
            fail ["Decode of" @encoded "gave" @de "expected" @decoded]
        ]
        let en: enhex decoded
        if en != re-encoded [
            fail ["Encode of" @decoded "gave" @en "expected" @re-encoded]
        ]
    )
]]
</code></pre>
<p>To me, this is more unsettling than the <code>$()</code>.  It seems so much easier to explain that if you'd said <code>${&lt;?&gt;}</code> instead then it would have looked for FENCE!s beginning with <code>&lt;?&gt;</code></p>
<p>(I'll intentionally paste it all out again here, because I'm trying to make a point.)</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">parse compose ${&lt;?&gt;} [
    "a%20b" &lt;-&gt; "a b"
    "a%25b" &lt;-&gt; "a%b"
    "a%ce%b2c" -&gt; "aβc" -&gt; "a%CE%B2c"  [1]
    "%2b%2b" -&gt; "++" -&gt; "++"  [2]
    "a%2Bb" -&gt; "a+b" -&gt; "a+b"  [2]
    "a%62c" -&gt; "abc" -&gt; "abc"  [2]
    "a%CE%B2c" &lt;-&gt; "aβc"
    {&lt;?&gt; as text! #{2F666F726D3F763D254335253939}} -&gt; "/form?v=ř"
][ some [
    let encoded: text!
    let arrow: ['&lt;-&gt; | '-&gt;]
    let decoded: text!
    let re-encoded: [when (arrow = '-&gt;) ['-&gt; text!] | (encoded)]
    optional block!  ; headnote comment
    (
        let de: dehex encoded
        if de != decoded [
            fail ["Decode of" @encoded "gave" @de "expected" @decoded]
        ]
        let en: enhex decoded
        if en != re-encoded [
            fail ["Encode of" @decoded "gave" @en "expected" @re-encoded]
        ]
    )
]]
</code></pre>
<p>Anyway, I'm very reticent to make plain <code>compose</code> capture its calling environment.  And if I'm not willing to do that, the options are that it take the binding from its template argument (won't work for strings, and a bit of a weird behavior to use as a default for lists), or it be arity-2.</p>
<p>I feel like arity-2 is winning, for me, so far.</p> ]]></description>
        <link>https://forum.rebol.info/t/enhex-and-dehex-testing-another-micro-dialect/2323#post_2</link>
        <pubDate>Fri, 22 Nov 2024 06:37:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7928</guid>
      </item>
      <item>
        <title>Abbreviations As Synonyms</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1211">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>I Propose Abbreviations As Synonyms For What They Abbreviate</strong></p>
<p>Purely synonyms. <code>/FUNC: FUNCTION/</code>.</p>
</blockquote>
</aside>
<p>Well, five years ago I put this idea forth.</p>
<p>Since locals-gathering function has been dead for some time now, I decided the <a href="https://forum.rebol.info/t/dropping-with-in-static/2335/2">end of the PARSE-based wrapper</a> that implemented the "higher-level" function was as good a time as any to finally make the change.</p>
<p>The FUNCTION native is now shorthanded as FUNC, as full synonyms.</p>
<p>Red still operates on the old idea:</p>
<pre><code>red&gt;&gt; x: 10
red&gt;&gt; foo: function [y] [x: y]
red&gt;&gt; foo 20
red&gt;&gt; x
== 10

red&gt;&gt; x: 10
red&gt;&gt; bar: func [y] [x: y]
red&gt;&gt; bar 20
red&gt;&gt; x
== 20
</code></pre>
<p>But as I point out at the top of this thread, <a href="https://forum.rebol.info/t/rethinking-auto-gathered-set-word-locals/1150">and in other posts</a>, it's just not good.</p>
<p>So nice to finally get this crossed off.</p> ]]></description>
        <link>https://forum.rebol.info/t/abbreviations-as-synonyms/1211#post_4</link>
        <pubDate>Fri, 22 Nov 2024 05:14:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7927</guid>
      </item>
      <item>
        <title>SET-WORD! To Initialize Locals In Function Specs?</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>When <a href="https://forum.rebol.info/t/dropping-with-in-static/2335">the higher-level FUNCTION code</a> was removed, that removed the code for assigning default values to locals.</p>
<p>As I mentioned, it was done with GROUP!s:</p>
<pre><code>/foo: function [arg1 arg2 &lt;local&gt; x y (1 + 2) z (null)] [...body...]
</code></pre>
<p>The way it worked was to augment the function's body:</p>
<pre><code>/foo: function [arg1 arg2 &lt;local&gt; x y z] [
   y: '3
   z: ~null~
   (...body...)
]
</code></pre>
<p>It evaluated the expression once, and then used a ^META of the evaluation product as the thing to assign.</p>
<h2><a name="p-7926-native-local-handling-brings-long-desired-advantage-1" class="anchor" href="https://forum.rebol.info#p-7926-native-local-handling-brings-long-desired-advantage-1"></a>Native <code>&lt;local&gt;</code> Handling Brings Long-Desired Advantage</h2>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2210">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>As it so happens, there's potential to exploit this for efficiency. The frame mechanics have a slot for each local in the function archetype that currently just holds nothing (~ antiform), and it could hold this default value / expression. So it wouldn't just save on typing the local name and then later the name again and the expression...but you're avoiding the need to perform the evaluation to do the assignment on each call!</p>
</blockquote>
</aside>
<p>This theoretical advantage was not realized by the FUNCTION abstraction, as it was just injecting assignments into the body.</p>
<p>But now that the FUNC native is orchestrating the situation, the advantage is there.</p>
<h2><a name="p-7926-feature-question-multi-returns-2" class="anchor" href="https://forum.rebol.info#p-7926-feature-question-multi-returns-2"></a>Feature Question: Multi-Returns</h2>
<p>When I brought up the question of <strong><code>[&lt;local&gt; word: expr]</code></strong> instead of <strong><code>[&lt;local&gt; word (expr)]</code></strong>, I didn't consider whether you could do multi-returns:</p>
<pre><code>/bar: function [arg &lt;local&gt; [begin end]: (find series "a")] [...]
</code></pre>
<p>First of all, I'm not certain that feels like it "belongs" in the spec.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_raised_eyebrow.png?v=12" title=":face_with_raised_eyebrow:" class="emoji" alt=":face_with_raised_eyebrow:" loading="lazy" width="20" height="20"></p>
<p>Secondly, this would require some significant redesign.  <img src="https://forum.rebol.info/images/emoji/twitter/fearful.png?v=12" title=":fearful:" class="emoji" alt=":fearful:" loading="lazy" width="20" height="20"></p>
<p>The problem is, that at the time of the spec processing, there's no object in existence to bind into and do such an evaluation.</p>
<p>So this would have to somehow collect the words inside the SET-BLOCK, save the expression, make the archetypal frame, bind into the <em>archetypal frame</em> and evaluate into its locals.</p>
<p>Continuing on this...</p>
<h2><a name="p-7926-set-words-not-being-bound-has-other-consequences-3" class="anchor" href="https://forum.rebol.info#p-7926-set-words-not-being-bound-has-other-consequences-3"></a>SET-WORD!s Not Being Bound Has Other Consequences</h2>
<p>Evaluating the expression, and then writing it into a slot of a partially constructed archetypal FRAME! has other things that are ruled out:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2210">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>What binding rules is it using? Could you initialize local3 and then say <strong><code>local4: (local2 * arg1)</code></strong>?</p>
<ul>
<li>Almost certainly not, and it would just be using the binding of the spec block</li>
</ul>
</blockquote>
</aside>
<p>So that can't work, because what's happening is that the expression is just being evaluated and put in a spot that represents local4.  No "SET" is actually happening, because there's no completed context to assign it to.</p>
<p>That rules out other ideas, like <a href="https://forum.rebol.info/t/a-dream-for-debugging-generalized-accessors/2259">assigning an "accessor"</a>.</p>
<p>When put this way, it makes it seem like using a GROUP! is clearer, because it makes you aware that there's no actual SET-WORD! to assign to.</p>
<h2><a name="p-7926-does-this-suggest-a-redesign-is-needed-4" class="anchor" href="https://forum.rebol.info#p-7926-does-this-suggest-a-redesign-is-needed-4"></a>Does This Suggest A Redesign Is Needed?</h2>
<p>The system <em>could</em> generate the archetypal frame, with nothing in the local slots, and then bind the expressions into it and run them...just as they would run had it been an instantiated function.</p>
<p>So this would be a two-phase thing, that would enable things like multi-returns, accessors, weird-infix-functions that capture the thing they're assigning to in order to know their names...etc.</p>
<p><strong>It's definitely a lot more than I bargained for when I suggested the feature.</strong>  So what would happen here is that only a subset would be implemented, with the rest being done at a future date...</p>
<p><strong>What it does point out is the set of things that the GROUP!-based syntax cannot do.</strong></p>
<pre><code> /foo: function [arg1 arg2 &lt;local&gt; x y (1 + 2) z (null)] [...body...]
</code></pre>
<p>So the big question is whether that's by design ("we don't plan to implement anything more, it's a simple low-hanging fruit you can take advantage of if it fits")... or if it's too limited.</p>
<h2><a name="p-7926-then-is-freeform-dialecting-good-5" class="anchor" href="https://forum.rebol.info#p-7926-then-is-freeform-dialecting-good-5"></a>Then... Is Freeform Dialecting Good?</h2>
<p>It forces the question of "is the word and set-word mix good"</p>
<pre><code> /foo: function [arg1 arg2 &lt;local&gt; x y: 1 + 2 z: null] [...body...]
</code></pre>
<p><em>Instinctually, I feel uneasy about that.</em></p>
<p>If we went that direction, I'd kind of rather have all the locals be SET-WORD!, and allow you to chain the assignments:</p>
<pre><code> /foo: function [arg1 arg2 &lt;local&gt; x: y: z: ~] [...body...]
</code></pre>
<p>I think that if people were hinted that they <em>could</em> assign the locals there, and if they found out this gave them an efficiency boost, the feature might be taken advantage of more.</p>
<p>But they would not be able to be assigned in terms of arguments, so that's a limitation.</p>
<p>And if it's going to be limited anyway, might it be best to let people in on the limitations and just keep it as WORD! plus GROUP! ?</p>
<h2><a name="p-7926-leaning-to-stick-with-word-optional-group-6" class="anchor" href="https://forum.rebol.info#p-7926-leaning-to-stick-with-word-optional-group-6"></a>Leaning To: Stick With WORD! + optional GROUP!</h2>
<p>Really, what we're talking about here is an optimization.</p>
<ol>
<li>
<p>If a local wants a fixed value upon entry to the function on each call, that fixed value can be stored by the archetypal frame and copied into a new instance's cell, at the same cost that initializing it with nothing would cost.</p>
</li>
<li>
<p>If you are initializing a local in such a way, you don't have to repeat its name to initialize it... because you're putting the initial value beside it.</p>
</li>
</ol>
<p>If the function creation process becomes two-pass, doing strange bindings/etc., you're starting to drift from the "optimizing" part of the optimization.  And I'm concerned about the complexity cost of that code.  Thinking about it now, there are details to where I'm not sure how it would work.</p>
<p>Evaluating a GROUP! and dropping its value into the slot of an incomplete archetype you're building is cheap-as-free, and not complicated.</p>
<p>It's a natural extension of just listing out locals as words, and I think it turns out to probably be for the best.</p> ]]></description>
        <link>https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210#post_2</link>
        <pubDate>Fri, 22 Nov 2024 04:04:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7926</guid>
      </item>
      <item>
        <title>Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2335">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Feature-wise, there's a slight loss of the commentary capacity of <code>&lt;with&gt;</code>.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">global-var: 10

foo: function [arg1 arg2 &lt;with&gt; global-var] [  ; no-op, but useful?
    global-var: 20
    return arg1 + arg2
]
</code></pre>
</blockquote>
</aside>
<p>So... deleting this information does seem lossy.  It's helpful to see when something uses non-local declarations.</p>
<p>But the premise of the language is that you get these things as visible by default.</p>
<p>Some time ago I wondered about the idea that only functions would have this visibility, and any non-functions you would need <code>&lt;with&gt;</code> to see and modify.</p>
<p>Today that would mean you'd have to explicitly bind it:</p>
<pre><code>global-var: 10

foo: function [
    arg1 arg2
]
bind @global-var [
    global-var: 20
    return arg1 + arg2
]
</code></pre>
<p>But this feels like an uphill battle, and you're probably inconveniencing as many or more situations than you are clarifying.</p>
<p>Perhaps it's better to just count one's small victories...e.g. that you have to pre-declare <code>global-var</code>, and typos like <code>globl-var:</code> won't work.</p>
<p>A lot of these cases are really situations where you should make an object with data members and methods, anyway... vs. have some sneaky relationship between global variables and certain functions.</p>
<h2><a name="p-7925-i-decided-to-tolerate-with-in-the-specs-for-now-1" class="anchor" href="https://forum.rebol.info#p-7925-i-decided-to-tolerate-with-in-the-specs-for-now-1"></a>I decided to tolerate <code>&lt;with&gt;</code> in the specs for now</h2>
<p>What the native code actually does is a better-than-nothing enforcement, that it checks to make sure the thing you mention for with has a binding.  This caught some stale <code>&lt;with&gt;</code>.</p>
<h2><a name="p-7925-and-i-might-bring-back-static-2" class="anchor" href="https://forum.rebol.info#p-7925-and-i-might-bring-back-static-2"></a>and... I <em>Might</em> Bring Back <code>&lt;static&gt;</code></h2>
<p>Since I've been able to easily implement the <code>&lt;local&gt;</code> initialization feature, as well as settle on <a href="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210/2">why it uses a WORD!+GROUP! instead of a SET-WORD</a>, I might be willing to add the feature back.</p>
<p>But as that thread explains, the notation of WORD!+GROUP! limits you in terms of what you can do with your assignments.  The workaround for locals is to put the assignments in the body.  The workaround for statics is to use BIND.</p>
<p>I'll weigh the pros and cons, but for right now BIND is getting exercised...and the PARSE wrapper that slowed down every function generation is gone.</p> ]]></description>
        <link>https://forum.rebol.info/t/dropping-with-in-static/2335#post_3</link>
        <pubDate>Fri, 22 Nov 2024 00:31:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7925</guid>
      </item>
      <item>
        <title>Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <h2><a name="p-7924-the-dying-parse3-based-func-wrapper-1" class="anchor" href="https://forum.rebol.info#p-7924-the-dying-parse3-based-func-wrapper-1"></a>The Dying PARSE3-BASED FUNC Wrapper</h2>
<p>Here's a snapshot of the code that was written to PARSE the spec, and produce a new one...creating any necessary objects for <code>&lt;static&gt;</code> etc.</p>
<p>As a shortcut, it first did a search with FIND to see if the spec contained any TAG!.  If it did not, it would fall through to the normal func.  <em>(Though this did mean that any <code>&lt;local&gt;</code> tags would trigger the longer version, even though that was supplied by FUNC.)</em></p>
<p>It used PARSE3 because UPARSE was built on top of it, and because it would of course be way too slow at this time.</p>
<p><strong>As I often say about these things... as grotesque as they may seem, they exercise the system asking if we can do certain things in usermode.</strong>  And it shows a good bet for not having written this as tailored native code, because that would all be getting thrown out right now!</p>
<p>And it's not getting <em>completely</em> thrown out... because it's shifting to be part of the test code (and I'm making it use UPARSE, since the performance no longer matters).</p>
<pre><code>/function: func [
    "Augment action with &lt;static&gt;, &lt;in&gt;, &lt;with&gt; features"

    return: [action?]
    spec "Help string (opt) followed by arg words (and opt type and string)"
        [block!]
    body "The body block of the function"
        [&lt;const&gt; block!]
    &lt;local&gt;
        new-spec var loc other
        new-body defaulters statics
][
    ; The lower-level FUNC is implemented as a native, and this wrapper
    ; does a fast shortcut to check to see if the spec has no tags...and if
    ; not, it quickly falls through to that fast implementation.
    ;
    all [
        not find spec tag?/
        return func spec body
    ]

    ; Rather than MAKE BLOCK! LENGTH OF SPEC here, we copy the spec and clear
    ; it.  This costs slightly more, but it means we inherit the file and line
    ; number of the original spec...so when we pass NEW-SPEC to FUNC or PROC
    ; it uses that to give the FILE OF and LINE OF the function itself.
    ;
    ; !!! General API control to set the file and line on blocks is another
    ; possibility, but since it's so new, we'd rather get experience first.
    ;
    new-spec: clear copy spec  ; also inherits binding

    new-body: null
    statics: null
    defaulters: null
    var: #dummy  ; enter PARSE with truthy state (gets overwritten)
    loc: null

    parse3 spec [opt some [
        :(if var '[  ; so long as we haven't reached any &lt;local&gt; or &lt;with&gt; etc.
            var: [
                &amp;set-word? | &amp;get-word? | &amp;any-word? | &amp;refinement?
                | quoted!
                | the-group!  ; new soft-literal format
            ] (
                append new-spec var
            )
            |
            other: block! (
                append new-spec other  ; data type blocks
            )
            |
            other: across some text! (
                append new-spec spaced other  ; spec notes
            )
        ] else [
            'bypass
        ])
    |
        other: group! (
            if not var [
                fail [
                    ; &lt;where&gt; spec
                    ; &lt;near&gt; other
                    "Default value not paired with argument:" (mold other)
                ]
            ]
            defaulters: default [inside body copy '[]]
            append defaulters spread compose [
                (var): default (meta eval inside spec other)
            ]
        )
    |
        (var: null)  ; everything below this line resets var
        bypass  ; failing here means rolling over to next rule
    |
        '&lt;local&gt; (append new-spec &lt;local&gt;)
        opt some [var: word! other: opt group! (
            append new-spec var
            if other [
                defaulters: default [inside body copy '[]]
                append defaulters spread compose [  ; always sets
                    (var): (meta eval inside spec other)
                ]
            ]
        )]
        (var: null)  ; don't consider further GROUP!s or variables
    |
        '&lt;in&gt; (
            new-body: default [
                copy:deep body
            ]
        )
        opt some [
            other: [object! | word! | tuple!] (
                if not object? other [
                    other: ensure [any-context?] get inside spec other
                ]
                new-body: bind other new-body
            )
        ]
    |
        '&lt;with&gt; opt some [
            other: [word! | path!]  ; !!! Check if bound?
        |
            text!  ; skip over as commentary
        ]
    |
        ; For static variables to see each other, the GROUP!s can't have an
        ; hardened context.  We ignore their binding here for now.
        ;
        ; https://forum.rebol.info/t/2132
        ;
        '&lt;static&gt; (
            statics: default [copy inside spec '[]]
            new-body: default [
                copy:deep body
            ]
        )
        opt some [
            var: word!, other: opt group! (
                append statics setify var
                append statics any [
                    bindable maybe other  ; !!! ignore binding on group
                    '~
                ]
            )
        ]
        (var: null)
    |
        &lt;end&gt; accept (~)
    |
        other: &lt;here&gt; (
            fail [
                ; &lt;where&gt; spec
                ; &lt;near&gt; other
                "Invalid spec item:" @(other.1)
                "in spec" @spec
            ]
        )
    ]]

    if statics [
        statics: make object! statics
        new-body: bind statics new-body
    ]

    ; The constness of the body parameter influences whether FUNC will allow
    ; mutations of the created function body or not.  It's disallowed by
    ; default, but TWEAK can be used to create variations e.g. a compatible
    ; implementation with Rebol2's FUNC.
    ;
    if const? body [new-body: const new-body]

    return func new-spec either defaulters [
        append defaulters as group! bindable any [new-body body]
    ][
        any [new-body body]
    ]
]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/dropping-with-in-static/2335#post_2</link>
        <pubDate>Thu, 21 Nov 2024 23:29:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7924</guid>
      </item>
      <item>
        <title>Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>In R3-Alpha, there was the idea that FUNC was lower-level, <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28C1-L56C2">and "FUNCTION" was built on top of it</a>.</p>
<p>Its principal difference was automatically collecting SET-WORD!s as locals.  But it added two refinements: <strong>/WITH</strong> and <strong>/EXTERN</strong>.</p>
<p>/EXTERN was a way of saying what shouldn't get collected as a local variable due to being a SET-WORD!:</p>
<pre><code>global-var: 10

foo: function/extern [arg1 arg2] [
    local-var: "hi"
    global-var: 20  ; /EXTERN protected this from being collected local
    return arg1 + arg2
] [global-var]
</code></pre>
<p>/WITH was a way of making static variables:</p>
<pre><code>accumulate: function/with [x] [
   return state: state + x
] [state: 0]
</code></pre>
<h2><a name="p-7923-early-on-ren-c-moved-everything-into-the-spec-1" class="anchor" href="https://forum.rebol.info#p-7923-early-on-ren-c-moved-everything-into-the-spec-1"></a>Early On, Ren-C Moved Everything Into The Spec</h2>
<p>I didn't like seeing the refinement arguments at the end (of what could be a very long function definition).</p>
<p>It didn't occur to me to suggest that <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">refinement arguments be moved to the head</a> (which they probably should).  But what did occur to me was that the function spec could incorporate these properties.</p>
<p>I actually thought <code>&lt;with&gt;</code> seemed better than extern, as a nicer word for "Use these existing variables".  And <code>&lt;static&gt;</code> seemed like a well-known term for static variables:</p>
<pre><code>foo: function [arg1 arg2 &lt;with&gt; global-var] [
    local-var: "hi"
    global-var: 20
    return arg1 + arg2
]

accumulate: function [x &lt;static&gt; state (0)] [
   return state: state + x
]
</code></pre>
<p>The subtlety of wanting to use an object instance was also added, as <code>&lt;in&gt;</code>:</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [x &lt;in&gt; obj] [
   return a + b + x
]
</code></pre>
<p>To my eyes, that all seemed like improvement.</p>
<p><strong>But it didn't come without cost: The spec had to be transformed into something the lower-level FUNC could understand.</strong></p>
<p>This meant there was a layer of parsing and production of a new spec that was a tax on every function creation.</p>
<h2><a name="p-7923-time-passes-set-word-gathering-is-panned-2" class="anchor" href="https://forum.rebol.info#p-7923-time-passes-set-word-gathering-is-panned-2"></a>Time Passes, SET-WORD! Gathering Is Panned</h2>
<p>It didn't take long for me to decide that <a href="https://forum.rebol.info/t/rethinking-auto-gathered-set-word-locals/1150">SET-WORD! locals-gathering was bad</a>... a gimmick that only made sense in very limited domains (perhaps code-golf)</p>
<p>This motivated having an answer for how to implement LET, as "virtual binding" became the new plan.</p>
<p>Once that transition went through, the effect of <strong><code>&lt;with&gt;</code></strong> was to become commentary.  Since all it did was remove SET-WORD!s from the collection list, and there was no collection any longer.</p>
<p>Though virtual binding did open up a new possibility, that if your block had a different binding than the spec, then the WITH might import visibility of terms to that block:</p>
<pre><code>global-variable: 10

block: /get-block-from-somewhere ...  ; doesn't know about GLOBAL-VARIABLE

/foo: function [x &lt;with&gt; global-variable] block
</code></pre>
<p>But this would be a binding operation, that is better generalized as:</p>
<pre><code>/foo: function [x] (bind @global-variable block)
</code></pre>
<h2><a name="p-7923-pushing-the-features-to-bind-make-the-most-sense-3" class="anchor" href="https://forum.rebol.info#p-7923-pushing-the-features-to-bind-make-the-most-sense-3"></a>Pushing The Features To BIND Make The Most Sense</h2>
<p>Not just <code>&lt;with&gt;</code>, but the <code>&lt;static&gt;</code> and <code>&lt;in&gt;</code> features seemed to be better as BIND operations as well.</p>
<p>The static syntax of not using SET-WORD!s was based on the idea that SET-WORD!s were reserved for local variables (and RETURN: syntax).  So it was a WORD! followed by a GROUP! to initialize.</p>
<p>I think it's better done with just <a href="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139">BIND to a FENCE!</a></p>
<pre><code>accumulate: function [
    x
] bind {state: 0} [
   return state: state + x
]
</code></pre>
<p><code>&lt;in&gt;</code> is similar.</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [
   x
] bind obj [
   return a + b + x
]
</code></pre>
<h2><a name="p-7923-uglier-maybe-more-general-yes-faster-definitely-4" class="anchor" href="https://forum.rebol.info#p-7923-uglier-maybe-more-general-yes-faster-definitely-4"></a>Uglier?  Maybe.  More General?  Yes.  Faster?  Definitely.</h2>
<p>Feature-wise, there's a slight loss of the commentary capacity of <code>&lt;with&gt;</code>.</p>
<pre><code>global-var: 10

foo: function [arg1 arg2 &lt;with&gt; global-var] [  ; no-op, but useful?
    global-var: 20
    return arg1 + arg2
]
</code></pre>
<p>But besides that, there's no loss of features to move everything to a BIND operation on the body.</p>
<p>Not having to PARSE the spec and generate a whole new one is a big performance win.</p>
<p>So I'm letting go of those features.</p> ]]></description>
        <link>https://forum.rebol.info/t/dropping-with-in-static/2335#post_1</link>
        <pubDate>Thu, 21 Nov 2024 22:06:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7923</guid>
      </item>
      <item>
        <title>Red&#39;s Take on String Interpolation</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>I'm a bit torn regarding default interpolation (and COMPOSE in general).</p>
<p>Conventional wisdom for interpolation or templating would be to use something fairly uncommon.</p>
<p>But if you can customize it and choose alternatives, that makes it seem like maybe you should capitalize on a more common thing...even if it competes for the notational space.</p>
<p><a href="https://github.com/red/REP/issues/112">Red gives some examples, e.g. in URL interpolation</a>, so consider something like:</p>
<pre><code>&gt;&gt; compose* http://(site)/(resource)?param=(date as "yyyy")
== http://example.com/whatever.html?param=1998
</code></pre>
<p>Compare that to:</p>
<pre><code>&gt;&gt; compose* http://{{site}}/{{resource}}?param={{date as "yyyy"}}
== http://example.com/whatever.html?param=1998
</code></pre>
<p>Something gets lost, there.</p>
<p>Single braces might be more out-of-band than parentheses, while not looking all that bad, and maybe two stars could be used when you want to double them up:</p>
<pre><code>&gt;&gt; compose* http://{site}/{resource}?param={date as "yyyy"}
== http://example.com/whatever.html?param=1998

&gt;&gt; compose** http://{{site}}/{{resource}}?param={{date as "yyyy"}}
== http://example.com/whatever.html?param=1998
</code></pre>
<p>Though it still doesn't look quite as good as the plain parentheses do.  And it has the problem that you're frequently interpolating braced strings:</p>
<pre><code>compose* -{Here's your {1 + 2} escape}-

compose* -{Here's your (1 + 2) escape}-  ; feels better
</code></pre>
<p>Parentheses could use the doubled-up shorthand idea with <code>**</code>:</p>
<pre><code>&gt;&gt; compose* http://(site)/(resource)?param=(date as "yyyy")
== http://example.com/whatever.html?param=1998

&gt;&gt; compose** http://((site))/((resource))?param=((date as "yyyy"))
== http://example.com/whatever.html?param=1998
</code></pre>
<p>There's a sort of weird logic to going with plain parentheses that I'm finding compelling.  On the surface it's naive, but in practice it may be that if you offer enough ways to raise and alter the escaping then picking something that simple makes sense.</p>
<p>I think that having the "real" COMPOSE be arity-2 helps the whole thing come across as less naive, because you're passing in not just a pattern but also a binding environment.  So saying <em>"look, this <code>compose*</code> and <code>print*</code> stuff is just for convenience, the real COMPOSE is solid"</em> feels more intelligent.</p>
<p>There's a non-zero benefit to aligning with historical Rebol in this design aspect.  (But certainly a lot of benefit from being able to customize the pattern!)</p> ]]></description>
        <link>https://forum.rebol.info/t/reds-take-on-string-interpolation/2121#post_7</link>
        <pubDate>Thu, 21 Nov 2024 08:18:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7922</guid>
      </item>
      <item>
        <title>First Bootstrap In At Least 6 Months: Watershed Changes</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>Evolving Ren-C is a messy and difficult balancing act.  Due to the experimental nature and bus-factor-of-one staffing, it's not always a good use of time to completely push through a change in all code...until it's seen to be a good change.</p>
<p>The adoption of dozens of experimental ideas had led to a situation where being able to bootstrap the codebase stalled... for possibly the longest period yet.  This is to say that while the old 2018-era executable is used to make all the <code>.h</code> and <code>.c</code> files to build the current sources, the executable it built would be unable to do so.</p>
<p>But a few days ago, I managed to accomplish bootstrap. And I've gotten several other codebases that had been atrophying (Whitespacers, Rebol-HTTPD, Query) up to date.</p>
<p>While there are a lot of shaky parts (in particular, the workings of the new form of methodization that relies on <a href="https://forum.rebol.info/t/word-as-member-selection/1843/3">leading-dot <strong>.member</strong> accesses</a>), I'd say overall things are very promising.</p>
<p>One of the toughest points was the institution of "strict mode"... where you cannot assign to a variable that has not been pre-declared in some way (either as a module-level declaration, a LET, a <code>&lt;local&gt;</code>, made with WRAP, etc.)  This is a big change, but a good one... for all the reasons "strict mode" is known to be good, but also because it eliminated <a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128">"attachment binding"</a></p>
<h2><a name="p-7921-not-easy-but-very-instructive-1" class="anchor" href="https://forum.rebol.info#p-7921-not-easy-but-very-instructive-1"></a>Not Easy, But Very Instructive</h2>
<p>In some ways, the story of Ren-C's evolution is told by Rebmake, and the process which produces all the <strong><code>.h</code></strong> and <strong><code>.c</code></strong> files that the build relies on.</p>
<p>It's certainly one of the top 3 biggest and snakiest Rebol codebases (I'd argue it's probably the <em>trickiest</em> codebase of its size, moreso than Red or Atronix Zoe).  And it contains the code of Carl, Shixin, Brett, BrianH, myself, and others... a mixture of styles, and patches, and hacks.  Some huge bends come from needing to run in an executable that's not much beyond a patched version of what ran in 2018.</p>
<p>I've also explained why <a href="https://forum.rebol.info/t/new-build-executables-new-build-strategy/1432">adopting Rebmake was very consequential, and complicating</a>.   It brought concerns to the build process to be a superset of CMake and GNU make, instead of being narrow and focused like other approaches (Giulio and Andreas tried their hands at much more succinct ideas, and Oldes <a href="https://forum.rebol.info/t/siskin-builder-rebol-based-build-tool-by-oldes/1672">is using something much lighter in daily work today</a>).</p>
<p>But this has informed the design, hardened it, and challenged it.</p>
<h2><a name="p-7921-a-new-weird-world-driven-by-reason-and-experience-2" class="anchor" href="https://forum.rebol.info#p-7921-a-new-weird-world-driven-by-reason-and-experience-2"></a>A New "Weird" World: Driven By Reason and Experience</h2>
<p>With changes like <strong><code>:refinement</code></strong> instead of <strong><code>/refinement</code></strong>, and the switch to where actions are assigned as <strong><code>/foo: func [...] [...]</code></strong>, plus member variables being indicated with <strong><code>.field</code></strong> -- things are starting to look quite different.</p>
<p><em>But I can say with confidence that from a usage perspective, it is very clearly better.</em></p>
<p>The slashes for functions is quite empowering.  Unlike the pox of <strong><code>:deactivating</code></strong> GET-WORD!s, slashes tell you <strong>what you know</strong> instead of <strong>what you DON'T know</strong>.</p>
<p>Refinements being done with colons does come out as what seems like a casualty of that, where you can have something like:</p>
<pre><code>data: copy:part series pos
</code></pre>
<p>It mingles refinements and assignments notationally, which some might find bad.  Though I think it's nothing like mingling field accesses and refinements with both being slashes.</p>
<p>And once you get used to it, I think it actually is nice to have the colons blend more quietly.  This allows the slashes to stand out, and it really is a better use of it popping.</p>
<p>The <strong><code>.field</code></strong> accesses are--I think--a pretty definite win.  I've made it so that the lone period (<strong><code>.</code></strong>) defaults to one of those sneaky functions that looks at the current environment, and gives you the object that the <strong><code>.field</code></strong> accesses are from.  So if you really want to bring all those fields into scope where you can use them undecorated, you'd be able to do something along the lines of:</p>
<pre><code>use &lt;*&gt; .
print ["Now I can access" field "without dots"]
</code></pre>
<p><em>(Though the notation for that is still in flux.)</em></p>
<p>But really, it's very hard to keep things straight and know what's an argument and what's a member... so I <em>like</em> the dots.  (They were added on purpose...and are harder to implement than just doing lookup in the object as a higher priority for regular words, so of course I must like them!)</p>
<h2><a name="p-7921-sowhats-not-working-well-3" class="anchor" href="https://forum.rebol.info#p-7921-sowhats-not-working-well-3"></a>So...What's NOT Working Well?</h2>
<p>One of the biggest problems I've run into is that the easy interplay between WORD! and SET-WORD! and GET-WORD! has been replaced by some really finicky sequence mechanics.</p>
<p>For instance, this no longer works:</p>
<pre><code> &gt;&gt; to word! first [a: 10]
 ** Error
</code></pre>
<p>TO's rule is reversibility.  And <strong><code>(to chain! 'a)</code></strong> shouldn't be biased to either <strong><code>a:</code></strong> or <strong><code>:a</code></strong></p>
<p>Maybe you could argue for saying that <strong><code>a:</code></strong> is more useful, and so TO for sequences should put words at the head.  But that's not really the case for <strong><code>a.</code></strong> or <strong><code>a/</code></strong>, is it?</p>
<p>Then you have composites like <strong><code>/a:</code></strong>, and the question of just how many routines have to deal with these composites... and what the rules are.  If you do a <strong>SET</strong> of plain <strong>a</strong> to an action, should that be an error unless you change it to set <strong>/a</strong> ?  Should SET support <strong>/a:</strong> or make you extract things down?</p>
<p>I've been building little parts to help attack this, such as a function RESOLVE for picking the variable out of a sequence:</p>
<pre><code>&gt;&gt; resolve first [/a:]
== a

&gt;&gt; resolve first [a.b/]
== a.b
</code></pre>
<p>And that's the kind of thing that helps pick up the slack from things like TO WORD!.</p>
<p>It's still new and awkward territory.  There's certainly going to be some amount of irreducible complexity that comes from working with these new parts, but I'm hopeful that I'll be able to reduce the pain as things develop.</p>
<h2><a name="p-7921-overall-things-are-reasonably-strong-4" class="anchor" href="https://forum.rebol.info#p-7921-overall-things-are-reasonably-strong-4"></a>Overall, Things Are Reasonably Strong</h2>
<p>I talk about how Ren-C's development methodology just keeps solidifying, to let it move on to building higher things.</p>
<p>Even with many pieces teetering on the edge, there's still a solidity underneath it all that means I almost never wind up chasing Heisenbugs.  When a part needs to be hardened, it can be hardened.</p>
<p>In any case, it's good to see it bootstrapping after a long time of not.  I'm hopeful that by the end of the year I'll feel comfortable enough to make new bootstrap executables and push out the web build, so expect a big "drop" sometime in December.</p> ]]></description>
        <link>https://forum.rebol.info/t/first-bootstrap-in-at-least-6-months-watershed-changes/2334#post_1</link>
        <pubDate>Thu, 21 Nov 2024 05:08:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7921</guid>
      </item>
      <item>
        <title>Red&#39;s Take on String Interpolation</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>The key is making it very light, and not to break the readability flow.</p>
<p><strong><code>print*</code></strong> might be light enough, with the <code>*</code> warning "I'm doing extra processing on this string" (and "I'm doing implicit environment capture"?)</p>
<pre><code>&gt;&gt; print* "Number is {{num}}"
Number is 10
</code></pre>
<p>There's also <strong><code>print+</code></strong>... a little less noisy, but maybe too much so... the <code>+</code> blends a bit and looks like a T, right against a T.</p>
<pre><code>&gt;&gt; print+ "Number is {{num}}"
Number is 10
</code></pre>
<p>I can empathize that there needs to be <em>something</em> there to clue you into the extra work going on.</p>
<p>It may look nicer--but it is less efficient to have to scan the code every time.  (Though investing on making that scan fast helps the whole system.)</p> ]]></description>
        <link>https://forum.rebol.info/t/reds-take-on-string-interpolation/2121#post_6</link>
        <pubDate>Thu, 21 Nov 2024 01:41:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7920</guid>
      </item>
      <item>
        <title>Red&#39;s Take on String Interpolation</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>On PRINT, I tend towards not doing implicit interpolation there. But it could work quite well as a refinement: <code>print:interpolate "Number is {{num}}"</code>.</p> ]]></description>
        <link>https://forum.rebol.info/t/reds-take-on-string-interpolation/2121#post_5</link>
        <pubDate>Thu, 21 Nov 2024 01:38:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7919</guid>
      </item>
      <item>
        <title>Red&#39;s Take on String Interpolation</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hiiamboris" data-post="3" data-topic="2121">
<div class="title">
<div class="quote-controls"></div>
 hiiamboris:</div>
<blockquote>
<p><em>"Try to look at these expressions and visualize how the resulting string will look like, and if I've got all spaces and quotes right. Not a human task, eh?"</em></p>
</blockquote>
</aside>
<p>I've proposed that COMPOSE be arity-2 and able to interpolate strings, e.g.</p>
<pre><code>&gt;&gt; num: 10

&gt;&gt; print compose ${{}} "Number is {{num}}, so there."
Number is 10, so there.
</code></pre>
<p>Having to say <strong>compose ${{}}</strong> is <em>noisy</em> for day to day use of a common construct like PRINT.</p>
<p>But even this trivial case shows a benefit of being able to put the comma right up against the number if you want to.  That's hard to do, as PRINT typically adds spaces around everything.  So you have to do something like this:</p>
<pre><code>&gt;&gt; print unspaced ["Number is" _ num ", so there."]
Number is 10, so there.
</code></pre>
<p>An experiment interprets BLOCK! in the source as grouping things tightly:</p>
<pre><code>&gt;&gt; print ["Number is" [num ","] "so there."]
Number is 10, so there.
</code></pre>
<p>Still, it's lousy compared to interpolation (see hiiamboris's examples for other ones).</p>
<h2><a name="p-7918-what-if-print-of-a-text-did-sneaky-interpolation-1" class="anchor" href="https://forum.rebol.info#p-7918-what-if-print-of-a-text-did-sneaky-interpolation-1"></a>What If PRINT of a TEXT! did "Sneaky Interpolation"?</h2>
<p>We could make it so that PRINT is one of the sneaky constructs that captures the binding from its callsite, and that it assumes some interpolation delimiter:</p>
<pre><code>&gt;&gt; num: 10

&gt;&gt; print "Number is {{num}}, so there."
Number is 10, so there.
</code></pre>
<p>Then we could say that if you don't want that, you can put the string in a block:</p>
<pre><code>&gt;&gt; print ["When using a block, {{...}} would not interpolate."]
When using a block, {{...}} would not interpolate.
</code></pre>
<p>There's another option to pass PRINT an <code>@var</code>, and if you did then that would suppress interpolation as well.</p>
<pre><code>&gt;&gt; str: "Number is {{num}}, so there."

&gt;&gt; print str
Number is 10, so there.

&gt;&gt; print [str]
Number is {{num}}, so there.

&gt;&gt; print @str
Number is {{num}}, so there.
</code></pre>
<h2><a name="p-7918-it-could-be-an-option-2" class="anchor" href="https://forum.rebol.info#p-7918-it-could-be-an-option-2"></a>It Could Be An Option</h2>
<p>There could be some way of turning this behavior on or off, and specifying what the delimiters are.</p>
<p>Maybe the default PRINT wouldn't have it, but you could say:</p>
<pre><code>/print: make-sneaky-print '(())  ; note unbound, since it captures binding
</code></pre>
<p>It's a little bit of a relearning of habits to know that plain <strong>print str</strong> would have this extra processing overhead.  But, I think it is learnable, and I'd definitely use it.</p>
<h2><a name="p-7918-other-options-brief-operators-other-names-3" class="anchor" href="https://forum.rebol.info#p-7918-other-options-brief-operators-other-names-3"></a>Other Options: Brief Operators, Other Names</h2>
<p>This could be a different word like <strong><code>echo</code></strong> or <strong><code>say</code></strong> or something like that, though I'm not crazy about either of those.</p>
<p>It could also be an operator you could make arbitrarily brief:</p>
<pre><code>print op "Number is {{num}}, so there."
</code></pre>
<p>But I don't know there's anything on the <a href="https://forum.rebol.info/t/tapping-the-untapped-potential-of-short-words/395">list of short words</a> that would make the cut.</p>
<p>It could be the result of some decoration:</p>
<pre><code>print @["Number is {{num}}, so there."]
</code></pre>
<p>But that's not what that is intended to mean.</p>
<p>It could be done with a different string type:</p>
<pre><code>print %"Number is {{num}}, so there."

print &lt;Number is {{num}}, so there.&gt;
</code></pre>
<p>The TAG! doesn't seem completely crazy, though I have other ideas for what TAG! means in PRINT as a formatting instruction.</p>
<p>It seems to me that giving the power to a plain PRINT is the most useful.</p>
<h2><a name="p-7918-most-likely-alternative-sneaky-compose-4" class="anchor" href="https://forum.rebol.info#p-7918-most-likely-alternative-sneaky-compose-4"></a>Most Likely Alternative: Sneaky COMPOSE</h2>
<p>I've debated if COMPOSE should use sneaky binding, and maybe it should.</p>
<p>Maybe its default should be <strong>{{...}}</strong> as well, and just make that out of band, as something that doesn't get other meaning in the system.</p>
<pre><code>&gt;&gt; compose '[(1 + 2) {{3 + 4}} {5 + 6}]
== [(1 + 2) 7 {5 + 6}]

print compose "Number is {{num}}, so there."

print compose:with $() "Number is (num), so there."
</code></pre>
<p>Or maybe the default should stay at <code>(...)</code> for the natural brevity:</p>
<pre><code>&gt;&gt; compose '[(1 + 2) {{3 + 4}} {5 + 6}]
== [3 {{3 + 4}} {5 + 6}]

print compose "Number is (num), so there."

print compose:with ${{}} "Number is {{num}}, so there."
</code></pre>
<p>It's just that parentheses seem so common in code and text that you'd often be pushing them out of the way.</p>
<p><em>I still feel like having it built into PRINT is a sort of convenience that it's hard to like any extra word in there, even just COMPOSE.</em>  And if it's built-in, then {{...}} seems better than (...)</p> ]]></description>
        <link>https://forum.rebol.info/t/reds-take-on-string-interpolation/2121#post_4</link>
        <pubDate>Wed, 20 Nov 2024 20:17:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7918</guid>
      </item>
      <item>
        <title>Design for IMPORT</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I like the idea of separating USE and IMPORT like that. It feels like a very clean design to me.</p>
<p>As for ‘opt all in’, I like the syntax <code>use &lt;*&gt; object</code> or <code>use # object</code>. I don’t feel like a specialisation or refinement is necessary. There’s probably further dialecting possibilities for the first argument of USE, if we just think about what people would want to do.</p> ]]></description>
        <link>https://forum.rebol.info/t/design-for-import/1570#post_5</link>
        <pubDate>Wed, 20 Nov 2024 05:32:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7917</guid>
      </item>
      <item>
        <title>Value (vs. Series) Modification Bit: CONST and MUTABLE</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>The const feature was implemented via CELL_FLAG_CONST, a bit that a cell could have set (or not) in its header.</p>
<p>But there was a second bit... called CELL_FLAG_EXPLICITLY_MUTABLE.</p>
<p>This bit protected a block from the "wave of constness".</p>
<p>It was necessitated by some behaviors that I ultimately deemed to be bugs.  Now that those bugs are gone, it's no longer mandatory to have it.</p>
<p>So I took it out, but found it broke a test:</p>
<pre><code>block: mutable [a b c]
eval compose:deep $() [repeat 2 [append (block) &lt;legal&gt;]]
assert [block = [&lt;legal&gt; &lt;legal&gt;]]
</code></pre>
<p>So previously, that mutable would put the CELL_FLAG_EXPLICITLY_MUTABLE bit on.  Then, when the COMPOSE ran, you'd get:</p>
<pre><code> eval [repeat 2 [append [a b c] &lt;legal&gt;]]
</code></pre>
<p>Because REPEAT is iterative, it applies CONST to its body.  And that CONST would get applied to the <code>[a b c]</code>...but, CELL_FLAG_EXPLICITLY_MUTABLE overruled it.</p>
<h2><a name="p-7916-but-i-dont-like-cell_flag_explicitly_mutable-1" class="anchor" href="https://forum.rebol.info#p-7916-but-i-dont-like-cell_flag_explicitly_mutable-1"></a>But I Don't Like CELL_FLAG_EXPLICITLY_MUTABLE</h2>
<p>There are other ways to get past the const wave, such as quoting it:</p>
<pre><code>block: [a b c]
eval compose:deep $() [repeat 2 [append '(block) &lt;legal&gt;]]
</code></pre>
<p>Or you could do <strong>append mutable</strong>:</p>
<pre><code>block: [a b c]
eval compose:deep $() [repeat 2 [append mutable (block) &lt;legal&gt;]]
</code></pre>
<p>Admittedly, these require you to have some control of the code the block is being fed into, vs. being able to put a "magic bit" on the block to counteract the const wave.</p>
<p>But the semantics of this magic bit are nebulous.  I would not have added such a thing if it wasn't for working around the things I decided were bugs.  It's not clear when (if ever) it should stop protecting the value, and that just opens a can of worms.</p>
<p>Cell flags are a pretty scarce resource, and giving one up for something that makes the code harder to understand than a simple CONST bit that's on or off is not a good investment.</p> ]]></description>
        <link>https://forum.rebol.info/t/value-vs-series-modification-bit-const-and-mutable/976#post_6</link>
        <pubDate>Wed, 20 Nov 2024 04:12:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7916</guid>
      </item>
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>So I went ahead and did the transition to arity-2 COMPOSE, so I could see the effects.</p>
<p>Since bootstrap needs to still work, I needed to have a name for the arity-1 version, and I called it <strong><code>compose1</code></strong>  <em>Which actually isn't a terrible name for the arity-1 version.</em>  Maybe <strong><code>compose-1</code></strong> would separate the <strong>e</strong> and the <strong>1</strong> a little better, but it also adds noise.</p>
<p>There's also the possibility of <strong><code>compose*</code></strong>, though adding a star usually means "lower level version".  But more generally it could be argued that it's a "special version".</p>
<p>What its doing is actually:</p>
<pre><code>compose1 list
=&gt;
compose (inside list '()) list
</code></pre>
<p>So maybe calling it <strong><code>compose-inside</code></strong> would be more informative, but that wouldn't tell you that you were using groups, so it's <strong><code>compose-groups-inside</code></strong>...</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Stealing the binding from the tip of the block you're composing and using that in the slots is a kind of "weird backchannel". If that's what you're doing, <em>you're the weird one</em>, so maybe your code should reflect that.</p>
</blockquote>
</aside>
<p>Well, when I put it that way, <strong><code>COMPOSE*</code></strong> might be good for this.</p>
<p>Anyway, I think the competition is between calling it <strong><code>COMPOSE*</code></strong> or <strong><code>COMPOSE1</code></strong></p>
<p>If we had <a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">CHAIN! dialecting</a>, it might permit:</p>
<pre><code>&gt;&gt; compose [a (1 + 2) b]
== [a 3 b]

&gt;&gt; compose:${{}} [(a) {{1 + 2}} {b}]
== [(a) 3 {b}]
</code></pre>
<p>But that feature is very speculative, and binding issues may make it non-feasible.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="5" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But, It Would Drive The "Noise" Level Higher...</p>
<p>Some (like <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>) do not like symbols in code at all.</p>
<p>Having COMPOSE frequently instantiated as <strong><code>compose $() [...]</code></strong> would be a thorn. (Though as I've stated, I think you really should be doing <strong><code>compose $() '[...]</code></strong> much more than one would think).</p>
</blockquote>
</aside>
<p><strong>This is a pretty tough call, but I think I'm on the side of saying that COMPOSE should be arity-2.</strong></p>
<p>Beyond the necessity of providing a binding environment when you want to apply COMPOSE to strings, I'm seeing too many places where an arity-1 COMPOSE <em>can't</em> do what you want.</p>
<p>I also feel like taking away the assumption of COMPOSE being groups is good--it's not groups, it's the pattern you choose.  I like <strong><code>{{...}}</code></strong> because at least now, that has no meaning and stands out a lot better.</p>
<p><strong>The harsh reality is that to really make things work... binding has to be thrust into the awareness of those who are building and composing code.</strong></p>
<p>Being able to evaluate templated code groups (or blocks, or fences...) in an environment that is different than the environment of the surrounding code is not something that has been easy before.</p>
<p>But I think it's foundational--and as I've said, the most common surrounding context is likely <em>no</em> context... with the intention of inheriting the meaning from wherever you are putting the composed code.</p> ]]></description>
        <link>https://forum.rebol.info/t/envelop-and-compose-by-example/2294#post_6</link>
        <pubDate>Wed, 20 Nov 2024 00:32:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7915</guid>
      </item>
      <item>
        <title>hiiamboris&#39;s WITH</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2138">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">with x  [..]          == bind [..] x
with 'x [..]          == bind [..] 'x
with :fun [..]        == bind [..] :fun
with [:fun] [..]      == bind [..] :fun
with [x y 'z] [..]    == bind bind bind [..] 'z y x
with [x: 1 y: 2] [..] == bind [..] context [x: 1 y: 2]
</code></pre>
</blockquote>
</aside>
<p>So I was wondering in the design of the WITH-like BIND what plain words should do, as opposed to <code>@word</code>.</p>
<p>One concept I had was that with plain words, BIND could serve the role of "old USE" and create new bindings.  Then, an <code>@word</code> would mean that you wanted to bind to that particular word.</p>
<pre><code>x: 10
y: 20
eval bind [@x y] [
   x: 100  ; overwrites X
   y: 200  ; would not overwrite as plain Y word made new variable
]
</code></pre>
<p>That would be making a distinction between words and <code>@word</code> that lines up with how FOR-EACH and others treat variables.  It was chosen over <code>$word</code> due to the ability to pass the variable reference without a block:</p>
<pre><code>iterate @var [...]   ; the @ sticks, but $var makes a plain bound word
</code></pre>
<p>But BIND has a competing intent, which is when you want to bind to the thing the word points to.</p>
<pre><code>foo: make object! [x: 10 y: 20]
bar: make object! [z: 30]

eval bind [@foo @bar] [  ; alternative intent of @
   assert [all [x = 10, y = 20]]
   assert [z = 30]
]
</code></pre>
<p>This is more like the PARSE meaning of @ which means "dereference this word".</p>
<p>Another way of doing that could be GROUP! evaluations:</p>
<pre><code>eval bind [(foo) (bar)] [
   assert [all [x = 10, y = 20]]
   assert [z = 30]
]
</code></pre>
<p>It's worth pointing out that making new variables with BIND can be done easily another way, with FENCE!, so we could say:</p>
<pre><code>x: 10
y: 20
eval bind [x {y: ~}] [  ; instead of [@x y]
   x: 100  ; overwrites X
   y: 200  ; would not overwrite as {Y: ~} made new variable
]
</code></pre>
<p>And I think giving a value to a new variable is probably more common than not wanting to, anyway.</p>
<p>That frees up the <code>@foo</code> to mean "what I intend to bind to is what you get by dereferencing this" intent.</p>
<p>So binding a single word means bind using the binding of that word.</p>
<pre><code>block: [print ["The value of x is:" x]]

foo: func [x] [
    eval bind $x block
    eval bind [x] block
]

foo 10  ; would print the message with x as 10
</code></pre>
<p><strong>I can't necessarily prove it offhand, but I feel like having <code>bind [@x y]</code> mean something parallel to <code>for-each [@x y]</code> would be beneficial.</strong></p>
<p>That would indicate producing a new variable for Y, and reusing a binding for X.</p>
<p>This makes BIND able to function easily as a "LET that takes a block"</p>
<pre><code>let x
x: 10

bind 'x [x: 10]
</code></pre>
<p>Something about pushing on these symmetries seems more important than giving you a way to dereference variables to implicate the objects they point to, that's briefer than a GROUP!.</p>
<p>(Honestly, multiple binds are probably not that common, and in fact you wouldn't get a lot of benefit out of it by saying <strong><code>bind [(obj1) (obj2)] ...</code></strong> as opposed to <strong><code>bind obj1 bind obj2 ...</code></strong>)</p>
<h2><a name="p-7914-the-binding-dialect-likely-needs-more-features-1" class="anchor" href="https://forum.rebol.info#p-7914-the-binding-dialect-likely-needs-more-features-1"></a>The Binding Dialect Likely Needs More Features</h2>
<p>This is sort of the tip of the iceberg in "meanings you might have for binding requests".  So <strong></strong> could be another way of saying you should dereference, as part of a broader idea of TAG!-instructions:</p>
<pre><code>foo: make object! [x: 10 y: 20]
bar: make object! [z: 30]

eval bind [&lt;in&gt; foo &lt;in&gt; bar] [
   assert [all [x = 10, y = 20]]
   assert [z = 30]
]
</code></pre>
<p>So really we're talking about the needs of the most common form.</p>
<h2><a name="p-7914-althoughignoring-the-binding-is-annoying-2" class="anchor" href="https://forum.rebol.info#p-7914-althoughignoring-the-binding-is-annoying-2"></a>Although...Ignoring The Binding Is Annoying</h2>
<p>This has some consequence, for instance this would have the binding ignored and make a new variable:</p>
<pre><code> eval bind (bind obj 'x) code
</code></pre>
<p>While this would use the binding:</p>
<pre><code> eval bind (bind obj '@x) code
</code></pre>
<p>That would be true of FOR-EACH as well.</p>
<p>It does point out that if you want to bind to a single object's field and not all of it, then it would be helpful to have a notation for that.</p>
<pre><code>eval bind [@obj.x] code
</code></pre>
<p>This could suggest that maybe undecorated means "evaluate this", such that these would be equivalent:</p>
<pre><code> bind foo [...]
 bind [foo] [...]
</code></pre>
<p>As opposed to the FOR-EACH equivalency, which would be:</p>
<pre><code> bind 'foo [...]
 bind [foo] [...]
</code></pre>
<p>I don't know.  <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20">  I guess I'll just have to try things and see what's most useful.</p> ]]></description>
        <link>https://forum.rebol.info/t/hiiamboriss-with/2138#post_3</link>
        <pubDate>Mon, 18 Nov 2024 21:29:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7914</guid>
      </item>
      <item>
        <title>Design for IMPORT</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1570">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We could make an IMPORT that can tell when you've assigned it:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">zip-stuff: import &lt;ZipModule&gt;
</code></pre>
<p>Such a form could then avoid consuming a BLOCK! after it naming individual things to export, since you have named an aggregator:</p>
<p><code>import &lt;ZipModule&gt; [zip unzip]</code></p>
</blockquote>
</aside>
<p>So the idea of a construct that behaves differently based on whether there's something to its left <a href="https://forum.rebol.info/t/skip-able-arguments-2024-update-removed/1013">was lost when <code>&lt;skip&gt;</code>-able parameters were killed off</a>.</p>
<p>This means today when you write something like:</p>
<pre><code>vm: import %ws-runtime.reb
</code></pre>
<p>...you do get the module that was imported in the <strong>vm:</strong> variable, but it also brings all the exports into the local space as words, too.  It had no detection to tell it not to.</p>
<p>I'll re-emphasize that modern languages are stressing the idea that you <em>have</em> to namespace things in this way.</p>
<p>If you want to bring all of those exports into "scope", that could be done with the USE meaning I've been suggesting:</p>
<pre><code>use import %ws-runtime.reb
</code></pre>
<p>But that's kind of an all-or-nothing, where you'd imagine wanting to be able to name just some things to use:</p>
<pre><code>use:some [foo bar] import %ws-runtime.reb
</code></pre>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1570">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think the first lines of the file need to be as good as they can.</p>
</blockquote>
</aside>
<p>Something like <strong><code>use:some [foo bar] import</code></strong> seems to drift a bit from that.</p>
<p>Losing the detection-of-assignment-on-left does set this back a bit...and isn't something I realized was going away when <strong><code>&lt;skip&gt;</code></strong> was tossed.  But there were good reasons for killing that off, and those good reasons don't go away just because it helped one usage.</p>
<p>Making USE arity-2 could avoid the <strong><code>use:some</code></strong>, to be more like:</p>
<pre><code>use &lt;*&gt; import %ws-runtime.reb
use [foo bar] import %ws-runtime.reb
vm: import %ws-runtime.reb
</code></pre>
<p>What to say for "opt all in" could be something else, maybe <strong>#</strong>.  Or maybe it would look nicer as a specialization?</p>
<pre><code>use # import %ws-runtime.reb
use-all import %ws-runtime.reb
</code></pre>
<p>I dunno.  Anyway, the generic USE construct would be something you could apply to any object, to bring its definitions into "scope" for word lookup.</p>
<p>It's probably better to go this direction than have IMPORT use a <strong><code>&lt;skip&gt;</code></strong> parameter.</p>
<p>Anyway, the design grind goes on.</p> ]]></description>
        <link>https://forum.rebol.info/t/design-for-import/1570#post_4</link>
        <pubDate>Mon, 18 Nov 2024 20:06:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7913</guid>
      </item>
      <item>
        <title>ENVELOP (and COMPOSE!) By Example</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2294">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Let's bring back an old term...and call it COMBINE.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; code: combine $() '[x + (var)]
== [x + y]  ; worked even though we passed in an unbound block!

&gt;&gt; eval compose [let x: 10 let y: 20 (as group! code)]
== 30
</code></pre>
<p>...Old COMPOSE Is Still Useful Day-To-Day</p>
<p>It's useful enough to keep its name, and do what it does. It works out a lot of the time.</p>
</blockquote>
</aside>
<p>So I've been stressing over the mental overhead of having two constructs, instead of just one.</p>
<h2><a name="p-7912-one-big-advantage-of-arity-2-compose-1" class="anchor" href="https://forum.rebol.info#p-7912-one-big-advantage-of-arity-2-compose-1"></a>One Big Advantage of ARITY-2 COMPOSE</h2>
<p>It's hard to think of a name for string interpolation, and expanding the scope of COMPOSE's powers seems like it would be a fit.</p>
<p>But that would <em>always</em> need you to give some capture of context as a parameter.</p>
<pre><code> &gt;&gt; compose $() "Strings (pick [do don't] 2) have binding"
 == "Strings don't have binding"
</code></pre>
<h2><a name="p-7912-composing-unbound-material-should-be-common-2" class="anchor" href="https://forum.rebol.info#p-7912-composing-unbound-material-should-be-common-2"></a>Composing Unbound Material Should Be Common</h2>
<p>In the modern binding model, unbound code is very much the default currency.</p>
<p>Many COMPOSEs should probably be making unbound material, and just aren't.  While we're getting away with not doing it, I think that's kind of accidental (and increasingly I've been running into problems where bound compose results are messing things up).</p>
<h2><a name="p-7912-would-stress-that-you-have-a-choice-3" class="anchor" href="https://forum.rebol.info#p-7912-would-stress-that-you-have-a-choice-3"></a>Would Stress That You Have a Choice</h2>
<p>If parentheses aren't the best choice for your situation, you can pick something else.</p>
<pre><code>&gt;&gt; compose ${{}} [{a} (b) [c] {{first [&lt;d&gt; #Z]}} {e}]
== [{a} (b) [c] &lt;d&gt; {e}]
</code></pre>
<h2><a name="p-7912-a-refinement-would-be-wordy-4" class="anchor" href="https://forum.rebol.info#p-7912-a-refinement-would-be-wordy-4"></a>A Refinement Would Be Wordy</h2>
<p>I'm questioning trying to differentiate the operations with a name difference (COMBINE vs. COMPOSE).  That's confusing.</p>
<p>A refinement makes more sense.  But even in the ideal case (where refinements are moved to the head) we'd have:</p>
<pre><code>compose:with $() [...]
</code></pre>
<p>And I don't know that ":WITH" is the best name, it acts as if it's adding something vs. overriding a default.  More honestly it would be:</p>
<pre><code>compose:pattern $() [...]
</code></pre>
<h2><a name="p-7912-weird-semantics-5" class="anchor" href="https://forum.rebol.info#p-7912-weird-semantics-5"></a>Weird Semantics...</h2>
<p>The behavior of stealing the binding from the block means that understanding COMPOSE as a specialization with $() is wrong.</p>
<p>Stealing the binding from the tip of the block you're composing and using that in the slots is a kind of "weird backchannel".  If that's what you're doing, <em>you're the weird one</em>, so maybe your code should reflect that.</p>
<h1><a name="p-7912-but-it-would-drive-the-noise-level-higher-6" class="anchor" href="https://forum.rebol.info#p-7912-but-it-would-drive-the-noise-level-higher-6"></a>But, It Would Drive The "Noise" Level Higher</h1>
<p>Some (like <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>) do not like symbols in code at all.</p>
<p>Having COMPOSE frequently instantiated as <strong><code>compose $() [...]</code></strong>  would be a thorn.  (Though as I've stated, I think you really should be doing <strong><code>compose $() '[...]</code></strong> much more than one would think).</p>
<p>And it is unfortunate that you need the $ to get the binding and suppress evaluation, plus you might think that would act on the pattern <strong><code>[... $(...) ...]</code></strong></p>
<p>But the game here is getting correctness.  And it seems to me that if you give people a powerful fundamental, they can adapt and specialize it to do whatever they want, under any name they want.</p>
<h2><a name="p-7912-should-sneaky-capture-be-the-default-7" class="anchor" href="https://forum.rebol.info#p-7912-should-sneaky-capture-be-the-default-7"></a>Should "Sneaky" Capture Be The Default?</h2>
<p>For COMPOSE to work with strings it either needs to take a pattern parameter, or be one of the sneaky constructs that uses the current context by default.</p>
<p>If it shifted to the "sneaky" behavior, then it would be more useful on unbound blocks:</p>
<pre><code>&gt;&gt; x: 10, compose '[a b (x + 1) c d]
== [a b 11 c d]

&gt;&gt; x: 10, compose "a b (x + 1) c d"
== [a b 11 c d]
</code></pre>
<p>But if you move code that says <strong><code>compose block</code></strong> from point A to point B, then you will be changing what it uses for its scope.  The same would be true of moving <strong><code>compose $() block</code></strong>, but at least there you can see the capturing construct... the <strong><code>$()</code></strong> should (?) call your attention to it.</p>
<hr>
<h1><a name="p-7912-i-think-my-biases-lead-me-to-arity-2-8" class="anchor" href="https://forum.rebol.info#p-7912-i-think-my-biases-lead-me-to-arity-2-8"></a>I Think My Biases Lead Me To Arity-2</h1>
<p>Looking at all the angles here, I just don't think it's that much of an imposition to pass the pattern.  And you live in a murky binding world if you don't.</p>
<p>If you are writing enough code where the <strong><code>compose $() [...]</code></strong> pattern is frequent enough to get on your nerves, then there are probably other ways you can attack that repetition that are even larger scale than just specializing that bit out.</p> ]]></description>
        <link>https://forum.rebol.info/t/envelop-and-compose-by-example/2294#post_5</link>
        <pubDate>Mon, 18 Nov 2024 19:16:30 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7912</guid>
      </item>
      <item>
        <title>Breaking MAKE OBJECT! Into Component Operations</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1442">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Since changing MAKE OBJECT! would be too far-reaching a change at the moment, I've retaken CONSTRUCT for this shallower version:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; x: 10
&gt;&gt; obj: construct [x: x * 2, f: func [] [print ["x is" x "and .x is" .x]]]
== make object! [
    x: 20
    f: ~#[frame! []]~
]

&gt;&gt; obj.f
x is 10 and .x is 20
</code></pre>
</blockquote>
</aside>
<p>I've had some success deploying this <strong><code>.word</code></strong> as member idea, with a shallow object creation... and it seems like the right fit for many cases--enough so that I think it should be the "default" for what we would traditionally think of as the creation of traditional "objects" and "classes".</p>
<p>But as expected, there are cases that don't fit.  For instance, in the bootstrap process, the configuration files make objects that are a bit more like modules:</p>
<pre><code>REBOL [Title: "Filesystem configuration file"]

name: 'Filesystem
source: %filesystem/mod-filesystem.c

os: platform-config.name
if os = 'Windows [  ; means OS as it was just defined...
    ...
]
</code></pre>
<p>This looks module-like, but it's done with objects (in particular because the bootstrap executable doesn't do modules correctly).  And additionally, it inherits from a base object.</p>
<p>So when I talk about the "component" operations, we have to consider:</p>
<ol>
<li>
<p>What kind of thing are we making (OBJECT!, MODULE!, ERROR!, ...)</p>
</li>
<li>
<p>Is there a parent to inherit from?  (if so, we presume this answers 1, which is why MAKE doesn't need to know the type if you pass an instance instead... you can't MAKE ERROR! from a parent that's a MODULE!)</p>
</li>
<li>
<p>Do you want the definitions of the object fields being defined to be visible to the code that's assigning those fields, or do you want the existing bindings to be visible?</p>
</li>
</ol>
<p>With the CONSTRUCT I mention above, that gives you an OBJECT! with no parent...and the fields of the object are not visible to the code doing the assigning.  (I propose this as the default behavior for FENCE!.)</p>
<p>I added a CONSTRUCT:WITH to pass in a parent, so you could add a parent...<a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">though it would be better if that argument came first</a></p>
<pre><code>construct:with [
    something: ...
    ...
] parent
</code></pre>
<p>vs.</p>
<pre><code>construct:with parent [
    something: ...
    ...
]
</code></pre>
<p>I could just go ahead and make it arity-2, though I'm not thrilled by it.</p>
<pre><code>construct object! [...]  ; shallow version, no parent
construct parent [...]  ; shallow version, parent

make object! [...]   ; inside version, no parent
make parent [...]   ; inside version, parent
</code></pre>
<h2><a name="p-7911-why-would-make-vs-construct-be-inside-binding-1" class="anchor" href="https://forum.rebol.info#p-7911-why-would-make-vs-construct-be-inside-binding-1"></a>Why would MAKE vs. CONSTRUCT Be "Inside Binding"?</h2>
<p>Outside of the inertia of history, I don't know how much sense this makes.  It could be <strong><code>construct:inside</code></strong> vs. plain <strong><code>construct</code></strong>.  :-/</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; construct [x: 20, y: x + 100]
== #{x: 20 y: 110}

&gt;&gt; x: 10
&gt;&gt; construct:inside [x: 20, y: x + 100]
== #{x: 20 y: 120}
</code></pre>
<p>The inside version being implemented by <strong><code>wrap:context</code></strong> was one idea I had:</p>
<pre><code>&gt;&gt; x: 10
&gt;&gt; wrap:context [x: 20, y: x + 100]
== #{x: 20 y: 120}
</code></pre>
<p>What this has going for it:</p>
<ul>
<li>
<p>"WRAP" really does sound like it's enclosing the code in a context</p>
</li>
<li>
<p>It aligns with what WRAP does to a BLOCK! normally... this would just say "make me a context out of that, vs. giving a block".</p>
</li>
</ul>
<p>But then you have the other parameterization points... MODULE! vs. OBJECT! etc., and whether you want to inherit or not.</p>
<p><strong>There's simply a lot of parameters here.</strong>  Anyway, there's a lot of new mechanics that need to settle out while contemplating this, just wanted to write that down.</p> ]]></description>
        <link>https://forum.rebol.info/t/breaking-make-object-into-component-operations/1442#post_5</link>
        <pubDate>Mon, 18 Nov 2024 02:14:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7911</guid>
      </item>
      <item>
        <title>.WORD as Member Selection</title>
        <dc:creator><![CDATA[@hostilefork Brian Dickens]]></dc:creator>
        <description><![CDATA[ <p>One little edge case on this, is whether to distinguish calling a member function from referencing a member variable.</p>
<pre><code>obj: {
    x: 10
    /foo: method [y] [return .x + y]
    /bar: method [z] [return .foo z]
}
</code></pre>
<p>It's unfortunate in my view that this isn't expressed as:</p>
<pre><code>/bar: method [z] [return /foo z]
</code></pre>
<p>The idea of "left hand side is implicit" that you get from <strong><code>.x</code></strong> for a non-method selection would be complemented nicely by <strong><code>/foo</code></strong> for a "left hand side is implicit" member.</p>
<p>Instead, what we get is that we've spent a character on a dot, and yet stayed in the domain of vagueness that a plain WORD! has in terms of whether it's a function call or not.</p>
<p>But staying in that domain of vagueness seems the best choice. I've found it too compelling to say:</p>
<pre><code>/foo: blah blah
</code></pre>
<p>And know from that source that FOO is an action antiform, with it not implying it's the member of any object.</p>
<p>So this means if you really want to clarify that you're calling a member function, you'd have to write the relatively ugly:</p>
<pre><code>/bar: method [z] [return /.foo z]
</code></pre>
<p>Ick.  <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=12" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<p>Well, for whatever it's worth... I haven't gotten the urge to go around sticking leading slashes on function calls on WORD! just for clarity's sake.  I only use it where it has meaning (e.g. PARSE to differentiate combinator invocation vs. plain function invocation with combinator-synthesized arguments).  This just feels a little different because it feels like it's a stand in for <strong><code>this.foo</code></strong>, which would error if foo was an action.</p>
<p>But sometimes when you're lining up puzzle pieces you hit these edges, and have to say "it's different when there's nothing to the left".  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p> ]]></description>
        <link>https://forum.rebol.info/t/word-as-member-selection/1843#post_4</link>
        <pubDate>Sun, 17 Nov 2024 17:05:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7910</guid>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>Reviving the Rebmu Dialect</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>One small step for a fork, one giant leap for a Rebmu...</p>
<p><strong><a href="https://github.com/hostilefork/rebmu/runs/5486704767?check_suite_focus=true#step:5:1">The roman numeral example (roman.rebmu) is now running on GitHub CI against the current Ren-C.</a></strong></p>
<p>Minus getting the input string into S, right now the converter looks like:</p>
<blockquote>
<p><code>J K 0 feCs[Nse[I01V05X10L50C100D500M1000]twCinzJ[a+KeiL?jN[sbNjEL N00]j]Jn]adKj</code></p>
</blockquote>
<p>The input routine hit a snag, because what used to be <strong>rS</strong> would translate to <strong>readin-mu s</strong>, where it would quote the argument and read based on its type.  And S started out as a string.</p>
<p>For reasons maybe good or bad, I dropped all the preloaded single-character values (like S starting as an empty string and B as empty block) because I thought that was a cheap trick.  It was only chopping off a tiny constant factor...and wasn't really teaching anything about the language.  Will have to rethink that.</p>
<p>In any case, I created the <a href="https://forum.rebol.info/c/domains/rebmu/56">Rebmu forum category</a> to discuss points as they come up.</p>
<h2>Priorities?</h2>
<p>Making the roman numeral converter work was the first order of business.  And I think I'd like to kind of keep going on getting <a href="https://github.com/hostilefork/rebmu/tree/master/examples">the example programs</a> working and tested before getting too involved in trying to rewrite any of the "engine".</p>
<p>Rebmu introduces some new challenges to the fledgling module system, with "sea of words" and "isolation" all being usermode concepts.  As well as how much might the interpreter recognize alternative headers?  Should a Rebmu file end in <strong>.reb</strong> or <strong>.rebmu</strong> or <strong>.rebmu.reb</strong>... and whether the header should say <strong>Rebol [Type: Rebmu]</strong> or <strong>Rebmu [...]</strong> and have that registered somewhere.</p>
<p>So there's no small amount of work here.  As usual, I'm not throwing softballs.  I'll post issues as they come up.</p> ]]></description>
        <link>https://forum.rebol.info/t/reviving-the-rebmu-dialect/1377/4</link>
        <pubDate>Wed, 09 Mar 2022 21:19:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5793</guid>
      </item>
      <item>
        <title>Kaj Gets on the Meta Train</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I looked to see if there were any updates on Kaj's Meta project, and it looks like he is kind of focusing on porting existing Atari 2600 demos written in assembly to the language.</p>
<p>There the usual debate on the Atari forum of people talking about why languages succeed or not, asking and trying to get at why anyone would care about Rebol, expressing skepticism that Kaj will strike gold...but he says it's successful even if he just uses it and it gives him a "competitive edge".</p>
<p>If you're interested you can read the threads:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <a href="https://atariage.com/forums/topic/326694-meta-language-released/" target="_blank" rel="noopener">AtariAge Forums</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:123/93;"><img src="https://atariage.com/forums/uploads/monthly_2021_11/MortalCoil.png.b6702cc80f0f198707eede8eae92e82f.png" class="thumbnail" width="123" height="93"></div>

<h3><a href="https://atariage.com/forums/topic/326694-meta-language-released/" target="_blank" rel="noopener">Meta language released</a></h3>

<p>Introduction thread here: I am starting a new thread, because Meta has a new website: https://language.metaproject.frl The old links from the early development period are gone, and a few of the method names in the program examples have changed. I...</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>One thing I noticed is that he has chosen to go with <strong>FIRST-OF</strong> instead of just <strong>FIRST</strong>.  I've questioned this before, because things like NEXT and FIRST are useful variable names.  In Ren-C there would be presumably no hyphen, so you could write:</p>
<pre><code>first: first of block
</code></pre>
<p>Similar to how you can today say:</p>
<pre><code>type: type of block
</code></pre>
<p>This is because OF quotes its left argument, with the idea that this is learnable.</p>
<p>You could of course still say:</p>
<pre><code>first: specialize :of [property: 'first]
</code></pre>
<p>Which is actually how it works today.</p> ]]></description>
        <link>https://forum.rebol.info/t/kaj-gets-on-the-meta-train/1753/3</link>
        <pubDate>Wed, 09 Mar 2022 06:00:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5792</guid>
      </item>
      <item>
        <title>Rebmu History Removed from File (is History: a good idea?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>When I started Rebmu I followed along the pattern of having seen people put <strong><code>History:</code></strong> in the headers of files.  And as it got longer, I kind of questioned the value of it.</p>
<p>I'm not sure what the "best practices" for history is, but it's a lot of stuff to skip over when you're trying to get to the meat of a file.  It warrants its own discussion topic (which I guess can be discussed here, with the extracted history).</p>
<pre><code>History: [
    0.1.0 [10-Jan-2010 {Sketchy prototype written to cover only the
    Roman Numeral example I worked through when coming up with the
    idea.  So very incomplete, more a proof of concept.}]

    0.2.0 [22-Jun-2010 {Language more complete, includes examples.
    Ditched concept of mushing symbols like + and - into single
    character operators is removed due to realization that A+
    B+ C+ etc. are more valuable in the symbol space than one
    character for AD.}]

    0.3.0 [24-Jun-2010 {Made backwards compatible with Rebol 2.
    Note that things like CN for continue or PERCENTAGE! datatype
    were added in Rebol 3.  You can use these in your Rebmu programs
    but they will only work if using Rebmu with an r3 interpreter.
    Also did several name tweaks like instead of AA for AND~ it's
    now A~ along with other consistencies.}]

    0.5.0 [16-Feb-2014 {Version bump to indicate growing maturity
    of the language.  Abandon Rebol 2 support.  Rebmu files now
    have proper Rebol ecology headers.}]

    0.6.0 [6-Apr-2014 {Large cleanup creating incompatibility with
    most all previous Rebmu code solutions.  Examples have been updated
    in GitHub.  Major theme was removing the custom IF/UNLESS/EITHER
    implementation and some clearer names.}]

    0.7.0 [15-Sep-2015 {Project revisited to incorporate new ideas and
    decisions from the Ren/C effort.  Incorporates the rebol-proposals
    module to work with experimental language features instead of
    having its own "incubator" project.  "Mu library" features removed
    in favor of embracing the language default more closely.}]
]</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/rebmu-history-removed-from-file-is-history-a-good-idea/1798/1</link>
        <pubDate>Mon, 07 Mar 2022 08:22:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5791</guid>
      </item>
      <item>
        <title>Symbols and Mushing in Rebmu</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>There are symbols like &amp; and | which were applied somewhat haphazardly in the original Rebmu, as experiments.</p>
<p>For instance, <strong>&amp;</strong> was a shortcut for DOES.</p>
<pre><code>phi: does [print "hi"]
=&gt;
PHI &amp;[print "hi"]
</code></pre>
<p>(There've been murmurs of other uses for &amp;, but no hard decisions on it yet...and even if it were used for HTML characters like <strong>&amp;nbsp</strong>, it might remain free standalone as a symbol.)</p>
<p>For a time, <strong>|</strong> in Ren-C was not something you could redefine as a WORD!, it was its own datatype "BAR!".  But that has been replaced by the successful COMMA!, retaking it as a word.  It was used in function definition, and some of the contractions I've suggested as things like <strong><code>fqC[...]</code></strong> =&gt; <strong>function [a b c] [...]</strong> were contracted as simply <strong><code>c|[...]</code></strong></p>
<p>There was a handling of dots which allowed a quick way of doing redefinitions:</p>
<pre><code>     .[aBCdEF] =&gt; .[a bc d ef] =&gt; a: :bc d: :ef
</code></pre>
<p>There's still some back-and-forth on the handling of lone dot.  I like it being a reduced case of a TUPLE! in some sense...because it makes it easier to write generic fusing code for things like JOIN.  But putting into the new SYMBOL! class (which cannot appear in TUPLE! or PATH!) might have advantages, and helpers to count the dots might serve just as well.</p>
<p>I'm not sure what the in-language default function for plain dot will be, but it's likely that it will not be more powerful than either <strong>.a</strong> or <strong>a.</strong> enough to justify that <strong>a.a</strong> should be interpreted as <strong>a . a</strong>.</p>
<p>It's important to look at the specifics of mushing with symbols as they have no case, so the breakapart rules are different.  I've diagrammed some of these before.</p>
<pre><code>a+b =&gt; a+b  ; compatibility with all lowercase code
a+B =&gt; a+ b  ; favors breaking to the left, vs. a +b
</code></pre>
<p>I'll delve into these justifications, but since I'm deleting the old definitions of things like <strong>a&amp;</strong> and <strong>a|</strong> I wanted to put a placeholder topic for discussing it.</p> ]]></description>
        <link>https://forum.rebol.info/t/symbols-and-mushing-in-rebmu/1797/1</link>
        <pubDate>Mon, 07 Mar 2022 08:08:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5790</guid>
      </item>
      <item>
        <title>Rebmu&#39;s FUNQTION (FQ): Dialecting Function Definition Itself</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1796">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It doesn't do anything <em>terribly</em> tricky because its arguments are both evaluative.</p>
</blockquote>
</aside>
<p>I say <em>not terribly</em> tricky, but it's a <em>little</em> tricky.</p>
<p>It defines R and RT as local synonyms for the function's definitional return.  Remember you can't globally say something like:</p>
<pre><code>r: rt: :return
</code></pre>
<p>Because each function defines its own local RETURN function.  So you have to basically augment the body during construction to get it bound to local definitions of RT and R:</p>
<pre><code>fn: adapt :function [
    body: compose [
        let rt: :return
        let r: :rt 
        (as group! body)
    ]
]
</code></pre>
<p>Another twist I think would be smart would be that while normal parameters don't accept isotopes in plain functions...it could turn all normal parameters to be ^META and then un-meta them implicitly.  Though that would affect the function's interface in ways that could lead to undesirable behaviors, so it might be better to put that in FQ (or something else, FX?)</p>
<p>There could also be some decisions that once an argument has been evaluated, it could treat invalid types differently:</p>
<pre><code>X 1  ; =&gt; x: 1
Y 2  ; =&gt; y: 2
fnADxY[...] ; =&gt; fn ad x y [...]
            ; =&gt; function add x y [...]
            ; =&gt; function 3 [...]   ; could mean something vs. error?
</code></pre>
<p>But again: I don't know how far one wants to bend the "standard" definitions in the space where things are errors today.  Worth being cautious about it.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebmus-funqtion-fq-dialecting-function-definition-itself/1796/2</link>
        <pubDate>Mon, 07 Mar 2022 07:25:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5789</guid>
      </item>
      <item>
        <title>Rebmu&#39;s FUNQTION (FQ): Dialecting Function Definition Itself</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <blockquote>
<p>After writing this I realized I had <a href="https://forum.rebol.info/t/function-mu-rebmus-function-generator-dialect/1379">already written a post about this in 2020</a>, but... here it is again, I guess!  Maybe I said it better or worse this time?</p>
</blockquote>
<p><em>(Note: FQ is pronounced EFF-QUEUE, say it carefully. <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">)</em></p>
<p>So in Rebmu, <strong>FN</strong> is a superset of <strong>FUNC</strong> (itself a synonym for <strong>FUNCTION</strong>).</p>
<p>It doesn't do anything <em>terribly</em> tricky because its arguments are both evaluative.  So you can pass it specs and bodies that are variables.  Here's a useless example of taking advantage of that with a spec in a variable:</p>
<pre><code>; define a spec which takes two arguments
S[xY]   ; =&gt; s: [x y]

; define function A that adds X and Y.
AfnS[adXy]  ; =&gt; a: fn s [ad x y]
            ; =&gt; a: function s [add x y]

; define function M that multiplies X and Y
MfnS[mpXy]  ; =&gt; m: fn s [mp x y]
            ; =&gt; m: function s [multiply x y]
</code></pre>
<p><em>...but what might a Code-Golf-Dialected FUNQTION (FQ) Do, unbound by rote evaluation of its parameters?</em>  Let's use our imagination...</p>
<h2>A Quoted Spec could permit Spec Compression</h2>
<p>How about if you gave a WORD! that was a letter and a number, you'd get 3 args starting with that letter?</p>
<pre><code>fqR3[adMPrSt]
; =&gt; fq r3 [ad mp r s t]
; =&gt; fn [r s t] [ad mp r s t]
; =&gt; function [r s t] [add multiply r s t]
; =&gt; function [r s t] [add (multiply r s) t]
</code></pre>
<p>That's a three character savings vs. having to express the block for <strong>[r s t]</strong> explicitly with a plain function:</p>
<pre><code>fn[rSt][adMPrSt]
</code></pre>
<p>If you didn't include a number that might be a different memoization of what the arguments were, such as:</p>
<pre><code>fqA[...] =&gt; fn [a] [...]
fqB[...] =&gt; fn [a b] [...]
fqC[...] =&gt; fn [a b c] [...]

fqX[...] =&gt; fn [z y x] [...]
fqY[...] =&gt; fn [z y] [...]
fqZ[...] =&gt; fn [z] [...]
</code></pre>
<p>The idea being that you need to sort of spread out your variable names in code golf, for instance when working with nested functions.  From a tactical standpoint one might be served to throw in curveballs:</p>
<pre><code>fqM[...] =&gt; fn [m j z] [...]
</code></pre>
<p>Though that lessens the readability/learnability.  Anyway, what else...?</p>
<h2>Variadically Quoted Bodies Could Circumvent Brackets</h2>
<p>Let's say if it found a word in the slot where the body block would ordinarily be, it would treat that as a function that should be called.</p>
<p>To make it easier, let's just think about this un-Rebmu'd:</p>
<pre><code>foo: func [x y z] [any [x y z]]

bar: funq [x y z] any [x y z]
</code></pre>
<p>If FUNQ is variadic and quoting its body slot, it could notice the body does not contain a block but a WORD!.  Seeing that function is ANY, it could count the number of parameters ANY needs and pick them up from the callsite.</p>
<p><em>Such mechanics are within reach using today's FRAME!s</em>, in fact <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">they are used by things like POINTFREE</a>...itself clearly useful in Rebmu.</p>
<h2>What Else Might FQ do?</h2>
<p>There's also things like GROUP!s, and <strong>fq(x)...</strong> could imply a completely different thing from <strong>fq[x]...</strong>, suggesting a mode switch in how the ensuing information is interpreted.</p>
<p>Or <strong>fqX(...)</strong> and <strong>fqX[...]</strong> could be completely different.  What about strings?  How might string interpolation fit into all of this?</p>
<pre><code>ZfqC{Implicit printing of $a and $b and $c?}
; =&gt; z: fn [a b c] [print interpolate {Implicit print of $a and $b and $c}]
</code></pre>
<p>Maybe the implicit printing is different, like FP, and FQ with a string simply interpolates it.</p>
<p><strong>Hopefully you get the drift.</strong>  I'm talking about making Rebmu a powerhouse showcase of what Ren-C is driving at.</p>
<p>How can quoting, variadics, frames, interpolation, and all of that be applied to dialecting the act of function definition itself?</p>
<h1><code>[insert your ideas here]</code></h1> ]]></description>
        <link>https://forum.rebol.info/t/rebmus-funqtion-fq-dialecting-function-definition-itself/1796/1</link>
        <pubDate>Mon, 07 Mar 2022 07:07:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5788</guid>
      </item>
      <item>
        <title>What was REBMU-WRAP (and why we no longer need it)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>As I bring the Rebmu dialect up to date I'll try and talk about any teachable moments that it provides.</p>
<p>Let's look at one of the earliest weird functions, REBMU-WRAP:</p>
<pre><code>rebmu-wrap: function [refined [path!] args [block!]] [
    func args compose [
        (refined) (args)
    ]
]
</code></pre>
<p>It was designed to make it (slightly) easier to define something like <code>APO</code> as a synonym for <code>APPEND/ONLY</code>.</p>
<pre><code>APO: rebmu-wrap 'append/only [series value]
</code></pre>
<p>So that turns into effectively:</p>
<pre><code>APO: func [series value] [
    append/only series value
]
</code></pre>
<p><strong>Basically this was an incredibly weak way to save a few characters while making a partial specialization.</strong>  Some of its weaknesses:</p>
<ol>
<li>
<p>You still have to specify the number and names of arguments the specialization takes.</p>
</li>
<li>
<p>If you make a mistake at the time of definition (like mentioning an unavailable refinement) you don't get the error until the call.</p>
</li>
<li>
<p>The other refinements are missing from the wrapped function, e.g. you can't invoke <code>apo/part</code> or <code>apo/dup</code>.</p>
</li>
<li>
<p>You don't inherit anything about the original function's parameter conventions; e.g. if an argument were quoted you'd get the parameter name word you passed for it.</p>
</li>
<li>
<p>Performance-wise you generate a whole new function call...path evaluation...argument evaluation...</p>
</li>
<li>
<p>Your new function doesn't have any HELP... etc. etc.</p>
</li>
</ol>
<h2>How To Make This Better in Classical "Redbol"?</h2>
<p>Let's put yourself in the mind of someone thinking about how I was at that time, <em>who wanted to use the same strategy but merely address (1) and (2)</em>.  So to be able to write the slightly shorter hand:</p>
<pre><code>APO: rebmu-wrap 'append/only
APD: rebmu-wrap 'append/dup
APDP: :rebmu-wrap 'append/dup/part
APPD: :rebmu-wrap 'append/part/dup  ; ...etc.
</code></pre>
<p>This version of REBMU-WRAP would need to analyze the spec, presumably with WORDS-OF:</p>
<pre><code>r3-alpha&gt;&gt; words-of :append
== [series value /part length /only /dup count]
</code></pre>
<p>So you might try something like the following nightmare...<strong>which took me at least an hour to write and debug!</strong> (probably more like two, because of the glitch of trying to mutate the spec in place and needing to notice when the insertion position matches the position a refinement argument is being moved from):</p>
<pre><code>rebmu-wrap: func [refined [path!] /local spec body pos insert-pos item] [
    if not any-function? (action: get first refined) [
        do make error! "first element of path must refer to a function"
    ]
    spec: words-of :action
    body: reduce [refined]
    insert-pos: spec  ; find where refinement args should be inserted
    while [all [not tail? insert-pos not refinement? insert-pos/1]][
        append body insert-pos/1
        insert-pos: next insert-pos
    ]
    foreach refinement-name (next refined) [
        if not pos: find spec to-refinement refinement-name [
            do make error! "missing or duplicate refinement specified"
        ]
        take pos  ; drop refinement from spec
        while [all [not tail? pos not refinement? pos/1 pos != insert-pos]] [
             insert-pos: insert insert-pos item: take pos
             append body item
        ]
    ]
    func ?? spec ?? body
]
</code></pre>
<p>If you try this in R3-Alpha, yes it does indeed work for (1) and (2). I put in the probes so you can see the spec and body of the new function:</p>
<pre><code>r3-alpha&gt;&gt; apo: rebmu-wrap 'append/only
spec: [series value /part length /dup count]
body: [append/only series value]

r3-alpha&gt; apd: rebmu-wrap 'append/dup
spec: [series value count /part length /only]
body: [append/dup series value count]

r3-alpha&gt;&gt; apdp: rebmu-wrap 'append/dup/part
spec: [series value count length /only]
body: [append/dup/part series value count]

r3-alpha&gt;&gt; appd: rebmu-wrap 'append/part/dup
spec: [series value count length /only]
body: [append/part/dup series value count]
</code></pre>
<p>It gets a head-start on (3) by leaving the refinements that haven't been partially specialized on the spec, but they're ignored in the call.</p>
<h2>That's A Lot Of Work for Something That Still Sucks! <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">
</h2>
<p>When you think of everything it entails to get (3) and (4), you are going to either need to COMPOSE your invocation on each call -or- change methodology to use APPLY.  But even if you are aware of APPLY it doesn't make this a trivial exercise, and doesn't help with (5) or (6).</p>
<p><strong>...and this is why I never even tried to write such things (before)... instead trying to add core interpreter features for partial specialization.</strong></p>
<h2>The Happy New World of Partial Specialization <img src="https://forum.rebol.info/images/emoji/twitter/sun_with_face.png?v=9" title=":sun_with_face:" class="emoji" alt=":sun_with_face:">
</h2>
<p>In today's Ren-C, all you have to do is get a function as a path, and you have (1) (2) (3) (4) (5).</p>
<pre><code>ren-c&gt;&gt; ap: :append
 == #[action! {ap} [series value /part /dup /line /only]]

ren-c&gt;&gt; ap [a b c] [d e]
== [a b c d e]

ren-c&gt;&gt; apo: :append/only
== #[action! {apo} [series value /part /dup /line]]

ren-c&gt;&gt; apo [a b c] [d e]
== [a b c [d e]]

ren-c&gt;&gt; apo/dup [a b c] [d e] 2  ; e.g. demonstrating (3)
== [a b c [d e] [d e]]
</code></pre>
<p>The new function call is just as efficient as the original (you might think of it moreso since there's no path processing, e.g. <strong>apo</strong> is faster than invoking <strong>ap/only</strong>!)</p>
<p>You don't get the HELP inherited automatically (it has an associated cost), but there is a function that will do it if you want to... you say <strong>inherit-meta :apo :append</strong> and then <strong>help apo</strong> will have the help strings copied into its meta information.</p>
<p>So that's some assistance with (6), but do remember that it's not a perfect world when talking about how to automatically write meaningful adjusted help.  If any parameter descriptions refer to the argument you specialized out, it's no longer on the interface, so they may not make sense!</p>
<p><em>(Note: Now that refinements are their own arguments, you can't tell by parameter list alone if a refinement is a 0 or 1 arg case.  It's determined by the typeset: if the typeset is empty--no types accepted--it is a 0 arg refinement.  Something to ponder if this can be done better, but see all the other nice things...like caching the label of the function name for stack traces, etc.)</em></p>
<h2>So long, REBMU-WRAP...</h2>
<p>...but I wanted to write this up just to show a good example of how early experiences playing with Rebmu led me to question Rebol, and want to shore up its abilities.</p>
<blockquote>
<p>"Beware of the Turing tar-pit in which <strong>everything is possible but nothing of interest is easy</strong>."</p>
</blockquote> ]]></description>
        <link>https://forum.rebol.info/t/what-was-rebmu-wrap-and-why-we-no-longer-need-it/1795/1</link>
        <pubDate>Mon, 07 Mar 2022 06:06:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5787</guid>
      </item>
      <item>
        <title>About the Rebmu category</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Rebmu is a dialect for solving <a href="https://en.wikipedia.org/wiki/Code_golf">Code Golf challenges</a>, where the goal is to express the source code for solving a puzzle in the fewest characters of source code possible.  See the README here:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/hostilefork/rebmu" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://opengraph.githubassets.com/1d67e812b647b23547cabb9d53af90f2917089ce3978ae8f525e7b31a26b475d/hostilefork/rebmu" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/hostilefork/rebmu" target="_blank" rel="noopener">GitHub - hostilefork/rebmu: Microscopic Rebol Dialect ("mooshed") for Code Golf</a></h3>


  <p><span class="label1">Microscopic Rebol Dialect ("mooshed") for Code Golf</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Significant design points in Ren-C were inspired by wanting to make the implementation and bending of Rebmu more effective.</p> ]]></description>
        <link>https://forum.rebol.info/t/about-the-rebmu-category/1794/1</link>
        <pubDate>Mon, 07 Mar 2022 04:15:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5786</guid>
      </item>
      <item>
        <title>(No) Alternative Local Notation in the Func Spec Dialect</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h1>TL;DR:</h1>
<p>When using a spec in FUNCTION (remember <a href="https://forum.rebol.info/t/abbreviations-as-synonyms/1211">FUNC is a synonym now</a>):</p>
<ul>
<li>
<p><strong>if you want to specify locals you say <code>[... &lt;local&gt; x y z ...]</code></strong> (/LOCAL is a normal refinement like any other in Ren-C.</p>
</li>
<li>
<p><strong>there is no longer a datatype-based shortcut for locals as a way to save the trouble of finding <code>&lt;local&gt;</code> in specs and inserting at the right point</strong>.</p>
<ul>
<li>
<p>Once you could toss random SET-WORD!s anywhere in a spec, like <strong><code>[a b c: d]</code></strong> and it would act like <strong><code>[a b d &lt;local&gt; c]</code></strong>.  This feature was to make higher-level function generators easier to write, to save them from having to find <code>&lt;local&gt;</code> in the spec...add it if not there...and do everything at the right point.</p>
</li>
<li>
<p>When multi-returns began using SET-WORD! this was changed to be <strong><code>[a b .c d]</code></strong> just to move it out of the way.</p>
</li>
<li>
<p>What this was trying to achieve has been obsoleted by newer and better methods, which actually entwine with the idea that <em>you should never know what local variables a function you are composing on top of has</em>.</p>
</li>
</ul>
</li>
</ul>
<h1>More Explanation</h1>
<p>Long ago, when I was looking at some of the higher-level function generators (like FUNCT on top of FUNCTION) I was struck by how tricky it was to get the adaptations written correctly.</p>
<p>We can look at <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28">FUNCT from R3-Alpha</a> and see some of that complexity, even just to try and add some local variables.</p>
<p>It had to check to see if there was already a /LOCAL, and add it if not:</p>
<pre><code>; Copy the spec and add /local to the end if not found
unless find spec: copy/deep spec /local [append spec [
	/local ; In a block so the generated source gets the newlines
]]
</code></pre>
<p><em>Bear in mind that specifying /LOCAL twice would be a duplicate refinement error, and /LOCAL did not have to be at the end of a spec.</em>  Things were tricky, because there were "private refinements".  These refinements were an artifact of how help worked--they were not shown--but weren't actually private.</p>
<p>So you had to be careful, to insert things after local but not after the private refinements, or they'd be arguments to those refinements:</p>
<pre><code>; Collect all set-words in the body as words to be used as locals, and add
; them to the spec. Don't include the words already in the spec or object.
insert find/tail spec /local collect-words/deep/set/ignore body either with [
   ...
]
</code></pre>
<p><strong>I wanted to take better advantage of datatypes, so I adopted the TAG! <code>&lt;local&gt;</code> in the spec so that /LOCAL could be used like any other refinement... e.g. GET-TIME/LOCAL or GET-LANGUAGE/LOCAL.</strong>  This is an idea preserved to this day, and I think it's a better move (though LET has been developing as the more viable general option for making locals).</p>
<p>But another concept I had was to make SET-WORD! in the dialect be another way to put a local anywhere in the spec.  So if you were writing code munging function specs you could just throw local variables on:</p>
<pre><code>foo: func [a b c: d] [...]

&lt;= equivalent to =&gt;

foo: func [a b d &lt;local&gt; c] [...]
</code></pre>
<p>But the idea was that <code>&lt;local&gt;</code> itself was transformed into the SET-WORD!, so the only language you needed to understand was that of the SET-WORD!s:</p>
<pre><code>&gt;&gt; foo: func [a b d &lt;local&gt; c] [...]

&gt;&gt; spec-of :foo
== [a b d c:]
</code></pre>
<p>When multi-returns came about and took SET-WORD!s, this idea was bumped around to be done with TUPLE!s with leading blanks like <strong>.c</strong></p>
<h1><a href="https://www.youtube.com/watch?v=2q9MaEKHakY">... but Everything Changed <img src="https://forum.rebol.info/images/emoji/twitter/robot.png?v=9" title=":robot:" class="emoji" alt=":robot:"> ...</a></h1>
<p>I've been marching toward something more like <a href="https://forum.rebol.info/t/seeing-all-action-s-as-variadic-frame-makers/1002">"Seeing all ACTION!s as Variadic Frame Makers?"</a></p>
<p>Function composition tools operate on FRAME!s using tools like ADAPT, SPECIALIZE, AUGMENT, ENCLOSE, etc.  There is no API for getting at the locals <em>because when you build on top of a function you can't see them, they're not part of the interface...they are sealed inside.</em>   This is good because you can build on top of a function without worrying about the details of the parts from which it was composed.</p>
<p>The migration to where <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">refinements are their own arguments</a> has been key in making function calls easier to model as an object.</p>
<p><strong>In this world we do not need a representation for locals in the spec to add them...because the entire concept of how FUNCT was written is gone.</strong>  If you want to add locals you use tools like AUGMENT and don't worry about it.</p>
<h1>There Are Still (many) Problems To Solve</h1>
<p>Consider that you can do something like ask for a FRAME! of something like APPEND, then enumerate the keys:</p>
<pre><code>&gt;&gt; f: make frame! :append

&gt;&gt; for-each key f [print mold key]
return
series
value
part
dup
line
only
</code></pre>
<p>There are a lot of questions to answer about the unique nature of the main function's RETURN.  Although other multi-returns have to be on the interface, should you be able to put a variable in that return?  Consider that you could use multi-return with append today:</p>
<pre><code>&gt;&gt; [var]: append "abc" "d"
== "abcd"

&gt;&gt; var
== "abcd"
</code></pre>
<p>So should you be able to preload the frame with <strong>f.return: 'var</strong> and get the same effect?  This is competitive with the notion that RETURN is a concept of a local variable to the action, that holds an action that returns specifically from that action... so the responsibilities are somewhat murky for this distinguished result.</p>
<p>But we can also see that if we only look at object keys, we don't know which things are refinements or which are not...if they are refinements we don't know if they are 0-arg or 1-arg form, we don't know what types they take... or are they <code>&lt;end&gt;</code>-able.  <strong>I believe getting at this information should be done by means other than analysis of some spec block you filter out for description strings/etc. so that is on the right track.</strong>  But it's still a long road.</p> ]]></description>
        <link>https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793/1</link>
        <pubDate>Sat, 05 Mar 2022 20:33:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5785</guid>
      </item>
      <item>
        <title>Could strings have context?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Red is continuing their investment in a kind of string interpolation:</p>
<p><a href="https://github.com/red/red/pull/5085">https://github.com/red/red/pull/5085</a></p>
<p>They are defaulting to parentheses instead of $, and escaping parentheses with backslash <code>(\on the inside, curiously\)</code></p>
<p>It's worth thinking about what a good default is, though ultimately I think it should be customizable (as with historical REWORD).  I had been considering plain parentheses for the same reasons at first, but leaned to $ just because of how popular it is in other languages for interpolation.</p>
<p>My concept is different because it is not a hardcoded preprocessor behavior, but making binding information available on strings as a map of words to values.  See <a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">"Rebol and Scopes: Well, why not?"</a> for thoughts on that distinction and the challenges it presents.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-strings-have-context/587/13</link>
        <pubDate>Wed, 23 Feb 2022 19:18:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5784</guid>
      </item>
      <item>
        <title>Shall we CONTINUE?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1790">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>How about WHILE or REPEAT or FOR-EACH? If we wanted it to be novel, it could say "don't change the pending overall result from whatever the last loop iteration would have returned":</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
]
== 20
</code></pre>
<p>Although I like that in theory, it would break the loop composition rules unless loops were allowed to be invisible. :-/</p>
</blockquote>
</aside>
<p>So what I'd missed here in the composition rules is a wrinkle that if you try the FOR-BOTH construct and the second list is <em>empty</em>, then you wind up overwriting the last result from the first list.  It creates the same kind of problem as if you wanted a CONTINUE with ~none~ to preserve the last value.</p>
<p>The tool to tackle this would be something that vanishes plain ~none~ after a META, or a version of meta that elides ~none~ isotopes.  So:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each :var blk1 body
        none-to-void/meta meta for-each :var blk2 body
    ]
]
</code></pre>
<p>or:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each :var blk1 body
        meta/none-to-void for-each :var blk2 body
    ]
]
</code></pre>
<p>Naming is open to discussion there.  Could be META/VANISHABLE or somesuch.  You can also make it symmetrical by doing it for both loops, it just doesn't matter because the ALL will give ~none~ isotope if the body turns up empty:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta/vanishable for-each :var blk1 body
        meta/vanishable for-each :var blk2 body
    ]
]
</code></pre>
<p>The consequence of this, though, is that you can't force a ~none~ isotope return result from a loop once the body has returned any non-~none~-isotope value.  You'd have to do something like a CATCH with a THROW of ~none~.</p>
<p>I can't offhand tell you if that's annoying or a feature.  You could always META your body result and UNMETA it outside the loop.</p> ]]></description>
        <link>https://forum.rebol.info/t/shall-we-continue/1790/2</link>
        <pubDate>Wed, 23 Feb 2022 16:57:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5783</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1792">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think if you look at the FOR-BOTH example in Ren-C, it really tells a story that isn't there in historical Rebol.</p>
</blockquote>
</aside>
<p>Hmmm, I realize there is a deficiency here...</p>
<pre><code> &gt;&gt; for-both x [1 2] [] [print ["x is" x], x * 10]
 x is 1
 x is 2
 == ~none~  ; isotope
</code></pre>
<p>What I want is for that to be 20.</p>
<p>For that to happen, the second FOR-EACH would have to vaporize somehow.</p>
<p>This means either the second clause would be invisible -or- something about the nature of ALL would choose to throw out a product.</p>
<p>There is NONE-TO-VOID but then you get in the trap of what if the second loop ran but intentionally produced a ~none~.  I guess we could say that ~none~ is skipped, which would manifest something along the lines of:</p>
<pre><code>&gt;&gt; for-each x [1 2] [
      if x = 2 [~none~] else [x * 10]
  ]
 == 10
</code></pre>
<p>Basically saying that "none isotopes don't count".  If that were the policy then turning nones into voids so they vanish in aggregating constructs would be considered acceptable.</p>
<p>I still maintain this is getting closer.  Just have to keep looking at it.</p> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/5</link>
        <pubDate>Wed, 23 Feb 2022 07:30:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5782</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="rgchris" data-post="3" data-topic="1792">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>which <em>more solidly designed language</em> used by non-crackpots are people more likely to opt for vs. popular languages</p>
</blockquote>
</aside>
<p>I'd guess the sort of competition in the homoiconic space I'd have in mind would be people using things like Clojure (or <a href="https://clojurescript.org/">ClojureScript</a>).  But I think if you look at things like Julia or Go, there are some real strengths there.  And Rust and Haskell are good projects for those who want to step away from popularity but get rigor as a benefit.</p>
<blockquote>
<p>The language itself wasn't <em>composable</em> the way one might like languages to be</p>
</blockquote>
<p>I think if you look at the FOR-BOTH example in Ren-C, it really tells a story that isn't there in historical Rebol.</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each :var blk1 body
        meta for-each :var blk2 body
    ]
]
</code></pre>
<p>It's just across the board more solid.  Not only does definitional RETURN mean that a return in the body will act as the person using the loop would expect, but BREAK and CONTINUE will behave correctly...returning the aggregate loop result.</p>
<pre><code> &gt;&gt; for-both x [1 2] [3 4] [print ["x is" x], x * 10]
 x is 1
 x is 2
 x is 3
 x is 4
 == 40

&gt;&gt; for-both x [1 2] [3 4] [print ["x is" x], if x = 2 [break]]
x is 1
x is 2
; null

&gt;&gt; for-both x [] [] [print ["x is" x], &lt;result&gt;]
== ~none~  ; isotope
</code></pre>
<p>All the ideas come together here.  With META ~unset~ isotopes and ~none~ isotopes etc. become plain BAD-WORD!s which are truthy, NULL goes to NULL, everything else (including plain BAD-WORD!) becomes one level more quoted than it was, and all QUOTED! (including a quoted #[false]) are truthy.  NULL is reserved uniquely for the signal of BREAK, and so everything... works.</p> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/4</link>
        <pubDate>Tue, 22 Feb 2022 20:24:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5781</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>Not disputing this overview <em>per se</em>—however these statements aren't immediately elucidated without some digging. Is there a succinct citation for each of them?</p>
<ul>
<li>
<p>When serious language theorists look at Rebol, they notice it is riddled with design holes</p>
</li>
<li>
<p>The language itself wasn't <em>composable</em> the way one might like languages to be</p>
</li>
</ul>
<hr>
<p>Would echo (I think) <a class="mention" href="/u/iarnold">@iArnold</a>'s sense on 3—which <em>more solidly designed language</em> used by non-crackpots are people more likely to opt for vs. popular languages which may have the same or worse design issues but have the security blanket implied by that popularity?</p> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/3</link>
        <pubDate>Mon, 21 Feb 2022 22:21:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5780</guid>
      </item>
      <item>
        <title>Should END-able constructs all use ^META parameters?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1783">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Killing off <code>&lt;end&gt;</code> as a core parameter flag would simplify things...</p>
</blockquote>
</aside>
<p>Trying to do this creates an unappealing situation, because it means all ^META parameters start accepting end conditions by default.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>That's a bit of an overreach.  Just because you say you want an argument to be passed via meta protocol, having to handle the ~void~ case of there being nothing there becomes a hassle.  Labeling things <code>&lt;end&gt;</code> is much more convenient, otherwise you will end up with a lot of accidental tolerance of ends...producing particularly troublemaking invisibility signals.</p>
<p>Nevertheless, I think we can say that if you care about the difference between an end and an evaluated NULL then we now have an answer: an endable ^META parameter which receives ~void~ can only get that if at an end.  With what I observed about <strong>^(...)</strong> I think we can say there are no "supermeta" parameters... so the only way you will get a ~void~ indication will be if the evaulation reaches an END (or a comma).</p>
<p>So "endish nulls" are dying, which should get rid of bugs like this:</p>
<aside class="onebox githubissue">
  <header class="source">
      <a href="https://github.com/metaeducation/ren-c/issues/1129" target="_blank" rel="noopener">github.com/metaeducation/ren-c</a>
  </header>
  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Issue">
	  <svg width="60" height="60" class="github-icon" viewbox="0 0 14 16" aria-hidden="true"><path d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/metaeducation/ren-c/issues/1129" target="_blank" rel="noopener">END being tolerated when it shouldn't</a>
    </h4>

    <div class="github-info">
      <div class="date">
        opened <span class="discourse-local-date" data-format="ll" data-date="2021-07-06" data-time="03:35:27" data-timezone="UTC">03:35AM - 06 Jul 21 UTC</span>
      </div>


      <div class="user">
        <a href="https://github.com/hostilefork" target="_blank" rel="noopener">
          <img alt="hostilefork" src="https://avatars.githubusercontent.com/u/20440?v=4" class="onebox-avatar-inline" width="20" height="20">
          hostilefork
        </a>
      </div>
    </div>
  </div>
</div>

<div class="github-row">
  <p class="github-content">&gt;&gt; collect [keep/line [a b c] keep/dup/line [d e f]]
== [
 a b c
 d e f
]
Is missing /DUP count, this...</p>
</div>

<div class="labels">
    <span style="display:inline-block;margin-top:2px;background-color: #B8B8B8;padding: 2px;border-radius: 4px;color: #fff;margin-left: 3px;">type.bug</span>
</div>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>
 ]]></description>
        <link>https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783/2</link>
        <pubDate>Sun, 20 Feb 2022 17:34:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5779</guid>
      </item>
      <item>
        <title>Pure vs. Impure Invisibility: Do We Need Both?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1782">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Pondering the potential implications of this form of thinking, it would mean there wouldn't be a form of invisibility that could beat a ^META operation:</p>
<pre><code>&gt;&gt; z: ^ comment ["hi"] ~something~
== ~something~  ; isotope

&gt;&gt; z
== ~void~
   ; ^-- the COMMENT was seen by the ^META, instead of bypassed
   ; (today COMMENT's status as a purely invisible construct means you
   ; would get Z as a non-isotope ~something~)
</code></pre>
</blockquote>
</aside>
<p>It occurs to me that <strong><code>^(...)</code></strong> could be leveraged as a defeat for this.</p>
<pre><code>&gt;&gt; z: ^ comment "hi" 1 + 2
== 3

&gt;&gt; z
== 3

&gt;&gt; z: ^(comment "hi") 1 + 2
== 3

&gt;&gt; z
== ~void~
</code></pre>
<p>Additionally, multi-returns with ^META could defeat invisibility, because multi-return is a syntactic convenience that applies to one-and-only-one function.  So if you meta its result, it can't vanish.</p>
<pre><code>&gt;&gt; [^x]: comment "hi" 1 + 2
== 3

&gt;&gt; x
== ~void~
</code></pre>
<p>This might be enough, actually!</p> ]]></description>
        <link>https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782/2</link>
        <pubDate>Sun, 20 Feb 2022 02:58:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5778</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>3 is also dealing with the shortcomings of the alternatives like there are ugly syntax and dependency hells.</p>
<p>Besides there are holes everywhere, they are more hidden or plugged with another library you do not control.<br>
And most important there is no fun and nothing to learn from option 3 and that is also a rectification for following option 2. We need to remember the state original Rebol was at before Red project started, it was not open sourced and it was abandonware.<br>
The effort of Oldes is imo to be placed as making it work for personal use mainly, like the World language and Boron.<br>
Kaj"s Meta is an interesting alternative bringing Rebol back to some computing roots to get the basics right, without need for fixing R3 or Red designs.</p> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/2</link>
        <pubDate>Sat, 19 Feb 2022 22:16:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5777</guid>
      </item>
      <item>
        <title>My Summary of the Big Picture</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I wrote this to someone in a GitHub issue and thought it was pretty salient:</p>
<blockquote>
<p>What has drawn people to Rebol historically has varied. But a large number who praised it and used it were less interested in the language itself, rather the properties of the executable. It was small, and you could run on any OS without installing anything else...it came with a GUI built in.</p>
<p>But when serious language theorists look at Rebol, they notice it is riddled with design holes. The language itself wasn't <em>composable</em> the way one might like languages to be: mixing constructs in new ways that weren't specifically accounted for never worked. It was more like a "scriptable app" that had a few features that pleased its userbase...and had to be extended by the designer every time a new need came up.</p>
<p>So put briefly: If you don't understand what these holes are, then you won't appreciate the many issues that Ren-C is trying to solve. Starting from scratch inevitably makes the same mistakes.</p>
<p>Once you know that historical Rebol was fundamentally broken, there are basically 3 choices:</p>
<ol>
<li>Inventory and address the holes one at a time and try to fix or mitigate them</li>
<li>Ignore the holes and just hope that if you add enough features and integration no one will notice</li>
<li>Turn away and run from the crackpots using it, and work with a more solidly designed language</li>
</ol>
<p>(1) is Ren-C's hard-chosen path. Energy is spent on identifying certain patterns in source that users <em>must</em> be able to write and have work, if the language is to justify its existence at all. While it would be nice if stack traces were beautiful and if building the sources was 100% easy, all of that would be meaningless if the punch line was <em>"oh, and the language this is all supporting doesn't actually work"</em></p>
<p>(2) is chosen by people like Red and <a href="https://github.com/Oldes/Rebol3">Oldes's branch of R3-Alpha</a>, as well as some clones that have popped up over the years.</p>
<p>(3) is probably the most sensible choice, but if I didn't think there was some promise in the language I wouldn't be pursuing (1).</p>
</blockquote> ]]></description>
        <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792/1</link>
        <pubDate>Fri, 18 Feb 2022 19:37:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5776</guid>
      </item>
      <item>
        <title>&lt;skip&gt;-able Arguments</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1013">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Skippable parameters have become an important piece of the system</p>
</blockquote>
</aside>
<p>I've certainly become attached to the feature of skippable parameters.  Of course, anything that is going to be "meta" about making function calls has to decide what to do with them.</p>
<p>One example would be APPLY.  Consider that COMPOSE has a first parameter which is the "Label" that can be (for instance) a tag to label the compose slots.</p>
<p>If you don't provide a label, all the GROUP!s are composed.</p>
<pre><code>&gt;&gt; compose [(1 + 2) (&lt;*&gt; 3 + 4)]
== [3 7]
</code></pre>
<p>But if you do provide a label, only the GROUP!s starting with that label get composed:</p>
<pre><code>&gt;&gt; compose &lt;*&gt; [(1 + 2) (&lt;*&gt; 3 + 4)]
== [(1 + 2) 7]
</code></pre>
<p>So when APPLY is processing parameters in order, what should it do about the label?  It's evaluating the arguments in the block, so I don't think that's very compatible with the hard-quote rule of skippability.</p>
<p>Hence I propose that APPLY always skips over the skippable parameters positionally, and they must be provided explicitly by name.</p>
<pre><code>&gt;&gt; apply :compose [[(1 + 2) (&lt;*&gt; 3 + 4)]]
== [3 7]  ; assumed first parameter was the block, not the label

&gt;&gt; apply :compose [[(1 + 2) (&lt;*&gt; 3 + 4)] /label &lt;*&gt;]
== [(1 + 2) 7]  ; you can still provide a label, just by name

&gt;&gt; apply :compose [[(1 + 2) (&lt;*&gt; 3 + 4)] /label second [&lt;x&gt; &lt;*&gt;]]
== [(1 + 2) 7]  ; evaluations are okay, since you explicitly named it
</code></pre>
<p>This seems the most sensible behavior.</p> ]]></description>
        <link>https://forum.rebol.info/t/skip-able-arguments/1013/3</link>
        <pubDate>Fri, 18 Feb 2022 19:25:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5775</guid>
      </item>
      <item>
        <title>Turning a Blind Eye to Evaluator &quot;Abuse&quot;</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I've gotten kind of attached to the current look and behavior of AND and OR, which allow short-circuiting even though one would not think the language could (should?) be able to.</p>
<p>It doesn't require simple variables be in a GROUP! on the right hand side.</p>
<pre><code>&gt;&gt; if true and true [print "True"] else [print "False"]
True
</code></pre>
<p>...but a function call has to be.</p>
<pre><code>&gt;&gt; foo: func [x] [
      print "Calling foo!"
      return x &gt; 1000
   ]

&gt;&gt; if false and foo 1020 [print "True!"] else [print "False"]
** Error: words/tuples can't be ACTION! as right hand of OR, AND, XOR

&gt;&gt; if false and (foo 1020) [print "True"] else [print "False"]
False

&gt;&gt; if true and (foo 1020) [print "True!"] else [print "False"]
Calling foo!
True
</code></pre>
<p><em>Note that if the thing to the left of the AND is false, it does not run the code in the GROUP! on the right.</em>  This requires that the right hand side be a quoted parameter convention.</p>
<p>Alternatively we could not quote it, and require the right hand side be in a block:</p>
<pre><code>&gt;&gt; if true and [true] [print "True"] else [print "False"]
True

&gt;&gt; if false and [foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p><strong>But I don't like that.</strong></p>
<p>Alternatively we could say we don't offer this and you always use ALL...maybe with COMMA! and maybe not:</p>
<pre><code>&gt;&gt; if all [true true] [print "True"] else [print "False"]
True

&gt;&gt; if all [false, foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p>I just don't think that looks as natural.</p>
<h2>It's Like I Said In <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">"Speaking With Tics"</a>...</h2>
<p>If you think seeing a GROUP! on the right of AND and OR that doesn't unconditionally evaluate at the callsite is weird, why are you comfortable with <strong><code>for-each x [1 2 3] [...]</code></strong>?  That didn't unconditionally evaluate x.  Do you expect it to be <strong><code>for-each 'x</code></strong> instead?</p>
<aside class="quote no-group">
<blockquote>
<p>The quoted parameter convention exists to save you the trouble of quoting the callsites. <em>If this isn't what that's for, then what <strong>is</strong> it for?</em></p>
</blockquote>
</aside>
<p>It's just too nice to be able to say things like <strong><code>if var1 and var2 or (a &gt; b) [...]</code></strong>.</p>
<p>To me, part of what makes the language special is the ability to bend the evaluator to how we want to read code, vs bending code to fit the evaluator.  The existence of mechanics like quoted parameters are there to let this happen.</p>
<p><em>You don't have to use it.</em>  And the ability to switch it to where AND is a prefix operator that does bitwise math is the magic of the freedom of choice.  You can choose to change the definition even on a module-by-module basis, or on a function-by-function basis.</p>
<p>Further: if you're not bending the language, you're probably not really using it.</p> ]]></description>
        <link>https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791/1</link>
        <pubDate>Fri, 18 Feb 2022 18:34:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5774</guid>
      </item>
      <item>
        <title>Should TRAP and CATCH return null if no fails/throws?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="940">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I made ENTRAP to address the problem of distinguishing errors from other values, by returning ordinary values enclosed in a block (unless it's null, which can't be put in blocks, so the entrapped thing is just null)</p>
</blockquote>
</aside>
<p>The world has changed, so now not only can NULL not be put in a block but neither can isotopes.</p>
<p>But we have a better solution than putting things in a BLOCK!... generic quoting and ^META!</p>
<p>Remember that ^META turns nulls into nulls, isotopes into BAD-WORD!s, and adds a quote level to everything else (including BAD-WORD!s and things that were already QUOTED!).</p>
<p>So now ENTRAP can be a simple usermode function built on top of the multi-return form of TRAP, that offers you either the raised error (if applicable) or the evaluative product:</p>
<pre><code>entrap: func [
    {If evaluation raises an error, return ERROR!...otherwise the ^META result}

    return: [&lt;opt&gt; any-value!]
    code [block! action!]
][
    let [error result]: trap code
    return any [error ^result]
]
</code></pre>
<p>Note that you could also do that as <strong><code>let [error ^result]: trap code</code></strong> and then <strong><code>return any [error result]</code></strong>.</p>
<p>This handles every possibility:</p>
<pre><code>&gt;&gt; entrap [1 / 0]
; gives you an ERROR! for division by zero

&gt;&gt; entrap [make error! "an error that isn't raised"]
; gives you a QUOTED! error, so you know it is just a value

&gt;&gt; entrap [print "Hello"]
; gives you a non-quoted BAD-WORD! for ~none~, so you know it's an isotope!

&gt;&gt; entrap [first [~none~]]
; gives you a singly-quoted bad-word, so you know it *wasn't* an isotope

&gt;&gt; entrap [first ['abc]]
; gives a doubly-QUOTED! word, so you know result was a singly-quoted WORD!
</code></pre>
<p>So you can just test if the result is an ERROR? and if it is, then an error was raised.  And if it's not, you UNMETA it and you will get the value (or leave null alone, as UNMETA is a no-op on NULL).</p>
<p>Pretty elegant!</p>
<p><em>(I'd actually thought of getting rid of ENTRAP, but it's actually very useful, especially when dealing with the "libRebol" API...since it is only really good at giving one value back in the C code...so I'm glad it doesn't have to be a separate codebase and can just piggy-back on top of TRAP.)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/should-trap-and-catch-return-null-if-no-fails-throws/940/7</link>
        <pubDate>Fri, 18 Feb 2022 07:34:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5773</guid>
      </item>
      <item>
        <title>Shall we CONTINUE?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>At some point I added the ability of CONTINUE to take a parameter.  The idea was that CONTINUE with a parameter would act the same as if the loop body had completed with that value.  One place this is most useful is MAP-EACH:</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 2 [continue &lt;twenty&gt;] else [x * 10]
   ]
== [10 &lt;twenty&gt; 30]
</code></pre>
<p>But what should CONTINUE with no argument do?  In the MAP-EACH case, I think it should pretty obviously not add anything to the output.</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 2 [continue] else [x * 10]
   ]
== [10 30]
</code></pre>
<h2>Nice.  But what about "ordinary" loops?</h2>
<p>How about WHILE or REPEAT or FOR-EACH?  If we wanted it to be novel, it could say "don't change the pending overall result from whatever the last loop iteration would have returned":</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
]
== 20
</code></pre>
<p>Although I like that in theory, it would break the loop composition rules unless loops were allowed to be invisible.  :-/</p>
<p>Think about the <a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/18">code I've previously written down</a> to implement FOR-BOTH:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each var blk1 body
        meta for-each var blk2 body
    ]
]
</code></pre>
<p>That FOR-BOTH could not have a CONTINUE that would run in the body of the second FOR-EACH and carry over a value from the first FOR-EACH.</p>
<p>Given that we'd be setting a standard that would be difficult to follow, I think the answer has to be:</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
   ]
== ~none~  ; isotope
</code></pre>
<h2>What about UNTIL and CONTINUE TRUE?</h2>
<p>I've given a rule that CONTINUE passed a parameter effectively jumps to the end of the loop body as if it had finished with that value.  But in UNTIL, the loop's body also is the condition.  So what about:</p>
<pre><code>&gt;&gt; until [print "A" if true [continue true] else [&lt;unreachable&gt;]] print "B"
A
B
</code></pre>
<p>It seems to make a certain amount of sense.</p> ]]></description>
        <link>https://forum.rebol.info/t/shall-we-continue/1790/1</link>
        <pubDate>Wed, 16 Feb 2022 04:10:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5772</guid>
      </item>
      <item>
        <title>About the Semantics category</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>While the "Internals" discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what <strong>do []</strong> should return.</p> ]]></description>
        <link>https://forum.rebol.info/t/about-the-semantics-category/1789/1</link>
        <pubDate>Wed, 16 Feb 2022 03:48:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5771</guid>
      </item>
      <item>
        <title>Syntactically Significant Newlines</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="918">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>JSON came from a Rebol heritage, yet people found it weak weak in a couple of areas. So odd-little YAML has come in to pick up some of that slack:</p>
<p><a href="https://learnxinyminutes.com/docs/yaml/" class="inline-onebox">Learn yaml in Y Minutes</a></p>
</blockquote>
</aside>
<p>I feel like I had a post talking more about YAML but can't find it now...</p>
<p><strong>I definitely think the things that have driven YAML's success are too important to overlook.</strong></p>
<p>Right now when creating data-ish things I often have to write:</p>
<pre><code>status: &lt;foo&gt;
description: {
    Here is some multi-line stuff.
    I can be free-form with the text.
}
widget: &lt;bar&gt;
</code></pre>
<p>But those braces are a tax.  We could take backslash, for instance:</p>
<pre><code>status: &lt;foo&gt;
description: \
    Here is some multi-line stuff.
    I can be free-form with the text.
widget: &lt;bar&gt;
</code></pre>
<p>Or something along those lines.  When I use YAML I am finding myself often thinking "this would be really ugly in Rebol".</p> ]]></description>
        <link>https://forum.rebol.info/t/syntactically-significant-newlines/918/5</link>
        <pubDate>Tue, 15 Feb 2022 13:47:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5770</guid>
      </item>
      <item>
        <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="Cplus" data-post="3" data-topic="1787">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/c/0ea827/40.png" class="avatar"> Cplus:</div>
<blockquote>
<p>It seems somewhat of a wasted opportunity that the language has drifted so far from its initiating vision.</p>
</blockquote>
</aside>
<p>Rebol had a lot of disparate elements, and people latched onto different ones... based on which parts they wanted to believe were the most important.</p>
<p>To some people, the lack of dependencies and not needing an install program was key.</p>
<p>To some people, it was very important that Rebol was cross-platform so they could deploy the same programs to customers on Windows/Linux/Mac.</p>
<p>To some people, they couldn't write a GUI on modern systems with other tools to save their life.  So having a way to get a button on the screen with minimal code and not having to figure out what graphics libraries to pick for their language was key.  <em>(These are people who could have used Visual Basic, but felt it was just getting too bloated and unpredictable, and found they liked other aspects of Rebol better.)</em></p>
<p>To some people--myself included--the notion of having a language you could really bend to whatever task you were doing via dialecting was the main draw.</p>
<p>Anyway: point being there are a lot of ideas in it, and wound up with a lot of wishful thinking and projection being put on an artifact that was ultimately too simple and under-designed to live up to the hype.  Carl called it his "grand experiment"...and I think of the usage of "experiment" in the sense of "this might not work".  Some things have worked out better than one would expect, and others have shown to be fairly intractable in the medium.</p>
<aside class="quote no-group" data-username="Cplus" data-post="3" data-topic="1787">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/c/0ea827/40.png" class="avatar"> Cplus:</div>
<blockquote>
<p>And now - nearly 25 years on - we can share neither information nor programs between even closely-related descendants of that initial release.</p>
</blockquote>
</aside>
<p>Data representation is tough, because the structure of data is often connected in weird ways...which you need graph databases to do correctly.  Trying to represent graph structures in text is a very narrow and limited idea.</p>
<p><strong>I think that JSON took most of the low-hanging fruit of what Rebol's base format could have offered in data exchange, and <a href="https://forum.rebol.info/t/syntactically-significant-newlines/918">YAML has actually stepped in</a> for a lot of places where JSON isn't a fit and shown to be better still.</strong></p>
<p>The fact that Rebol did not set up a clear way to lexically exchange objects left it in a tough situation where I think it often works out to be inferior to JSON for most tasks...despite having some superficial niceties of knowing how to--say--exchange dates.  <em>(More often than not, people wind up needing <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> dates anyway, which shows that Rebol's peculiarities aren't always all they're cracked up to be when working in a world that Rebol is not a standard.)</em></p>
<p>Carl seems to have wanted to rethink the object issue--to the point of sacrificing braced strings--see his ASON:</p>
<p><a href="https://forum.rebol.info/t/carls-new-projects-altscript-altos/1571" class="inline-onebox">Carl's New Projects (?) AltScript, AltOS</a></p>
<p><em>(I considered this, but ultimately decided I thought the braced strings were too foundational to what makes Rebol good...so we'll have to address that weakness some other way.)</em></p>
<p>As a thought experiment it would be great to see if Rebol-to-Rebol data exchanges could have a start-to-finish story where the whole experience is better than JSON, without this:</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245.jpeg" data-download-href="https://forum.rebol.info/uploads/default/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245_2_297x375.jpeg" alt="image" data-base62-sha1="6VwcMBpWYvNwVAACi6aobDTlK7P" width="297" height="375" srcset="https://forum.rebol.info/uploads/default/optimized/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245_2_297x375.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245_2_445x562.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245_2_594x750.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/308d8ef782bc919ecc0e8e5f0ff21d80c7a6e245_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">850×1073 168 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>I've written some thoughts here and there about directions I think things might be able to go in the representation:</p>
<p><a href="https://forum.rebol.info/t/block-and-object-parity-in-pathing-picking/1086" class="inline-onebox">BLOCK! and OBJECT! Parity in Pathing/Picking</a></p> ]]></description>
        <link>https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787/4</link>
        <pubDate>Tue, 15 Feb 2022 12:04:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5769</guid>
      </item>
      <item>
        <title>REBOL 1 Manual</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But I'd guess unless Carl himself has a copy of the source of his old website somewhere, it's gone.</p>
</blockquote>
</aside>
<p><a class="mention" href="/u/gchiu">@gchiu</a> apparently has a printout... perhaps we can scan it and OCR/HTML-ify it.</p>
<p>But given that the Rebol2 manual was pretty light on binding explanation, it might not provide much insight relative to having executables to poke at.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-manual/1788/3</link>
        <pubDate>Tue, 15 Feb 2022 01:20:30 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5768</guid>
      </item>
      <item>
        <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
        <dc:creator><![CDATA[@Cplus]]></dc:creator>
        <description><![CDATA[ <p>It seems somewhat of a wasted opportunity that the language has drifted so far from its initiating vision.</p>
<p>The earliest copy of the <a href="http://Rebol.com" rel="noopener nofollow ugc">Rebol.com</a> home page on <a href="http://Archive.org" rel="noopener nofollow ugc">Archive.org</a> is from May 1998. It contains the sentence:</p>
<p><em>The Relative Expression-Based Object Language (REBOL, pronounced "reh-bul") is the language of inter-communications. It supports both the exchange and interpretation of information, and offers an easy way to share information and programs between people, applications, and computers.</em></p>
<p>And now - nearly 25 years on - we can share neither information nor programs between even closely-related descendants of that initial release.</p>
<p>Such is progress.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787/3</link>
        <pubDate>Mon, 14 Feb 2022 13:24:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5767</guid>
      </item>
      <item>
        <title>REBOL 1 Manual</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1788">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>Will it be possible to share the manual/guide/documentation for REBOL 1 here? It is a piece of history, and it'll be a shame if it just disappears.</p>
</blockquote>
</aside>
<p>It appears that the documentation was HTML files, but Carl didn't make it so you could click through to them without going through a form until version 2.  Hence <a href="http://archive.org">archive.org</a> couldn't scrape it until then:</p>
<p><a href="https://web.archive.org/web/19981212020708/http://rebol.com/">https://web.archive.org/web/19981212020708/http://rebol.com/</a></p>
<p>If it had been a .PDF or something, then someone might have a downloaded a copy and archived it along with the executable.  But I'd guess unless Carl himself has a copy of the source of his old website somewhere, it's gone.</p>
<p>More likely you could find a Rebol 1 executable someone has around.  Though even that might not be as easy to find as one would think.</p>
<blockquote>
<p>I was reading about some of the design choices in REBOL, and came upon Joe Marshall's writings where he talks about the changes between REBOL 1 and 2 (missing continuations, changed scoping rules, absence of tail recursion, etc.)</p>
</blockquote>
<p>If you haven't gotten a chance to read my own most recent thoughts on what binding/scoping can or should be:</p>
<p><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751" class="inline-onebox">Rebol And Scopes: Well, Why Not?</a></p>
<p>That points to the directions I myself want to keep exploring.  <em>(I've been playing hooky for a couple months and not programming.  But have been taking proactive steps like sending my "work" laptop in for its necessary repairs... and am going to arrange for a place to retreat and design/code for a while.)</em></p>
<p>P.S. Please <a href="https://forum.rebol.info/c/introductions/46">feel free to introduce yourself</a>...</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-manual/1788/2</link>
        <pubDate>Mon, 14 Feb 2022 05:17:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5766</guid>
      </item>
      <item>
        <title>REBOL 1 Manual</title>
        <dc:creator><![CDATA[@DefinitionalUsername]]></dc:creator>
        <description><![CDATA[ <p>I was reading about some of the design choices in REBOL, and came upon Joe Marshall's writings where he talks about the changes between REBOL 1 and 2 (missing continuations, changed scoping rules, absence of tail recursion, etc.). This made me curious about the differences between the two version; however, I can't find anything related to REBOL 1 on the internet (save for a Scheme compiler).</p>
<p>Will it be possible to share the manual/guide/documentation for REBOL 1 here? It is a piece of history, and it'll be a shame if it just disappears.</p> ]]></description>
        <link>https://forum.rebol.info/t/rebol-1-manual/1788/1</link>
        <pubDate>Mon, 14 Feb 2022 03:29:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5765</guid>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So I had the idea that <strong>do []</strong> would be <em>conceptually</em> nothing, but represented in some "ornery" reified form.  I was going to represent this with a ~void~ isotope.</p>
<p>But the new revelation I had was that <code>~void~</code> isotopes are best if they are so "unstable" that they disintegrate immediately, only visible with the detector of a <strong>^META</strong> step.  Won't rehash the good reasons for that here:</p>
<p><a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782" class="inline-onebox">Pure vs. Impure Invisibility: Do We Need Both?</a></p>
<p><strong>This doesn't have to crush the idea:</strong> ~none~ isotopes can fulfill the role previously theorized for the ~void~ isotope.  Because isn't that essentially what PRINT returning a <code>~none~</code> isotope means?  <em>"I don't have a useful result, I'd be invisible except for the fact that might be confusing...and someday I might want to have a result that means something."</em></p>
<p>But ANY and ALL no longer need to vaporize ~void~ isotopes... they vaporize themselves.  So this needs to be revisited:</p>
<blockquote>
<p>"I think ANY and ALL are the kinds of construct that become more interesting if they vaporize ~void~ isotopes...and if ALL returns a ~void~ isotope itself if its contents all vaporize!"</p>
<p>"The idea this brings back is the concept of having a third option for value-returning functions... so truthy, falsey, and "opt out". But opting out is not conflated with nullness or unsetness, and it doesn't force unsafe "vanishing" semantics."</p>
</blockquote>
<p>It turned out to be a refreshing simplification when I ripped out the weird code in ANY and ALL to try and facilitate treating ~void~ isotopes as invisible.  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:"></p>
<p>If you wish, you could write a version of ANY that actually vanished if it got a block of nothingness.</p>
<pre><code>&gt;&gt; 1 + 2 vanishable-any [1020 null]
== 1020

&gt;&gt; 1 + 2 vanishable-any []
== 3
</code></pre>
<p>But I think we're likely better off making vanishing of ~none~ isotopes explicit, akin to what used to be called "DEVOID" when ~void~ isotopes were reified/ornery:</p>
<pre><code>&gt;&gt; ~none~
== ~none~  ; isotope

&gt;&gt; 1 + 2 ~none~
== ~none~  ; isotope

&gt;&gt; 1 + 2 none-to-void ~none~
== 3

&gt;&gt; any []
== ~none~  ; isotope

&gt;&gt; 1 + 2 none-to-void any [1020 null]
== 1020

&gt;&gt; 1 + 2 any []
== ~none~  ; isotope

&gt;&gt; 1 + 2 none-to-void any []
== 3
</code></pre>
<p><em>(NONE-TO-VOID is not a perfect name...but I'd consider it a better choice than DENONE.  Other ideas welcome.  VANISHABLE?)</em></p>
<p>You could have a corresponding construct which turned ~none~ into NULL.  Notice that Rebol2 and Red both decided that <strong>any []</strong> should be their concept of BLANK! (e.g. legacy "none").  If you wanted something akin to that via a "NONE-TO-NULL", you could have it:</p>
<pre><code>&gt;&gt; any []
== ~none~  ; isotope

&gt;&gt; none-to-null any []
; null
</code></pre>
<h2>What About The "Loop Control Protocol"?</h2>
<p>I think this policy makes reasonable sense for loops that never run:</p>
<pre><code>&gt;&gt; while [false] [1 + 2]
== ~none~  ; isotope
</code></pre>
<p>Though it aliases with loops that return none incidentally from their bodies:</p>
<pre><code>&gt;&gt; repeat 1 [print "Remember PRINT returns ~none~ isotope"]
Remember PRINT returns ~none~ isotope
== ~none~  ; isotope
</code></pre>
<p>If that's a problem for you then you can force some other return result from the loop body:</p>
<pre><code>&gt;&gt; repeat 1 [print "Control your result", true]
Control your result
== #[true]
</code></pre>
<p>NULL is still the unique signal to say the loop encountered a BREAK, which makes it easier to make composite loops that are sequences of other loops.</p>
<p>But there's no unique signal to say the loop never ran...only that the overall loop operation "provided no meaningful result".  This can play well with NONE-TO-VOID and NONE-TO-NULL</p>
<h2>Today's Loop Story Gets Even Better... <img src="https://forum.rebol.info/images/emoji/twitter/heavy_heart_exclamation.png?v=9" title=":heavy_heart_exclamation:" class="emoji" alt=":heavy_heart_exclamation:">
</h2>
<p>Consider my classic example of a composite loop that actually iterates over two collections:</p>
<pre><code> &gt;&gt; for-both x [1 2] [3 4] [print ["x is" x], &lt;result&gt;]
 x is 1
 x is 2
 x is 3
 x is 4
 == &lt;result&gt;

&gt;&gt; for-both x [1 2] [3 4] [print ["x is" x], if x = 2 [break]]
x is 1
x is 2
; null

&gt;&gt; for-both x [] [] [print ["x is" x], &lt;result&gt;]
== ~none~  ; isotope
</code></pre>
<p><strong>Trying to write something like FOR-BOTH in historical Redbol and get coherent behavior for BREAK for an arbitrary loop body is effectively impossible.</strong>  (If anyone wants to troll Red, ask them how to do it and watch them give you scrambled broken solutions.)  But modern Ren-C has it covered!</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each :var blk1 body
        meta for-each :var blk2 body
    ]
]
</code></pre>
<p><strong>This isn't that hard to understand:</strong> Remember that META leaves NULL as NULL...turns isotopic BAD-WORD!s into plain BAD-WORD!s...and quotes all other values one level.  So here you're getting a pass through of non-null values, with NULL able to skip past the second loop if a break is signaled in the first loop.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_teacher.png?v=9" title=":man_teacher:" class="emoji only-emoji" alt=":man_teacher:"></p>
<p><em>(Actually needs a small tweak because plain BAD-WORD! is neither true nor false at this time and would need to be truthy, but I will make that change given this new obvious indicator they must be truthy...they're ornery enough by not being accepted as an argument to things like APPEND.)</em></p>
<h2>So That Settles It</h2>
<pre><code>&gt;&gt; first [~none~]
== ~none~

&gt;&gt; if (first [~none~]) [print "plain BAD-WORD! now truthy."]
plain BAD-WORD~ now truthy

&gt;&gt; ~none~
== ~none~  ; isotope (not displayed by console)

&gt;&gt; if ~none~ [print "non-meta arguments can't be isotopes"]
** Script Error: if needs condition as ^META for ~none~ isotope

&gt;&gt; print "The die is cast"
The die is cast
== ~none~  ; isotope (not displayed by console)

&gt;&gt; do []
== ~none~  ; isotope (not displayed by console)

&gt;&gt; while [false] [&lt;never-runs&gt;]
== ~none~  ; isotope (not displayed by console)
</code></pre>
<p>We'll have to debate whether it's a good idea for REDUCE to allow ~none~ isotopes to be converted into plain ~none~ BAD-WORD!s without you asking to do so explicitly:</p>
<pre><code>&gt;&gt; reduce [1 + 2 print "Good or bad idea?"]
Good or bad idea?
== [3 ~none~]
</code></pre>
<p>The conservative decision would be to make people use some function like REIFY to get that.</p>
<p><strong>In the end, the sum of the decisions involved in building the solution shows that persistence ultimately pays off... and the pursuit of non-softball problems like building a 100% correct FOR-BOTH out of two FOR-EACH loops has lent Ren-C its true power.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/18</link>
        <pubDate>Fri, 11 Feb 2022 12:42:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5764</guid>
      </item>
      <item>
        <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The term "Ren" (REadable Notation) was an initiative from--I believe--Gregg Irwin and Rebolek, where the idea was to standardize notations between Rebol and Red in a similar way to how JSON was standardized... then allowing other languages (like Python or JavaScript) be able to read the messages as well:</p>
<p><a href="https://pointillistic.com/ren/">https://pointillistic.com/ren/</a></p>
<p>Since that was in the air at the time...and my fork wouldn't/couldn't be called Rebol(tm), the idea was to embrace the idea and call itself "Ren-C" to be the C implementation of that data structure.</p>
<p>That was long ago.  And you won't hear the term "Ren" thrown around by Red much anymore.  And with consensus designs between the projects out the window, it's clear Ren-C is overdue for a name change.  <em>(But you don't get a second chance to make a first impression, so no point in announcing a new name unless there's a bigger announcement to accompany it.)</em></p>
<p>...point of the above being...</p>
<blockquote>
<p>The very basics - MOLD and SAVE are almost in place.</p>
</blockquote>
<p>...I don't know how close we're going to get on this.</p>
<p>Ren-C hopes to be a <em>kind-of-superset</em>.  So far, the superset is an emulation layer I call "Redbol", and that emulation becomes more difficult as we go along.  (Though I have some ideas.)</p>
<blockquote>
<p>The "binary" equivalent with some form of compatible REBBIN is surely not that hard to agree between the two sets of developers.</p>
</blockquote>
<p>I'd say it's very hard if redbin attempts to capture objects and (I think?) binding.  Binding is going to be very different, as summarized in:</p>
<p><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751" class="inline-onebox">Rebol And Scopes: Well, Why Not?</a></p>
<aside class="quote no-group" data-username="Cplus" data-post="1" data-topic="1787">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/c/0ea827/40.png" class="avatar"> Cplus:</div>
<blockquote>
<p>Fuller, fluid, message passing - for example the seamless invoking of functions and continuations within a running instance of the other language would be an important demonstration of the REBOL cousins' languages abilities to do what they have stated is a desired characteristic of their respective dialects of REBOL.</p>
</blockquote>
</aside>
<p>I understand feeling there must be some teachable moment to be found on what essence of shared concepts and syntax both Ren-C and Red find so critical as to not throw out.</p>
<p><em>Despite understanding someone having the feeling that should be true...</em> the reality is that interoperability is likely to get worse and not better.  Less will work in the future than works today.</p>
<p>It may be a subset of what could be called "Ren" could be read and written by both.  Important to note is that JSON is typically parsed and not "LOAD"-ed as code even by JavaScript, so similar premises could apply there.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787/2</link>
        <pubDate>Fri, 11 Feb 2022 11:08:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5763</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was split to a new topic: <a href="/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787">Could Ren-C and Red Interoperate (and if so, <em>should</em> they?)</a></p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/5</link>
        <pubDate>Fri, 11 Feb 2022 05:59:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5762</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="johnk" data-post="6" data-topic="1786">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/johnk/40/229_2.png" class="avatar"> johnk:</div>
<blockquote>
<p>Browsable Archive now located on github pages here:</p>
</blockquote>
</aside>
<p>Wow--thank you!  It's comforting to think that if I get hit by a bus these ideas will still be somewhere out there...  <img src="https://forum.rebol.info/images/emoji/twitter/bus.png?v=9" title=":bus:" class="emoji" alt=":bus:"></p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/7</link>
        <pubDate>Sun, 06 Feb 2022 12:37:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5761</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>Done. Browsable Archive now located on github pages here:<br>
<a href="https://johnk-.github.io/forum.rebol.info/index.html">https://johnk-.github.io/forum.rebol.info/index.html</a><br>
I am just running this from my laptop for the moment on a weekly cron job (and I have added a few delays to reduce the server load).<br>
Not the most robust approach, but it should do for the moment. I think we have moved the risk of losing the forum content a few points down the scale.<br>
-John</p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/6</link>
        <pubDate>Sun, 06 Feb 2022 03:10:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5760</guid>
      </item>
      <item>
        <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
        <dc:creator><![CDATA[@Cplus]]></dc:creator>
        <description><![CDATA[ <p>When this year can we expect to see full "message passing" inter-operability between Ren-C and Red?</p>
<p>The very basics - MOLD and SAVE are almost in place.</p>
<p>The "binary" equivalent with some form of compatible REBBIN is surely not that hard to agree between the two sets of developers.</p>
<p>Fuller, fluid, message passing - for example the seamless invoking of functions and continuations within a running instance of the other language would be an important demonstration of the REBOL cousins' languages abilities to do what they have stated is a desired characteristic of their respective dialects of REBOL.</p>
<p>This would also harness the strengths of both dialects - for each has been focused these last few years on different arenas. Together, they have the makings of a formidable whole.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787/1</link>
        <pubDate>Fri, 04 Feb 2022 19:20:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5759</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>Happy New Year and thanks for the excellent update.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1786">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>(Makes me think of the <a href="https://en.wikipedia.org/wiki/Conservation_status">species extinction risk scale</a>. Sure, the source code is on GitHub, and the topic list of this forum seems to be on the Internet Archive...but if you click through to individual pages there's nothing about the post contents. Should we do a scrape of the data here and put it elsewhere?)</p>
</blockquote>
</aside>
<p>Following this <code>wget</code> suggestion (<a href="https://meta.discourse.org/t/how-to-create-a-read-only-archive-version-of-discourse-content/139256" class="inline-onebox">How to create a read only, archive version of discourse content - support - Discourse Meta</a>) I just quickly did a full scrape of this forum (public posts only). It works very well.<br>
All the best, John</p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/4</link>
        <pubDate>Fri, 04 Feb 2022 01:08:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5758</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Like it is said, "if you do what everyone else is doing, you will get the same as all of them".<br>
The lack of continuity on the posts of the f00 team is legendary, and combined with the prioritised goals it is encouraging many to wander on.<br>
The dynamics of REN-C, changing even core behavior if seen as a promising experiment is on the complete other end of the spectrum. Not suitable for many seeking an alternative to the library madness, where using even for standard functionality refuge is sought in external API's, for their stable project needs.</p>
<p>Fortunately I am very busy with my new career, but as a downside almost no devtime. But still like what I am doing, so must do more now ... <img src="https://forum.rebol.info/images/emoji/twitter/smiley.png?v=9" title=":smiley:" class="emoji" alt=":smiley:"></p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/3</link>
        <pubDate>Thu, 03 Feb 2022 19:56:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5757</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A little addendum from one of my recent favorite YouTubers, Joel Haver, on doing what you love:</p>
<div class="onebox lazyYT lazyYT-container" data-youtube-id="BizvIhp5clM" data-youtube-title="Some Scattered Thoughts on Doing What You Love" data-parameters="feature=oembed&amp;wmode=opaque">
  <a href="https://www.youtube.com/watch?v=BizvIhp5clM" target="_blank" rel="noopener">
    <img class="ytp-thumbnail-image" src="https://i.ytimg.com/vi/BizvIhp5clM/maxresdefault.jpg" title="Some Scattered Thoughts on Doing What You Love" width="480" height="360">
  </a>
</div>

<p>And I think that is a good meditation on not really deviating from the parts of this that I find interesting, but staying that course...even if it takes time.</p>
<p>So I'll try and promise to keep doing the parts that impress me.  And someday, it might find an audience.</p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/2</link>
        <pubDate>Tue, 01 Feb 2022 07:16:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5756</guid>
      </item>
      <item>
        <title>Belated 2021 Post-Mortem + New Years 2022 Vision 🤹</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h1>Happy 2022!</h1>
<p><strong>...and I Hope Your New Year's Was Better Than Mine...</strong> <img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji" alt=":man_facepalming:"></p>
<p>Though I've spent most of the last few New Years Days (and this last one) traveling and in some hotel...I've usually gotten myself a nice supply of beer, and worked start-to-finish through a post.  I talk about what worked and didn't work, and where things might go next.  Although it generally takes the greater part of a day to write those, it's in some ways kind of a fun thing to write...and I was always pleased to beat Red to the punch with accomplishments I found more impressive.</p>
<p><em>This year felt unfortunately different.</em>  I had a big wave of pessimism for all kinds of reasons--ranging from personal relationships, to my new laptop screen getting cracked when it was in my bag...to just a general feeling that the world is going to hell in a handbasket.</p>
<p><strong><img src="https://forum.rebol.info/images/emoji/twitter/skull.png?v=9" title=":skull:" class="emoji" alt=":skull:"> ...But It's Not As Grim As All That... <img src="https://forum.rebol.info/images/emoji/twitter/potato.png?v=9" title=":potato:" class="emoji" alt=":potato:"></strong></p>
<p>After eating a ridiculous potato from <a href="https://stpeterising.com/home/2021/9/16/a-loaded-baked-potato-restaurant-the-half-baked-potato-is-coming-soon-to-downtown-st-pete">A Hipster Potato Restaurant In St. Petersburg</a>--and inadvisedly drinking 2 Sugar-Free Red Bulls--my stomach and brain weren't going to sleep for a long time.</p>
<p>Though traveling makes retrieving a repaired laptop on an extended warranty difficult, I still had my old laptop with me.  So I dug it out, and found an unfinished post about a seemingly-esoteric point about invisible evaluations and void isotopes.  <a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782">Some deep realizations clicked into place</a>.  Those realizations led to a proud thought:</p>
<p><strong>2021 was the year of invention for BAD-WORD!s, "isotopes", and ^META.  While the older invention of NULL was akin to mathematicians inventing zero to solve previously hard problems... <em>isotopes and meta-transformations are like the invention of imaginary numbers</em>.</strong></p>
<p>Having that energy boost put me on a slight incline toward positive thinking.  Enough so that I'm pushing out a New Year's post before the calendar ticks over to February... here goes:</p>
<h2>UPARSE Is Already a Big Success Story</h2>
<p>Many who use Rebol got addicted because of PARSE.  But people who work with other languages and parser combinators have wondered what the big deal is.  Though Rebol's PARSE is a literate alternative to simple RegEx scenarios, it's weak at building high level structures from smaller simpler parsers--<em>there are too many inconveniences in writing reusable rules</em>.</p>
<p>UPARSE stands for <a href="https://github.com/metaeducation/ren-c/blob/26752e701d9585a7dd5bb1c4cb2e78c901908c5b/src/mezz/uparse.reb"><em>(U)sermode PARSE</em></a> and to me it deals Rebol back in the parsing game:</p>
<ul>
<li>
<p>It keeps the classic feel of PARSE alive, while bringing its power up to the level of combinators in other languages.  Arbitrary values can be synthesized from processing the input, instead of just data captures at the level of the input series.</p>
</li>
<li>
<p>You can come up with "new keywords" without waiting for someone to do so.  These are expressed as ordinary functions with multiple return values, and hence can be optimized as natives.</p>
</li>
<li>
<p>The behavior of values of certain datatypes themselves can be overridden, to bend parsing to entirely different meanings.</p>
</li>
<li>
<p>It has a <a href="https://github.com/metaeducation/ren-c/blob/26752e701d9585a7dd5bb1c4cb2e78c901908c5b/tests/parse/examples/maxmatch.parse.test.reb">generic architecture for rolling back the effects of combinators</a>, with a default behavior that lets the average combinator author avoid the details if they just want any failure to roll back everything in the order it was done.</p>
</li>
<li>
<p>As a proof of its flexibility, a Rebol2/Red-compatible combinator set is defined.</p>
</li>
</ul>
<p><strong>But besides the combinators, the usermode implementation of the UPARSE engine itself that composes and runs them is as much of the story as anything else.</strong>  Rebol has had a shaky history of giving usermode code the same perceptive power as what could be done from C...and that can be as basic as how to tell the difference between <strong>[a b #[none]]</strong> and <strong>[a b]</strong> with looking at the result of THIRD of the block.  All these upgrades come into the mix in UPARSE...from FRAME! mechanics and specializations to ^META and isotopes and generic quoting.</p>
<p>On the downside: it hasn't been optimized much yet, so the performance is abysmal...and a lot of work is left to do on error messages.  But seeing how to build a dialect in this way--where it's not like you have to be a C programmer, but you can wire together the pieces--is the "Minecraft of Programming" I talk about.</p>
<h2>The <a href="https://forum.rebol.info/t/the-new-ren-c-github-action-run-natively-run-on-web/1562">Ren-C GitHub Action</a> Has Been Amazing</h2>
<p>Although it required me gritting my teeth through some JavaScript programming, we now have a turnkey way to install an up to date interpreter with a line of code on a cloud runner for Mac, Linux, and Windows...as well as run automation of the latest web build.</p>
<p>It's a big force multiplier, and it's helped with testing the <a href="https://forum.rebol.info/t/whitespace-interpreter-revisited/1482">Whitespace Interpreter Dialect</a> and the <a href="https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713">USCII Dialect</a>...both of which received major updates this year.  When Redbol examples are given they often risk merely showing the language is capable of generic computation and if you put enough hours into it then you might get something that sort-of-works.  But I feel these are approaching good examples of the form--where they lay out the particular power and composability that Ren-C has been angling for.</p>
<h2>
<a href="https://forum.rebol.info/t/devices-are-gone-but-what-were-they/1692">Devices are Gone</a> and <a href="https://forum.rebol.info/t/libuv-integration-has-started-an-i-o-renaissance/1694">now it's all libUV</a>
</h2>
<p>I think that libUV pretty much represents the objectives of what Carl might have wanted a device layer to be.  Not only is it pure C code that can be built with things like the TinyC compiler, it compiles for esoteric platforms like Haiku.  It's something Rebol might well have used had it been around.</p>
<p>And the web build doesn't use libUV at all--accomplishing its network reads and such through completely different mechanisms.  So it shows the language is staying pure and repurposeable on platforms that don't have threads or whatever dependencies libUV requires.  A simple stripped down version could just offer C stdio (for instance).</p>
<p>There's a long way to go for our usage of libUV to live up to its potential.  But it gives the foundations for doing things like a <a href="https://forum.rebol.info/t/semantics-of-read-and-tcp-streams-past-and-future/1733">good version of async IO, where you code in a synchronous style</a>.  (I've explained that I think the old WAIT/AWAKE model really <a href="https://forum.rebol.info/t/the-weirdness-of-wait/1703">represented a dead end</a>, and so it had to be ripped out).</p>
<h2>
<a href="https://forum.rebol.info/t/the-sea-of-words/1564"><em>Sea of Words</em></a> and Customizable Modularization Arrives</h2>
<p>What was supposed to be unique about Rebol's modules was that the code that processed headers would be like a dialect.  That dialect was processed by usermode code, and you could write your own spin on it if you had some other idea of how you wanted modularization to work.</p>
<p>It's early yet to really say for sure how the mechanics behind this will evolve.  But there have been big steps taken--and the personal success I feel is how the test dialect can create modules out of individual tests.  So the test files are really making thousands upon thousands of isolating contexts, and when the tests are done running the user context is not contaminated at all.  This makes the tests less subject to weird side effects from each other...keeps things tidy...and is overall good for the garbage collector as well.</p>
<p>Disconnecting the use of words from the creation of variables is good for all the reasons I cite.  I've been very happy with that idea, though what "attachment" to a context means has design work to do.  Make no mistake--this is a process of invention--and so it's going to be weird and take time.</p>
<h2>
<a href="https://forum.rebol.info/t/get-set-vs-pick-poke-whats-the-difference/1719">PICK and POKE and Pathing Are Resolved</a> (I Think)</h2>
<p>I've struggled since very early on to tame "path dispatch", which was very oddly shaped.  I'm not going to rehash all of the thought process.  But I'm pleased with the outcome, and I think it will generalize well to extension types.</p>
<h2>First Try At String Binding + Interpolation</h2>
<p>It isn't there yet, but it has been prototyped.  I've written up a post about where I think binding/scoping has to go:</p>
<p><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751" class="inline-onebox">Rebol And Scopes: Well, Why Not?</a></p>
<p>There are still no easy answers.  But there's good news about having so many complex codebases in play (like UPARSE, whitespace dialect, etc.) that are not throwing softballs at the language.  If new binding concepts add functionality but don't break any of that, that's a good sign it may be good.</p>
<h2>...A Lot Of Other Stuff Happened...</h2>
<p>This is just a mini list of some of the things I find most notable to call out. As usual, you can scroll through posts or commit logs to see more.</p>
<p>But I also got the chance to visit <a class="mention" href="/u/blackattr">@BlackATTR</a> and meet his family and dogs, so that was fun.  We got some work done on his QUERY dialect, but more to go.</p>
<p>I managed to get ODBC and webserver bugs fixed for <a class="mention" href="/u/gchiu">@gchiu</a> so he could do a demo, and to put it on GitHub Actions with tests.</p>
<hr>
<h1>What Hangs in the Balance for 2022?</h1>
<p>I mentioned my bad New Years, and reading <a href="https://www.red-lang.org/2021/12/2021-winding-down.html">Red's New Years post</a> did not help, because it felt so incredibly <em>cyclic</em>.  Seeing them start a New Year by long-windedly plagiarizing <a href="https://forum.rebol.info/t/back-to-personal-computing/186">Back to Personal Computing</a>... <em>again</em>... made me fear their man-years of toil without heeding advice or warnings has grown no audience for either their work, nor Ren-C's inventions.  Their formerly active YCombinator group had a collective yawn about it...<a href="https://news.ycombinator.com/item?id=29758024">one comment</a> at time of writing, so they seem to be slipping off the radar...even though they are much less research-oriented and more "give-the-people-what-they-want-right-now" oriented (in theory).</p>
<p>Apologies to Gregg Irwin for ranting at him.  <strong>But we/I sadly can't count on Red to keep an audience alive for Redbols, as the old guard moves on and new people aren't there to replace them.</strong>  And I'm not a marketer, especially since I fundamentally disagree with the way social media power structures work.  So Ren-C's cool creations are at high risk of not even making it to <a class="mention" href="/u/blackattr">@BlackATTR</a>'s "bad"-case outcome of becoming <em>"a museum piece like the Antikythera mechanism."</em></p>
<p><em>(Makes me think of the <a href="https://en.wikipedia.org/wiki/Conservation_status">species extinction risk scale</a>.  Sure, the source code is on GitHub, and the topic list of this forum seems to be on the Internet Archive...but if you click through to individual pages there's nothing about the post contents.  Should we do a scrape of the data here and put it elsewhere?)</em></p>
<p>I have always been able to consider the notion that Rebol's fundamental idea is flawed and it <em>should</em> die out.  In fact: I started out getting involved in Rebol <em>to prove to Reichart that it was bad</em>, and using it for Qtask was misguided.  My attempts to construct that proof ran up against the fact that its odd plasticity and choice to throw out the rulebook on what a computer language is-or-should-be gave it a slippery yet timeless nature...like English itself.</p>
<p><strong>But given the bus-factor-of-one nature of Ren-C, I should probably be thinking more about how to communicate that to new audiences, vs. going too deeply into an engineering project where I try to re-graft Ren-C onto a Go-like runtime model.</strong></p>
<p>So maybe I need to be better about making YouTube videos, packaging demos, and showing off the existing infrastructure.  <strong>When I look at other WebAssembly language projects, we actually still compare favorably.</strong>  And maybe I'm too quiet about it for fear of looking a fool for all the things that I know aren't working right.  Still...my confidence increases as I've been moving the architecture around to try and steer away from the obviously bad ideas, in a way that new people coming in would be able to shore up missing pieces.</p>
<h2>...Predictions Are Hard To Make</h2>
<p>It probably looks as if I've been notoriously bad at predicting what things are going to get accomplished.  I'd wanted 2021 to hopefully be when stacklessness got integrated, and I wanted to see progress on debugging.  And it may seem like none of that happened.</p>
<p>But sometimes progress is subtle.  There were major barriers to making R3-Alpha's PARSE architecture stackless, but the UPARSE design is much more amenable to it.  So I think the answer will just be that we'll skip stackless PARSE3 and just assume UPARSE is the future of PARSE.</p>
<p>And when it comes to debugging, I demonstrated some <a href="https://forum.rebol.info/t/getting-hooks-into-events-during-parse/1640/5">impressive tracing in UPARSE</a> that works today...which is the sort of thing a user can customize.  Understanding how dialect authors are going to be able to hook and trace their dialects ties in a lot to seeing a big picture of how the evaluator itself might be traced, so all of this really does plug together.</p>
<p>Nevertheless, I feel skeptical of making new predictions.  Especially because here in 2022: <em>Realistically speaking, so long as I'm traveling and trying to find a new home base it's hard to get very much done.</em>  I've chosen to travel in Florida because things are open for business despite the existence of coronavirii...and that aligns with my belief that being vaccinated and boostered is enough to have a social life.  That means I am out maskless indoors doing a fair number of things with people...and changing locations every few days.  It may be a while before I can really focus on coding.</p>
<h2>So Let's Put Predictions On Hold, at least until I have a <img src="https://forum.rebol.info/images/emoji/twitter/derelict_house.png?v=9" title=":derelict_house:" class="emoji" alt=":derelict_house:">
</h2>
<p>One thing that's been working so far, it's my mandate on continuous integration and keeping all the things that are supposed to work, working, as new experiments are tried.  This is not a natural habit for the personality type that programs in Rebol.  People drawn to the language are not <em>"correct-by-construction"</em> folks, more like Larry The Cable Guy "Git-R-Done" mentality.</p>
<p>I want to keep developing <a class="mention" href="/u/blackattr">@BlackATTR</a>'s QUERY and make it part of that "everything is kept working" strategy.</p>
<p>All of <a class="mention" href="/u/gchiu">@gchiu</a>'s projects, as well.  And my USCII, Whitespacers, <code>hostilefork.com</code> itself, etc.  Anything I can convince <a class="mention" href="/u/giuliolunati">@giuliolunati</a> to put in a GitHub workflow, as well!</p>
<p>I want to re-commit to <a href="http://rebmu.hostilefork.com/">Rebmu</a>, also, and make it part of the CI tests.  It might seem like I am always putting this off--even though I claim to say it's one of the big motivators, the <em>"great code golf game in the sky"</em> that I say I'm pursuing.  (When have you seen me solve a puzzle or develop it lately?)  But it's actually in the back of my mind, always.</p>
<p>It was nice with Whitespace to actually draw some attention from a curator of <a href="https://github.com/wspace/corpus">collections of implementations of whitespace</a>... <a class="mention" href="/u/aarchi">@aarchi</a>.  He said he found it to be one of the more interesting examples, and that's always been my goal with this.  To build on the novelty of the medium and give people a new tool to think.  (Recently re-watching that movie <a href="https://www.youtube.com/watch?v=8Fc-7SuebTQ">"Arrival"</a> and the "language/weapon/tool" bit.)</p>
<p>I'm a few minutes from February so I'll just close by saying: continue automating, continue examples, and maybe do a bit more YouTube evangelism.  I'll keep frittering with the mechanics.  And get my laptop fixed (!)</p> ]]></description>
        <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786/1</link>
        <pubDate>Tue, 01 Feb 2022 04:49:12 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5755</guid>
      </item>
      <item>
        <title>Understanding Definitional Scoping</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Hello there... thanks for your question, and no need to be sorry.  Questions are well warranted.</p>
<p>(Note that I take no responsibility for the madness that is Rebol--I just happen to hack on a derivative of the open source codebase because I have found various interesting aspects about it.  :-P)</p>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1785">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>First, when the code is compiled</p>
</blockquote>
</aside>
<p>Rebol is interpreted--not compiled.  (Red attempts to do some compilation, and I'm unclear on how that works...you will have to ask them.)</p>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1785">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p><strong>Load-time:</strong> When the code is loaded, context <strong>A</strong> is created with those symbols as members.</p>
</blockquote>
</aside>
<p>It's probably dumber than you think.  Not only is there no "compile-time", "load-time" isn't where the binding happens.  It all happens at run time.</p>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1785">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>if <code>a: 2</code> didn't exist, will it still create the slot for <code>a</code> due to <code>a: 3</code> deep inside?</p>
</blockquote>
</aside>
<p>CONTEXT is an alias in historical Rebol for MAKE OBJECT! and the behavior of that is that it only searches one level of depth symbolically for SET-WORD!s to gather.</p>
<p>Deeper walks are possible.  The concept behind R3-Alpha and Red's FUNCTION is that it searches deeply the body for any SET-WORD!s and assumes they should be local variables.  This creates the problems you would expect: a nested function's locals will be picked up as locals in the outer function, and SET-WORD!s used in the body incidentally as object members or for dialect purposes will also be picked up.  This is why Ren-C has LET and does runtime variable instantiation which runs in a wave (virtual binding), you can't sensibly calculate a static concept of what symbols are variables or not.</p>
<p>Ren-C is quite different from Rebol, and so answers will vary significantly, if you find that you care about the difference.</p>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1785">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>Did <code>context</code> bind <code>a</code> in <code>[/local a]</code> too, before <code>func</code> was executed?</p>
</blockquote>
</aside>
<p>No, CONTEXT was merely looking for symbolic SET-WORD! tokens at one level of depth underneath it.  <strong><code>a</code></strong> is a plain WORD!, and it's in a block one level deep, so that's two strikes.</p>
<aside class="quote no-group" data-username="DefinitionalUsername" data-post="1" data-topic="1785">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/d/aeb1de/40.png" class="avatar"> DefinitionalUsername:</div>
<blockquote>
<p>Is there a parent-child relationship between contexts, or are they free-standing? Given a context, can I chase some pointer to its parent or child?</p>
</blockquote>
</aside>
<p>Contexts inherit keylists as an implementation detail for efficiency, and it's weaker than v8 hidden classes.</p>
<p><a href="https://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html" class="inline-onebox">Javascript Hidden Classes and Inline Caching in V8</a></p>
<p>I have thought hidden classes might be better, at times, but then again that would complicate the code.  And part of the point is to let everyone understand the stack.  It's a thought experiment.</p>
<p>Rebol was written to be a brutishly simple C '89 codebase and a lot of the "interesting" aspects were higher-order studies on top of an interpreter that worked better than you would think for how dumb it was.</p>
<p>My take is to call it "Amish Programming", you may find my talk at the 2019 conference useful if you're getting your bearings.</p>
<p><a href="http://2019.reb4.me/talks" class="inline-onebox">Talks | Rebol [2019]</a></p> ]]></description>
        <link>https://forum.rebol.info/t/understanding-definitional-scoping/1785/2</link>
        <pubDate>Mon, 24 Jan 2022 12:11:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-5754</guid>
      </item>
  </channel>
</rss>

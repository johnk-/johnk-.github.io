<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>PARSE vs. Haskell&#39;s (X)PARSEC</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>By contrast, Rebol parsers are completely specified ahead of time.</p>
</blockquote>
</aside>
<p>A constrained parse dialect could be a parser generator, and the constrained dialect could probably subset the unconstrained one pretty closely.</p>
<p>But unconstrained PARSE as-we've-known-it is quite dynamic.  I've tried to nail down some minimal rules for the sake of coherence:</p>
<p><a href="https://forum.rebol.info/t/when-should-parse-notice-changes/1528" class="inline-onebox">When Should PARSE Notice Changes</a></p>
<aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I think there is definite untapped potential for Ren-C to be better than Haskell, at least in one of these metrics.</p>
</blockquote>
</aside>
<p>My main point of view that where this fits in the "Loom of Language" is packaging this kind of methodology in a way that brings it to the common programmer, using naught but mostly-C89.  A kind of <em>"organic, locally-sourced software"</em> without inscrutable additives and preservatives.  I want it to be constructed obviously and my performance goals are modest--seeing it as a toy almost more than anything.</p>
<p>This is in contrast to fairly bold claims about the pervasive applicability of the medium, believed by Carl and Red.</p>
<p>Ultimately if it gets used by others, it won't be up to me.  I don't know if you read Graydon Hoare's bit on Rust going in a direction he didn't envision--but that his vision probably had no realistic future:</p>
<p><a href="https://graydon2.dreamwidth.org/307291.html">https://graydon2.dreamwidth.org/307291.html</a></p>
<p>Maybe my more humble framing isn't the way the world will take it.  I don't know, but I'm glad you see potential in it!</p> ]]></description>
        <link>https://forum.rebol.info/t/parse-vs-haskells-x-parsec/1321#post_4</link>
        <pubDate>Fri, 15 Mar 2024 00:19:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7254</guid>
      </item>
      <item>
        <title>PARSE vs. Haskell&#39;s (X)PARSEC</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Forget the idea of ever competing on performance or rigor. No way.</p>
</blockquote>
</aside>
<p>As a Haskeller, I don’t actually think this is valid. I think there is definite untapped potential for Ren-C to be better than Haskell, at least in one of these metrics.</p>
<p>Firstly: note that parser combinators were not always ‘blazing fast’. There was a time when they were considered almost unusably slow. <a href="https://forum.rebol.info/t/haskell-parser-combinators/2173">As I’ve said</a>, the Haskell community needed to find the right trade-offs to get the speed up to where it is now… and I’ve definitely met people who think those trade-offs aren’t worth it (even if I personally do).</p>
<p>But also: it’s worth thinking a little closely about how Haskell parser combinators get that ‘rigor’. In large part, they do it by building everything off a set of well-defined abstractions: <code>Monad</code>, <code>Alternative</code>, and so on. This gives a flexible and reliable toolkit for composing parsers together, from which flows many other advantages.</p>
<p>But this approach has some disadvantages as well. The most prominent is that these particular abstractions can be, in some sense, ‘<em>too</em> big’: they might give parsers capabilities you might not want. In this case, the main culprit is <code>Monad</code>, which gives parsers the ability to depend arbitrarily on the results of earlier parsers. On the one hand, this allows context-sensitive parsing — but on the other, it makes static analysis impossible.</p>
<p>By contrast, Rebol parsers are completely specified ahead of time. You can inspect at the BLOCK! which is passed to PARSE or UPARSE, and see ahead-of-time the entire control flow of the parser. That gives you the opportunity to do clever optimisations… such as, let’s say, precompiling the whole parser into an ultra-fast LR lookup table. Even in Haskell, many people prefer to use such <a href="https://en.wikipedia.org/wiki/Compiler-compiler">parser generators</a> over parser combinators, despite the clunkiness it adds — a parser generator <em>embedded into the language itself</em> would be pretty amazing to use.</p>
<p>You can think of more creative uses too, of course. For instance, the Red people have used this capability <a href="https://www.red-lang.org/2020/03/gtk-fast-lexer-money-deep-testing-and.html">to generate railroad diagrams</a>, another thing Haskell parser combinator libraries can’t do.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But since Haskell is compiled, you don't get the opportunity to build parse rules dynamically.</p>
</blockquote>
</aside>
<p>I’m not <em>quite</em> sure what you’re referring to here… but if I understand you correctly, this sounds equivalent in power to what the <code>Monad</code> interface gives you. Most parser combinator libraries will allow you to alter the parser on-the-fly in crazy ways, if you really want to do so.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1321">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I thought Haskell parsers were network-stream-capable out of the box...e.g. that they would have an intelligent formulation so you could parse an infinite number of data items one at a time. But nearly all of the parsers--including Megaparsec--require all the data to be in memory from the beginning (the way Rebol PARSE does today). Even the parsers that are "incremental" hold onto all the historical input in case they need to backtrack...whether the rules need to or not. <em>I've found some research pointing to architectures of doing this better...<a href="https://www.cs.tufts.edu/~nr/cs257/archive/doaitse-swierstra/combinator-parsing-tutorial.pdf">see Section 4 of this paper</a></em></p>
</blockquote>
</aside>
<p>This is another one of those tradeoffs. To support arbitrary backtracking in a parser combinator system, you need to store the text to backtrack over. You can just <em>not store</em> that text, but then you can’t do any backtracking (or in more technical terms, you’re restricted to LL(1) grammars). So this is another place where Rebol potentially has an advantage, since it can analyse the parser before running it.</p> ]]></description>
        <link>https://forum.rebol.info/t/parse-vs-haskells-x-parsec/1321#post_3</link>
        <pubDate>Tue, 12 Mar 2024 08:58:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7253</guid>
      </item>
      <item>
        <title>Haskell parser combinators</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I've written a little here before:</p>
<p><a href="https://forum.rebol.info/t/parse-vs-haskells-x-parsec/1321">PARSE vs. Haskell's (X)PARSEC</a></p>
</blockquote>
</aside>
<p>Interesting, thanks! After reading it, I do have a few thoughts, but I’ll reply in that thread.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One thing to notice is that UPARSE doesn't have a <em><strong>sequencing</strong></em> combinator. Instead, it has a <em><strong>BLOCK!</strong></em> combinator.</p>
</blockquote>
</aside>
<p>Sure, but I wasn’t aiming to describe Rebol there.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>UPARSE adds in another element to BLOCK!'s recognized-literally vocabulary of <strong><code>||</code></strong></p>
</blockquote>
</aside>
<p>This certainly is neat. Reminds me a bit of Haskell’s <code>($)</code> operator, but more flexible.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p><code>string "word 1" &lt;|&gt; string "word 2"</code> no longer works: as soon as this parser sees <code>'w'</code>, it matches the first parser, so the second parser will never be run.</p>
</blockquote>
</aside>
<p>Seems unfortunate that the default is biased that way, and you have to tack on more to get the likely-intended meaning.</p>
</blockquote>
</aside>
<p>But on the other hand, this approach greatly improves performance, and makes control flow far more manageable. From my experience using parser combinators, the trade-off is well worth it.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>There was significant discussion on what to call the "0 or more" combinator. Historical Redbol called this ANY and I did not like that […] But I do not like MANY either--it might be worse. Ultimately I decided that OPTIONAL SOME (or OPT SOME) is just what you would write out.</p>
</blockquote>
</aside>
<p>In Haskell, <code>many</code> is just the conventional term which has stuck. Haskell tends to care much less about names than Rebol does, probably because the types and the syntax carry so much more information.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">return :: a -&gt; Parser a
return a = Parser $ \input -&gt; Just (input, a)
</code></pre>
</blockquote>
</aside>
<p>To prematurely return a result from UPARSE (without requiring reaching the end of input), the ACCEPT combinator can be used.</p>
</blockquote>
</aside>
<p>Apologies, I should have made this clearer. <code>return</code> in Haskell does <strong>not</strong> prematurely return a result. It simply takes a value and hoists it into a monadic context. In this case, <code>return value</code> is a parser which consumes no characters and always succeeds, yielding the result <code>value</code> as it does so.</p>
<p>(Note that <code>return</code> has the alias name <code>pure</code>. Arguably that’s a less confusing name, and I should have used it.)</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">-- sequencing ignoring result
(&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q
</code></pre>
</blockquote>
</aside>
<p>UPARSE combinators can synthesize antiforms, including NIHIL. So there's an ELIDE combinator.</p>
<pre><code class="lang-plaintext">&gt;&gt; parse [a b a b b c c] [accumulate ['a | 'b], some 'c]
== c

&gt;&gt; parse [a b a b b c c] [accumulate ['a | 'b], elide some 'c]
== [a b a b b]
</code></pre>
</blockquote>
</aside>
<p>Again, this is something I should have been clearer about. Haskell <code>(&gt;&gt;)</code> is simply the equivalent of  Rebol COMMA!.</p>
<p>In this case, <code>(&gt;&gt;)</code> is used to write the equivalent of your first example, not your second. In Haskell, these would be:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">parser1 = many (char 'a' &lt;|&gt; char 'b') &gt;&gt; some (char 'c')
parser2 = many (char 'a' &lt;|&gt; char 'b') &gt;&gt;= \result -&gt; (some (char 'c') &gt;&gt; return result)
</code></pre>
<p>Although in practice we have another operator <code>(&lt;*)</code> to make that second example a bit shorter: <code>many (…) &lt;* some (char 'c')</code>.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The most useful thing is bringing this outside perspective to the sort of "people who grew up on C64 BASIC" who tend to populate and design Rebol.</p>
</blockquote>
</aside>
<p>Yep, you understand my intentions!</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The big areas where ideas are needed most are in error delivery</p>
</blockquote>
</aside>
<p>Some parser combinator libraries have interesting strategies for error handling, so that might be worth a look. I know that the paper I linked summarises the basic ideas around how that works. (If I get time, perhaps I can investigate further and write it up here.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>what the story is for binding tools within parse to help dialect authors accomplish cool things easily</p>
</blockquote>
</aside>
<p>Haskell is well-suited in this regard, because it has so many well-specified abstractions for combining things together. (e.g., many libraries implement parsers as monad transformers.) And of course parsers are simply ordinary values, so it’s easy to manipulate them using the rest of the language.</p>
<p>By contrast, I’ve always felt this is the limitation of dialecting: the elements of a dialect are just words in a block, rather than first-class values of the language. Rebol has parse specifications, but the ‘parsers’ themselves don’t actually exist outside the call to <code>uparse</code>. There may be some solution to this problem, but I’m not sure what it is.</p> ]]></description>
        <link>https://forum.rebol.info/t/haskell-parser-combinators/2173#post_3</link>
        <pubDate>Tue, 12 Mar 2024 08:29:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7252</guid>
      </item>
      <item>
        <title>Haskell parser combinators</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Thank you for summarizing!  I've written a little here before:</p>
<p><a href="https://forum.rebol.info/t/parse-vs-haskells-x-parsec/1321" class="inline-onebox">PARSE vs. Haskell's (X)PARSEC</a></p>
<p>Parser combinators were not an influence on the original Rebol PARSE (circa 90s), but were what I drew inspiration from for UPARSE.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">(&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a
p &lt;|&gt; q = Parser $ \input -&gt;
    case runParser p input of
        Just result -&gt; Just result
        Nothing -&gt; runParser q input
</code></pre>
</blockquote>
</aside>
<p>One thing to notice is that UPARSE doesn't have a <em><strong>sequencing</strong></em> combinator.  Instead, it has a <em><strong>BLOCK!</strong></em> combinator.</p>
<p>And it's the BLOCK! combinator that generally does the "combinating".  It can technically be replaced, but it is the most complex combinator and so difficult to replace entirely... it's almost like the block combinator <em>is</em> UPARSE.  So it is more likely that it would be augmented vs. people wanting to rewrite it entirely.</p>
<p>When one of the parsers the block combinator has "combinated" fails, it then scans literally for the next <strong><code>|</code></strong> in the input and starts applying rules there.  This is true also historical Redbol, in that you can write any old (LOAD-able) gibberish after a failing rule, due to the skipping:</p>
<pre><code>red&gt;&gt; parse "aaa" [some "b" fhqwhgads ??? | some "a"]
== true
</code></pre>
<p>(Should a debug mode exist that runs through and ensures these regions will combinate, just not call the parsers?  Probably not in this language paradigm.  Mismatching rules can guard against dereferencing undefined variables and such, and that's kind of how the whole language works... it's modeling clay.)</p>
<p>UPARSE adds in another element to BLOCK!'s recognized-literally vocabulary of <strong><code>||</code></strong>, that is a synonym for putting everything to the left of it in a block:</p>
<pre><code>[rule1 | rule2 | rule3 || rule4]
=&gt;
[[rule1 | rule2 | rule3] rule4]

[rule1 | rule2 || rule3 | rule4 || rule5]
=&gt;
[[rule1 | rule2] [rule3 | rule4] rule5]
</code></pre>
<p>(Well, it's a synonym so long as you haven't redefined the BLOCK! combinator itself to other meanings, but if you did you might also redefine <code>||</code> while you're at it.)</p>
<p>Anyway, I'm rather fond of <code>||</code>.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p><code>string "word 1" &lt;|&gt; string "word 2"</code> no longer works: as soon as this parser sees <code>'w'</code>, it matches the first parser, so the second parser will never be run.</p>
</blockquote>
</aside>
<p>Seems unfortunate that the default is biased that way, and you have to tack on more to get the likely-intended meaning.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">-- 0 or more
many :: Parser a -&gt; Parser [a]
many p = some p &lt;|&gt; return []
</code></pre>
</blockquote>
</aside>
<p>There was significant discussion on what to call the "0 or more" combinator.  Historical Redbol called this ANY and I did not like that (<a href="https://forum.rebol.info/t/the-cool-new-repurposing-of-any-in-parse/1662">instead pursuing an ANY that is aligned with the ANY construct in the language</a>).</p>
<p>But I do not like MANY either--it might be worse.  Ultimately I decided that OPTIONAL SOME (or OPT SOME) is just what you would write out.</p>
<p>On the linguistic front, we don't have a word for "zero or more" in English, and maybe there is a reason for that.  What I found in going through replacing the old "ANY"=&gt;"OPT SOME" was that there were a lot of cases where someone reached for ANY when it actually wasn't a zero-or-more situation, so I liked it being explicit.</p>
<p>Many cases I looked at tidied up (and by many I mean many, not zero). I found this code removing 0 or more newlines at the head of a series via ANY:</p>
<pre><code class="lang-plaintext">parse series [
    remove [any newline]
    ...
]
</code></pre>
<p>But when you rephrase this with OPT SOME it suggests a better factoring:</p>
<pre><code class="lang-plaintext">parse series [
    remove [opt some newline]
    ...
]
</code></pre>
<p>It reads clearest when you bring the OPT outside, to say you're <em>optionally removing some newlines</em>:</p>
<pre><code class="lang-plaintext">parse series [
    opt remove [some newline]
    ...
]
</code></pre>
<p>Plus it's now more obvious that the whole expression will be NULL in the case when no newlines are removed, and leverage that.</p>
<p>Note that the block is not necessary there:</p>
<pre><code class="lang-plaintext">parse series [
    opt remove some newline
    ...
]
</code></pre>
<p>And shows a bit of the dynamics of choice we like about the medium.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">return :: a -&gt; Parser a
return a = Parser $ \input -&gt; Just (input, a)
</code></pre>
</blockquote>
</aside>
<p>To prematurely return a result from UPARSE (without requiring reaching the end of input), the ACCEPT combinator can be used.</p>
<pre><code>&gt;&gt; parse [a b c 10 20 &lt;d&gt;] [some [word! | integer!]]
** Error: PARSE partially matched the input, but didn't reach the tail

&gt;&gt; parse [a b c 10 20 &lt;d&gt;] [some [word! | accept integer!]]
== 10

&gt;&gt; parse [a b c 10 20 &lt;d&gt;] [some [word! | accept [let i: integer! accept (i * 3)]]]
== 30
</code></pre>
<p>R3-Alpha added this as "RETURN", but Red doesn't seem to have carried that forward.  I like using a different word.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code class="lang-plaintext">-- sequencing ignoring result
(&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q
</code></pre>
</blockquote>
</aside>
<p>UPARSE combinators can synthesize antiforms, including NIHIL.  So there's an ELIDE combinator.</p>
<pre><code>&gt;&gt; parse [a b a b b c c] [accumulate ['a | 'b], some 'c]
== c

&gt;&gt; parse [a b a b b c c] [accumulate ['a | 'b], elide some 'c]
== [a b a b b]
</code></pre>
<p>This is particularly helpful to reach for in cases where an ACCEPT that returned prematurely would not complete your match.  e.g. you synthesized your result, but you still have more matching to do, and want to avoid the inconvenience of making and naming a variable for the synthesized result and then evaluating to it at the end.</p>
<p><em>(Note that COMMA! doesn't do anything, they are skipped by the BLOCK! combinator so long as they are between combinated parsers.  <strong>some "a", some "b"</strong> is legal but not <strong>some, "a" some, "b"</strong>).</em></p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>It holds onto the input string during the whole time <code>p</code> is executing. This creates a space leak, which grows larger the more nested choices you have.</p>
</blockquote>
</aside>
<p>Rebol PARSE has lots of performance issues.  e.g. when doing something like a seek, a block rule is re-applied at each location:</p>
<pre><code>red&gt;&gt; parse "aaaaab" [thru [(print "testing") "b"]]
testing
testing
testing
testing
testing
testing
== true
</code></pre>
<p>There are attempts in historical Rebol and Red to try and optimize where possible, e.g. the implementation of <strong><code>to "b"</code></strong> optimizes the find to do a faster seek for the pattern.  But you lose that optimization as soon as you change it to <strong><code>to ["b"]</code></strong>, and it recurses the parser.</p>
<p>Ren-C dials things up to 11, including the crappy performance.  UPARSE is knowingly painfully turtle slow, because it is really just a sketch of the architecture for how parser combinators would be done.  But as its broken up into functions, those functions can be rewritten as native C when the time comes (though I want to make sure the usermode implementations are kept in sync and can be swapped in and still work equivalently--so I imagine maintaining each usermode combinator and its C implementation in the same file).</p>
<p>I also want to make sure all the right hooks are in place to do things like stepwise debugging:</p>
<p><a href="https://forum.rebol.info/t/replpad-visual-parse-debugger/2063" class="inline-onebox">ReplPad Visual PARSE Debugger</a></p>
<p>But I'm trying to put that together as part of a bigger story of what kind of infrastructure exists for dialect debugging and debugging in the main language (e.g. you'd be able to "step in" to a dialect at the Rebol instructions--like an assembly view--or at the level the dialect offers).</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2173">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>What use is this for Rebol?</p>
<p>Quite probably, none at all.</p>
</blockquote>
</aside>
<p>The most useful thing is bringing this outside perspective to the sort of "people who grew up on C64 BASIC" who tend to populate and design Rebol.  (You've already usefully pointed out that OPTIONAL is a perfectly acceptable word and explained the Haskell sense of TRY...)</p>
<p>Like I say above, the UPARSE design is still very much prototype-y.  It's at the "amazing it works at all" phase, though it's already the most tested PARSE variant by far (e.g. <a href="https://forum.rebol.info/t/making-red-tests-useful-starting-uparse-on-the-right-foot/1649">by subsuming Red's PARSE tests</a>).  But by being all usermode code, it's still at the point where there's plasticity in the design to incorporate new ideas.</p>
<p>The big areas where ideas are needed most are in error delivery, and what the story is for binding tools within parse to help dialect authors accomplish cool things easily.  And any architectural ideas to bolster performance (while still keeping the pleasing ergonomics) would be welcome.</p> ]]></description>
        <link>https://forum.rebol.info/t/haskell-parser-combinators/2173#post_2</link>
        <pubDate>Tue, 12 Mar 2024 05:24:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7251</guid>
      </item>
      <item>
        <title>Haskell parser combinators</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I’ve seen a few parsing-related threads recently in this forum. I haven’t been commenting much on them, since I don’t have enough experience with UPARSE (or for that matter historical PARSE) to say anything helpful.</p>
<p>On the other hand, I <em>do</em> have a lot of experience with parser combinators in Haskell. In terms of structure and purpose, they’re probably the concept most similar to UPARSE that I’ve seen from another language. So I thought I’d write this post in the hope that something, somewhere, might eventually prove useful somehow.</p>
<h2>
<a name="high-level-overview-1" class="anchor" href="https://forum.rebol.info#high-level-overview-1"></a>High-level overview</h2>
<p>The first and most important thing to realise about parser combinators is that <strong>they’re not built into the language</strong>. They’re simply ordinary libraries which make it easy to construct parsers compositionally.</p>
<p>(I mean, for that matter, UPARSE isn’t built in either. But there’s a different level of integration with the rest of the language.)</p>
<p>The basic approach is to define a new datatype for parsers, usually called something like <code>Parser a</code>. This is a parser which can process a string (or other datatype), returning a result of type <code>a</code> if it succeeds. Alongside this there will be a set of primitive parsers, most notably <code>char</code> (to parse single characters), <code>return</code> (which always succeeds with a result), and <code>empty</code> (which always fails).</p>
<p>(Of course, practical libraries will have more primitives. <code>megaparsec</code> has <a href="https://hackage.haskell.org/package/megaparsec-9.6.1/docs/Text-Megaparsec.html#g:4">a nice selection</a>, with good comments.)</p>
<p>The most interesting bit is the way these parser combinators are combined to create larger parsers. This, of course, relies on the standard abstractions of Haskell. Two operators are particularly important:</p>
<ul>
<li>Sequencing: <code>p &gt;&gt;= f</code> is a parser which runs <code>p</code> and passes the result to function <code>f</code>, then runs the resulting parser.</li>
<li>Choice: <code>p &lt;|&gt; q</code> is a parser which runs <code>p</code>, then backtracks and runs <code>q</code> if that failed.</li>
</ul>
<p>From these basic elements you can define a very wide range of generic combinators, for instance these useful ones:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">-- sequencing ignoring result
(&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q

-- Match a whole string
string :: String -&gt; Parser ()
string "" = return ()
string (c:cs) = char c &gt;&gt; string cs

-- 1 or more
some :: Parser a -&gt; Parser [a]
some p =
    p &gt;&gt;= \first -&gt;
    many p &gt;&gt;= \rest -&gt;
    return (first : rest)

-- 0 or more
many :: Parser a -&gt; Parser [a]
many p = some p &lt;|&gt; return []
</code></pre>
<h2>
<a name="a-basic-implementation-2" class="anchor" href="https://forum.rebol.info#a-basic-implementation-2"></a>A basic implementation</h2>
<p>This is all a little abstract, though. Probably the easiest way to understand parser combinators is to implement them.</p>
<p>A basic implementation is quite simple. A parser is just a function which takes in a string, and on success returns the result alongside the unparsed portion of the string:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">newtype Parser a = Parser (String -&gt; Maybe (String, a))
</code></pre>
<p>You then run the parser simply by unwrapping the function and applying it to your input:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">runParser :: Parser a -&gt; String -&gt; Maybe (String, a)
runParser (Parser p) input = p input
</code></pre>
<p>Simple parsers work as you’d expect:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">char :: Char -&gt; Parser ()
char c = Parser $ \input -&gt; case input of
    (c':cs) | c == c' -&gt; Just (cs, ())
    _ -&gt; Nothing

return :: a -&gt; Parser a
return a = Parser $ \input -&gt; Just (input, a)

empty :: Parser a
empty = Parser $ \_ -&gt; Nothing
</code></pre>
<p>The combinators require more elaborate state-threading, but are still straightforward:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">(&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
p &gt;&gt;= f = Parser $ \input -&gt;
    case runParser p input of
        Nothing -&gt; Nothing
        Just (partiallyParsed, a) -&gt;
            runParser (f a) partiallyParsed

(&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a
p &lt;|&gt; q = Parser $ \input -&gt;
    case runParser p input of
        Just result -&gt; Just result
        Nothing -&gt; runParser q input
</code></pre>
<p>This simple code suffices for a surprisingly wide variety of tasks. For instance, a slight variant is present in the base library as <a href="https://hackage.haskell.org/package/base-4.16.3.0/docs/Text-Read.html#t:ReadS"><code>ReadS</code></a>. (The variation is that <code>ReadS</code> can produce multiple results.)</p>
<h2>
<a name="managing-backtracking-3" class="anchor" href="https://forum.rebol.info#managing-backtracking-3"></a>Managing backtracking</h2>
<p>Unfortunately, <strong>this has serious problems with any larger-scale use</strong>. For one thing, it can’t do error reporting beyond ‘it failed somewhere’. But there are even bigger problems with this implementation of the choice combinator <code>(&lt;|&gt;)</code>:</p>
<ol>
<li>It behaves unpredictably: any error anywhere will result in the parser backtracking to the last choice, and so on until every single choice has been exhausted. This is bad for the time complexity, plus it leaves you no chance of ever reporting errors nicely.</li>
<li>It holds onto the input string during the whole time <code>p</code> is executing. This creates a space leak, which grows larger the more nested choices you have.</li>
</ol>
<p>The first parser combinator library to solve these issues was <code>Parsec</code>. Its design is described in <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf">this paper</a> (which seems very readable). I won’t describe its implementation here… but the basic idea is simple to summarise: each parser keeps track of what it’s consumed, and <strong>commits to a parser as soon as it’s consumed any characters</strong>.</p>
<p>Some parsers require no changes under this new semantics. For instance, <code>string "first word" &lt;|&gt; string "second word"</code> works without problems. If it sees an input character <code>f</code>, the first choice <code>string "first word"</code> matches immediately, meaning the library can commit to the first parser, and know that the second parser never needs to run. On the other hand, upon seeing an input character <code>'s'</code>, that first parser will fail on that very first character: since no characters have been consumed, control passes over to the second parser to succeed or fail.</p>
<p>On the other hand, more elaborate lookahead becomes more difficult. For instance, <code>string "word 1" &lt;|&gt; string "word 2"</code> no longer works: as soon as this parser sees <code>'w'</code>, it matches the first parser, so the second parser will never be run.</p>
<p>To solve this, Parsec introduces a new primitive combinator: <code>try</code>, which creates a parser which never consumes characters on failure. The effect of this is to allow backtracking over whatever is in the <code>try</code>. For this example, <code>try (string "word 1") &lt;|&gt; string "word 2"</code> would work as expected.</p>
<p>The nice thing about this approach is the control it gives you. For instance, I can write things like:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">(try (string "App") &gt;&gt; string "le") &lt;|&gt; string "Apricot"
</code></pre>
<p>Here, as soon as the parser reaches a second <code>'p'</code>, it can commit to the first branch. But if it sees another character, it’s still able to backtrack through the <code>string "App"</code> and move on to the second branch. Of course, this is a contrived example — but in general, being able to specify the control flow of your parser like this is exceedingly useful in larger parsers.</p>
<h2>
<a name="what-use-is-this-for-rebol-4" class="anchor" href="https://forum.rebol.info#what-use-is-this-for-rebol-4"></a>What use is this for Rebol?</h2>
<p>Quite probably, none at all.</p>
<p>But like I said, I’m hoping potentially some of this might end up useful somewhere. If it can act as inspiration which helps solve any problems, I’m happy.</p>
<p>And, of course, now that we have this thread for it, feel free to ask me any questions about parser combinators you might have!</p> ]]></description>
        <link>https://forum.rebol.info/t/haskell-parser-combinators/2173#post_1</link>
        <pubDate>Mon, 11 Mar 2024 15:08:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7250</guid>
      </item>
      <item>
        <title>-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2172">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> might argue such mechanics shouldn't be necessary, because source-level non-evaluation should be explicit, e.g. <strong><code>'x -&gt; [...]</code></strong></p>
</blockquote>
</aside>
<p>I’ve come to accept that this idea has valid usecases. It’s still not my favourite design choice, but I’m OK with it.</p> ]]></description>
        <link>https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172#post_3</link>
        <pubDate>Mon, 11 Mar 2024 00:37:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7249</guid>
      </item>
      <item>
        <title>Implicit Capture In PARSE - How To Get It?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1718">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm nearly certain we'll have <strong>$word</strong>, <strong>$[bl o ck]</strong>, <strong>$(gr o up)</strong> and friends. Maybe that?</p>
<pre><code>parse isodate [$year "-" $month "-" $day "T" ...]
</code></pre>
<p>Though since the general meaning would be "get-environment-variable" this would raise questions about dialects bending the meaning of things so severely.</p>
<p><em>It Feels Weak To Not Have An Answer For This</em></p>
</blockquote>
</aside>
<p>As it happens, we do now have the $XXX types.  And they do not mean "environment variable" in the main evaluator... they relate to applying the "current binding" of the evaluator onto the thing in hand.</p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; get 'x
** Error: x is not bound

&gt;&gt; get $x
== 10
</code></pre>
<p>As far as PARSE goes, "capture thing at current position into a variable" is still a compelling thing to do succinctly.  Though having $ not related to binding would be a loss (given that we know that there need to be some binding assistance for propagating binding while parsing, to keep dialect implementation from being too much of a hassle.)</p>
<p><em>So could it be both?</em>  Could $xxx capture the current thing, and apply the binding (if applicable?)  Binding wouldn't be applicable to strings (though it could if you reached the string via a SUBPARSE of a block).</p>
<p>Don't know, just wanted to give this thread a bump since $ types exist now.</p> ]]></description>
        <link>https://forum.rebol.info/t/implicit-capture-in-parse-how-to-get-it/1718#post_2</link>
        <pubDate>Sun, 10 Mar 2024 20:57:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7248</guid>
      </item>
      <item>
        <title>-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2172">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code class="lang-plaintext">y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then (lambda [x] [
    assert [x = &lt;yes&gt;]
    1000 + 20
])
assert [y = 1020]
</code></pre>
</blockquote>
</aside>
<p>I remembered while writing this that you have to put branches in GROUP!s, because branches are "soft-quoted" slots (or, more accurately "soft literal") slots.</p>
<p>The reason you don't have to put the <strong><code>-&gt;</code></strong> form in groups when you use them as branches is because there's deference to a leftward-literal operation in a soft-literal slot.  The left literal beats the right literal.</p>
<p>But this has a cost: <em>you're paying to generate the function whether it gets called or not</em>.</p>
<p>Historical Rebol has this problem anywhere functions are passed as handlers.  Consider TRY/EXCEPT in R3-Alpha:</p>
<pre><code>r3-alpha&gt;&gt; try/except [1 / 0] func [e] [print ["Error Handler:" form e/id]]  
Error Handler: zero-divide
</code></pre>
<p>Putting it in a GROUP! won't help there, because /EXCEPT doesn't suppress any evaluation from that GROUP!.  But in Ren-C, branches are literal, so the groups can be used to suppress the evaluation unless the branch runs.</p>
<h2>
<a name="is-making-uncalled-unpacking-lambdas-a-problem-1" class="anchor" href="https://forum.rebol.info#is-making-uncalled-unpacking-lambdas-a-problem-1"></a>Is Making Uncalled (Unpacking-) Lambdas A Problem?</h2>
<p>That depends...</p>
<ol>
<li>
<p>does an unpacking lambda make a deep copy of the block?</p>
</li>
<li>
<p>or does it just make a small structure that pairs the name of the parameter(s) with the body of code?</p>
</li>
</ol>
<p>Today's it's [2]... <strong><code>-&gt;</code></strong> just makes that small structure (while LAMBDA makes the full copy).  But this means you get the semantics of a non-copying construct:</p>
<pre><code>&gt;&gt; block: [print ["Hello" x]]

&gt;&gt; one: x -&gt; block

&gt;&gt; append block spread [print ["Goodbye" x]]

&gt;&gt; two: x -&gt; block

&gt;&gt; one 1020
Hello 1020
Goodbye 1020

&gt;&gt; two 1020
Hello 1020
Goodbye 1020
</code></pre>
<p>So you would have to say <strong><code>x -&gt; copy/deep block</code></strong> to get a unique copy of the body.</p>
<p>Beyond the semantic implications of not copying, there's a performance implication if you call it more than once... because the <a href="https://forum.rebol.info/t/semantics-and-optimization-of-copying-function-bodies/2119">preparations that make the body a little faster to call</a> that happen during the copy are not done.</p>
<p>There are some other options like going in some strange "branch dialected" direction, and say that BLOCK!s with a certain format were "parameterized", moving the parameter name into the block somehow, not necessarily this but like this:</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then [x -&gt;
    assert [x = &lt;yes&gt;]
    1000 + 20
]
</code></pre>
<p>I'd rather put every parameterized branch in a group than do that.</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then (x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
])
</code></pre>
<p>But still, no.  It's much better to push on optimizations of the stylized function generation so that it's cheap as can be to make regardless of the branch being taken, <em>it's the source we want to write</em>:</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
</code></pre>
<p>Just another devil in the details to worry over.  But wanted to write up a reminder of why plain LAMBDA has to be in a GROUP! if you're going to use it in a branch, because I'd forgotten you had to do that.</p> ]]></description>
        <link>https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172#post_2</link>
        <pubDate>Sun, 10 Mar 2024 19:02:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7247</guid>
      </item>
      <item>
        <title>-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So I'm still shoring up a new bootstrap executable, patching around in a 6-years-out-of-date codebase.   It's in some ways a cruel and unusual punishment... but in other ways a good trip down memory lane to revisit decisions that were made, and ask "was that the right decision?"</p>
<p>The 6-year-old EXE defined an enfix form of lambda as <strong><code>=&gt;</code></strong>.  I shifted it to the lighter form as <strong><code>-&gt;</code></strong>.  Contrast:</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then (lambda [x] [
    assert [x = &lt;yes&gt;]
    1000 + 20
])
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x =&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p><em>(Supplemental: Reddit post on <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/shllr3/whats_the_syntax_of_lambda_expressions_in_your/">"What's the syntax of lambda expressions in your language"</a>)</em></p>
<p><strong>I like the <code>-&gt;</code> and don't think there's a greater purpose for it in the box.</strong>  As with everything else, overriding it is a personal choice.</p>
<h2>
<a name="a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1" class="anchor" href="https://forum.rebol.info#a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1"></a>A <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">Speaking-With-Tics</a> Note</h2>
<p>Mechanically getting this to work is non-trivial:</p>
<p><a href="https://forum.rebol.info/t/the-most-vexing-evaluation-lambda-meets-then-else/1361" class="inline-onebox">The Most Vexing Evaluation: LAMBDA meets THEN/ELSE</a></p>
<p>Part of what makes it non-trivial is the "literal lookback" by which <strong><code>-&gt;</code></strong> infixedly snatches the X without letting it evaluate.</p>
<p><a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> might argue such mechanics shouldn't be necessary, because source-level non-evaluation should be explicit, e.g. <strong><code>'x -&gt; [...]</code></strong></p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then 'x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p>But that's one more stroke of key than I want, and one more piece of dirt than I want to see.  <em>I know from context that slot is a variable name, in the most common case.</em>  I'm not upset by intricate work to faciliate it, if it actually works (and empowers other creative things).  So I need to see hard disproofs before sacrificing what I consider to be "the point" of the design.</p>
<p>I'm always ready to look at it from a further perspective to see a "greater point".  But still--from where I stand--that apostrophe sucks relative to not having it.  (And if you read the details of the implementation post, the only reason it's allowed to work in a quoted slot is because of left literalism, so...)</p>
<h2>
<a name="what-about-multiple-arguments-2" class="anchor" href="https://forum.rebol.info#what-about-multiple-arguments-2"></a>What About Multiple Arguments?</h2>
<p>Notationally there are questions about this form of lambda.  Does it use a block for multiple arguments?</p>
<pre><code>&gt;&gt; foo: [a b] -&gt; [a + b + 20]

&gt;&gt; foo 400 600
== 1020
</code></pre>
<p>It could, but you could be weirder:</p>
<pre><code>foo: a.b -&gt; [a + b + 20]

foo: a/b -&gt; [a + b + 20]
</code></pre>
<p>This would look a little tighter with branching, I think, since it wouldn't compete with the branches:</p>
<pre><code>case [
    ...
] then [a b] -&gt; [
    ...
]

case [
    ...
] then a.b -&gt; [
    ...
]
</code></pre>
<p><em>But wait, you'd never use it with a branch... because a branch only produces one value.</em></p>
<p>UNLESS... what if what this form of lambda did was unpack packs?</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]  ; makes antiform ~['30 '7]~
    ...
] then [a b] -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a -&gt; [
    assert [a = 30]
]
</code></pre>
<p>So I've been thinking this is what it should actually do.  It means -&gt; won't be a good way to define functions or lambdas generally, but you have FUNC(TION) and LAMBDA for that.</p>
<p>I don't know that enabling a lighter notation like <strong><code>a.b</code></strong> or <strong><code>a/b</code></strong> is worth it.</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a.b -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a/b -&gt; [
    assert [a = 30, b = 7]
]
</code></pre>
<p>Maybe just confusing, and limits what you can put in the spec.  Easier to add later if it seems useful than put it in now and take out later.</p>
<h2>
<a name="is-there-a-good-name-for-lambda-lite-3" class="anchor" href="https://forum.rebol.info#is-there-a-good-name-for-lambda-lite-3"></a>Is There A Good Name For "Lambda Lite"?</h2>
<p>We could call it an "unpacking lambda".  Maybe it's controlled with a refinement:</p>
<pre><code> &gt;&gt; foo: lambda/unpack [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :lambda/unpack</code></strong></p>
<p>We could just call it <em>"an unpacker"</em>.</p>
<pre><code> &gt;&gt; foo: unpacker [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :unpacker</code></strong></p>
<p>The problem with calling it an "unpacker" is that 9 (or more) times out of 10 it will only take a single argument and not unpack anything.  So it seems better to classify it as a shade of distinction on lambda, but still when you point to an <code>-&gt;</code> on the screen say <em>"then it passes the argument to the lambda..."</em></p> ]]></description>
        <link>https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172#post_1</link>
        <pubDate>Sun, 10 Mar 2024 15:21:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7246</guid>
      </item>
      <item>
        <title>REIFY and DEGRADE: a Narrower META and UNMETA</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2163">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think that I've settled on the name for the function that turns quasiforms into antiforms, but leaves everything else alone: <strong>DEGRADE</strong>...and its complement <strong>REIFY</strong></p>
</blockquote>
</aside>
<p>I guess I should have an answer to the question of why I didn't pair REIFY with UNREIFY.</p>
<p>Uh, maybe it should be called that?</p>
<p>The rationale in my head was something like:</p>
<ul>
<li>
<p>"oh, it's not always UNREIFY-ing, it leaves non-quasi things in their plain forms".  But it's not "always degrading" either.</p>
</li>
<li>
<p>UNREIFY doesn't scan well as a word (but UNMETA does?)</p>
</li>
</ul>
<p>There's an implicit meaning here where it's "REIFY-ANTIFORMS" and "UNREIFY-QUASIFORMS".  Something about REIFY only applying to antiforms makes clear intuitive sense (you don't need to reify a WORD!, it's already reified).  But you could imagine UNREIFY-ing a WORD! and getting an antiform word.  So the "-QUASIFORMS" is not as obvious.</p>
<p>I'm not 100% confident that the benefit of choosing a word besides UNREIFY is worth breaking the pairing, but DEGRADE is less off-putting in the source.  So it's what I went with.</p> ]]></description>
        <link>https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163#post_2</link>
        <pubDate>Sat, 09 Mar 2024 15:32:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7245</guid>
      </item>
      <item>
        <title>Could we replace PARSE&#39;s OPT with TRY ?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Haskell has <strong><a href="https://hackage.haskell.org/package/parsers-0.12.10/docs/Text-Parser-Combinators.html#v:try">try</a></strong> defined as <em>"Take a parser that may consume input, and on failure, go back to where we started and fail as if we didn't consume input."</em></p>
<p>If I'm reading that correctly, this is a parallel meaning to OPT.</p>
</blockquote>
</aside>
<p>Just as a quick note: you’ve read this wrong. (Though to be fair it’s a bad comment from a little-used library.) The <em>actual</em> function of <code>try</code> is, ‘allow this parser to be rolled back on failure’. The stuff about ‘consuming input’ comes from a subtlety of parser combinator implementation, which is that they commit to a sub-parser as soon as it consumes a single element.</p>
<p>Of course, Haskell libraries must still offer a combinator for optional elements, which may be either present or absent. It’s an important aspect of parsing, after all. And they call it… <a href="https://hackage.haskell.org/package/parser-combinators-1.3.0/docs/Control-Monad-Combinators.html#v:optional"><code>optional</code></a>.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-we-replace-parses-opt-with-try/1888#post_7</link>
        <pubDate>Sat, 09 Mar 2024 12:40:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7244</guid>
      </item>
      <item>
        <title>Could we replace PARSE&#39;s OPT with TRY ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'd been letting this turn over in my head a bit before committing to it</p>
</blockquote>
</aside>
<p>So...we've had a good 7 months of TRY replacing OPT for me to get a truly informed feeling.</p>
<p><em><strong>Getting cold feet... <img src="https://forum.rebol.info/images/emoji/twitter/ice_cube.png?v=12" title=":ice_cube:" class="emoji" alt=":ice_cube:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/footprints.png?v=12" title=":footprints:" class="emoji" alt=":footprints:" loading="lazy" width="20" height="20"> I don't 100% love it.</strong></em></p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Yet it still felt a bit strange to me at first to say you were "trying S".</p>
<p>I think this is just a lack of familiarity, and it will seem more natural with time.</p>
</blockquote>
</aside>
<p>Nope.  Still feels like the wrong part of speech.</p>
<p>And I don't think the idea that it relates to error suppression comes across meaningfully to users, especially since the errors of combinators already are suppressed and translated into mismatch-and-continue.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think the OPT is ugly</p>
</blockquote>
</aside>
<p>Beauty is in the eye of the beholder, I guess.  People in Red certainly aren't bothered, and I'm probably the only person to have complained loudly about it.</p>
<p>If we made OPTIONAL a PARSE keyword and then said OPT was a shorthand for it, then that would at least offer a full-"English" choice:</p>
<pre><code>parse url ["http" optional "s" "://gitlab.com/" ...]

parse url ["http" opt "s" "://gitlab.com/" ...]
</code></pre>
<p>I can see using it in tutorials, so it's less jarring.  People would probably quickly switch to the abbreviation in practice.  But I can't say that for sure... looking at the above, I might well write it out.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<p>Guess it depends on how many times I'm using it.  UPARSE offers more factoring capability than historical PARSE, so you don't wind up repeating yourself as often... and maybe being super brief in saying something is optional isn't that necessary.</p>
<aside class="quote no-group" data-username="gchiu" data-post="3" data-topic="1888">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/gchiu/40/22_2.png" class="avatar"> gchiu:</div>
<blockquote>
<p>If you wanted one could try <code>MAYBE</code></p>
</blockquote>
</aside>
<p>Coming back to this... I still don't feel like I can justify it.  MAYBE is for null-defusing.  If it had a parse analogue, it would be more like this:</p>
<pre><code>&gt;&gt; rule: null

&gt;&gt; parse "aaaccc" [some "a", some maybe rule, some "c"]
== "c"
</code></pre>
<p>I've said that we could not do this, because RULE fails at the moment of "combinating"... it can't look up the rule to form the subparser for <code>[maybe rule]</code>, during the build of the parser for <code>[some maybe rule]</code>.  So SOME is never called, hence it can never call MAYBE, where the logic to disable the error would live.</p>
<p><em>But...what if NULL did "combinate", just to a parser raising a specific error related to null combinators?</em>  Hm.  The problem would be that parsers would have to default to promoting that error to a failure somehow.  E.g. MAYBE would need to call its combinated parser with <strong><code>parser/null-error-ok</code></strong> or somesuch, to distinguish it from all the other parsers that don't want to be tolerant.</p>
<p>Or... maybe there's a specific recognition of the null-producing parser by its identity?  e.g. the "null combinator" builds a parser that hard fails if it gets called, but MAYBE never makes that call...doing an inspection of it through some other means.</p>
<p>Though notice this usage wouldn't actually work anyway... SOME MAYBE RULE would make MAYBE RULE succeed without advancing, and be an infinite loop.  (You can't use SOME OPT either with that meaning, for that matter...so not a complete indictment of the concept, just pointing out that it's not necessarily as useful as it seems at first.)</p>
<p><strong>In any case, my bigger point being that I think this is the spirit of what a MAYBE combinator would be for... not imply generic mismatch tolerance.</strong>  Just because it can't work mechanically for its natural meaning doesn't mean the word is up for grabs.  And weighing it in my head right now, I kind of think it may be worth pushing through some tricks to do it...the idea of making the hard-failing combinator that's noticed by MAYBE's identity inspection on the parser sounds like it could work.</p>
<h2>
<a name="odds-are-im-swapping-the-trys-back-out-1" class="anchor" href="https://forum.rebol.info#odds-are-im-swapping-the-trys-back-out-1"></a>Odds Are, I'm Swapping The TRYs Back Out</h2>
<p>Likely going back to a mix of OPTIONALs and OPTs... maybe see how favoring OPTIONAL works out in real code.</p> ]]></description>
        <link>https://forum.rebol.info/t/could-we-replace-parses-opt-with-try/1888#post_6</link>
        <pubDate>Sat, 09 Mar 2024 11:29:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7243</guid>
      </item>
      <item>
        <title>How To Choose Between Returning VOID and NIHIL?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2171">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Both seem to vaporise in lists, after all.</p>
</blockquote>
</aside>
<p>There's some touchy-feely choices made in the constructs regarding voids.</p>
<p>I think it's important that they're not truthy or falsey.</p>
<pre><code>&gt;&gt; if void [print "This is important."]
** Script Error: Invalid use of void
</code></pre>
<p>Which rules out IF on an IF, since failed IF returns void:</p>
<pre><code>&gt;&gt; if (if false [&lt;a&gt;]) [&lt;b&gt;]
** Script Error: Invalid use of void
</code></pre>
<p>However, ALL is kind of like a chain of IF statements testing for logic.  Given the existence of NIHIL, should it demand that for opting out?</p>
<pre><code>&gt;&gt; all [if true [1 &lt; 2] if false [3 &gt; 4] if true [5 &lt; 6]]
** Script Error: Invalid use of void
</code></pre>
<p>If it wasn't willing to erase voids, you'd need to use ELIDE-IF-VOID to erase the voids:</p>
<pre><code>&gt;&gt; all [if true [1 &lt; 2] elide-if-void if false [3 &gt; 4] if true [5 &lt; 6]]
== ~true~  ; anti
</code></pre>
<p>But I feel like it works out better in practice if ANY and ALL consider void as no vote.  Also, if all the expressions opt out of voting, the ANY or ALL overall is void.</p>
<pre><code>&gt;&gt; any [void, all [if false [1 &lt; 2] if false [3 &gt; 4] if false [5 &lt; 6]], void]
== ~void~  ; anti
</code></pre>
<p>But other constructs--like CASE--do not erase voids...only NIHIL.  They have a "structure" to them, and it's desirable to not disrupt that structure too easily, e.g. by looking up a variable which could be void.  (variables cannot be NIHIL, it's an unstable isotope)</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2171">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Though this does now raise the question of whether a function should return nihil or void.</p>
</blockquote>
</aside>
<p>I think it should be a very rare choice to make things return VOID unconditionally.</p>
<p>And I think it should be an even rarer choice to return NIHIL (e.g. because of the damage it can do to things like CASE or SWITCH structure).  And when NIHIL is returned it should almost always be unconditional.</p>
<p>NIHIL is nice for debugging statements, because you can throw them in without disrupting the surrounding code</p>
<pre><code>&gt;&gt; y: 10 + do [x: 1 + 2, dump x]
x: 3
== 13
</code></pre>
<p>Because of this, there's been some pressure to say that PRINT return NIHIL.  <a href="https://forum.rebol.info/t/why-doesnt-print-return-void-or-vaporize-via-nihil/1466">So far, I've rejected that</a>.</p>
<pre><code>append [a b c] print "I think this should error"  ; rules out void

message: null
(print maybe message) else [print "I like reacting to no output"]
</code></pre>
<p>Also, though people reach for PRINT for debug output, I think it's poor for that.  The fact that it evaluates blocks means I don't like the idea of <strong>print x</strong> taking too many kinds of input, that could one day become a block and surprise you by evaluating.  So it's already a bad generic "debug dump".  And logging with the same thing you use for committed output makes it hard to search for debug code and remove or disable it.</p>
<p>I like there being relatively few NIHIL-returning operations, and if you want to erase something use ELIDE.</p>
<p>But ASSERT returns NIHIL and that's neat in things like CASE or SWITCH for asserting something as true when you've gotten to a certain point:</p>
<pre><code>case/all [  ; /ALL -&gt; don't stop on first condition matched
    x &lt; 10 [y: &lt;lesser&gt;]
    x &gt; 10 [y: &lt;greater&gt;]
    assert [(x = 10) or (find [&lt;lesser&gt; &lt;greater&gt;] y)]
    x = 10 [print "You can imagine this kind of thing being useful"]
]
</code></pre>
<p><sub><em>I should go through and replace these with real useful examples someday, but my hope is people get the point abstractly.</em></sub></p>
<p>Anyway, I think it's nice to be able to do that particular thing without saying ELIDE ASSERT.  A few other constructs make the cut of justifying NIHIL.</p>
<p>Hopefully it's clear why I don't think there are that many applications for functions that return nihil conditionally.  ELIDE-IF-VOID is a very niche function that I don't think there are that many legitimate uses for.  If you're going to come up with a construct that does return nihil conditionally, it should be discernible from the source-level syntax if it's a vanishing or non-vanishing invocation.</p> ]]></description>
        <link>https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171#post_2</link>
        <pubDate>Sat, 09 Mar 2024 09:41:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7242</guid>
      </item>
      <item>
        <title>Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2170">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>TAG! does feel like the right type for this.</p>
</blockquote>
</aside>
<p>I actually got the original idea for having "named trash" from some scripts <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> had where he had configuration in the header of a script, something in the spirit of:</p>
<pre><code>Rebol [
    Title: "Configurable Foo Interface Script"
    DLL-Directory: &lt;directory where FOO.DLL lives&gt;
]

...stuff...

if tag? system.script.header.DLL-Directory [
    fail "Set the DLL-Directory in the header to where FOO.DLL lives"
]
libfoo: make library! system.script.header.DLL-Directory
</code></pre>
<p>I thought <em>"hm, that's an interesting idea, a sort of placeholder...would be better if it errored on accidental access"</em>.</p>
<p>So when TRASH! was initially conceived--prior to isotopes--it was a reified type that started and ended with tilde (actually called BAD-WORD!)</p>
<pre><code> DLL-Directory: ~directory-where-FOO-DLL-lives~
</code></pre>
<p>That does show weaknesses in having to convert the dots and spaces to dashes.  So going back to the original placeholder type of TAG! is an interesting move.</p>
<p>It's tempting to say that the whole category would be called TRASH! and take over that role.  But unfortunately <strong><code>&lt;&gt;</code></strong> is a WORD!, so there'd be no slight-looking <strong>~&lt;&gt;~</strong> trash for unset variables.  It would have to be <strong><code>~&lt;unset&gt;~</code></strong> or something like that, which doesn't have the brevity of <strong>~</strong> that I am very attached to now... though there is a slightness to it which can <em>sometimes</em> be undesirable.</p>
<p>It seems to me that DEFAULT should treat these as unassigned:</p>
<pre><code>&gt;&gt; x: ~&lt;some placeholder&gt;~
== ~&lt;some placeholder&gt;~  ; anti

&gt;&gt; x: default [10 + 20]
== 30

&gt;&gt; x
== 30

&gt;&gt; x: default [3 + 4]
== 30
</code></pre>
<p>But does that mean UNSET? should return true, had you asked <strong>unset? 'x</strong> ?</p>
<p>So some issues to sort through here regarding what to call it and how it acts.</p> ]]></description>
        <link>https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170#post_3</link>
        <pubDate>Sat, 09 Mar 2024 09:11:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7240</guid>
      </item>
      <item>
        <title>Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="6" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/6">Shades of Distinction In Non-Valued Intents</a>
</div>
<blockquote>
<p>I've come to question this as things have gone on, to where I'm wondering if all antiform words should be reserved by the system (there are system purposes for the ~end~ antiform, for instance).</p>
<p>A generic "error trigger" might come from something like antiform TAG!, permitting spaces</p>
</blockquote>
</aside>
<p>I like this idea! TAG! does feel like the right type for this.</p> ]]></description>
        <link>https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170#post_2</link>
        <pubDate>Sat, 09 Mar 2024 08:50:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7239</guid>
      </item>
      <item>
        <title>Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>In the post <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">"Shades of Distinction In Non-Valued Intents"</a>, I had originally written:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/1">Shades of Distinction In Non-Valued Intents</a>
</div>
<blockquote>
<p>Eventually the NULL state became the isotopic status of the WORD! null, so a <strong>~null~</strong> antiform.</p>
<p>It joined <strong>~true~</strong> and <strong>~false~</strong> as being antiforms you could test for truthiness and falseyness. But if you were okay with getting an error on conditional testing, any other word could be used:</p>
<pre><code class="lang-plaintext">  config: ~initialize-system-not-called~

  initialize-system: func [
      {Let's say this function reads the config file}
  ][
      ...
      config: [...]
  ]
</code></pre>
<p>This usually causes a nice labeled message anytime someone tries to use CONFIG:</p>
<p>Going this route would create a pain point for anyone who thought they were going to test for whether you had a config initialized by testing <strong>if config [...]</strong>. So that has to be considered as whether it's what you want.</p>
</blockquote>
</aside>
<p>I've come to question this as things have gone on, to where I'm wondering if all antiform words should be reserved by the system (there are system purposes for the ~end~ antiform, for instance).</p>
<p>A generic "error trigger" might come from something like antiform TAG!, permitting spaces:</p>
<pre><code>config: ~&lt;INITIALIZE-SYSTEM not called&gt;~

initialize-system: func [
    {Let's say this function reads the config file}
][
    ...
    config: [...]
]

&gt;&gt; config
** Error: INITIALIZE-SYSTEM not called
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170#post_1</link>
        <pubDate>Sat, 09 Mar 2024 08:49:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7238</guid>
      </item>
      <item>
        <title>Getting an unset variable</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Attachment binding is just something that had to be done in order to get the system to boot under new binding rules.  I don't have a coherent theory for it.</p>
<p>As such, I can't offhand immediately name "here's a thing that fundamentally doesn't work about equating attachment-bound things with being unset".</p>
<p>I can tell you that at least for my sake in debugging things, I like to know the difference.</p>
<p>But more generally, I can tell you that attachment binding is dodgy.  If you try to pretend attachment-bound things are real variables that are backed by a memory location, then you'll be lying when you answer various questions like BINDING OF (not a great question to ask these days, crashes on things).</p> ]]></description>
        <link>https://forum.rebol.info/t/getting-an-unset-variable/2169#post_4</link>
        <pubDate>Sat, 09 Mar 2024 03:03:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7237</guid>
      </item>
      <item>
        <title>Getting an unset variable</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2169">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It's possible to not draw a distinction in the UI, and treat these as existing but unset... but I suspect that's not a good thing to do.</p>
</blockquote>
</aside>
<p>What’s wrong with that? To me it seems the most logical approach. If I mention a variable which has never been set, I’d <em>expect</em> it to behave as if it were unset.</p> ]]></description>
        <link>https://forum.rebol.info/t/getting-an-unset-variable/2169#post_3</link>
        <pubDate>Sat, 09 Mar 2024 02:50:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7236</guid>
      </item>
      <item>
        <title>Getting an unset variable</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>You're hitting a modern issue of "attachment binding":</p>
<p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128" class="inline-onebox">Caching Binding Lookup, and "Attachment Binding"</a></p>
<p>Today's attached variables aren't unset, they don't exist at all.</p>
<p>It's possible to not draw a distinction in the UI, and treat these as existing but unset... but I suspect that's not a good thing to do.</p>
<p>But really, attachment binding is kind of dodgy.  Better ideas are welcome.</p> ]]></description>
        <link>https://forum.rebol.info/t/getting-an-unset-variable/2169#post_2</link>
        <pubDate>Sat, 09 Mar 2024 02:46:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7235</guid>
      </item>
      <item>
        <title>Getting an unset variable</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>Trash (now anti BLANK!) <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">has been established</a> as the value of unset variables. As the example in that thread states:</p>
<pre><code class="lang-plaintext">&gt;&gt; trash-value
** Error: TRASH-VALUE variable is unset

&gt;&gt; append [a b] get/any 'trash-value
** Error: APPEND does not allow adding ~ antiforms to blocks
</code></pre>
<p>But when I try this, I get quite different results:</p>
<pre><code class="lang-plaintext">&gt;&gt; trash-value
** Script Error: trash-value word is attached to a context, but unassigned

&gt;&gt; append [a b] get/any 'trash-value
** Script Error: trash-value word is not bound to a context
</code></pre>
<p>In fact, even GET/ANY doesn’t seem to work… even when I make sure the binding is right:</p>
<pre><code class="lang-plaintext">&gt;&gt; get/any 'trash-value
** Script Error: trash-value word is not bound to a context

&gt;&gt; get/any $trash-value             
** Script Error: trash-value word is attached to a context, but unassigned
</code></pre>
<p>So, what’s happening here? And how <em>do</em> I get trash out of an unset variable?</p> ]]></description>
        <link>https://forum.rebol.info/t/getting-an-unset-variable/2169#post_1</link>
        <pubDate>Sat, 09 Mar 2024 02:39:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7234</guid>
      </item>
      <item>
        <title>How To Choose Between Returning VOID and NIHIL?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/6">Shades of Distinction In Non-Valued Intents</a>
</div>
<blockquote>
<p>Void is used generically in many places when you want things to vanish:</p>
<pre><code class="lang-plaintext">&gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
</blockquote>
</aside>
<p>Ah-ha… I’d completely missed this use of void, as a return value.</p>
<p>Though this does now raise the question of whether a function should return nihil or void. Both seem to vaporise in lists, after all. I guess it depends on whether you want the function call to be ignored or not.</p> ]]></description>
        <link>https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171#post_1</link>
        <pubDate>Sat, 09 Mar 2024 02:30:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7233</guid>
      </item>
      <item>
        <title>Shades of Distinction In Non-Valued Intents</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="5" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>‘Nihil’: the antiform of an empty block, i.e. a multi-return containing no elements. Completely ignored by the evaluator.</p>
</blockquote>
</aside>
<p>Note that NIHIL is only ignored in "interstitial slots".  If you try to call a function that isn't expecting a NIHIL and pass it as an argument, that's an error:</p>
<pre><code>&gt;&gt; append [a b c] 'd comment "ignored"
== [a b c d]

&gt;&gt; append [a b c] comment "not ignored" 'd
** Script Error: No value in antiform BLOCK! pack: ~[]~ (nihil)
</code></pre>
<p>At one point in time, the second worked.  For an understanding of why it no longer does, see:</p>
<p><a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034" class="inline-onebox">Invisibility Reviewed Through Modern Eyes</a></p>
<aside class="quote no-group" data-username="bradrn" data-post="5" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>‘Void’: the antiform of <code>void</code>. Throws an error on variable access or any other attempt to use it, except with APPEND, where it acts as a no-op. Not sure how this is used.</p>
</blockquote>
</aside>
<p>Void is used generically in many places when you want things to vanish:</p>
<pre><code>&gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
<p>Allowing NULL to vanish here would be too liberal and not reveal what were likely errors.  If you have something that may be NULL that you want to convert to a VOID if so, you can use MAYBE.</p>
<p>VOID is also is used for opting out of things, using the "void-in-null-out" strategy.  Compare:</p>
<pre><code>&gt;&gt; block: ["a" "b"]

&gt;&gt; unspaced block
== "ab"

&gt;&gt; to word! unspaced block
== ab
</code></pre>
<p>With:</p>
<pre><code>&gt;&gt; block: []

&gt;&gt; unspaced block
== ~null~  ; anti

&gt;&gt; to word! unspaced block
** Script Error: to expects [~void~ element?] for its value argument

&gt;&gt; maybe unspaced block
== ~void~  ; anti

&gt;&gt; to word! maybe unspaced block
== ~null~  ; anti
</code></pre>
<p>With:</p>
<pre><code>&gt;&gt; block: null

&gt;&gt; unspaced block
** Script Error: unspaced expects [~void~ text! block! the-block! issue!]
                 for its line argument

&gt;&gt; unspaced maybe block
== ~null~  ; anti

&gt;&gt; to word! maybe unspaced maybe block
== ~null~  ; anti
</code></pre>
<p>Historical Redbol had a lot of people asking that things give NONE! back when they took NONE! in, and this "none propagation" was messy in terms of leading to whole chains which would opt themselves out without knowing where the problem was.  Void-in-null-out encourages being more purposeful--you only throw in the MAYBE where you need them.</p> ]]></description>
        <link>https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604#post_6</link>
        <pubDate>Sat, 09 Mar 2024 02:14:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7232</guid>
      </item>
      <item>
        <title>Terminology MAP</title>
        <dc:creator><![CDATA[@GiuseppeChillemi Giuseppe Chillemi]]></dc:creator>
        <description><![CDATA[ <p>Yes, thats the idea. The first thing needed is a list of what has been added/changed (in MACRO way, not in details). Then add short description on its side. Having it as a base, you could start adding "chapters".</p> ]]></description>
        <link>https://forum.rebol.info/t/terminology-map/2162#post_7</link>
        <pubDate>Sat, 09 Mar 2024 01:58:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7231</guid>
      </item>
      <item>
        <title>Shades of Distinction In Non-Valued Intents</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>I’ve read this through a couple of times, but am still not sure I understand it correctly. The discursive treatment in the first post is nice for motivating the various types, but confusing for actually getting a handle on how they work.</p>
<p>So, trying to summarise the situation, here’s my understanding at the moment of the various values involved:</p>
<ul>
<li>‘Blank’: an ordinary datatype inhabited by the single value <code>_</code>.</li>
<li>‘Trash’: the antiform of <code>_</code>. Throws an error on variable access, or any other attempt to use it. Used to represent unset variables.</li>
<li>‘Void’: the antiform of <code>void</code>. Throws an error on variable access or any other attempt to use it, except with APPEND, where it acts as a no-op. Not sure how this is used.</li>
<li>‘Null’: the antiform of <code>null</code>. Does not throws an error on variable access, and tests falsey in conditionals, but throws an error on other attempts to use it. Used to represent uninitialised variables.</li>
<li>‘Nihil’: the antiform of an empty block, i.e. a multi-return containing no elements. Completely ignored by the evaluator.</li>
</ul>
<p>Does this seem correct?</p> ]]></description>
        <link>https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604#post_5</link>
        <pubDate>Sat, 09 Mar 2024 01:17:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7230</guid>
      </item>
      <item>
        <title>What deserves to be a datatype?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Aside: it really should be fascinating to people that a popular language feature like multi-returning would be implemented in this way... with a part like SET-BLOCK!, that isn't reserved by the system but is free for other designs...</p>
</blockquote>
</aside>
<p>Well… this behaviour is hard-coded in the evaluator, right? So I don’t see how it’s any less ‘reserved by the system’ than the behaviour of all the other vocabulary which Ren-C gives you.</p>
<p>(But also, there’s parallels in other languages: e.g. Haskell doesn’t have ‘true’ multi-returns, but if you pattern-match on a returned tuple, that looks very much like a multi-return.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But here's a problem: if we take @ generally meaning "inert, no binding added", then there's a suggestion of <strong><code>[x @y]:</code></strong> not being able to even <em>see</em> the binding of Y in order to write it.</p>
<p>Does a dialect need to follow the evaluator exactly? No... and here, the SET-BLOCK! can see the evaluator's "current" binding and can find the Y. But how divergent it can be depends on what percentage of the evaluator it's going to interact with. If you're in another case like the variables of FOR-EACH, and have a situation where instead of <strong><code>[x @y]</code></strong> you have a case like <strong><code>[@y]</code></strong> and you want to further shorthand that as <strong><code>@y</code></strong> passed as an argument, the rules of the evaluator will affect you in being unable to set the variable.</p>
</blockquote>
</aside>
<p>VAR-WORD! instead of THE-WORD!. At least in the case of FOR-EACH, it makes sense with the semantics of ‘use existing variable’. I think I can justify it with SET-BLOCK! too: ‘use as main variable’. (It does make processing more complicated though, since FOR-EACH would have to see what has bindings and what doesn’t.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>In this particular case, there are already problems with @ not coupling well with wanting a meta result, e.g. <strong>[x ^y]:</strong>, how would you circle the Y in that case?</p>
</blockquote>
</aside>
<p>I thought you said we could handle this case by doing <code>[x @[^y]]:</code> and so on? It’s a little ugly, but logical.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm glad you have a pretty full grip on it (what's there is not complicated, outside of maybe isotopes... but you understand those too).</p>
</blockquote>
</aside>
<p>The one major thing I don’t really understand yet is the various kinds of ‘non-valued intents’ (as you’ve put it). But that can go in a separate thread.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164#post_9</link>
        <pubDate>Sat, 09 Mar 2024 00:06:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7229</guid>
      </item>
      <item>
        <title>Renaming SPECIFIER =&gt; CONTEXT ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2168">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Hm, maybe we consider ANY-BINDABLE? to be the category for things that can be bound <em>to</em>, and come up with another name for anything that can be bound? ANY-REFERENCE?</p>
<p>Eh, that sounds confusing.</p>
</blockquote>
</aside>
<p>BINDABLE is wrong, but thinking about this in the source and being fully literal about it, the superclass could be called "Binding":</p>
<pre><code> Binding* binding = Cell_Binding(cell);
</code></pre>
<p>And that would give you back something you knew to be a type that can serve as a binding.</p>
<p>ANY-BINDING?.. perhaps.</p> ]]></description>
        <link>https://forum.rebol.info/t/renaming-specifier-context/2168#post_3</link>
        <pubDate>Fri, 08 Mar 2024 19:46:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7228</guid>
      </item>
      <item>
        <title>What deserves to be a datatype?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Instead, the gap was that I hadn’t realised how widely useful THE-* is.</p>
</blockquote>
</aside>
<p>Glad you see the applications of THE-XXX! now.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>There's an uneasy aspect of how dialects which interact with the evaluator either align with the evaluator or not, and how much to balance that.  I've already mentioned "circling"... the feature was initially thought of as:</p>
<pre><code>&gt;&gt; [a b]: multi-returning-thing ...
== 10

&gt;&gt; a
== 10

&gt;&gt; b
== 20

&gt;&gt; [x @y]: multi-returning-thing ...
== 20

&gt;&gt; x
== 10

&gt;&gt; y
== 20
</code></pre>
<p><em>(Aside: it really should be fascinating to people that a popular language feature like multi-returning would be implemented in this way... with a part like SET-BLOCK!, that isn't reserved by the system but is free for other designs... and with an "unstable isotope" of antiform block carrying the values, such that it decays to the first element on a normal variable assignment.  While Rebol did put the overall weird idea of an evaluator of this style "out there", Ren-C has dialed it up to 11... and this really is where we're talking about the "new artistic medium, unlike anything else".)</em></p>
<p>But here's a problem: if we take @ generally meaning "inert, no binding added", then there's a suggestion of <strong><code>[x @y]:</code></strong> not being able to even <em>see</em> the binding of Y in order to write it.</p>
<p>Does a dialect need to follow the evaluator exactly?  No... and here, the SET-BLOCK! can see the evaluator's "current" binding and can find the Y.  But how divergent it can be depends on what percentage of the evaluator it's going to interact with.  If you're in another case like the variables of FOR-EACH, and have a situation where instead of <strong><code>[x @y]</code></strong> you have a case like <strong><code>[@y]</code></strong> and you want to further shorthand that as <strong><code>@y</code></strong> passed as an argument, the rules of the evaluator will affect you in being unable to set the variable.</p>
<p>(In this particular case, there are already problems with @ not coupling well with wanting a meta result, e.g. <strong>[x ^y]:</strong>, how would you circle the Y in that case?  GROUP!s escape into evaluation to synthesize the variable name, so they're not available.  This seems a good fit for FENCE! for circling, e.g. <strong>[x {^y}]:</strong>, and is the sort of thing driving the "braces are too valuable to waste on a non-array type" mentality.)</p>
<h1>
<a name="block-group-fence-1" class="anchor" href="https://forum.rebol.info#block-group-fence-1"></a><code>[block]</code> <code>•</code> <code>(group)</code> <code>•</code> <code>{fence}</code>
</h1>
<p>Another thing I'll bring up is the current meaning for @ in PARSE, "I mean it literally, not as a rule":</p>
<pre><code> &gt;&gt; block: ["a" "b"]

 &gt;&gt; parse ["a" "b" "a" "b" "a" "b"] [some block]
 == "b"

 &gt;&gt; parse [["a" "b"] ["a" "b"]] [some @block]
 == ["a" "b"]
</code></pre>
<p>Is that good or bad?  Is there some other meaning that's more related to the evaluator behavior that's getting elbowed out, here?  We want this as a keyword, anyway... maybe LIT/LITERAL:</p>
<pre><code> &gt;&gt; parse [["a" "b"] ["a" "b"]] [some literal block]
 == ["a" "b"]

 &gt;&gt; parse [["a" "b"] ["a" "b"]] [some lit block]
 == ["a" "b"]
</code></pre>
<p>Having lately brought some of the philosophy points to the forefront, I might have been over-concerned about symbol meanings in dialect...and should retrain my focus onto those <em>mechanically essential</em> aspects, like carrying the sigil to someone who will be looking at it.</p>
<p>As mentioned, that should often be done by a word too, probably:</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; inert block
== @[a b c]
</code></pre>
<p>All of this is mad science, but can be very addictive once you get into it.</p>
<aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>However, on reflection, the whole type system of Ren-C <em>does</em> seem to be in flux at the moment…</p>
</blockquote>
</aside>
<p>Very much so!  I'm glad you have a pretty full grip on it (what's there is not complicated, outside of maybe isotopes... but you understand those too).</p>
<p>With the time I have, I'm pushing on a lot of things...FENCE! is one.  But I hope the type concept gets a shot in the arm like binding has, which has gotten it out of the stalled state.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164#post_8</link>
        <pubDate>Fri, 08 Mar 2024 17:12:28 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7227</guid>
      </item>
      <item>
        <title>What deserves to be a datatype?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>Returning back to my original post…</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>But, unfortunately, there are some other types, whose presence is explained by neither of those criteria. As I’ve said previously, the ones which make me feel most uncomfortable are THE-* and TYPE-*. Neither of these represent common types of data that one would want to pass around. And, with the possible exceptions of THE-WORD! and TYPE-BLOCK!, they’re basically useless in ‘regular’ programming.</p>
<p>Despite this, <a class="mention" href="https://forum.rebol.info/u/hostilefork">@hostilefork</a> has lobbied pretty hard for both of these. Hopefully it should be clear now why I find this viewpoint confusing. I can’t say the existence of these types is <em>problematic</em>, as such, but I feel this <strong>indicates a gap in my understanding of the language</strong>.</p>
</blockquote>
</aside>
<p>The conclusion I’ve taken from this discussion is that: no, I actually didn’t have a gap in my understanding of Ren-C as a language. Instead, the gap was that I hadn’t realised how widely useful THE-* is. Now that I understand that, it fits neatly into my criteria for deciding when datatypes are useful to have.</p>
<p>Admittedly, this still leaves TYPE-* without a motivation. (Other than ‘useful in dialecting’, and I’ve already explained why I dislike that.) However, on reflection, the whole type system of Ren-C <em>does</em> seem to be in flux at the moment… to take but one example, currently we only use TYPE-BLOCK!s which are one element long (at least as far as I’m aware). So perhaps the design just needs to be refined a bit, and then it will become something which makes more sense.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164#post_7</link>
        <pubDate>Fri, 08 Mar 2024 13:39:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7226</guid>
      </item>
      <item>
        <title>Renaming SPECIFIER =&gt; CONTEXT ?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>This looks good, although I’m not sure I fully understand all the implementation details about OBJECT! and MODULE! which you mention. ‘Context’ feels like a good name to me.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2168">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Which would mean that you wouldn't have Specifiers. You'd just ask for the binding of a block and maybe get a MODULE! that inherits from an OBJECT!, or an OBJECT! that inherits from a MODULE!, or a LET! that inherits from a LET! that inherits from an OBJECT!, etc.</p>
</blockquote>
</aside>
<p>This feels like it’s getting closer to what R does — where ‘environments’ (its name for contexts) are first-class values, which inherit from each other. It doesn’t give ‘inheritance powers’ to other types, but that’s mostly because it has very few datatypes in the first place.</p> ]]></description>
        <link>https://forum.rebol.info/t/renaming-specifier-context/2168#post_2</link>
        <pubDate>Wed, 06 Mar 2024 23:44:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7225</guid>
      </item>
      <item>
        <title>What deserves to be a datatype?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>Starting in the middle:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One place I see THE-BLOCK! coming into great use is if for a dialect that is not purely mechanical (the way PICK and FOR-EACH are), and leaving the @ off of a block signaling that you would like the "INSIDE / IN" binding to be applied automatically.</p>
</blockquote>
</aside>
<p>This is simply going back to what I said originally: <em>‘The closest to an explanation I’ve found is that these types are useful in dialecting’</em>.</p>
<p>But then, if you’re willing to accept that as sufficient reason for syntax to exist… well, you can use that to justify basically <em>any</em> syntax, as indeed <a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147/2">I once tried to do</a>:</p>
<aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="2147">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147/3">A proliferation of $#@^':~WORD~:s</a>
</div>
<blockquote>
<p>I do see this as having real utility in dialects. For instance, a dialect to interface with C++ code might use this to refer to <code>::global</code> variables. Or a statistical modelling library might want to follow precedent when talking about regression <code>~parameters</code>. Or filesystem operations on Windows might want to refer to <code>\\REMOTE</code> directories… anyway, you get my point, hopefully.</p>
</blockquote>
</aside>
<p>The lesson I took out of that discussion is that adding syntax purely for usage in dialected code is a bad idea, because it’s impossible to know where to stop.</p>
<p>That being said, beyond dialecting, it <em>is</em> pretty useful to have this distinction of ‘this list represents code, evaluate please’ vs ‘this list is just a list, do not evaluate’. After all, it’s nice to be able to pass around lists without worrying that they’ll be evaluated randomly. And it makes sense to store that distinction on the datatype, rather than as a refinement (cf. /ONLY vs antiforms). So, on balance… yeah, I think THE-* is starting to make much more sense to me now.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>And I will reiterate that an important application of TYPE-TUPLE! is when you have a predicate function inside an object or module</p>
</blockquote>
</aside>
<p>Ah-ha, I keep on forgetting that Rebol uses TUPLE!s for access within an object. (In my defense, historical Rebol didn’t use dot-syntax, and neither do some of the languages I use daily, so I sometimes forget it exists.)</p>
<p>Although… then again, this looks like it’s yet another instance of ‘syntax which is only useful in dialects’. That still bothers me, for the reasons I already mentioned.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Imagine I decide to use $1 and $2 etc. to be some kind of positional substitution notation in a dialect</p>
</blockquote>
</aside>
<p>OK, I didn’t even think of that possibility. That makes sense.</p>
<p>I disagree with it though, for two reasons:</p>
<ul>
<li>I think MONEY! is actually very useful. Working with money requires specialised requirements (e.g. fixed-point storage), which can be a bit painful — so having that type built-in to the language eliminates a whole class of subtle errors. And, of course, all kinds of software requires working with money.</li>
<li>I think positional substitution is a particularly annoying kind of substitution. I use it in Bash, and hate it. I’d much rather do something like <code>substitute [a b $bar c d $foo e f] {foo: &lt;some&gt; bar: &lt;thing&gt;}</code>, which is less error-prone and more descriptive.</li>
</ul>
<p>So, I’d rank them the other way around: MONEY! is most useful, and DOLLAR-INTEGER! is less useful.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I would use DOLLAR-INTEGER! more than MONEY! in the kinds of things I'd use Rebol stuff for.</p>
</blockquote>
</aside>
<p>Admittedly, I would do the same. But for a general-purpose language I think MONEY! is important and very useful.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Where do you find the time for all these interests? <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
</blockquote>
</aside>
<p>I couldn’t really tell you; I’ve always just had very broad interests. And linguistics has always been one of my favourite areas.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164#post_6</link>
        <pubDate>Wed, 06 Mar 2024 23:26:46 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7224</guid>
      </item>
      <item>
        <title>Renaming SPECIFIER =&gt; CONTEXT ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>There was a typeset in historical Rebol that was called ANY-OBJECT!, that tried to pull together anything that had WORD! keys that could be used as a binding target:</p>
<pre><code>r3-alpha&gt;&gt; help any-object!
ANY-OBJECT! is a typeset of value: make typeset! [
    object! module! error! task! port!
]
</code></pre>
<p>I had sort of a naming philosophy (which I still have) that you shouldn't name the category based on one of its instances like this.  Several reasons, but one is that it certainly confuses the implementation when you extract the pointed-to entity out of a cell:</p>
<pre><code> if (Cell_Type(cell) == TYPE_ERROR) {
     Object* = Cell_Object(cell);  // wait, but it's an ERROR! not an OBJECT!
     ...
 }
</code></pre>
<p>You could call it <code>AnyObject</code>, I guess.  But that's not the direction I took... instead calling the category ANY-CONTEXT!, and if you saw <code>Context*</code> in the source you wouldn't get confused to thinking it was an extraction from a CONTEXT! cell, because there was no such thing.  You knew it was the implementation of a superclass.</p>
<h2>
<a name="enter-specifier-1" class="anchor" href="https://forum.rebol.info#enter-specifier-1"></a>Enter "Specifier"</h2>
<p>"Specifier"--the aggregated inheritance of binding candidates--has moved from an implementation detail to something which is rising to the surface of user awareness.  For that, it's a lousy name... and am near-certain I want to take "Context" for it.</p>
<p>I like Context better than Environment, as it's shorter and leaves environment for "environment variables" (which being a script-class language Ren-C needs to be better at interacting with than it is today).</p>
<p>We could say the other types are ANY-DICTIONARY!, although the name DICTIONARY! has been suggested as a replacement for MAP!, since we are thinking of MAP more as a function now.  But Dictionary may make more sense for things that only permit "words" as keys.</p>
<p>A CONTEXT! itself--as a composition of other dictionaries (and possibly even just programmatic code that answers value-for-WORD!)--may itself be categorized as an ANY-DICTIONARY!</p>
<h2>
<a name="implementation-variance-needs-work-2" class="anchor" href="https://forum.rebol.info#implementation-variance-needs-work-2"></a>Implementation Variance Needs Work</h2>
<p>So something that has happened in the messy evolution of the code is that the one-size-fits all <strong><code>Context*</code></strong> data structure that backed things like OBJECT!, ERROR!, MODULE! etc. became fractured around the time of Sea of Words and LET.</p>
<p>Modules do not use the same representation, and have to be enumerated completely differently.  There's not really a lot of generic code that acts the same way for OBJECT! and MODULE!, to the point that we'd be better off dispelling the illusion in the C sources and making <strong><code>Module*</code></strong> its own distinct type.</p>
<p>There's a lot to consider here about what the limits of "Amish" implementation are:</p>
<ul>
<li>
<p>I'm pretty much sold on the known-integer-values concept for Frame.  And if <em><strong>I</strong></em> say that drifting away from that destroys what the project <em>is</em>, then it almost certainly does--because I'm known for being iconoclastic about a fair number of Rebol sacred cows.</p>
</li>
<li>
<p>BUT taking a diverging approach for Module from "parallel arrays of Key and Value cell indexed by integer" has proven essential.  Floating variable stubs hanging off the word symbols themselves is an answer that has been critical in giving some legitimacy to modules, and it still passes the "simple" test for me.</p>
<ul>
<li>R3-Alpha was utterly hopeless, and Red will be too if they follow down that path (should they ever get modules).  I do not think this is a problem appropriate to approach with two-parallel-arrays.</li>
</ul>
</li>
<li>
<p>Objects are kind of a wild card.  Given their attempt to be dirt-simple, we might more accurately call the current version "Struct" or "Structure" instead (major annoyance in C naming the variables though, <code>Struct _struct</code>, to dodge the <code>struct</code> keyword?)</p>
<ul>
<li>
<p>People want to dynamically add and remove keys from objects.  Rebol2 and Red don't allow it, and R3-Alpha only permitted growth (so the index numbers stored in words that were bound at an index wouldn't be invalidated)</p>
</li>
<li>
<p>Moving to a more amortized implementation that spreads and shares keys gets you to something more like a database, where you can't point to little contiguous packets of memory and say "there is the object."</p>
</li>
<li>
<p>As I said above, I think this was a necessity for Modules.  But the simple implementation that works quite well for them wouldn't scale to tens of thousands of objects which have keys with the same name.</p>
</li>
<li>
<p>There's plenty of prior art and writeups of how JavaScript engines and others have approached this, and gotten it to be fast.</p>
</li>
</ul>
</li>
</ul>
<p>Anyway, this all kind of culminates in saying that objects are due for a reckoning at some point.  We want to err on the side of simplicity over optimized complexity, but there may be a sufficiently elegant way to attack objects that can grow and shrink effectively and having better code overall than we have today.</p>
<h2>
<a name="anyway-back-to-the-naming-issue-3" class="anchor" href="https://forum.rebol.info#anyway-back-to-the-naming-issue-3"></a>Anyway, Back To The Naming Issue...</h2>
<p>The above sort of reveals why ANY-OBJECT! isn't a good name for ANY-DICTIONARY or ANY-BINDTARGET?.</p>
<p>Hm, maybe we consider ANY-BINDABLE? to be the category for things that can be bound <em>to</em>, and come up with another name for anything that can be bound?  ANY-REFERENCE?</p>
<p>Eh, that sounds confusing.  Dictionary may be about as good as it gets (?)</p>
<p>So basically, Dictionary would be a superclass offering lookup from Word Symbol =&gt; Value.  If you wanted anything else from it, you would have to figure out what subclass it was, because how you do things like enumerate keys and values diverges significantly.</p>
<h2>
<a name="or-maybe-some-unifying-theory-will-come-along-4" class="anchor" href="https://forum.rebol.info#or-maybe-some-unifying-theory-will-come-along-4"></a>Or Maybe Some Unifying Theory Will Come Along?</h2>
<p>It could be, that everything--including OBJECT! and MODULE!, have the "inheritance" powers of what Specifier has today.</p>
<p>Which would mean that you wouldn't have Specifiers.  You'd just ask for the binding of a block and maybe get a MODULE! that inherits from an OBJECT!, or an OBJECT! that inherits from a MODULE!, or a LET! that inherits from a LET! that inherits from an OBJECT!, etc.</p>
<p>It all warrants more thought, and maybe a quick attempt to swap out the current OBJECT! implementation with something like V8's <a href="https://v8.dev/docs/hidden-classes">Hidden Classes</a> and see how it meshes with the system.  I've been so focused on the "bricks" in the language that these sorts of "boring" implementation details have just sort of been left alone while that's sorted out, but now it's getting to the point where there seem to be some answers to guide the shape.</p> ]]></description>
        <link>https://forum.rebol.info/t/renaming-specifier-context/2168#post_1</link>
        <pubDate>Wed, 06 Mar 2024 18:56:13 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7223</guid>
      </item>
      <item>
        <title>What deserves to be a datatype?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I don’t see any problem with this; could you elaborate?</p>
</blockquote>
</aside>
<p>Imagine I decide to use $1 and $2 etc. to be some kind of positional substitution notation in a dialect:</p>
<pre><code>&gt;&gt; substitute [a b $2 c d $1 e f] [&lt;some&gt; &lt;thing&gt;]
== [a b &lt;thing&gt; c d &lt;some&gt; e f]
</code></pre>
<p>If I reflect it out to the user in any way, it will carry the decoration I don't want unless I get involved in removing the extra digits:</p>
<pre><code>&gt;&gt; substitute/trace [a b $2 c d $1 e f] [&lt;some&gt; &lt;thing&gt;]
DEBUG: $1.00 is &lt;some&gt;
DEBUG: $2.00 is &lt;thing&gt;
== [a b &lt;thing&gt; c d &lt;some&gt; e f]
</code></pre>
<p>Being a headache in that way--and having to decide things like if you round down $1.01 or error--means it's not a fit for such purposes.  It wasn't intended to be used that way, but my point was just that it's one of my pet peeves about the type, because I would use DOLLAR-INTEGER! more than MONEY! in the kinds of things I'd use Rebol stuff for.</p>
<aside class="quote no-group" data-username="bradrn" data-post="3" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>As it happens, I have a (quite intense) side interest in linguistics.</p>
</blockquote>
</aside>
<p>Where do you find the time for all these interests?  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">  Point was just <em>whatever it is</em> that is innate in us to let us see structure in streams of words, we want to leverage that "zone" as I called it.  Most languages don't try to go there.</p>
<p>Rebol does so on purpose, letting you organically decide when you want to delimit e.g. with BLOCK! in parse rules ([try some integer!] vs. [try [some integer!]]) or GROUP! in evaluator code.  As you get more comfortable with things, the training wheels fall off and you tend to delimit less...or at least much more purposefully.  As with English.</p>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>THE-BLOCK! is the one which feels most redundant and useless.</p>
</blockquote>
</aside>
<p>One place I see THE-BLOCK! coming into great use is if for a dialect that is not purely mechanical (the way PICK and FOR-EACH are), and leaving the @ off of a block signaling that you would like the "INSIDE / IN" binding to be applied automatically.</p>
<p>e.g. some <a href="https://forum.rebol.info/t/the-circled-dialect-example-of-the-form/1849">variation of the CIRCLED dialect</a> might work like so:</p>
<pre><code>&gt;&gt; x: 10 y: 20

&gt;&gt; var: circled [x (y)]
== y

&gt;&gt; get var
== 20

&gt;&gt; var: circled @[x (y)]
== y

&gt;&gt; get var
** Error: y is not bound
</code></pre>
<p>Being able to draw that distinction is dependent on the callee being able to see the sigil.  And I think that if we say that @[...] blocks do not bind (as no other @ types do, at least by default) you help to guide the implementation offerings of the dialects in this direction.  If you don't have a binding passed in, you can't give one back (unless the value already had it deliberately glued on)</p>
<p>I've mentioned the other cues here that are useful, such as when ANY and ALL don't want to evaluate but only to run the predicate:</p>
<pre><code>&gt;&gt; any/predicate [3 + 4 10 + 20] :even?
== 30

&gt;&gt; any/predicate @[3 + 4 10 + 20] :even?
== 4
</code></pre>
<p>This is important if someone else ran a reduce step and you still have questions about the data... it keeps you from having to do something like MAP-EACH item to a QUOTED! version just to suppress evaluation in the ALL.  It could be done with a refinement, but the single-character notation as a convention--which aligns with not adding binding--seems a salient solution.</p>
<p>So it's far from useless in my eyes.  And I will reiterate that an important application of TYPE-TUPLE! is when you have a predicate function inside an object or module:</p>
<pre><code> &gt;&gt; obj: make object! [lucky?: number -&gt; [number = 7]]

 &gt;&gt; parse [7 7 7] [some &amp;obj.lucky?]
 == 7
</code></pre>
<p>And then TYPE-PATH! when your function has refinements.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164#post_5</link>
        <pubDate>Wed, 06 Mar 2024 17:20:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7222</guid>
      </item>
      <item>
        <title>Mapping from Series =&gt; Series By Co-Opting The Key Series</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>There was an unfinished idea in an old version of the interpreter.  It related to how to deal with problems like trying to make a copy of a block, and make sure any series with the same identity are only copied once in the new structure, and point to that one copied identity.</p>
<p>Rebol2 did not have this behavior:</p>
<pre><code>rebol2&gt;&gt; block: [a]
== [a]

rebol2&gt;&gt; original: reduce [block block]
== [[a] [a]]

rebol2&gt;&gt; append block 'b
== [a b]

rebol2&gt;&gt; original
== [[a b] [a b]]  ; both aliases see the append

rebol2&gt;&gt; duplicate: copy/deep original
== [[a b] [a b]]

rebol2&gt;&gt; append first duplicate 'c
== [a b c]

rebol2&gt;&gt; duplicate
== [[a b c] [a b]]  ; considered by many to be wrong: independent copies
</code></pre>
<p>This post isn't about whether that is right or wrong (and having such questions may seem to some as an indication of <em>"this language is madness! get me to Haskell"</em>, etc. But as I've said this is the game we're playing here so we roll with it.)</p>
<p>But to not get independent copies, you need a way to map series nodes to copies you've already created...so you can consult that mapping before making new copies.  And the direction that was being pursued by the old interpreter I am looking at was to actually do surgery on the originating series nodes, to alter them so they shifted out some of their content, such that they could be their own keys in the mapping.</p>
<p>Generally speaking, all the bits in a series stub are spoken for.  So it would seem there's nowhere to stow a pointer to the new series you are creating in it.  What the implementation was doing was pushing a 4 pointer cell on the data stack, writing one pointer's worth of information from the stub into that cell, then replacing that pointer slot in the stub with the stack index.  Then it wrote the new series into the cell...so the cell contained one stowed pointer from the original series and one pointer for the new series.</p>
<p>This meant the original series was now in a "weird" state, that things like the GC had to know about and tolerate.  Other operations looking for the missing information in the stub needed to be caught if they tried to get at it without following the stack index through to the stack cell.</p>
<p>Having the cells on the data stack meant it was not necessary to enumerate all the series stubs after a copy to "clean them up".  Otherwise, I'd imagine it may be possible to make some kind of guarantee that for any series appearing in source, the union of the bits in the source series and the bits of the copied series can hold all the information necessary to construct two valid series... e.g. one pointer's worth of information is always redundant in those two copies.  If you can get <em>two</em> pointers' worth of information redundant, the second could be used to chain a linked list as you go...removing the need for the stack cells to enumerate.</p>
<p>Though having the stack cells and no particular requirement of information redundancy in source series with their copies offers another benefit: being applicable for creating mappings that aren't copying-related.</p>
<p>Anyway, it was a little unfinished idea I ran across that I wanted to document.  I'm cleaning up the bootstrap executable to refresh it with something that will help <a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">in the FENCE! migration</a>, and mercilessly deleting any code in the bootstrap executable that does not specifically benefit bootstrap... to reduce the instability surface, speed things up, and make it easier to debug the 6-year old executable if worst comes to worst.</p> ]]></description>
        <link>https://forum.rebol.info/t/mapping-from-series-series-by-co-opting-the-key-series/2166#post_1</link>
        <pubDate>Wed, 06 Mar 2024 15:24:07 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7220</guid>
      </item>
      <item>
        <title>Revisiting a Maybe-Not-So-Weird Old Idea: &lt;- as IDENTITY</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>So at one point I had a kind of strange idea for what to do with <strong><code>&lt;-</code></strong>.</p>
<p>It would just pass through what you gave on its right.  And the idea was that you could use this in various situations as a kind of visual signal that you intended to produce a value that would be used by... something.</p>
<p>You could use it to hint when a line is being continued:</p>
<pre><code>browse join
    &lt;- https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
    &lt;- unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>That JOIN is arity 2.   The arrows do nothing, but quickly pass through what they were passed.</p>
<p>The current alternative you might reach for are parentheses, but you can only put it around the outermost level, and it's noticeably inferior:</p>
<pre><code>browse (join
    https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
    unspaced [system.version.1 "." system.version.2 "." system.version.3]
)
</code></pre>
<p>I had another idea that the arrow might be nice for signaling when you're at the end of a branch to help hint that the branch result is actually used.</p>
<pre><code> something: case [
     ... [...]
     ... [...]
     ; lots of code to where SOMETHING: has scrolled off the screen
     ... [
         your code here
         more code here
         &lt;- append data "stuff"
     ]
 ]
</code></pre>
<p>It gives you a nice hint that the result of the append (the head of the appended series) is actually used.<br>
<strong>But, these two uses are in contention.</strong>  You can't use it to mean "continue the line above" and "pipe result out to some higher level.  Perhaps this is better done with an impromptu CATCH/THROW?</p>
<pre><code> something: catch [case [
     ... [... throw ...]
     ... [... throw ...]
     ; lots of code to where SOMETHING: has scrolled off the screen
     ... [
         your code here
         more code here
         throw append data "stuff"
     ]
 ]]
</code></pre>
<p>(Note that CATCH/THROW have nothing to do with errors in Rebol, it's a lightweight construct for doing this kind of manipulation.)</p>
<h2>
<a name="why-did-i-kill-off-the-as-identity-1" class="anchor" href="https://forum.rebol.info#why-did-i-kill-off-the-as-identity-1"></a>Why Did I Kill Off The &lt;- As Identity?</h2>
<p>It was changed shortly after deciding to take <strong>-&gt;</strong> for an infix lambda operation.</p>
<pre><code> foo: x -&gt; [print ["I'm a lambda" x]]

 &gt;&gt; foo 1020
 I'm a lambda 1020
</code></pre>
<p>This is particularly nice-looking in branching when you want to pass the branch result.</p>
<pre><code>all [
    1 &lt; 2
    3 &lt; 4
    #something
] then x -&gt; [
   print ["X is" mold x]  ; X is #something
]
</code></pre>
<p>The first incarnation used <strong><code>=&gt;</code></strong> as JavaScript did.  But not only is the arrow lighter, it doesn't weigh on the question of whether <strong><code>=&gt;</code></strong> is an "arrow", when <strong><code>&lt;=</code></strong> is not one.  (Debate has been had over whether =&gt; should be a synonym for &gt;=, and =&lt; a synonym for &lt;=, etc. but status quo has won out.)</p>
<p>So <strong><code>&lt;-</code></strong> was targeted as another function generator, namely for doing tacit programming as an alias for POINTFREE.</p>
<pre><code>foo: &lt;- [append [a b c]]

&gt;&gt; foo 'd
== [a b c d]
</code></pre>
<p>The attempt to write POINTFREE entirely in usermode stalled a bit in the face of other priorities, though it's still very much desired.  And it doesn't seem like a bad idea to have &lt;- and -&gt; both connected as fundamental convenient function generators.</p>
<p>I've not really questioned the decision to strike &lt;- as identity until I realized looking at some old code that it really is nice to have some alias for identity, used for one of the annotation purposes I mention.</p>
<p>We do have single tick free, now <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<pre><code>browse join
  ' https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  ' unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>That actually looks kind of decent.  It's not super consistent, because quoting implies not binding...and we'd want binding applied.  Can people mentally separate "the tick operator" as IDENTITY, from the non-bindingness of quoting?</p>
<p>Backtick is available, though backticks are kind of a blight in general:</p>
<pre><code>browse join
  ` https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  ` unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>Despite my hatred of backticks, I almost actually prefer that to the normal ticks in this narrow application.</p>
<p>There's a few other ugly options, e.g. backslash which we still haven't given meaning to either.</p>
<pre><code>browse join
  \ https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  \ unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p><strong>Anyway, the cool idea here was just that line continuation not be a scanner feature, but be signaled by means of a normal token that ran the identity function... and you'd be cued into realizing that it was a continuation just because there's no point in calling the identity function in source unless you were applying it like this.</strong></p>
<p>We could throw in a little help by having the evaluator only allow this if it was--actually--an argument to a function.</p>
<p>Based on the above, I'm liking the backtick and apostrophe, and am not sure I'd want heavier for line continuation.</p>
<p>The idea of &lt;- being an alternate way of saying identity that is used for the other annotation purpose (this result is used by the higher up stack level) would then be a possibility.  The system could maybe help a little bit here too, by making sure the <strong>&lt;-</strong> <em>isn't</em> an argument to a function...</p>
<p>POINTFREE would need some other shorthand.  But maybe it's just an alternate mode of LAMBDA.  Or maybe it doesn't really need a shorthand.</p>
<pre><code>foo: ... -&gt; [append [a b c]]

foo: &lt;*&gt; -&gt; [append [a b c]]

foo: |-&gt; [append [a b c]]

foo: -|&gt; [append [a b c]]

foo: pointfree [append [a b c]]

&gt;&gt; foo 'd
== [a b c d]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165#post_1</link>
        <pubDate>Wed, 06 Mar 2024 14:20:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7219</guid>
      </item>
      <item>
        <title>What deserves to be a datatype?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="bradrn" data-post="3" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Some of these questions... like preserving quote-style string vs. non... register on the needle in ways that trying to assassinate THE-BLOCK! or TYPE-TUPLE! do not... especially when I have compelling applications for them.</p>
</blockquote>
</aside>
<p>[…]</p>
<p>(Also, I suspect you misunderstood me. I singled out THE-BLOCK! and TYPE-BLOCK! as two types which <em>do</em> have compelling applications. It’s the other types in their family which confuse me.)</p>
</blockquote>
</aside>
<p>Actually… re-reading this, I got confused here. It’s THE-WORD! and TYPE-WORD! which I can see the need for. By contrast, out of all the types we have, THE-BLOCK! is the one which feels most redundant and useless. (And TYPE-TUPLE! and TYPE-BLOCK! aren’t far behind.)</p> ]]></description>
        <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164#post_4</link>
        <pubDate>Wed, 06 Mar 2024 13:20:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7218</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So...I'm afraid that BLANK!'s relationship to nullness and falseness has basically gone away. Instead, it's the "space unit" of BLOCK!s--the moral equivalent of a space character in a TEXT!.</p>
</blockquote>
</aside>
<aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I do think that having SPREAD of a BLANK! return a VOID or an empty splice is probably a good thing... though not completely sure on the merits of choosing one over the other. An empty splice may be "more coherent" in the sense that one probably wouldn't want <strong><code>foo spread _</code></strong> to give back null if <strong><code>foo spread []</code></strong> would not. Considering it "EMPTY?" in certain contexts may be appropriate as well...but not falsey.</p>
</blockquote>
</aside>
<p>Okay, I think this kind of sums up the difference here:</p>
<h2>
<a name="blanks-arent-null-equivalents-or-falsey-they-are-empty-1" class="anchor" href="https://forum.rebol.info#blanks-arent-null-equivalents-or-falsey-they-are-empty-1"></a>BLANK!s aren't null-equivalents or falsey, <em>they are EMPTY?</em>
</h2>
<p>You (<a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>) hopefully don't expect an empty block to be falsey.</p>
<p>EMPTY? is a test which can work across both blanks and empty blocks (and empty strings, binaries...), to say they are values that are intentionally empty.  And then EMPTY? on null can be an error.</p>
<p>I'm a bit reticent to say that a blank can be passed anywhere you'd pass a void to... but rather they can be passed anywhere you can pass an empty block (or empty string?) to, and give you back the same meaning.  That's actually an interesting point: if the meaning for an empty block and empty string would be different when passed to a routine, then I don't think blank should play favorites in acting like either, because it doesn't connote any particular kind of emptiness.</p>
<p>I have some other thoughts here about how BLANK! seems to be useful as a way of fitting into places that want to say they are conceptually holding series, but want to avoid the creation of a series identity.  The issue being that you wouldn't so much mind writing <strong><code>[]</code></strong> in these slots except for the fact that what you really need is <strong><code>copy []</code></strong> which gets ugly...and with just <strong><code>_</code></strong> you push the responsibility of making the series to whoever starts expanding it.  But then, if you're making a prototype of an object that's going to get copied that isn't enough to get new copies in the instances... which points to a deeper problem that BLANK! is only papering over.  That needs a bigger discussion, but other things need to be sorted out related to objects first.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942#post_10</link>
        <pubDate>Wed, 06 Mar 2024 13:19:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7217</guid>
      </item>
      <item>
        <title>Terminology MAP</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2162">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I've made a chat channel for this purpose: <strong><a href="https://forum.rebol.info/chat/c/usage-chat/3">#usage-chat</a></strong></p>
</blockquote>
</aside>
<p>Responding to your post there:</p>
<aside class="quote no-group">
<blockquote>
<p>Ask here if doing a search on the forum isn't finding you the information you want on a topic.</p>
</blockquote>
</aside>
<p>At least for me, it’s not about ‘finding information I want’. (Generally if I’m looking for something, I have few problems finding it.) The problem is that I <em>don’t know what’s out there in the first place</em> — as they say, I don’t know what I don’t know. An index summarising the advances Ren-C has made would be very helpful in that regard.</p> ]]></description>
        <link>https://forum.rebol.info/t/terminology-map/2162#post_6</link>
        <pubDate>Wed, 06 Mar 2024 13:17:23 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7216</guid>
      </item>
      <item>
        <title>Terminology MAP</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><a class="mention" href="https://forum.rebol.info/u/giuseppechillemi">@GiuseppeChillemi</a> Note that it's not actually clear to me what the terms are beyond isotopic ones that you don't know, and a few posts I've linked (or that are easy to find) cover these.  :-/</p>
<p><strong>I'm all for better and more organized documentation.  But I'm going to insist that it be done on a more "as-needed basis" at this moment in time.  I will find a place where what you are curious about in that moment is documented, improve if necessary (or make documentation if none exists), and provide you the link.</strong></p>
<p>I've made a chat channel for this purpose: <strong><a href="https://forum.rebol.info/chat/c/usage-chat/3">#usage-chat</a></strong></p>
<p>Think of it like using an AI search engine vs. a traditional one...which is what the world is going toward anyway.</p>
<hr>
<p>What I want before going on a documentation binge is to ensure whatever is written is in a verifiable format, where embedded code samples can be checked by CI tests.</p>
<p>A long while ago, I tried to use Trello to document things.  It's completely and fully out of date at this point:</p>
<p><a href="https://trello.com/b/l385BE7a/rebol3-porting-guide-ren-c-branch">Rebol 3 Porting Guide (Ren-C Branch)</a></p>
<p>HOWEVER I really did like Trello's UI for editing and arrangement, and I think it's a good tool for this kind of "glossary" / "overview".</p>
<p>What I don't like about it is that there's no verification process for making sure any code samples given there are kept working.</p>
<p>So if I was going to invest into that again, I wanted some Rebol code that would scrape and validate it... as well as back it up in a non-proprietary format.  <em>(<a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a> had some Trello API-using code, and I did do a demo of embedding a card in in the Web Repl at one point...since we're looking for examples of Brett's code to rewrite in Ren-C and add to CI, maybe the Trello lib is a useful candidate.)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/terminology-map/2162#post_5</link>
        <pubDate>Wed, 06 Mar 2024 13:06:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7215</guid>
      </item>
      <item>
        <title>What deserves to be a datatype?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <p>It’s late here, and that’s a fairly comprehensive post, so it’ll take me a while to absorb it fully. I’ll continue thinking over it until I reach some more definite conclusion.</p>
<p>But, until then, here’s my immediate thoughts:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Some of these questions... like preserving quote-style string vs. non... register on the needle in ways that trying to assassinate THE-BLOCK! or TYPE-TUPLE! do not... especially when I have compelling applications for them.</p>
</blockquote>
</aside>
<p>You’re right; in the scheme of things, it isn’t a significant objection. But from a <em>personal</em> perspective, it’s important for me: it’s a place where I clearly haven’t understood the language, and that annoys me.</p>
<p><s>(Also, I suspect you misunderstood me. I singled out THE-BLOCK! and TYPE-BLOCK! as two types which <em>do</em> have compelling applications. It’s the other types in their family which confuse me.)</s></p>
<p>[EDIT: I got confused there, see below]</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So Rebol's spiritual inspiration is more-or-less <em>English</em>. In that sense, it's important not to drift too far into "symbol soup" in the general practice. There's probably some sweet spot of the percentage of what your dialects can do with WORD!...and that percentage should be high.</p>
</blockquote>
</aside>
<p>This is one of the big things I haven’t fully absorbed, I think. ‘You should be able to do most things using WORD!’ is a good summary of the aims.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We're trying to tap into that "Language Instinct" (<a href="https://en.wikipedia.org/wiki/X-bar_theory">X-bar Theory</a>) that research has shown we all carry in our heads.</p>
</blockquote>
</aside>
<p>As it happens, I have a (quite intense) side interest in linguistics. By and large, I strongly reject Chomskyanism, including the ‘language instinct’ idea. As for X-bar theory, that was more or less a fad which has by now long passed. (The Chomskyanists obsess over <a href="https://en.wikipedia.org/wiki/Minimalist_program">Minimalism</a> now, though I’m sure that too will pass.)</p>
<p>Insofar as I subscribe to any linguistic theory at all, I tend to sympathise the most with <a href="https://en.wikipedia.org/wiki/Construction_grammar">construction grammar</a>… which, interestingly, strikes me as being remarkably close to how we think about Rebol programs. It’s certainly a closer fit to Rebol than generative approaches are: essentially, ‘building sentences [or programs] out of smaller, idiomatic parts’.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>There isn't a "no silliness rule" in effect. What curbs the existence of things like--say--SET-ISSUE! is trying to balance competing meanings, and pick the most useful one.</p>
</blockquote>
</aside>
<p>Perhaps ‘silliness’ wasn’t quite the right word here — it’s that same sense of ‘most-useful-ness’ which I was trying to get at. SET-ISSUE! is of minimal use, so it gets trashed in favour of the more useful datatype.</p>
<p>That being said, I hadn’t fully appreciated the extent to which these kinds of collisions between syntaxes was possible. There are more ‘competing meanings’ here than I had thought.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Silly or not, apostrophes are legal inside words</p>
</blockquote>
</aside>
<p>By the way, this is legal in Haskell too. It’s particularly common for making ‘primed’ symbols, which as you note is thoroughly useful.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We've <a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147">gone into the reasoning</a> for why <strong>$foo:</strong> does not exist, and why arrays are the "API" for letting you pick these apart as <strong>$[foo:]</strong> or <strong>[$foo]:</strong> etc.</p>
</blockquote>
</aside>
<p>Sure, and I agree with that, which is why I didn’t object to these in my original post.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>For myself, I'm bothered by things like:</p>
<pre><code class="lang-plaintext">&gt;&gt; $1
== $1.00
</code></pre>
</blockquote>
</aside>
<p>I don’t see any problem with this; could you elaborate?</p> ]]></description>
        <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164#post_3</link>
        <pubDate>Tue, 05 Mar 2024 15:09:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7214</guid>
      </item>
      <item>
        <title>What deserves to be a datatype?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h3>
<a name="a-few-opening-thoughts-1" class="anchor" href="https://forum.rebol.info#a-few-opening-thoughts-1"></a>A Few Opening Thoughts...</h3>
<p><a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> wrote the <a href="http://2019.reb4.me/">tagline of the 2019 conference</a> as:</p>
<p><strong>Rebol</strong> • /ˈrɛbəl/ <em>“It’s about language […] We believe that language itself, when coupled with the human mind, gains significant productivity advantages over traditional software technologies.”</em></p>
<p>He's elsewhere <a href="https://forum.rebol.info/t/the-r3c-branch-chriss-rebol-or-rebol-3-conservative/1858/6">given the high-level bullet points of</a>:</p>
<ul>
<li>Data/messaging come first, and words without qualifying symbols [are] the premium currency.</li>
<li>Source should as much as possible resemble the molded representation of said source loaded.</li>
</ul>
<p>So Rebol's spiritual inspiration is more-or-less <em>English</em>.  In that sense, it's important not to drift too far into "symbol soup" in the general practice.  There's probably some sweet spot of the percentage of what your dialects can do with WORD!...and that percentage should be high.  <em>(So regardless of the merit of the <a href="https://forum.rebol.info/t/raku-perl-6-type-system/2156">underlying ideas in Raku</a>, it's a poster child for what we don't want common Rebol code to look like.)</em></p>
<p>It is certainly possible to not like the premise, <a href="https://forum.rebol.info/t/the-sherman-rebol-to-scheme-compiler/2076">e.g. Joe Marshall rejects it</a>.  And you can pick what at least <em>look</em> like bad examples easily.  But if he stopped and reflected on the reflexive and fluid mode his mind was in while writing the paragraph of English critiquing the Rebol, he should grok that what's being pursued is to put you in that same "zone".  We're trying to tap into that Language Instinct (<a href="https://en.wikipedia.org/wiki/X-bar_theory">X-bar Theory</a>) that research has shown we all carry in our heads.</p>
<p>So with all this in mind, it's important to realize that Rebol embraces its outgrowth from 10-fingered creatures and QWERTY keyboards, vs. fighting that.  Since the inspiration is English, it's an inevitable outcome that it's going to be at odds with the kind of clean and orthogonal model sought by languages which draw their inspiration from other places (e.g. math).</p>
<p><a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a> has said: <em>"[Rebols] are a bit like the family of soft-body invertebrates in the language kingdom. Their special traits don't necessarily shine in common computing domains, but... On a second level I think Domain Specific Languages remains an open frontier largely uncracked by the hidebound languages who originally mapped the territory.</em></p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>(For instance, we don’t have ISSUE-TEXT!, ISSUE-BINARY!, ISSUE-EMAIL!… we just have a single textual ISSUE! type, because doing otherwise would be silly.)</p>
</blockquote>
</aside>
<p>There isn't a "no silliness rule" in effect.  What curbs the existence of things like--say--SET-ISSUE! is trying to balance competing meanings, and pick the most useful one.</p>
<pre><code>rebol2&gt;&gt; type? first [#this:is:a-valid-issue]
== issue!
</code></pre>
<p>Given that <code>:</code> is legal internally to the ISSUE!, that's one of the points guiding us toward ruling out SET-ISSUE! (as well as ruling out issues as words more generally), and favoring that a colon at the end is literally part of the content.</p>
<p>Note that if colons are internal to things that look word-ish, they are actually URL! (more specifically, <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Name">"Uniform Resource Names"</a>)</p>
<pre><code>&gt;&gt; type? first [urn:isbn:0451450523]
== url!
</code></pre>
<p>Silly or not, apostrophes are legal inside words:</p>
<pre><code>rebol2&gt;&gt; type? first ['abc'def]
== lit-word!

rebol2&gt;&gt; to word! first ['abc'def]
== abc'def
</code></pre>
<p>I actually don't think that's silly, because I want the words.</p>
<pre><code>if x is 10 [...]  ; there is debate on what this means, but I won't digress
if x isn't 10 [...]  ; natural complement

if did (match [~null~ integer!] null) [  ; did treats "boxed" nulls as truthy
    print "This one exists today, and avoids thinking there was no match."
]
if didn't match ...  ; complement of the above. 
</code></pre>
<p>Terminal apostrophes lead to a weird looking thing when quoted, seemingly enclosed in quotes like a string type.  But my desire to be able to have "name-prime" or "name-double-prime" style words like <strong><code>foo'</code></strong> or <strong><code>foo''</code></strong> (especially for variables that hold meta states) makes me tolerate the consequence of <strong><code>'foo'</code></strong> and learn to read it correctly... though I'll choose <strong><code>@ foo'</code></strong> or <strong><code>the foo'</code></strong> instead when writing in source.</p>
<p>What does this imply for edge cases, like lone apostrophe?  Rebol2 and Red call it illegal.  Ren-C had a usage as quoted void which was dropped, so it's back on the table.  Plain <strong><code>'</code></strong> <em>could</em> be a WORD!, but then <strong><code>''</code></strong> can't be... because that needs to be a quoted form of the single apostrophe.</p>
<p>As documented here recently, my own philosophy on <a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560">how far we should be willing to go with WORD!</a> has faced reckonings.  The introduction of SIGIL! solved the problems with wanting <strong>:</strong> and <strong>::</strong> as words, and said "no, they should not be words" and went in a new direction with that.</p>
<aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2164">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>So, when all is said and done, we have a set of types which don’t seem to be of general use, and have no convincing reason to exist, but are nonetheless kept in the language. And <strong>I want to know why that is</strong>, because I can’t figure it out.</p>
</blockquote>
</aside>
<p>We've <a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147">gone into the reasoning</a> for why <strong>$foo:</strong> does not exist, and why arrays are the "API" for letting you pick these apart as <strong>$[foo:]</strong> or <strong>[$foo]:</strong> etc. So again it's nothing to do with avoiding silliness... it's mechanically motivated, with me simply not knowing how to implement the underlying bytes and a pleasing API for destructuring it otherwise.</p>
<p>In terms of prohibiting any items <a href="https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163">in the SIGIL! table</a>, I am not by-and-large concerned about things that aren't competing for the same lexical space.  If there needs to be special code in the lexer to rule something out that works fine otherwise, then in my calculus, throwing in a branch with an error <em>"has a cost"</em> and is (some) addition of complexity.</p>
<p><em>The error branches are there to stop ambiguities and align with the rules of the implementation--not to keep parts out of your hands.</em></p>
<p>If that sounds like it's not enough of constraint, well... it is a big constraint.  Ambiguity-wise, Ren-C has a nearly-total lexical saturation for ASCII (in as far as its rules permit).  It's less ambiguous than Rebol for the most part, though it introduces some of its own... e.g. what is <strong><code>~/abc/~</code></strong>... is that a quasi-path! or a plain PATH! with meta-trash in the first and last positions?  (Right now this is a leading argument for ruling out path isotopes, because I want tildes in paths more than I want antiform or quasiform paths.)</p>
<p>Anyhoo... my advice to you would be to get a bit more experience in the medium...and <strong><a href="https://www.playyourwaysane.com/blog/finding-the-game">"Find The Game"</a></strong>, as we say in improv.  It's of course perfectly valid and desirable to scrutinize the design and the datatypes.  But if you had found the game, then I think you'd see these aspects as more of a tangential detail when weighed against bigger design issues... plus be more targeted in what things needed critique.</p>
<p>For myself, I'm bothered by things like:</p>
<pre><code>&gt;&gt; $1
== $1.00
</code></pre>
<p>I have little use for the MONEY! type, and when it can't serve correctly as DOLLAR-INTEGER! it becomes basically completely useless to me.</p>
<p>Some of these questions... like preserving quote-style string vs. non... register on the needle in ways that trying to assassinate THE-BLOCK! or TYPE-TUPLE! do not... especially when I have compelling applications for them.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164#post_2</link>
        <pubDate>Tue, 05 Mar 2024 14:11:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7213</guid>
      </item>
      <item>
        <title>What deserves to be a datatype?</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2159">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159/7">Header dialect and multiline strings</a>
</div>
<blockquote>
<p>(If I may philosophise for a moment… I feel there’s a big, gaping hole in my understanding of how we decide ‘what Rebol syntax is’, so to speak. Perhaps my caution around sigils and TYPE-BLOCK!s are a manifestation of that hole, as is this. I’ll make a new thread about it if I can figure out any clearer way to articulate my concerns.)</p>
</blockquote>
</aside>
<p>This is that thread.</p>
<p>I’ll begin by observing that in Rebol, the complexity of the lexer vs the parser is ‘reversed’ compared to other programming languages. In Rebol, the actual syntax is highly minimalistic: there’s only a few constructs which provide explicit grouping, and none provide anything more than a simple list of items. By contrast, the lexer is exceedingly complicated: nearly every datatype has its own literal form, oftentimes more than one.</p>
<p>Language design ends up ‘reversed’ in a similar way. In most languages, discussion centres around questions like ‘which new syntactic constructs should we add’. By contrast, Rebol (and especially Ren-C) more often poses the question: ‘which new datatypes do we want to include, with which literal syntax?’.</p>
<p>At the moment, I still feel uncomfortable discussing such questions. I don’t feel that I fully understand the kind of criteria we should consider to know whether a datatype is worth including or not. Or, more concisely, I don’t understand how decide: <strong>what deserves to be a Ren-C datatype?</strong>.</p>
<hr>
<p>One obvious criterion is simply, <em>datatypes representing common types of data</em>. This is why we have things like MONEY! and FILE! and DATE! and so on. Ultimately this stems from Rebol’s heritage as a data-transfer format, but obviously these types are far more broadly useful.</p>
<p>Another obvious criterion is <em>syntax which is important for programming</em>. This gives us GROUP! and GET-WORD! and PATH! and so on. These exist as datatypes ultimately because Rebol is homoiconic, but their presence has suggested a wide range of uses beyond simple programming.</p>
<p>This accounts for most of the types in Ren-C. And, if that were all to it, I’d have no objections.</p>
<hr>
<p>But, unfortunately, there are some other types, whose presence is explained by neither of those criteria. As I’ve said previously, the ones which make me feel most uncomfortable are THE-* and TYPE-*. Neither of these represent common types of data that one would want to pass around. And, with the possible exceptions of THE-WORD! and TYPE-BLOCK!, they’re basically useless in ‘regular’ programming.</p>
<p>Despite this, <a class="mention" href="https://forum.rebol.info/u/hostilefork">@hostilefork</a> has lobbied pretty hard for both of these. Hopefully it should be clear now why I find this viewpoint confusing. I can’t say the existence of these types is <em>problematic</em>, as such, but I feel this <strong>indicates a gap in my understanding of the language</strong>.</p>
<p>The closest to an explanation I’ve found is that these types are useful in dialecting. That is, they may not be useful for programming <em>per se</em>, but having the syntax around is useful for constructing new languages. (For instance, using TYPE-WORD!s in PARSE dialect, or THE-WORD!s for module inclusion.) The problem with this is, <a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147">as we’ve established</a>, that there’s a huge number of syntaxes which would be ‘useful in dialecting’: clearly, this is too low a bar for deciding ‘what deserves to be a datatype’.</p>
<p>(And, incidentally, this also establishes that we’re quite willing to reject datatypes that don’t seem to be of sufficiently general usage.)</p>
<p>Another argument is simply consistency: other sigils have versions for words, blocks, tuples, etc., so THE-* and TYPE-* should as well. But this doesn’t strike me as particularly convincing — there’s nothing intrinsic in Ren-C which requires sigils to generalise to all possible types. Indeed, we’re quite willing to avoid doing so when it would make no sense. (For instance, we don’t have ISSUE-TEXT!, ISSUE-BINARY!, ISSUE-EMAIL!… we just have a single textual ISSUE! type, because doing otherwise would be silly.)</p>
<p>So, when all is said and done, we have a set of types which don’t seem to be of general use, and have no convincing reason to exist, but are nonetheless kept in the language. And <strong>I want to know why that is</strong>, because I can’t figure it out.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164#post_1</link>
        <pubDate>Tue, 05 Mar 2024 08:20:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7212</guid>
      </item>
      <item>
        <title>Terminology MAP</title>
        <dc:creator><![CDATA[@bradrn]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="GiuseppeChillemi" data-post="3" data-topic="2162">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/g/838e76/40.png" class="avatar"> GiuseppeChillemi:</div>
<blockquote>
<p>However a single page in alphabetical order (and eventually sortable by date) of all these messages is needed as index.</p>
</blockquote>
</aside>
<p>I agree with this. Several times now I’ve been thinking of something, only to discover that it’s already been thought of and answered — but not in an obvious place. It feels like Ren-C’s design is slowly becoming more stable, so I feel an index would be really helpful.</p> ]]></description>
        <link>https://forum.rebol.info/t/terminology-map/2162#post_4</link>
        <pubDate>Mon, 04 Mar 2024 01:05:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7211</guid>
      </item>
      <item>
        <title>&quot;Extension Types&quot; Implementation (On Hold)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Note that extension types were removed--at least temporarily--because there were more fundamental things in the type system which needed to be resolved.</p>
<p>However, a similar approach is likely to be re-added once things settle down, that similarly reserve one of the 4 platform-pointer-sized slots for type information.</p>
<blockquote>
<p>Of this byte, only 64 of the states are used in R3-Alpha--and I believe Red. This was chosen instead of 256 in order to limit the number of kinds that need to be handled in a TYPESET! to 64 bits...making typesets small enough to fit in the rest of the cell. (That simplicity is nice for implementation, but points to a pretty big weak spot in the type system for more sophisticated purposes...which new designs will be needed for!!)</p>
</blockquote>
<p>Though the "unlimited" number of types from extension types is on hold, the basic limit of 64 fundamental types has been lifted to 256.</p>
<p>It might sound like a small thing to implement, but rigging it up to work and not perform terribly involved some thinking.</p>
<p>You can see some of these new types and SIGIL! here:</p>
<p><a href="https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163" class="inline-onebox">REIFY and DEGRADE: a Narrower META and UNMETA</a></p>
<p>You can do as you wish with them in dialects, but the evaluator meaning is specific...and I definitely do want to put together a presentation explaining why they are all necessary and what they do.</p>
<aside class="quote no-group" data-username="GiuseppeChillemi" data-post="3" data-topic="1203">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/g/838e76/40.png" class="avatar"> GiuseppeChillemi:</div>
<blockquote>
<p>I have not logged in sice last year but I have been here reading the progresses without logging in</p>
</blockquote>
</aside>
<p>Last year I didn't get all that much done (more has happened in the past two months than all of last year).  But there were a few things:</p>
<p><a href="https://forum.rebol.info/t/2023-another-year-a-few-things-that-happened/2089" class="inline-onebox">2023, Another Year 💨 A Few Things That Happened</a></p> ]]></description>
        <link>https://forum.rebol.info/t/extension-types-implementation-on-hold/1203#post_4</link>
        <pubDate>Sun, 03 Mar 2024 20:40:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7210</guid>
      </item>
      <item>
        <title>Terminology MAP</title>
        <dc:creator><![CDATA[@GiuseppeChillemi Giuseppe Chillemi]]></dc:creator>
        <description><![CDATA[ <p>Thank you for the links. Waiting to see other "start-to-finish" containers of design messages for a topic. However a single page in alphabetical order (and eventually sortable by date) of all these messages is needed as index.</p>
<p>Also, it was interesting to see my gitter message from the past with this specific problem. Thank you!</p>
<p>I will study what you already have written to uderstand the whole design choices.  Looking forward to see them.</p> ]]></description>
        <link>https://forum.rebol.info/t/terminology-map/2162#post_3</link>
        <pubDate>Sun, 03 Mar 2024 20:31:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7209</guid>
      </item>
      <item>
        <title>Console Treatment of VOID vs. TRASH</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><strong>This behavior has flipped around more times than I can count, but I think when all is taken into consideration the right thing to do is to not display TRASH.</strong></p>
<p>It's a curious case of going full-circle, to align with historical Rebol's choice that what doesn't show is the same thing as what's in an unset variable.  <em>(Though there really are only so many choices.)</em></p>
<p>This does mean you don't see a "fully instructive feedback" on when something generates trash.  ...BUT, some cases like unset variables will often error before you even see that:</p>
<pre><code>&gt;&gt; foo: ~

&gt;&gt; foo
** Error: ...
</code></pre>
<p>So that's at least some argument further in favor of it.</p>
<p>Further, now that <a href="https://forum.rebol.info/t/why-shouldnt-void-be-done-with-a-void-word-antiform/2160">voids are word antforms</a>, they are no longer the "lightest" candidates representationally for vanishing, even if their meaning is vanishing-oriented.</p>
<pre><code>&gt;&gt; if false [&lt;a&gt;]
== ~void~  ; anti
</code></pre>
<h2>
<a name="remember-there-are-other-ui-options-in-rich-consoles-1" class="anchor" href="https://forum.rebol.info#remember-there-are-other-ui-options-in-rich-consoles-1"></a>Remember, There Are Other UI Options in Rich Consoles</h2>
<p>I think that if a light gray <strong><code>== ~  ; anti</code></strong> showed up and then faded out of the display, that might make a neat default.  I'd have to see the effect.</p> ]]></description>
        <link>https://forum.rebol.info/t/console-treatment-of-void-vs-trash/2045#post_3</link>
        <pubDate>Sun, 03 Mar 2024 19:12:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7208</guid>
      </item>
      <item>
        <title>Terminology MAP</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="GiuseppeChillemi" data-post="1" data-topic="2162">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/g/838e76/40.png" class="avatar"> GiuseppeChillemi:</div>
<blockquote>
<p>Also, it would be great to have a link to the introductiory post to each feature (like UPARSE) and all the subsequent posts regarding the design.</p>
</blockquote>
</aside>
<p>So I'm aiming at what you suggest--even going as far as to reorganize the posts here "wiki-style" to cull dead-ends, and make start-to-finish design summaries.</p>
<p>For example:</p>
<p><strong><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">The History of Multi-Return in Ren-C</a></strong></p>
<p>Doing this maintenance is an ongoing task... and I can't stop working on things to do focus solely on documentation.  But if there's something specific you are curious about, I can raise the priority of organizing the information here on that topic better.</p>
<aside class="quote no-group" data-username="GiuseppeChillemi" data-post="1" data-topic="2162">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/g/838e76/40.png" class="avatar"> GiuseppeChillemi:</div>
<blockquote>
<p>This could be done either via a direct link to the introductory post for the new feature, and also filtering via TAG and DATE using tags like <span class="hashtag">#ANTIFORM</span> <span class="hashtag">#DESIGN</span></p>
</blockquote>
</aside>
<p>Using tagging on the forum more effectively is a good idea.  But there are also categories, and there is a <a href="https://forum.rebol.info/c/usage/feature-discover/24">Feature Discover</a> one which could be better.</p>
<p>For now...I can give you a couple of quick pointers that should be plenty to occupy you.  <em>(You can try Ren-C in the browser at <a href="http://hostilefork.com/media/shared/replpad-js/">the online ReplPad</a>, but please do not advertise it to the world at large.  It is not meant to be published broadly yet.)</em></p>
<p>Isotopes and Quasiforms/Antiforms are explained reasonably well.  READ THIS CAREFULLY:</p>
<p><strong><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">A Justification of Generalized Isotopes</a></strong></p>
<p>As for UPARSE, the best place to get a sense of what it can do is probably the tests.  Each combinator has its own file:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/tree/master/tests/parse">https://github.com/metaeducation/ren-c/tree/master/tests/parse</a></strong></p>
<aside class="quote no-group" data-username="GiuseppeChillemi" data-post="1" data-topic="2162">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/letter_avatar_proxy/v4/letter/g/838e76/40.png" class="avatar"> GiuseppeChillemi:</div>
<blockquote>
<p>it is hard to follow what has been changed/created, and the discussion that led to the development of a feature, from start to end.</p>
</blockquote>
</aside>
<p>It could be made somewhat easier, but understanding is always a fundamentally hard thing.</p>
<p>Regardless of how much work I put into documenting, understanding requires patience... putting in effort... and asking questions when you don't understand.</p>
<p>I think you will find it very worth it.  The details are addressing important points... including this one from you  (as I've mentioned before) that <a href="https://web.archive.org/web/20210926170338/https://gitter.im/red/red?at=60c7d06956df183c231514c6">you brought up in Red Gitter</a> <em>(<code>archive.org</code> link, as I guess Gitter scrapped their history...lovely)</em></p>
<blockquote>
<p><em>"When code is data and data is code, sometimes you can't distinguish a situation from a value:"</em></p>
<pre><code>&gt;&gt; a: [b c #[none!]]

&gt;&gt; probe type? probe pick a 3 
none
none!

&gt;&gt; probe type? probe pick a 10
none
none!
</code></pre>
<p><em>"None is returned either as an element picked from a block and when we are out of the boundaries. In any function of this kind, you have to create another one to check if we are in a situation that returns None. It's just a personal thought spoken out instead of remaining in my mind."</em></p>
</blockquote>
<p>Couldn't have said it better myself.  And this is why things like antiforms exist, which can't be put in blocks.  But then that raises the question of what your options are when you want to put a representation of that state in the block... which is why quasiforms exist.</p>
<pre><code> &gt;&gt; a: [b c]

 &gt;&gt; pick a 3
 == ~null~  ; anti

 &gt;&gt; append a null
 ** Script Error: append expects [~void~ element? splice?] for its value argument

 &gt;&gt; append a meta null
 == [b c ~null~]

 &gt;&gt; pick a 3
 == ~null~

 &gt;&gt; null? pick a 3
 == ~false~  ; anti

 &gt;&gt; unmeta pick a 3
 == ~null~  ; anti

 &gt;&gt; null? unmeta pick a 3
 == ~true~  ; anti
</code></pre>
<p>If you think Rebol-family languages are interesting, I see almost no way to not find Ren-C interesting.  But somehow the Red people accomplish it. <em><a href="https://www.youtube.com/watch?v=4Ar2TaIY5PU">There's a difference...</a></em></p>
<blockquote>
<p><em>"It is difficult to get a man to understand something, when his salary depends on his not understanding it."</em><br>
-- Upton Sinclair</p>
<p><em>"Convictions are more dangerous enemies of truth than lies"</em><br>
--Friedrich Nietzsche.</p>
</blockquote> ]]></description>
        <link>https://forum.rebol.info/t/terminology-map/2162#post_2</link>
        <pubDate>Sun, 03 Mar 2024 17:38:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7207</guid>
      </item>
      <item>
        <title>REIFY and DEGRADE: a Narrower META and UNMETA</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>In the "small improvements can be big" category, I think that I've settled on the name for the function that turns quasiforms into antiforms, but leaves everything else alone: <strong>DEGRADE</strong>...and its complement <strong>REIFY</strong> which turns antiforms into quasiforms (but leaves everything else alone).</p>
<pre><code>&gt;&gt; first [1020 ~null~]
== 1020

&gt;&gt; second [1020 ~null~]
== ~null~

&gt;&gt; degrade first [1020 ~null~]
== 1020

&gt;&gt; degrade second [1020 ~null~]
== ~null~  ; anti

&gt;&gt; 304
== 304

&gt;&gt; reify 304
== 304

&gt;&gt; true
== ~true~  ; anti

&gt;&gt; reify true
== ~true~
</code></pre>
<p>If you're dealing with a full-band situation where you genuinely don't know if you're working with a "meaningful quasiform" where <em>quasi means quasi</em>, you have to use META and UNMETA.  But if you know that quasiforms aren't part of your data of interest, REIFY and DEGRADE can help you dodge adding and removing quote marks much (or most) of the time.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/12">Weird WORD!s - Allow, But Escape Them?</a>
</div>
<blockquote>
<p>Maybe it would be better (and give Chris less of a heart attack) if it said:</p>
<pre><code class="lang-plaintext">for-each [sigil' items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    '::    [  word:  tu.p.le:  pa/th:  [bl o ck]:  (gr o up): ]
    ':     [ :word  :tu.p.le  :pa/th  :[bl o ck]  :(gr o up)  ]
    '^     [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    '&amp;     [ &amp;word  &amp;tu.p.le  &amp;pa/th  &amp;[bl o ck]  &amp;(gr o up)  ]
    '@     [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    '$     [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
 ][
      for-each item items [
          if (unmeta sigil') &lt;&gt; sigil of item [fail [mold item]]
      ]
 ]
</code></pre>
</blockquote>
</aside>
<p>I like how DEGRADE can be used in situations like this to help you strike the quotes on the normal values...since SIGIL OF never returns quasiforms, only SIGIL! or a null antiform:</p>
<pre><code>for-each [sigil items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    ::     [  word:  tu.p.le:  pa/th:  [bl o ck]:  (gr o up): ]
    :      [ :word  :tu.p.le  :pa/th  :[bl o ck]  :(gr o up)  ]
    ^      [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    &amp;      [ &amp;word  &amp;tu.p.le  &amp;pa/th  &amp;[bl o ck]  &amp;(gr o up)  ]
    @      [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    $      [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
][
    for-each item items [
        if (degrade sigil) &lt;&gt; sigil of item [
            fail [mold item]
        ]
    ]
]
</code></pre>
<p>I think this will be a useful and common pattern.</p>
<p>Void being a word antiform is locking this all up into place!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=12" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=12" title=":+1:" class="emoji only-emoji" alt=":+1:" loading="lazy" width="20" height="20"></p> ]]></description>
        <link>https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163#post_1</link>
        <pubDate>Sun, 03 Mar 2024 15:28:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-7205</guid>
      </item>
  </channel>
</rss>

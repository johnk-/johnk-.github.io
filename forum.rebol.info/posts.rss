<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>The Pending New Meaning of GET-XXX!</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="1901">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1901">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But Like I Said, You Can't Wish Away Complexity...</p>
</blockquote>
</aside>
<p>Indeed you cannot.</p>
</blockquote>
</aside>
<p>Why not? I think you can. It won't work, but you can wish it away.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-pending-new-meaning-of-get-xxx/1901/3</link>
        <pubDate>Sun, 27 Nov 2022 21:09:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6503</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>While <strong>~null~</strong> is definitely more verbose than using <strong>_</strong> to null out variables, I'm not entirely sure that nulling out variables needs to be in the scheme of things any more succinct than setting a variable to false</p>
</blockquote>
</aside>
<p>Having made the change and examined all the callsites, I definitely have some mixed feelings.</p>
<p>Turning <strong><code>_</code></strong> back into a WORD! vs a separate BLANK! type is the only thing that I might see as a reasonable alternative, and then setting it to be null by default, but then settable to anything else in contexts you wanted it.  You could then take it for granted that <strong><code>(x: _)</code></strong> would set X to null just as much as you would be that <strong><code>(x: null)</code></strong> would.</p>
<p>It's tempting to try picking something else to represent nothingness.  What if you could opt-out of a FOR-EACH variable using a lone apostrophe?</p>
<pre><code>&gt;&gt; for-each ' [1 2 3] [print "no variable"]
no variable
no variable
no variable
</code></pre>
<p>It's more slight than <strong><code>for-each _ [1 2 3]</code></strong>, but not awful.  And since voids are used to opt-out in slots it actually dovetails nicely with if the evaluated forms were allowed to opt out via void:</p>
<pre><code>for-each (if false ['x]) [1 2 3] [print "no variable"]
</code></pre>
<p>That seems to make perfect sense.  If your expression produces no iterative variables to bind in the body assume that you didn't need them.  The alternative of <strong><code>(if false ['x] else [_])</code></strong> or even <strong><code>(if false 'x else '_)</code></strong> seems like busywork.</p>
<p>This even would mean you could use <strong><code>()</code></strong> as a less slight alternative, if you didn't like the <strong><code>'</code></strong>  syntax:</p>
<pre><code>for-each () [1 2 3] [print "no variable"]  ; actually pretty nice!
</code></pre>
<p>The premise may hold for multi-returns also:</p>
<pre><code>&gt;&gt; [a ' c]: pack [1 2 3]
== 1

&gt;&gt; c
== 3

&gt;&gt; [a () c]: pack [4 5 6]
== 4

&gt;&gt; c
== 6
</code></pre>
<p>I'm not sure it looks worse than <strong><code>[a _ c]: pack [...]</code></strong>, and would open up:</p>
<pre><code>&gt;&gt; [a _ c]: pack [8 9 10]
== 8

&gt;&gt; _
== 9

&gt;&gt; c
== 10
</code></pre>
<p><em>One potential qualm:</em> a quoted word vs. a regular word is seen as a different instruction by both FOR-EACH and multi-return.  So from a type system perspective it's like you're conflating some meanings of what QUOTED! is supposed to signal when you use an apostrophe vs. a distinct BLANK! type.  e.g. there's no "unquoted void literal", only a quoted one.</p>
<p>In the case of how the mechanics of LET works, this is actually a problem, because the apostrophes escape things it's not supposed to consider part of the LET :-/</p>
<pre><code> let [a 'b]: multi-returner ...
 =&gt;
 let a, [a b]: multi-returner ...  ; just drops the quote level from quoted things

 let [a ' c]: multi-returner ...
 =&gt;
 let [a c], [a ??? c]: multi-returner ...  ; can't drop quote level from lone quote
</code></pre>
<p>Yes, it could say that there's an exception for lone quotes and they stay as is, but it sort of points to the general unease and "weird exceptions" you have to make when the quoted state of void is used to represent something that is only quoted at all because it's "probably not meaningful otherwise".  Just seems to lead to snakey rules that the more-visible blank doesn't require.</p>
<p>Or maybe we just say <strong><code>()</code></strong> is what you use, I don't know.</p>
<pre><code>let [a () c]: multi-returner ...
</code></pre>
<p>Thinking further... today BLANK! is the default used by things like ARRAY but that could have different choices too:</p>
<pre><code>&gt;&gt; array 3
== [' ' ']  ; quoted voids

&gt;&gt; array 3
== [~ ~ ~]  ; isotopic voids

&gt;&gt; array 3
== [# # #]  ; empty tokens
</code></pre>
<p>Of those choices, I'd probably say I like the isotopic voids, just because of how ornery they become when evaluated....and orneryness seems like a good characteristic for when you didn't specify an /INITIAL value to be used.</p>
<p>But just because we would return <strong>_</strong> to the WORD! pool... would making it defined to evaluate to a null isotope be a good thing?  People might want it for other purposes (consider things like the <a href="https://underscorejs.org/">underscore.js library</a>, where it's the name of a utility module that tries to disappear).</p>
<pre><code>&gt;&gt; _: import %my-utility-lib.r

&gt;&gt; _.sum [1020 304]
== 1234
</code></pre>
<p>If you're going to open <strong>_</strong> up for potentially interesting purposes, but then turn around and say everyone assumes it evaluates to null, then I'm not clear that the ability to redefine it is as much a benefit as a potential nuisance.  <img src="https://forum.rebol.info/images/emoji/twitter/angry.png?v=9" title=":angry:" class="emoji" alt=":angry:"></p>
<p>So I think my leaning on this would be that if underscore is given back to the word pool, it should not be defined by default.  It would be particular people who decided that making underscore mean null was their expedient use for the symbol, and defining it to be that.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/8</link>
        <pubDate>Sun, 27 Nov 2022 13:01:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6502</guid>
      </item>
      <item>
        <title>Python Speedup Proposals</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The original "CPython" implementation is in some ways similar to Rebol/Red... though these days Ren-C is more aligned with the stackless Python implementation...which is also written in C, but distinct from CPython.</p>
<p><em>(But Ren-C's design overall is a lot less comparable to anything, due to the number of very "alien" ideas in it, but that I think are what gives it more notable properties.)</em></p>
<p>In any case, despite running an interpreter loop and doing kind-of-what-Rebol-does, they've committed themselves to doing some speedup proposals and apparently it's paying off:</p>
<p><a href="https://devblogs.microsoft.com/python/python-311-faster-cpython-team/" class="inline-onebox">A Team at Microsoft is Helping Make Python Faster - Python</a></p>
<p>Some of their proposals involve JIT-compiling things (which they know won't work on restrictive platforms like iOS).  But they apparently have done a lot of tweaks besides that which have turned out beneficial.  Because it's a C interpreter there might be something applicable to be learned by looking at their "Stage 1" and "Stage 2" changes.</p>
<blockquote>
<h3>Stage 1 -- Python 3.10</h3>
<p>The key improvement for 3.10 will be an adaptive, specializing interpreter. The interpreter will adapt to types and values during execution, exploiting type stability in the program, without needing runtime code generation.</p>
<h3>Stage 2 -- Python 3.11</h3>
<p>This stage will make many improvements to the runtime and key objects. Stage two will be characterized by lots of "tweaks", rather than any "headline" improvement. The planned improvements include:</p>
<ul>
<li>Improved performance for integers of less than one machine word.</li>
<li>Improved peformance for binary operators.</li>
<li>Faster calls and returns, through better handling of frames.</li>
<li>Better object memory layout and reduced memory management overhead.</li>
<li>Zero overhead exception handling.</li>
<li>Further enhancements to the interpreter</li>
<li>Other small enhancements.</li>
</ul>
<h3>Stage 3 -- Python 3.12 (requires runtime code generation)</h3>
<p>Simple "JIT" compiler for small regions. Compile small regions of specialized code, using a relatively simple, fast compiler.</p>
<h3>Stage 4 -- Python 3.13 (requires runtime code generation)</h3>
<p>Extend regions for compilation. Enhance compiler to generate superior machine code.</p>
</blockquote> ]]></description>
        <link>https://forum.rebol.info/t/python-speedup-proposals/1992/1</link>
        <pubDate>Sun, 27 Nov 2022 10:05:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6501</guid>
      </item>
      <item>
        <title>VID/S or Spaces, from Red&#39;s hiiamboris</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>There's now a 250-line VID/S markdown viewer example called "Redmark":</p>
<p><a href="https://codeberg.org/hiiamboris/red-spaces/src/branch/master/programs/redmark.red" class="inline-onebox">red-spaces/redmark.red at master - red-spaces - Codeberg.org</a></p>
<p>It depends on an external function called DECODE-MARKDOWN, which means its starting from a Red-friendly format of some kind.</p>
<p>If DECODE-MARKDOWN produces something parallel to an HTML DOM then this would basically be comparable to the CSS you'd need to render that on a page with proper resize behavior, I guess...</p>
<p><a href="https://codeberg.org/hiiamboris/red-spaces/src/branch/master/programs/#red-mark-redmark-red">Some notes about it here.</a></p>
<p>                    <a href="https://i.gyazo.com/548ce314237cf14e8daea7fd77503e13.gif" target="_blank" rel="noopener" class="onebox">
            <img src="https://i.gyazo.com/548ce314237cf14e8daea7fd77503e13.gif" width="690" height="497">
          </a>

</p> ]]></description>
        <link>https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886/4</link>
        <pubDate>Sun, 27 Nov 2022 08:46:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6500</guid>
      </item>
      <item>
        <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Historically one might have asked why ELSE doesn't think falseness is something worth reacting to:</p>
<pre><code>&gt;&gt; 1 = 2 else [print "Why not print?"]
Why not print?  ; seems not so bad, right?
</code></pre>
<p>The idea was panned, because <code>#[false]</code> was <em>a value</em> and ELSE's main job was to react to the situation of a branching construct that didn't produce a value:</p>
<pre><code>&gt;&gt; math-broken: if 1 = 1 [false] else [true]
== #[false]  ; if this were #[true], math seems broken
</code></pre>
<p>But now, the actual falsey <code>~false~</code> state is isotopic.  And some years of struggle with the parallel problem of what to do with branches that returned "non-values" bore curious fruit: a box that could hold a "non-value" like a null.</p>
<pre><code>&gt;&gt; if false [null]
== ~null~  ; isotope
     ^-- there is no result

&gt;&gt; if true [null]
== ~[~null~]~  ; isotope
     ^-- there is a result and it is null
</code></pre>
<p>Isotopic blocks containing one element will decay to that one element in most situations.  But ELSE is sensitive to the difference via a ^META parameter.  If someone has gone through the effort to box up a null or void vs leave it as a plain isotope, the ELSE assumes it's a meaningful result and should pass it on.  And conditional expressions know to do this; they box up nulls and voids if they are produced by executing branches.</p>
<p><strong>The same technique could work for false.</strong></p>
<pre><code>&gt;&gt; if 1 = 1 [false]
== ~[~false~]~  ; isotope

&gt;&gt; if 1 = 1 [false] else [true]
== ~[~false~]~  ; isotope

&gt;&gt; math-broken: if 1 = 1 [false] else [true]
== ~false~  ; isotope
</code></pre>
<p>It's barely any additional work for conditionals to do on top of what they're doing already.  Although it can result in branches producing false to cost a small bit more than they do today <em>(I wouldn't worry about it, these single element boxes could be optimized if it was a problem)</em></p>
<p>But I don't know how useful it would actually be.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:">  Just writing down the observation.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991/1</link>
        <pubDate>Sun, 27 Nov 2022 06:00:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6499</guid>
      </item>
      <item>
        <title>The History of Multi-Return in Ren-C</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1134">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But lingering issues regarding wrapping and composing multi-returns remained...</p>
</blockquote>
</aside>
<p>The proxying technique had shown clear advantages for the authors of functions, to be able to do direct assignments vs. need to remember to always <strong><code>SET</code></strong> the named variable passed in.</p>
<p>But underneath the hood, the names of the variables were still like inputs to the lower-level function.  This went as far as trying to act compatibly with the variable-passed-by-refinement trick that historical Redbol used for multiple returns.</p>
<p>Among the many problems were trying to write something like ENCLOSE.  An enclosing function could only influence the primary output, unless it went through some particularly convoluted work:</p>
<ul>
<li>
<p>It would have to capture the variable name passed in before delegating, because the name would be repurposed as the proxied value slot</p>
</li>
<li>
<p>The delegated function would be called and would update the variable as part of its RETURN</p>
</li>
<li>
<p>The encloser would then have to read back this written variable with GET to see it, and use SET to update it...again.</p>
</li>
</ul>
<p>Here's an example of what you could think you might have to do:</p>
<pre><code>multi-returner: func [
    return: [integer!]
    extra: [integer!]
][
    extra: 20  ; by this point, variable passed as /EXTRA hidden
    return 10  ; stowed /EXTRA variable written back using EXTRA's 20 value
]

wrapper: enclose :multi-returner func [f [frame!]] [
    let extra-var: f.extra  ; capture var before call via DO moves it aside
    result: do f  ; callee proxies input variable during RETURN
    set extra-var (get extra-var) + 1  ; get new written value and update it 
    return result + 1
]

&gt;&gt; [a b]: wrapper
== 11

&gt;&gt; a
== 11

&gt;&gt; b
== 21
</code></pre>
<p><em>The situation was actually even worse than that.</em>  All the complex logic for filling proxy slots with variable WORD!s was done during the frame building.  e.g. <strong><code>extra-var</code></strong> wasn't the hypothetical "parameter passed to extra before it got shifted into a hidden variable slot by FUNC", it was already the unset slot to be filled by the callee.  And the actual variable name was private, known only to the enclosed function.</p>
<p><em>And it's worse than that</em> if you want to preserve the ability to have behavior depending on how many inputs are requested, because there may be no variable at all... or an "opt in for the feature without a variable" placeholder.  Correct code would be much more convoluted, if meaningful code could be written at all.</p>
<p>The headaches go deeper.  Copying a frame and running it multiple times introduced semantic and ordering problems about the writing of these additional outputs!</p>
<h2>Simply Put: Variable Names As Inputs Make Poor Outputs</h2>
<p>All of this pointed to the inconvenient truth:</p>
<p><strong>Implementing a function's conceptual outputs by passing named variables as input that are imperatively written during the function's body--anywhere, even at the end--is something that will break composition.</strong></p>
<p><strong>It's also horrible for atomicity, because a SET of an output variable may happen but then there's an error which occurs before the final return result can be produced... so any multi-return function working in this way is either broken or bearing an undue burden to do its own "transaction management", which is to say probably also broken.</strong></p>
<p>Of course we knew this.  But to get the desired effects (single return unless you use a SET-BLOCK!), there's no other choice, right?</p>
<p>The idea of making an ANY-VALUE! which tried to bundle values was nixed in the beginning.  Because if we declared some new datatype to represent a multi-return pack that decays to its first value when assigned to a variable, you enter a catch-22, like this early puzzle when <strong><code>@[...]</code></strong> was being considered to denote multi-returns:</p>
<pre><code>multi-return: func [] [
    return @[10 20]  ; assume RETURN is "magic" and returns @[10 20] vs. 10
]

&gt;&gt; x: multi-return
== 10

&gt;&gt; [x y]: multi-return
== 10

&gt;&gt; x
== 10

&gt;&gt; y
== 20
</code></pre>
<p>The problems are apparent on even a trivial analysis.  These "highly reactive" <strong><code>@[...]</code></strong> values wreak havoc in a general system.  If you walked across a block and encountered one, trying to work with it to store them in a variable would introduce distortions on assignment when they "decayed" to their first element.</p>
<pre><code>for-each x [foo @[10 20] bar] [
    if integer? x [...]  ; INTEGER? sees @[10 20] as just 10
] 
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji" alt=":man_facepalming:"> ...but gee... if only there were some variation of BLOCK! which you could be guaranteed not to encounter when enumerating other blocks, and that couldn't be stored in variables... and a method for dealing with transforming them into and out of reified states so you could work with them...</p>
<p><em>Hey, waitaminute...</em> <img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=9" title=":atom_symbol:" class="emoji" alt=":atom_symbol:"></p>
<h2>September 2022: Core Multi-Return via Isotopic BLOCK!</h2>
<p><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">Generalized Isotopes</a> made longstanding problems seem to fall like dominos; like block splicing and error handling.  And they could be applied here, too... solving several profound problems:</p>
<ul>
<li>
<p>As with all isotopes, you wouldn't be able to put BLOCK! isotopes in blocks...alleviating many conceptual problems.</p>
</li>
<li>
<p>Yet even more severely, you wouldn't be able to put BLOCK! isotopes in <em>variables</em>.  Isotopic BLOCK!s would decay to their first value when assigned to <em>any</em> variable</p>
<ul>
<li>
<p>This turned out to be the <em>only</em> isotopic "decay" mechanism required, subsuming prior concepts like decaying "heavy null" to "light null".  Heavy null would simply be a null representation in an isotopic block.</p>
</li>
<li>
<p>Representing things like null would be possible since ^META values would be used in the multi-return convention, to afford the multi-return of isotopes themselves</p>
</li>
</ul>
</li>
<li>
<p>Fitting in with the general rules of isotopes, a QUASI-BLOCK! would evaluate to an isotopic block:</p>
<pre><code>&gt;&gt; ~['10 '20]~
== ~['10 '20]~  ; isotope

&gt;&gt; x: ~['10 '20]~
== 10
</code></pre>
</li>
<li>
<p>Functions that might be interested in the isotopic state would need to take a parameter via a ^META parameter, in which case they would receive a QUASI-BLOCK! vs the decayed parameter</p>
<ul>
<li>
<p>A good example of a function that would want this would be RETURN, in order to be able to have a forwarding mode that would return an isotopic result vs. its decayed first value</p>
</li>
<li>
<p><strong>This doesn't rule out the proxying-named-output-variable concept</strong>; in fact it fixes its problems, by limiting the relevance of the fact that proxying is being used to the interior of the function, and making its external speak the isotopic block protocol.  If you want a proxying-FUNC you can have it.</p>
</li>
<li>
<p>It also opens the doors to many other conceptions of how to abstract the multi-return process</p>
</li>
</ul>
</li>
<li>
<p>SET-BLOCK! assignments would have special understandings of how to decompose isotopic blocks and assign the component variables</p>
<ul>
<li>
<p>This would break the uneasy "backchannel" between caller and callee of variable names</p>
</li>
<li>
<p>The most obvious sign this had been a problem was that mere parenthesization would break historical multi-assignment:</p>
<pre><code>&gt;&gt; [a b]: multi-return   ; would work

&gt;&gt; [a b]: (multi-return)  ; would act like `(a: multi-return)`
</code></pre>
</li>
<li>
<p>Now any expression that doesn't store a variable as intermediate can act pass-thru (such as a conditional), and if a variable wanted to capture the multi-return character temporarily it could META it...potentially manipulate the QUASI-BLOCK!, and UNMETA it back</p>
</li>
</ul>
</li>
</ul>
<h2>Casualties of Composability</h2>
<p>One casualty of this was be the feature of being able to make a function's behavior depend on how many outputs were requested.  But the feature can still be achieved with enfix quoting left-hand-side and managing the assignment, it's just no longer be something the core attempts to generalize.</p>
<p>Another casualty is legacy compatibility with passing in variable names via refinement.  But again: this feature could be achieved by AUGMENT-ing the function with the refinement, then ENCLOSE-ing that with something that wrote the multi-return's output to the variable passed in via that augmented refinement.</p>
<p>But there's really no competition here.  As I've hopefully made clear, passing in a named variable via refinement is simply not in the same league as a mechanism which legitimately makes additional outputs.</p>
<p><strong>As usual with these things, I'll admit it may not be simple or obvious at first glance, but the results are speaking for themselves!</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/12</link>
        <pubDate>Sun, 27 Nov 2022 04:54:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6498</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Question 3: Should BLANK! Evaluate to NULL ?</p>
</blockquote>
</aside>
<p>I worked up a test for this and I have to say that it looks very good.</p>
<p><em>Now that I've seen it, I don't want to go back.</em> Ren-C aims for solid and pleasing parts... and the lone apostrophe doesn't have that solidity for something so fundamental.</p>
</blockquote>
</aside>
<p>I found a different solution to this particular problem, <a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989">to where <strong><code>~null~</code></strong> is conveyed by an isotopic word</a>.</p>
<p><strong>This gives us a convenient and relatively readable meta-representation for null isotopes... as the quasiform of null.</strong></p>
<pre><code>&gt;&gt; make object! [x: null]
== make object! [
    x: ~null~
]
</code></pre>
<p>I tried this after feeling success from using isotopic WORD! forms for signaling <strong><code>~true~</code></strong> and <strong><code>~false~</code></strong>.  Being isotopic, none of these signaling words can be put in blocks directly... but must be transformed first.  (That's a new thing for a "logic!" representation, but not a new thing for nulls.)</p>
<p>Having them be word!s in their cell guts may seem odd vs. having a "distinct type" with a lexical form.  But I think this squares the circle with how words were often used in lieu of a lexical type in historical Redbol.  It's generalized and something that we could even imagine seeing internationalized.  <em>it all comes back to words</em>.</p>
<p>The enigmatic and slight single apostrophe is now taken as the meta form of void:</p>
<pre><code>&gt;&gt; '
; void

&gt;&gt; 1 + 2 '
== 3
</code></pre>
<p>While <strong>~null~</strong> is definitely more verbose than using <strong>_</strong> to null out variables, I'm not entirely sure that nulling out variables needs to be in the scheme of things any more succinct than setting a variable to false.  The uninitialized state of <strong><code>~</code></strong> is still succint:</p>
<pre><code>obj: make object! [
    foo: ~
    baz: null
    bar: ~
]
</code></pre>
<p><strong>Every experiment leads to a new thought...and trying blank led to seeing nulls as an isotopic state of blank, which led to the thought of being the isotopic state of the actual WORD! of "null"</strong>.  So in that sense it was a success.</p>
<p>Having a distinct BLANK! type which isn't a WORD! still seems like it offers us value... in being usable as a placeholder for where a variable would be, and a dialect part that can't be reassigned (so it can act as meaning "space" for instance, or an empty slot in block data).  So I think it's going to go back to serving that role.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/7</link>
        <pubDate>Wed, 16 Nov 2022 21:27:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6496</guid>
      </item>
      <item>
        <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>My general intuition is that from a user's standpoint, it's an uphill battle to teach them isotopic blank is something called "null"... and that the majority of technical problems that are involved in making NULL be a word isotope are problems that have to be tackled anyway with true and false as word isotopes.</p>
<p>I'm going to likely give it a shot, when I get some programming time again, hopefully soon.</p>
</blockquote>
</aside>
<p>Just got snowed on.  <img src="https://forum.rebol.info/images/emoji/twitter/snowflake.png?v=9" title=":snowflake:" class="emoji" alt=":snowflake:"> So there's an incentive to stay inside and program...</p>
<p>Hence I've gone ahead and done this <strong>~null~</strong> change, and am looking over the implications.</p>
<hr>
<p>My first impressions are that it feels right, though I definitely will admit that there's a lot of <em>subtlety</em> to it.  To try and put the whole thing into perspective.</p>
<ul>
<li>
<p>The first attempt by Ren-C to make a state that could not be put in a block called it "void", and it was the <em>only</em> non-valued state.</p>
<ul>
<li>It was used as the contents of an uninitialized variable</li>
<li>It was the result of a function like HELP that didn't want to show a result</li>
<li>It was the result of a PICK out of a block which was out of range</li>
<li>It was the result of a SELECT out of a map when the key wasn't present</li>
</ul>
<p>This "non-valued" state took on a number of Redbol NONE!'s responsibilities, but was "ornery" in the way Redbol UNSET! was--hence it could not be tested for truth or falsehood.</p>
</li>
<li>
<p>Realizing that the orneryness of not being testable by logic was inconvenient, the concept was changed to be called "null" and be falsey</p>
<ul>
<li>The API exposed NULL results as C/Javascript <code>null</code> pointer
<ul>
<li>this was conveniently also falsey in those languages</li>
</ul>
</li>
<li>The term "void" was reclaimed to describe invisibles, like COMMENT</li>
<li>Unset variables held another ornery state called "nihil"
<ul>
<li>calling the state "unset" seemed semantically wrong</li>
<li>
<em>variables</em> are unset, not the <em>contents</em> of a variable</li>
</ul>
</li>
</ul>
<p>This was a great development for the API, and working with blocks was still rigorous.  But for some other questions, being able to tell the difference between "no answer" and "there's an answer, but it's null" still presented a puzzle.</p>
</li>
<li>
<p>Isotopes were introduced as a nuance on a value that would only be detectable by those who cared.</p>
<ul>
<li>"heavy null" and "light null" were the first isotopic concept
<ul>
<li>heavy null meant "there <em>is</em> an answer, but it's null"</li>
<li>ELSE would only react to light null (no answer, not even null)</li>
<li>heavy null would decay to light null on variable assignment</li>
</ul>
</li>
</ul>
<p>The isotope mechanic became generalized (as explained here):</p>
<p><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918" class="inline-onebox">A Justification of Generalized Isotopes</a></p>
</li>
<li>
<p>With notable features pertaining to splicing intent (group isotopes) and errors (error isotopes), a new way of saying "there is no answer" vs. "there is an answer, but it's null" came out of using block isotopes as multi-return signals.</p>
<ul>
<li>null itself no longer needed an isotopic form</li>
<li>a block isotope with a null represented in it could be "heavy null"
<ul>
<li>this required null to have a meta-representation to be in a block</li>
<li>but META of NULL had been defined as NULL</li>
<li>null was thus rethought as being an isotope itself</li>
</ul>
</li>
<li>making NULL an isotope of the WORD! null seemed the cleanest answer</li>
</ul>
</li>
</ul>
<p><strong>An important point to make is that there's now only one form of isotopic decay:</strong> multiple return results, e.g. BLOCK! isotopes, will decay to their first result.  So you'll never find a block isotope in a variable.</p>
<p>It's pretty wild to look at how it all works.</p>
<pre><code>&gt;&gt; first [~null~]
== ~null~

&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; null
== ~null~  ; isotope (null WORD! is defined to be ~null~ isotope)

&gt;&gt; reify null
== null

&gt;&gt; meta null
== ~null~

&gt;&gt; third [a b]
== ~null~  ; isotope

&gt;&gt; third [a b] else ['c]
== c

&gt;&gt; if true [null]
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; meta if true [null]
== ~[~null~]~

&gt;&gt; if true [null] else [123]
; first in pack of length 1
== ~null~  ; isotope    
</code></pre>
<p>I know it's a lot to take in, but I feel like everything is there for a reason...</p> ]]></description>
        <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/3</link>
        <pubDate>Sat, 12 Nov 2022 22:08:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6495</guid>
      </item>
      <item>
        <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So... Why Shouldn't NULL Be Done With <code>~null~</code> isotope ?</p>
</blockquote>
</aside>
<p>I might as well throw in the adjunct question of: <strong>"Why shouldn't VOID be done with ~void~ isotope?"</strong></p>
<p>It's worth noting that regardless of whether NULL is represented as <code>~_~</code> isotopes or <code>~null~</code> isotopes, it used to merely be said as having "no representation".  That's true of isotopes also, but there's been a standard that the interface shows an isotope by printing the quasiform and then commenting it as <em>"oh, it's actually an isotope state"</em></p>
<p>At that time, the console had a special exception for displaying nulls.  And the "quoted" form of null was just a single apostrophe with nothing after it:</p>
<pre><code>&gt;&gt; null
; null

&gt;&gt; quote null
== '

&gt;&gt; '
; null
</code></pre>
<p>This was all conceived before the idea of having a meta state for void, because voids just vanished.  But as things shuffled around, I came to think that this "no representation" made more sense for voids...</p>
<pre><code>&gt;&gt; '
; void

&gt;&gt; quote void
== '

&gt;&gt; meta void
== '

&gt;&gt; 1 + 2 '
== 3
</code></pre>
<p>Having a META state that is quoted vs. quasi puts VOID in a bizarre middle ground of not being isotopic.  Yet void can't be put in a block.  Though I've argued that we might also see it as that you can put infinitely many voids in a block...</p>
<pre><code>&gt;&gt; append [a b c] '
== [a b c]

 &gt;&gt; append [a b c] comment "hi"
 == [a b c]

 &gt;&gt; first []
 == ~null~  ; isotope (new proposal as word isotope vs isotopic blank)

 &gt;&gt; append [a b c] first []
 ** Error: Can't append ~null~ isotope (see MAYBE)

 &gt;&gt; maybe first []
 ; void

 &gt;&gt; append [a b c] maybe first []
 == [a b c]
</code></pre>
<p>Generally speaking I'm pleased with that.  Though it means if you wind up setting a variable to void, it will look kind of slight:</p>
<pre><code> &gt;&gt; make object! [x: comment "hi"]  ; might require a SET/ANY or similar
 == make object! [
     x: '
 ]
</code></pre>
<p>Why not push it the other way, and say that void states are isotopic?</p>
<p><strong>One key value of saying that void states are "ordinary" is that it means they have an isotopic form, and that isotopic form is rendered as just <code>~</code>.</strong></p>
<p>This isotopic void state of <strong><code>~</code></strong> is being used as the "truly unset" state.  An even meaner idea of complete absence of value than void.  I'm of the belief that it's important to have this not be the same thing as void, because the tolerance of void by so many constructs (including things like ANY and ALL to skip them, or opting out of APPENDs, or making SELECTs just return a null).</p>
<p>The design of the system is such that the quote byte of 0 means isotopic status (e.g. "quote level negative 1" is represented by 0), and the void type is a 0 byte.  So you can memset() an area to 0 and get all unset states (typically an optimized operation).  And the operating system clears all memory to 0 before giving it to your application as well.  It's kind of pleasing that such a representation gives you a nice unset state.</p>
<p>It seems to me that the pieces of the puzzle fit together better this way.</p> ]]></description>
        <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/2</link>
        <pubDate>Tue, 25 Oct 2022 13:14:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6494</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Well I told you that my time to work on hobby projects like this is very limited, even when I think I can spend over an hour, it will be likely that some interruption will occur within the next 5 minutes, dragging me away.<br>
Even a git workflow apparently changes over time and given the intervals between when I need to use this, keeping up with that is not worth the trouble and certainly not something I will remember how to do.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think systems development seems to annoy you more than intrigue you.</p>
</blockquote>
</aside>
<p>Well let's say that I do want to spend my time on the real matters, not on the gits, githubs, and other obstacle courses to get to it.</p>
<p>AH, time's up, gotta run! cu later!</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/11</link>
        <pubDate>Tue, 25 Oct 2022 07:21:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6493</guid>
      </item>
      <item>
        <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The concept of having isotopic <strong>~true~</strong> and <strong>~false~</strong> as WORD! isotopes instead of having a distinct LOGIC! type is admittedly somewhat weird.  It means they can't be put in blocks and need some sort of transformation if they're going to be put into blocks.</p>
<ul>
<li>
<p>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</p>
</li>
<li>
<p>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</p>
</li>
<li>
<p>Your circumstance may mean that neither of those choices are what you want when in a situation where the isotopes can't work...maybe it means you have to rethink what you're doing, or maybe you want some other transformation.  It's good to be alerted to the fact that it's dodgy to put what you think of as a "logic" in a reified context.</p>
</li>
</ul>
<p>One should note that Lisp has no false at all, only NIL for false (since everything else is truthy, you could use anything else for true, but they have T predefined).  But their NIL isn't isotopic--so it can appear in lists literally.</p>
<p>And as I've repeatedly pointed out, Redbol's historical choice to render LOGIC! conflated with the words <code>true</code> and <code>false</code> (instead of <code>#[true]</code> and <code>#[false]</code>) shows a desire to avoid the logic literals "escaping" into the reified consciousness of the user.  Making the logic forms actually impossible to put into blocks without a conscious transformation feels like it's good.</p>
<p>I know it's a strange choice, but it's seeming like it fits with the territory.  It's a sort of tradeoff you need when you choose to be firm that TRUE and FALSE are redefinable words and not lexical forms of logic constants.</p>
<h2>So... Why Shouldn't NULL Be Done With <code>~null~</code> isotope ?</h2>
<p>Right now what I call "null" is isotopic BLANK!.  It is not pretty looking:</p>
<pre><code>&gt;&gt; null
== ~_~  ; isotope

&gt;&gt; _
== ~_~  ; isotope
</code></pre>
<p>But what <em>is</em> pretty looking is that if you assign a bunch of variables to null, the fact that blanks evaluate to the null isotope gives a great visibility to where the actual values to pay attention to are:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>If we used a word isotope, then at source level we're writing:</p>
<pre><code>obj: make object! [
    alpha: null
    beta: null
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: null
    omega: 'now
 ]
</code></pre>
<p>And if we view it after evaluation that fetches (<code>null</code> =&gt; <code>~null~  ; isotope</code>), it gets uglier:</p>
<pre><code>make object! [
    alpha: ~null~
    beta: ~null~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~null~
    omega: 'now
 ]
</code></pre>
<p>We can't show it as the WORD! null because there's no guarantee that word always will evaluate back to the null isotope.  But the concept is that since BLANK! can't be redefined, we can put it in an evaluative context as a substitute for <code>~_~</code> if we want.</p>
<p>If we were "more honest" and just META'd the isotopic blank, we'd get renders like:</p>
<pre><code>make object! [
    alpha: ~_~
    beta: ~_~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~_~
    omega: 'now
 ]
</code></pre>
<p>But I might actually like that less than seeing <strong><code>~null~</code></strong> there.</p>
<h2>Things To Weigh In This Consideration</h2>
<p>I'm really torn.  Certainly having people be able to see ~null~ written out as a word corresponds to what we want to refer to the state as.  We aren't going to replace people's vernacular to say "isotopic blank" instead of null.  And trying to teach people "isotopic blank is null" is an uphill battle.</p>
<p>Let's look back at that seemingly beautiful situation with all the blanks-to-nulls at source level:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>But, hmmm.  The <strong><code>~</code></strong> is now an assignable state meaning variable is not set.  How often will you want to set something to NULL...which won't generate an error on access like being unset would, but is falsey and can't be passed to many routines without a MAYBE?</p>
<p><strong>Statistically, we might often have a situation where NULL is the minority initialization, more like this:</strong></p>
<pre><code>obj: make object! [
    alpha: ~
    beta: ~
    delta: true
    epsilon: null
    gamma: "nutty"
    rho: ~
    omega: 'now
 ]
</code></pre>
<p>My point is that intentionally initializing things to null may not be as common as setting to an error-provoking unset state.  And when null happens it may be just as noteworthy to call out as setting something to true or false.</p>
<h2>Are There Technical Barriers To This?</h2>
<p>It has some of the same problems as having to deal with the type checking of LOGIC! actually being an isotopic subclass of two words.  It means <code>&lt;opt&gt;</code> is an isotopic subclass of one word, so there's no specific null datatype.  :-/</p>
<p>I was already saying that TYPE OF NULL was probably an error, and TYPE OF MAYBE NULL would be void... anyway, this fits into some of the same type issues that logic has.</p>
<p>Previously NULL cells held nothing, so I'd put a payload of the file and line that were in effect in the evaluator.  This was supposed to give better errors about where a null originated from.  This could still be done if NULL was a special case of WORD! isotope that said it was null via a flag vs. storing the symbol, but could be complicated.  None of the better error mechanics were done yet.</p>
<p><strong>My general intuition is that from a user's standpoint, it's an uphill battle to teach them isotopic blank is something called "null"... and that the majority of technical problems that are involved in making NULL be a word isotope are problems that have to be tackled anyway with true and false as word isotopes.</strong></p>
<p>Additionally, I've written about my desire for BLANK!s to serve in dialects as spaces.  That gets very screwed by the (<strong><code>_</code></strong> =&gt; <strong><code>~_~</code>  ; isotope</strong>) evaluation.  Recovering blank for space intent would be good.</p>
<p>I'm going to likely give it a shot, when I get some programming time again, hopefully soon.</p> ]]></description>
        <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/1</link>
        <pubDate>Tue, 25 Oct 2022 04:07:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6492</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="iArnold" data-post="5" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>Long time ago I tried building on Ubuntu myself, to find that something happened with the blanks! in the script not being accepted anymore.</p>
</blockquote>
</aside>
<p>That is because there were some changes to the bootstrap to make the older executable act more like the newer executable.  You'd written some extension configuration based on old build system files that needed to be updated.</p>
<p><a href="https://github.com/metaeducation/ren-c/compare/master...r3n:ren-c:gtk3and4">I did those changes in July</a>. And as I mentioned at the time, what was left was a linker error in the automated build related to GTK.  I said that was something you would need to research.</p>
<p>So resolving the linker error would have been a good thing to tackle before merging more things that would restart the situation again of needing me to sync it up.</p>
<p>In fact, the particular blank behavior may even <a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989">wind up being undone</a>, due to new considerations.  :-/</p>
<aside class="quote no-group" data-username="iArnold" data-post="7" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>I had some "fun" with github/git tonight that has cost me my time and energy</p>
</blockquote>
</aside>
<p>I generally do not use merging, but I rebase instead.  This allows you to play back each commit one at a time, and resolve the differences at every step.</p>
<p>If you're merging with 1000 commits--and things are added and removed at each intermediate point which conflict with your changes--then that may sound laborious.  You might find yourself resolving against things that ultimately get deleted, so it could seem like you wasted time.  It could seem that merging the final states together is less work.</p>
<p>But in practice, all those 1000 commits wouldn't conflict.  Just some of them--and I think it's much more sane and educational to resolve the individual commits "as they happen" and make sure you can get a working build each time.</p>
<p>However this requires understanding how to rebase and to have a really comfortable feeling with how branching and staging and "HEAD" and all of those other things work.</p>
<aside class="quote no-group" data-username="iArnold" data-post="9" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>Yes, the odd thing here is how are you supposed to work from the command line if passwords are no longer accepted and my 2FA is not invoked?</p>
</blockquote>
</aside>
<p>These mechanisms do keep changing and evolving.</p>
<p>You can generate a personal access token and use it like a password, but it's not something you get to type and remember... so you have to copy/paste it from some local file you keep... and it expires so you have to keep regenerating it.</p>
<p>It's valid to be frustrated at technology and how the world is.  But... y'know, sometimes you just have to commit yourself to raising your level of understanding.  Git is one of those things where the payoff to mastering it is high.  And it's also a real liability in the software industry to not be fluent.</p>
<p>I go between SmartGit and the command line, and I'm sure that some 1-on-1 screencast tutoring of seeing my workflow for things would be informative for you...but...I'm busy these days.  Maybe there's some kind of online git school that gives you puzzles to sort out, and then shows the kinds of ways to solve them?</p>
<p><a href="https://learngitbranching.js.org/">https://learngitbranching.js.org/</a></p>
<p><a href="https://ohmygit.org/">https://ohmygit.org/</a></p>
<p><a href="https://github.com/git-game/git-game">https://github.com/git-game/git-game</a></p>
<aside class="quote no-group" data-username="iArnold" data-post="5" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>Sure I know you cannot be bothered by me not being able to build REN-C. But if I can't chances are others also cannot build it. Which is good when "we" do not want too much activity in "our" world. Such a situation I would classify as unfortunate.</p>
</blockquote>
</aside>
<p>I'm bothered by a lot of things, but people not being able to build it isn't really that high on the list.  People familiar with what it takes to build interpreters and compilers would not find it that odd.</p>
<p>I think systems development seems to annoy you more than intrigue you.  It requires a certain kind of patience and willingness to go deep in the mastery of things.  And I can speak to the fact that much of it has gotten more annoying... and the only thing that shines a light on it is stuff that you would probably not enjoy either (e.g. modern C++, Haskell, Rust...)</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/10</link>
        <pubDate>Tue, 25 Oct 2022 02:53:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6491</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Thanks Ingo,</p>
<p>Yes, the odd thing here is how are you supposed to work from the command line if passwords are no longer accepted and my 2FA is not invoked?</p>
<p>Now I had to accept a complete stranger website that happened to be home of a git gui client with my credentials to github, which personally I consider a HUGE LARGER security risk over a well chosen password.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/9</link>
        <pubDate>Fri, 21 Oct 2022 17:17:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6490</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>If I run into problems updating a repo,I normally just delete it, and then clone anew.</p>
<p>Of course hoping I have not made any changes in said repo, which normally holds true.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/8</link>
        <pubDate>Fri, 21 Oct 2022 11:41:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6489</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="6" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>It's not like we would expect a run on ren-c, just because binaries are downloadable.</p>
</blockquote>
</aside>
<p>LoL!<br>
I had some "fun" with github/git tonight that has cost me my time and energy to update my repo's and resulting in a merge mess of differences between HEAD and index and no clue as to which is which and smartgit not telling and not letting me select which version to pick over the other, and finally resulting in a failed build because it was the gtk branch that was probably suffering from a wrongly chosen update. But then again I have no idea what I have done, cause I had a proper script, sequence of instructions, to do my update but git wanted my password and then said "no more passwords accepted for updates". So completely lost again. My solution probably will be to go uninstall git and reinstall, if I could I would probably uninstall github itself <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"></p>
<p>Well, git-hell.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/7</link>
        <pubDate>Thu, 20 Oct 2022 21:51:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6488</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>I'm regularly building on Ubuntu and it works like charm. You may need the correct r3 executable for the make process, though.</p>
<p>Being able to download the binaries which are built anyway would be good. It might lead to some additional testing, and yes, these are debug builds and not optimized for speed.</p>
<p>It's not like we would expect a run on ren-c, just because binaries are downloadable.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/6</link>
        <pubDate>Thu, 20 Oct 2022 13:09:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6487</guid>
      </item>
      <item>
        <title>On how to build REN-C on Windows</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1845">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>To be clear, I build it every day...and there are <a href="https://github.com/metaeducation/ren-c/actions/workflows/windows-msvc-build.yml">GitHub Actions that keep it going</a>, demonstrating 32-bit and 64-bit builds.</p>
</blockquote>
</aside>
<p>Right what happens with the build executables? Are the most recent ones downloadable so nobody actually has to build them, unless they make changes in the sources to experiment / develop new features.</p>
<p>Running in the web/browser is not my cup of tea and certainly given the quirks of FireFox lately with mouseovers over links not even showing the links, and when reporting FF devs go "it is open source, you can fix it yourself" this feeling does nothing good to that. I feel much more like I need a tool in my toolbox and I want the tool to be on my platform of choice, not on the browser on the platform of my choice, if I wanted a tool on the browser platform perhaps I would already have gone with one of the alternatives.</p>
<p>My view is, the tool is available just on the platform (Windows and a Posix) and supporting it on the browser is good for the cases the platform itself is a more exotic one or to be used to prevent users from installing a thing. I should say I see users and developers as two categories, the second is a species that will be in danger of extinction because everything will be shielded off. It is also why I feel the need for a tool on the platform itself.</p>
<p>Long time ago I tried building on Ubuntu myself, to find that something happened with the blanks! in the script not being accepted anymore. I should try to build again, hope I find the time to do so soon, unfortunately my time is always fragmented into tiny chunks, and hope this has been fixed in the meantime.</p>
<p>Sure I know you cannot be bothered by me not being able to build REN-C. But if I can't chances are others also cannot build it. Which is good when "we" do not want too much activity in "our" world. Such a situation I would classify as unfortunate.</p> ]]></description>
        <link>https://forum.rebol.info/t/on-how-to-build-ren-c-on-windows/1845/5</link>
        <pubDate>Wed, 19 Oct 2022 12:50:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6486</guid>
      </item>
      <item>
        <title>Default Values And MAKE FRAME!</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1412">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Anyway, long story short, I think the baseline mechanics of FRAME! has to be as-is.</strong> Whatever else is an exception and should be handled specially. If you want a ^META parameter, that should be something that happens after the function starts running. This improves matters greatly.</p>
</blockquote>
</aside>
<p>As is often the case... the old way had right parts, the new way had right parts, and the answer is going to need... nuance.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></p>
<p>The way it works today, frames are initialized to "nihil" (the isotope of void), because <strong><code>~</code></strong> is what denotes the unset state.  For I-believe-to-be-good-reasons, it's no longer a synonym for void itself (the meta/quoted form of void is a single <strong><code>'</code></strong> apostrophe):</p>
<pre><code>&gt;&gt; f: make frame! :append
== make frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]
</code></pre>
<p>While fetching such variables should be an error by default, I've also said that I like the idea of this being an easy, legal assignment... so you can say <strong><code>(var: ~)</code></strong> to unset it.</p>
<p>I've also become attached to saying that true and false are actually WORD! isotopes, and although you can't put isotopes in blocks...you can freely assign these to variables, and retrieve them from variables.</p>
<pre><code>&gt;&gt; flag: true
== ~true~  ; isotope

&gt;&gt; flag
== ~true~  ; isotope

&gt;&gt; reify flag
== true

&gt;&gt; meta flag
== ~true~
</code></pre>
<p><em>It would be annoying if you could not directly assign a ~true~ or ~false~ isotope to a variable in a frame, and had to use some kind of ^META parameter convention to process it.</em></p>
<p>Yet I'm suspicious of being able to put parameter packs (isotopic blocks) or isotopic errors into a variable... <em>ever</em>:</p>
<pre><code>&gt;&gt; ~['10 '20]~
== ~['10 '20]~  ; isotope

&gt;&gt; value: ~['10 '20]~
== 10

&gt;&gt; set/any 'value ~['10 '20]~
== ~['10 '20]~  ; isotope (sketchy!)

&gt;&gt; :value
== ~['10 '20]~  ; isotope (sketchy!)
</code></pre>
<p>It is likely the case that isotopes fit into categories of things that can be assigned to variables literally, and things that cannot.  Keeping with the terminology, these might be called <strong>stable isotopes</strong> and <strong>unstable isotopes</strong>.  And the only way you can capture an unstable isotope is to transform it into some stable form, e.g. with META or REIFY:</p>
<pre><code>&gt;&gt; value: meta ~['10 '20]~
== ~['10 '20]~
</code></pre>
<p>Yet recall that with <strong><code>~</code></strong> and <strong><code>~true~</code></strong> and <strong><code>~false~</code></strong> (and <strong><code>~_~</code></strong> for null), it would seem we have a proof case that stable isotopes <em>exist</em>.</p>
<p>But there are other stable isotopes.  e.g. now ACTION! isotopes are used to be the form of action that runs from a variable reference.  Hence by definition you need to be able to store these in variables, and they are stable also.</p>
<p>How about splices?  Is there any great reason to make them unstable?  The following seems useful...</p>
<pre><code>&gt;&gt; data: spread [d e]
== ~(d e)~  ; isotope

&gt;&gt; append [a b c] data
== [a b c d e]
</code></pre>
<p>And if you're going to specialize a function like APPEND, shouldn't you be able to just write:</p>
<pre><code>apde: specialize :append [value: spread [d e]]
</code></pre>
<p>And this is where I was talking about the hassle of forcing these isotopes to be communicated by the ^META protocol, because if it meant you would sometimes take splices, you would <em>always</em> need to quote values you were appending... that was a headache.  So we want as few of these ^META functions as we can possibly have.</p>
<p>Yet fetching without complaint makes it very easy to unintentionally get effects you weren't intending, like if you didn't realize DATA was a splice isotope and expect exactly two items here:</p>
<pre><code>&gt;&gt; reduce [1 data]
== [1 d e]
</code></pre>
<p>We might say that the table stakes for showing you are aware that something "weird" is going on is on the access side, to use a GET-WORD!</p>
<pre><code>&gt;&gt; reduce [1 :data]
== [1 d e]
</code></pre>
<p>Yet do note that if DATA were bound to a function, that function could return an isotope like SPREAD does, putting you back at the point of being unable to tell from the callsite how many elements will be resolved to.</p>
<p>Hm.  Well, needing to use a GET-WORD! doesn't feel all that oppressive, and it offers some light protection that historical precedent has also offered (if a function in R3-Alpha/Red returns an UNSET! that's not an erroring condition, but if you get an unset out of a variable it will error without a GET-WORD!)</p>
<h2>This Means ^META Arguments Must Be Special</h2>
<p>I suggested this:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1412">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Anyway, long story short, I think the baseline mechanics of FRAME! has to be as-is. Whatever else is an exception and should be handled specially. If you want a ^META parameter, that should be something that happens after the function starts running. This improves matters greatly.</p>
</blockquote>
</aside>
<p>But now I'm saying that really there are just more isotopes in the stable family, communicated "as-is" to functions.</p>
<p>Yet when unstable isotopes are needed to be considered as parameters, the inability to encode them in variables "as is" would necessitate passing them via ^META conventions.</p>
<p>Consider RETURN.  There is a RETURN/FORWARD that if you are returning a pack (isotopic block) actually returns the entire isotopic block, not just the first value.  So this falls under the "can't do it without meta" category.</p>
<p>What about SET?  At first it would seem to not have the problem, because it's setting a variable and everything it can take is representable in a variable (by definition).</p>
<p>But... if we leave <strong><code>~</code></strong> isotopes as the "I didn't specialize that" state of frames, and if <strong>SET</strong> doesn't take its argument as a <strong>^META</strong> parameter, then there's no way to SET something to an unset state... without some mitigation.</p>
<p>Possible mitigations:</p>
<ol>
<li>
<p>just make UNSET a distinct native that's a completely distinct entry point, and argue you don't use SET to unset variables with a function</p>
</li>
<li>
<p>during typechecking, nihil arguments are left as nihil if they're not refinements, vs. being set to null</p>
<ul>
<li>
<p>this means if you're trying to set a variable's state from a refinement instead of a normal argument, you would not get full coverage of all possible variable states</p>
</li>
<li>
<p>this also means that if a normal argument is marked as being optional/nullable, then not acting on it when doing a MAKE FRAME! would not wind up with it being null as default</p>
</li>
</ul>
</li>
<li>
<p>make the parameter ^META...then let SPECIALIZE compensate for it normally.  But when you want to write an UNSET function that is implemented as a specialization over SET, you build the frame directly and pass the value via ^META conventions</p>
<p>3a. Have a more foundational SET* that takes a ^META argument and lets you unset things, but the plain SET takes a normal argument and does not</p>
</li>
</ol>
<p>I'm rather attached to <strong>(var: ~)</strong> to unset things, so I feel (1) would be inconsistent with that mechanic.</p>
<p>With (3a), having SET* feels like a bad precedent.  It may seem like it's making life a little easier for some people who are writing ADAPT...but I don't think the net benefit outweighs making it a ^META argument.</p>
<p>(2) sounds good in theory, if we're just making a frame and DO'ing it:</p>
<pre><code>&gt;&gt; f: make frame! :set
== make frame! [
    target: ~
    value: ~
    groups: ~
]

&gt;&gt; x: 10
&gt;&gt; f.target: 'x
&gt;&gt; do f
&gt;&gt; x
** Error: x is ~ isotope (unset)
</code></pre>
<p>But if you try to turn a frame into an ACTION! and leave fields as <strong>~</strong>, it treats them as unspecialized.  This is designed to make it easier to write custom specialization functions, built on top of frame mechanics.</p>
<p><strong>It's annoying that this is in the vein of exact problems ^META exists to solve...but you're having to shift to the meta convention to get coverage for <em>just one</em> isotopic state, which almost no one will be specializing functions to use!</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>Annoying though it may be, I think it's going to have to be how it's done.  If this is the biggest problem the whole thing has, then it's not really that bad!</p> ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame/1412/7</link>
        <pubDate>Tue, 18 Oct 2022 19:01:07 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6485</guid>
      </item>
      <item>
        <title>October 2022 General Status &amp; Reflection</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1988">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>With so many aspects of isotopes working out, it's unfortunate that the terrible type system is getting in the way. A dissatisfying answer would be just to say that all isotopes report that they are ISOTOPE! and you have to perform operations on them to find out the actual type... but this is what you historically have to do with items in BLOCK! (you can't typecheck for "block that contains one integer!" vs. "block that contains two strings").</p>
</blockquote>
</aside>
<p>When we think about this, it is the programmer that decides that the things an end-user selects get put inside a block to process the given information, it is also to the programmer to check on the validity of the items inside a block! (type! and value).<br>
That is thus okay.<br>
The problem is that even if the rest of the software development world thinks that fewer than 64 datatypes is sufficient, we the Redbol world occupants really want to expand beyond that limit. What you describe is the (non)solution of having ISOTOPE! call out "hey I am different, but you need to find out for yourself how different exactly". Which is surely not what we really want.<br>
Hence we need a way to expand beyond our 64 datatypes limit.<br>
When there is no room anymore, which is the case, I propose to follow some kind of ASCII to UTF extension trick. This will limit the number of primary datatypes (with a 0 in first position) even more, but other type would then make use of a follow up byte to mark the definitive datatype.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1988">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Also, I'm packing up and moving in less than two weeks and there's a lot to do for that.</p>
</blockquote>
</aside>
<p>Take care, hope you have found a great place to stay!</p> ]]></description>
        <link>https://forum.rebol.info/t/october-2022-general-status-reflection/1988/2</link>
        <pubDate>Sun, 16 Oct 2022 10:08:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6484</guid>
      </item>
      <item>
        <title>October 2022 General Status &amp; Reflection</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><em>Having hit up against some pretty deep questions about redesigning datatypes, I've been taking a break.</em>  It's good to clear one's head sometimes.  Also, I'm packing up and moving in less than two weeks and there's a lot to do for that.</p>
<p>I've been poking around some other languages and tools... tinkering with things like the Rust compiler sources... looking at Stable Diffusion and what sorts of trends are on the rise in open-source AI.  Reading a lot of articles and watching YouTube Videos.</p>
<p>Hopefully some of the datatype-related ideas will settle in my head and I'll be able to start making progress on those.  But I thought I'd review some of what's gone on the last months.</p>
<ul>
<li>
<p>It's certainly worth pointing out that the <a href="https://forum.rebol.info/t/stackless-is-here-today-now/1844">system is using "stackless" processing</a>... which is a significant change, that from a practical standpoint has let us get rid of costly workarounds needed for browser interop in the web build.</p>
</li>
<li>
<p>Changes were made to <a href="https://forum.rebol.info/t/ren-c-is-now-on-the-clouds-with-wasi/1854">permit executing in WASI runtimes</a>, enabling a new cross-platform target as well as being used in "serverless" cloud computing scenarios.</p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/visual-parse-on-the-web-has-arrived/1837">Integrating a rich editor and tabbed interface to the web REPL</a> is a big cool thing.</p>
</li>
</ul>
<p>I could go on about every little thing (like updating the crypto, or that web tests now <a href="https://forum.rebol.info/t/js-testing-with-cypress-io/1778">run on cypress.io</a>) but there are posts and git commits for that.</p>
<p>Nearly every other major change worth discussing involves big changes surrounding isotopes.</p>
<h2>Generalized Isotopes Have Changed (Almost) Everything</h2>
<p>From the beginning, Ren-C's goal has been to attack the fundamental weaknesses in how Rebol works as a language.</p>
<p>Integral to attacks on several major problems has been the idea of <em>"generalized isotopes"</em>.  If anyone hasn't had a chance to read the thread describing the rationale, I suggest doing so now (or re-reading it):</p>
<p><strong><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">"A Justification of Generalized Isotopes"</a></strong></p>
<p>This development kind of touches everything in the system:</p>
<ul>
<li>
<p><strong><a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607">It strikes at the heart of the /ONLY issue</a></strong>.  When you see it used with something like REPLACE, you can really have that "A Ha" moment... that splicing intent should never have been carried by a refinement</p>
<pre><code>&gt;&gt; replace/all [[a b] a b a b] [a b] [c d e]
== [[c d e] a b a b] 

&gt;&gt; replace/all [[a b] a b a b] spread [a b] [c d e]
== [[a b] [c d e] [c d e]]

&gt;&gt; replace/all [[a b] a b a b] [a b] spread [c d e]
== [c d e a b a b]

&gt;&gt; replace/all [[a b] a b a b] spread [a b] spread [c d e]
== [[a b] c d e c d e]
</code></pre>
</li>
<li>
<p><strong><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">"Definitional Errors" have arisen</a></strong> as a crucial combination of solutions: one of the earliest Ren-C mechanics (definitional returns) mixes with a new idea (error isotopes), to give an actual viable answer for error handling in the system:</p>
<pre><code>&gt;&gt; attempt [print "Attempting to read file" read %nonexistent-file.txt]
Attempting to read file
; null

&gt;&gt; attempt [print "Attempting but made typos" rread %nonexistent-file.txt]
Attempting but made typos
** Script Error: rread word is attached to a context, but unassigned
** Near: [rread ** %nonexistent-file.txt]
</code></pre>
</li>
<li>
<p>Moving away from a dedicated "LOGIC!" datatype to <strong><a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">~true~ and ~false~ isotopes</a></strong> solves a "top-of-the-page" representational issue... giving an in-between state that can be held in a variable, but must undergo some reification process before being carried in an array:</p>
<pre><code>&gt;&gt; 1 = 2
== ~false~  ; isotope

&gt;&gt; append [a b c] 1 = 2
** Error: Arrays cannot hold ~false~ isotopes, must REIFY or META

&gt;&gt; append [a b c] meta 1 = 2
== [a b c ~false~]

&gt;&gt; append [a b c] reify 1 = 2
== [a b c false]
</code></pre>
</li>
<li>
<p>Treatment of <strong><a href="https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955">BLOCK! isotopes as "packs"</a></strong> gives answers to how to pipe and transform multi-return expressions... and has also been leveraged as a way to tell the difference between "true null" (e.g. should trigger an else) and "packaged null" (a null packed into a block that is "a positive result that just happens to be null").</p>
</li>
<li>
<p>It has reshaped "voidness"--as something <strong><a href="https://forum.rebol.info/t/non-interstitial-invisibles-more-trouble-than-theyre-worth/1582">which only vanishes in interstitial slots</a></strong>, and can be manipulated conveniently in its isotopic form.</p>
<ul>
<li>Being able to pass voids as arguments enables fully functional compositions, <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">like the infamous FOR-BOTH case</a> of writing a loop wrapper that preserves the loop behavior invariants.</li>
</ul>
</li>
<li>
<p>Isotopes are also covering things like being able to tell the difference between <strong><a href="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881/2">passing an ACTION! you want to run and an ACTION! you want to look for literally</a></strong> (by its identity)</p>
</li>
</ul>
<p>In some sense, this "discovery" has pushed a big reset button on the project... because it affects so many things.  Nearly everything has to be revisited.  But the biggest issue is with the type system.</p>
<h2>Isotopes Further Stress Weaknesses Of DATATYPE! / TYPESET!</h2>
<p>Rebol and all of its clones deal with datatypes in the exact same simplistic way, limiting it to 64 datatypes... with a TYPESET! being a 64-bit number with one bit for each type.</p>
<p>Perhaps there are those out there who think this is fine.  They may see it as like the <a href="https://www.danielsen.com/jokes/objecttoaster.txt">engineer and the toaster story</a>... where making a toaster with very few settings is virtuous, and it's unnecessary complexity to have any more complicated type system.</p>
<p>I've laid out some of my beliefs...such as that "kinds" of values (in a coarse sense) are at the very least based on WORD!, so you can add new things like <strong><code>vector</code></strong> and <strong><code>matrix</code></strong> and <strong><code>image</code></strong>...none of which I believe should be mandatory to build into the core...so lighter builds can be made.</p>
<p>Beyond that I have suggested that getting a full "type" description could be a more descriptive structure, telling you not only that something is a matrix but also giving you its dimensions.</p>
<p>The more these kinds of thoughts seem true, it makes TYPESET! seem like a bogus kind of thing... and type checking functions might make more sense.  Why not something like:</p>
<pre><code>foo: func [bar [integer! series? even?]] [...]
</code></pre>
<p>Performance aside, trading off typesets has some dangerous implications...such as what if a function gets specialized with a value that passes, but either the function or something about the value changes so it wouldn't pass?  As it happens, today's specialized values are written in the place where type information for a parameter would usually be--so you can't typecheck after the fact.</p>
<p>With so many aspects of isotopes working out, it's unfortunate that the terrible type system is getting in the way.  A dissatisfying answer would be just to say that all isotopes report that they are ISOTOPE! and you have to perform operations on them to find out the actual type... but this is what you historically have to do with items in BLOCK! (you can't typecheck for "block that contains one integer!" vs. "block that contains two strings").</p>
<p>Anyway: this is a longstanding problem area, that isotopes are now making it more imperative to solve.</p>
<h2>Still...There Are A Lot Of New And Interesting Things</h2>
<p>The biggest takeaway here is that isotopes have added new dimensions that are letting Ren-C bring really advanced capabilities within reach of very novice users.</p>
<p>There are many examples, but some of the most amazing to me are things like hooking the default UPARSE combinators--which have multiple return values--by being able to turn those return values into blocks and transform them.</p>
<p>So I'm still "finding the cool" in new behaviors, so that's motivating.  But maybe with the basics sorted out, it's getting closer to time to start ripping out some unnecessary parts, so that a committed subset can be pushed out to people on the web.  Will see what I can get done in the next couple of months--travels notwithstanding.</p> ]]></description>
        <link>https://forum.rebol.info/t/october-2022-general-status-reflection/1988/1</link>
        <pubDate>Sun, 16 Oct 2022 04:56:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6483</guid>
      </item>
      <item>
        <title>A Justification of Generalized Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h2>If Isotopes Are So Great, Why Don't Other Languages Have Them?</h2>
<p>In a way, Rebol2 had some inkling of isotopic ideas with errors.  Because an ERROR! couldn't be fetched from a WORD! without triggering an exception...you'd have to DISARM it, and that would convert it into an OBJECT!.</p>
<p>Early on when I was looking at the language, I did wonder if functions should have an "armed" vs. "disarmed" state--like errors.  This arose while trying to generate C code which assigned function variables...kind of along these lines:</p>
<pre><code>r3-alpha&gt;&gt; do compose/only [append-alias: (:append)]
; How to stop APPEND from running, by changing *only* inside the (...) ?
; (and still make APPEND-ALIAS act as a synonym for APPEND)
</code></pre>
<p>I talked myself out of it at the time...because I worried about "hidden bits" like the armed state.  But after years of building on incremental ideas like generic quoting, there are answers to such historical problems.  You can put a quasiform in that slot and it can evaluate to the isotope (itself having no representation, and can't be put in blocks, stopping the spread of this "invisibility").</p>
<p>But why didn't a parallel concept evolve in Lisp or other languages?  Here are some thoughts on reasons...</p>
<hr>
<p><strong>Lisp's quoting is a rendering trick on its list structures, there's not an actual place to store a negative quoting level.</strong></p>
<p>Isotopes are tied closely to the concept of generic quoting, and I've kind of said that they're akin to <em>"having a quoting level of negative one"</em>.</p>
<p>One thing that would hold Lisp back from seeing this as a natural possibility is that there isn't actually a "quoted value type".  When you see quotedness, it's just a rendering trick.  Something along these lines:</p>
<pre><code>lisp&gt;&gt; (print "Hi")
"Hi"

lisp&gt;&gt; '(print "Hi")
== (print "Hi")

lisp&gt;&gt; (quote abc)
== abc

lisp&gt;&gt; '(quote abc)
== 'abc

lisp&gt;&gt; '(quote (quote abc))
== ''abc

lisp&gt;&gt; (type-of '(print "hello"))
== cons  ; someting like "group!"

lisp&gt;&gt; (type of '''abc)
== cons
</code></pre>
<p>On the plus side of not building quote levels into the cells themselves, they can use the existing flexibility of lists to get arbitrarily high levels of quoting.  <em>(Right now Ren-C mechanics only allow 127 quote levels.)</em></p>
<p>But you can see how this would create a pretty big barrier to coming up with an idea like "negative quoting"; it would seem to make no sense.</p>
<p>Also: Like in Ren-C, if you evaluate a quoted structure in Lisp you drop one level of quoting.  But <a href="https://stackoverflow.com/questions/18515295/why-isnt-there-an-unquote-lisp-primitive">they didn't think it worth it to put an UNQUOTE in the box</a> as a narrowed form of EVAL that only took quoted structures.  Without that, one wouldn't be likely to think of wilder things like UNMETA.</p>
<hr>
<p><strong>Lisp's focus on compilation means they wouldn't like the idea of things like runtime conversions of normal values into states that would make a variable act undefined.</strong></p>
<p>This kind of fits in with the fact that a lot of things Rebol does would be off the table for many Lisp implementers.</p>
<p>For instance: Lisp <a href="http://web.cs.wpi.edu/~jshutt/kernel.html">dropped the idea of being able to mark a function's arguments as being quoted at the callsite</a>, because of how much that interferes with compilation:</p>
<blockquote>
<p><em>"The idea of first-class <em>operative</em> combiners, i.e., first-class combiners whose operands are never evaluated, has been around a long time. Such creatures were supported by mainstream Lisps through the 1970s, under the traditional name <code>fexprs</code>, but they made a mess out of the language semantics because they were non-orthogonal to the ordinary variety of procedures constructed via lambda — and, more insidiously, because at that time the mainstream Lisps were dynamically scoped (a language feature that causes more problems for fexprs than it does for the less powerful macros)."</em></p>
</blockquote>
<hr>
<p><strong>Most Languages Use Containers</strong></p>
<p>I've done a writeup of Haskell's Either and Rust's Result, showing some of what's similar about them to isotopes:</p>
<p><a href="https://forum.rebol.info/t/haskell-and-rust-error-handling/1987" class="inline-onebox">Haskell and Rust Error Handling</a></p>
<p>There are actually a fair number of nuances, but isotopes <em>kind of</em> like a container that's available system-wide on every variable... but <em>not</em> array slots.</p>
<p>And because it's systemic and built in, you don't have to think about this containership in advance.  Look at what it takes to return an Either from some sample Haskell code:</p>
<pre><code>parseDigit :: Char -&gt; Either ParseDigitError Int
parseDigit c =
  case c of
    '0' -&gt; Right 0
    '1' -&gt; Right 1
    '2' -&gt; Right 2
    '3' -&gt; Right 3
    '4' -&gt; Right 4
    '5' -&gt; Right 5
    '6' -&gt; Right 6
    '7' -&gt; Right 7
    '8' -&gt; Right 8
    '9' -&gt; Right 9
    _ -&gt; Left (NotADigit c)
</code></pre>
<p>The isotope model is more like letting you say <strong>(<code>'0' -&gt; 0</code>)</strong> and <strong>(_ -&gt; raise NotADigit c)</strong>, so you only have to call out the "weird" cases.</p>
<p>Though there's no truly silver bullet: if you're exchanging reified data via arrays, you can't use isotopes there.  So the convention of "containership" has to be decided on in advance for <em>fully</em> generic code.  (If the code isn't fully generic and you aren't using QUASI!-forms for something else, then the QUASI! can serve as a means of tunnel isotopic intent.)</p>
<hr>
<p><strong>It turns out to be actually really hard to tie these concepts together coherently, and people who undertake such challenges usually wouldn't bother with a runtime model as informal as a Redbol's.</strong></p>
<p>Newcomers to non-rigorous languages like JavaScript will often ask questions along the lines of "hey, why does JavaScript need both null and undefined".  This triggers a lot of conversation about the various practical problems that would happen if you only had one or the other, and usually people throw up their hands and say "what's done is done" and get on with their lives.</p>
<p>A much rarer question would be: <em>"might null and undefined be related in some transformative way, where certain basic operations naturally coerce and promote/demote between them in a meaningful pattern"</em>.  Because that's a sophisticated academic way to think, and people who care about that use "better" languages.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_monocle.png?v=9" title=":face_with_monocle:" class="emoji" alt=":face_with_monocle:"></p>
<p>While someone might suggest this means the isotope design is thus a case of polishing a turd, my recent forays into Rust are reminding me of the unusual and distinct strengths that Ren-C has.  I'm withholding my verdict on whether its future is more than a kind of educational video game, but I think it's at least that... so making the design "click" where it can feels worth it.</p> ]]></description>
        <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918/5</link>
        <pubDate>Sun, 16 Oct 2022 03:52:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6482</guid>
      </item>
      <item>
        <title>Haskell and Rust Error Handling</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Ren-C is shoring up Rebol's historically problematic exception-based error handling by blending together two mechanics: definitional returns and isotopic errors.  This gives what I'm calling "definitional failures":</p>
<p><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852" class="inline-onebox">FAIL vs. RETURN RAISE: The New Age of Definitional Failures!</a></p>
<p>Pivoting to this line of thinking has some non-accidental similarity to <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Either.html">Haskell's <code>Either</code></a> and <a href="https://doc.rust-lang.org/std/result/">Rust's <code>Result</code></a>, which I mentioned when first sketching out the motivation for change:</p>
<p><a href="https://forum.rebol.info/t/the-need-to-rethink-error/1371" class="inline-onebox">The Need To Rethink ERROR!</a></p>
<p>I thought it would be worth it to make a thread for pointing out similarities and differences, and if there are libraries they use that might have relevant inspiration.</p>
<h2>An Out-Of-Band State On The Value Is... Like An Isotope?</h2>
<p>Either is fully generic beyond just allowing errors (and <a href="https://docs.rs/either/latest/either/">Rust has its own generic Either</a> as well).  So you can really say whatever you are returning can come in two forms: the left form vs. the right form.</p>
<p>But even Rust's <code>Result</code> container will permit you to make an Error class the "valid" result, as well as the "invalid" result.</p>
<p>So here we see generic way of letting a value carry a bit--independent of what the payload is--saying whether that is a "normal" state or a "weird" state.  Then, the system has an assortment of operations that are designed for directing program flow in different ways reacting to it.</p>
<p>Ren-C embraces this deeply: effectively saying that every variable and expression product has the potential of being in this "weird" state... and <em>no array can contain a value in the weird state</em>.  But you don't have to do anything special to a value that <em>isn't</em> weird to extract it... you just get runtime errors if you use the weird values where they're not expected.</p>
<h2>Rust Tackles Low-Hanging Fruit via <code>unwrap()</code> and <code>?</code>
</h2>
<p>In Ren-C, if you don't have handling at the callsite when a definitional error happens, it's promoted to being more like a throw--and most code should not intercept it.</p>
<p>Being more formal by nature, both Haskell and Rust force <em>some</em> handling at the callsite when an error result is possible.  You have to define a code path to take if there's an error, or a code path to take if there's not.</p>
<p>But Rust has a couple of conveniences.  If you want something like the Ren-C behavior, you can just call the <code>.unwrap()</code> method on the result.  It will give you the ordinary value if the function didn't return, otherwise raise the error as a "panic".</p>
<p>There's also a cool shortcut with a postfix operator of <strong>?</strong> on the call.  This makes it so that if you call a function that returns a <code>Result</code> type from inside another function that returns a <code>Result</code> type, it will automatically propagate the result if it's an error out of the calling function.</p>
<p>Getting this behavior is more laborious in Ren-C:</p>
<pre><code>foo: func [...] [
    x: bar (...) except e -&gt; [return raise e]
    ...
]
</code></pre>
<p>Implementing the feature as postfix raises its own problems, so let's just imagine we were trying it prefix:</p>
<pre><code>foo: func [...] [
    x: ? bar (...)  ; we want this to act the same as above
    ...
]
</code></pre>
<p>For this to work under the current system, each FUNC would have to define its own <strong>?</strong> operator... because much like definitional RETURN, it would have to know what it was returning <em>from</em> in case of a raised error.</p>
<h2>Haskell Has Generic Compositional Smarts</h2>
<p>As mentioned, the strict compile-time typing in Haskell forces you to be explicit about your reaction when a function returns one of these <code>Either</code> values.</p>
<p>But because Either fits in with monadic/applicative/functor stuff, you can have higher-order operations that <a href="https://lhbg-book.link/06-errors_and_files/01-either.html">can compose together</a> failure scenarios...and gather up failures from several functions or cascade the failure through to where you want.</p>
<p>Ren-C can do this kind of thing as well, such as how you can write higher-order functions like ATTEMPT in usermode, or REDUCE a block of values in one pass with META and get the errors, then react to them later.</p>
<p>But in practice, the lack of a static type system makes this more precarious.</p>
<h2>Links To Error Handling Libraries</h2>
<ul>
<li>Rust's ANYHOW!: <a href="https://docs.rs/anyhow/">https://docs.rs/anyhow/</a>
</li>
</ul> ]]></description>
        <link>https://forum.rebol.info/t/haskell-and-rust-error-handling/1987/1</link>
        <pubDate>Sun, 16 Oct 2022 02:17:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6481</guid>
      </item>
      <item>
        <title>Why (or why not) have UNSET! in Rebol-like Languages</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was merged into an existing topic: <a href="/t/a-justification-of-generalized-isotopes/1918/4">A Justification of Generalized Isotopes</a></p> ]]></description>
        <link>https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/6</link>
        <pubDate>Sat, 15 Oct 2022 20:51:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6480</guid>
      </item>
      <item>
        <title>A Justification of Generalized Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Looking back at a <a href="https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/2">quote from Nenad I have historically taken issue with</a>, we may not actually disagree as much as it first seems.  He said:</p>
<blockquote>
<p><em><strong>"Redbol languages are based on denotational semantics, where the meaning of every expression needs to have a representation in the language itself.</strong> Every expression needs to return a value. Without unset! there would be a hole in the language, several fundamental semantic rules would be collapsing, e.g. <code>reduce [1 print ""]</code> =&gt; <code>[1]</code> (reducing 2 expressions would return 1 expression)."</em></p>
</blockquote>
<p>We actually agree on the part in bold.  The twist is that he goes on from what I think is the true part (<em>"needs to have <strong>a</strong> representation"</em>), and conflates it with the idea that the direct use of an expression's result must behave as something you can put in a block.</p>
<p>I'm saying you should always be able to get to a value to put in a block... but you might need an additional step to get it.  That could be an operation like <code>META</code> or <code>^</code>, which gives a "friendly" (reified) value, but can then be reversed to provide an isotope back.</p>
<p>In Ren-C, PRINT returns not an "unset" state (that's a different isotope) but actually an empty parameter pack isotope (e.g. a multi-return with no returns in it)</p>
<pre><code>&gt;&gt; reduce [1 print ""] 
** Error: cannot splice empty pack ~[]~ isotope in REDUCE (0 results in pack)

&gt;&gt; reduce [1 meta print ""] 
== [1 ~[]~]

&gt;&gt; reduce [1 ^ print ""] 
== [1 ~[]~]
</code></pre>
<p>These are the problems that isotopes are designed to solve!  Without formalizing an isotope mechanism in the language, your choices are:</p>
<ul>
<li>
<p>Write your code manipulating Rebol structures in another language (like C or Red/System)...which is inherently "meta" and can handle the oddness of these states.</p>
<ul>
<li><em>(People should be suspicious when problems with the language are addressed by not using the language!)</em></li>
</ul>
</li>
<li>
<p>Make usermode code struggle with refinements like /ONLY that pushes the oddness off of the values and forces generalized code to shift into a different handling mode.</p>
</li>
</ul>
<p>It's a significant enough problem area to be worth attacking with a generalized solution, that keeps the oddness on the value states where it belongs.  People should have an "a ha" moment about that when seeing things like REPLACE:</p>
<pre><code>&gt;&gt; replace/all [[a b] a b a b] [a b] [c d e]
== [[c d e] a b a b] 

&gt;&gt; replace/all [[a b] a b a b] spread [a b] [c d e]
== [[a b] [c d e] [c d e]]

&gt;&gt; replace/all [[a b] a b a b] [a b] spread [c d e]
== [c d e a b a b]

&gt;&gt; replace/all [[a b] a b a b] spread [a b] spread [c d e]
== [[a b] c d e c d e]
</code></pre>
<p>As I say, when Red tries to solve these kinds of problems without isotopes--e.g. claiming UNSET! is "just another type"--it's like they're doing complex math without complex numbers.  You will hit limits when trying to do nontrivial things.</p> ]]></description>
        <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918/4</link>
        <pubDate>Sat, 15 Oct 2022 20:13:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6479</guid>
      </item>
      <item>
        <title>A Justification of Generalized Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>2 posts were merged into an existing topic: <a href="/t/should-reduce-heed-spread/1917/2">Should REDUCE Heed SPREAD?</a></p> ]]></description>
        <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918/3</link>
        <pubDate>Sat, 15 Oct 2022 19:59:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6478</guid>
      </item>
      <item>
        <title>Q: Should ~ Be The Unevaluated Form of VOID ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1915">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>Q: Should ~ Be The Unevaluated Form of VOID ?</strong></p>
<p><strong>YES!</strong></p>
</blockquote>
</aside>
<p>Aaarrgh.  <img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji" alt=":man_facepalming:"></p>
<p>So... with isotopes on the rise, GET-WORD!s like <strong>:foo</strong> were changed back to where it allows you to basically GET/ANY value (because it's not just used for ACTION!s, but other isotope forms).</p>
<p>Now if <strong><code>:mispelld</code></strong> references come back too friendly (as void) we wind up in trouble, because voids are accepted a lot of places.</p>
<p>Before I was saying that this was all right, because no variable should ever be able to represent void legitimately.  But representation has been evolving to where voids <em>can</em> be represented in variables, as a legitimate intent, different from being invalid.</p>
<p><strong>The new conception would be that the contents of an unset variable are <em>void isotopes</em>, something that is an ornery form of less than nothing.</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></p>
<p>This would mean <strong>~</strong> isotope could come back for an ornery value (I still don't want to call this "unset"...we could call it something like "nihil"?).  Then voids could be meta'd as just a plain apostrophe instead of NULL.</p>
<pre><code>&gt;&gt; meta void
== '

&gt;&gt; meta null
== _

&gt;&gt; meta nihil
== ~
</code></pre>
<p>This doesn't look too bad on the surface, and gives COMPOSE slightly more coherence...because you're allowed to compose in voids, not nulls.  So if you've got apostrophes on the outside of a GROUP!, you get the answer you expect:</p>
<pre><code>&gt;&gt; compose ['(void)]
== [']

&gt;&gt; compose ['(null)]
** Error: Can't compose nulls
</code></pre>
<p>Not having a meta-form represented via QUASI! suggests voids not being isotopes.</p>
<p>I don't know if this suggests allowing fetching void variables without an error, but... so long as you deliberately assigned a variable to be void... maybe it's... not that bad?</p>
<pre><code> &gt;&gt; x: if 1 &gt; 2 [print "not run"]

 &gt;&gt; 10 + 20 x
 == 30
</code></pre>
<p>I'm not particularly loving that.  I feel like you should at least have to say <strong><code>:x</code></strong> there, because part of the argument for "void-in-null-out" being rigorous is that voids are hard to get accidentally.</p>
<p>But the point would be that this would mean that <strong><code>~</code></strong> isotopes could go back to being ornery again.</p>
<h2>So NULL Would Be BLANK! Isotope... ?</h2>
<p>This is where things have been headed, I guess.  It resolves some edge case issues.</p>
<p>An entirely different direction could leave blanks alone, and say that ~null~ is a word isotope (in a similar way to my suggestion that ~true~ and ~false~ could/should be word isotopes):</p>
<pre><code>&gt;&gt; null
== ~null~  ; isotope

&gt;&gt; ^ null
== ~null~

&gt;&gt; reify null
== null
</code></pre>
<p>This would also make things more in line with what other languages expect from nullness.  It's rocking the boat to take this other path.</p>
<p>But in the same way that <strong>~</strong> is particularly pleasing as a meta-representation for unset things, I feel like <strong>_</strong> is particularly pleasing for being able to null out variables.</p>
<h2>I Think NIHIL and NONE Are Distinct</h2>
<p>Right now, NONE is the return result of things like PRINT, and it's an isotopic block indicating a pack of parameters...but it's empty:</p>
<pre><code>&gt;&gt; none
== ~[]~  ; isotope
</code></pre>
<p>It makes a lot of sense to me that if you are trying to do an assignment, e.g. with a SET-WORD! or SET-BLOCK!, that this be considered to not have any values to use for the assignment, and error.</p>
<p>But it's visually noisier than the very succinct <strong><code>~</code></strong> isotope.  And also, it's nice to be able to unset variables with that single intent:</p>
<pre><code>&gt;&gt; x: ~
== ~  ; isotope
</code></pre>
<p>Which is contrary to the intent of blocking assignment, that is what NONE is trying for.</p> ]]></description>
        <link>https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915/5</link>
        <pubDate>Mon, 03 Oct 2022 12:54:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6477</guid>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>What about some kind of solution like utf-8 where the ascii characters take up 1 unit and more exotic take up more units?</p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300/11</link>
        <pubDate>Tue, 27 Sep 2022 20:41:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6471</guid>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>To recap: It's a real sticking point that Rebol's historical typeset was tied to the idea of a maximum of 64 types, simply checked by a bitset for each of those things.  That is a very limited concept.  Every Rebol clone has lockstep copied this model--despite sometimes making overtures to the existence of extending types.  (and I point out how R3-Alpha's UTYPE! was complete vaporware in every aspect)</p>
<aside class="quote no-group" data-username="IngoHohmann" data-post="6" data-topic="1300">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>By the same token you could stop showing binaries, blocks and strings in the console.</p>
</blockquote>
</aside>
<p>There's some fairly different characteristics in play.  e.g. when you have ANY-VALUE!, if you load another extension datatype, the set of available types <em>should</em> grow.</p>
<p>This is where I've made the suggestion that ANY-VALUE! might need to just be a "typecheck-flavored function".  So some form of function where you know the implicit meaning is to use it to match types.</p>
<p>Hand-waving what that sort of thing might look like:</p>
<pre><code>any-even!: &amp;(even?)

parse [2 4 6] [some any-even!]
</code></pre>
<p>Implicit here is that we presume that just referencing a function without that twist...e.g. <strong>parse [2 4 6] [some even?]</strong> would get you something different (currently, an error).</p>
<h2>Seems Cool, But What's The Catch?</h2>
<p>A problem with this direction comes down to what happens if you're allowed to change what the words you capture look up to.  I cover this in the <strong><a href="https://forum.rebol.info/t/survey-of-redefining-datatype-word-s/1479">Survey of Redefining Datatype Words</a></strong>.</p>
<p>To sum up: Native code fiddles cell bits under the expectation that the type checking has been done correctly.  If you can change what INTEGER! is defined as--and what the typeset consists of is <strong><code>[integer!]</code></strong>--the guarantees the native expected are broken.</p>
<p>We can harden things by reducing them.  So instead of the native storing <strong><code>[integer!]</code></strong> it stores <strong><code>[&amp;[integer]]</code></strong>, which retains <em>some</em> amount of readability.  But it's not what HELP wants to show, so it either has to reverse-engineer INTEGER! back or keep the source block separately.</p>
<p>If "typesets" are actually "typechecker-flavored functions" it's worse, because they become ugly action literals.  Though there's a modern feature that can help with this being not <em>quite</em> as bad as it was: <strong><a href="https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357">ACTION! symbol caching</a></strong>:</p>
<pre><code>&gt;&gt; any-even!: reduce &amp;(:even?)
== &amp;(#[action! {even?} [value]])
</code></pre>
<p>So EVEN? symbol can still be in there.  But again this isn't what HELP wants...it presumably wants to show ANY-EVEN!.</p>
<p>(I'll point the obvious that when using a typecheck function, it has to remove from consideration anything not a candidate in the component function's type checking.  So if EVEN? only takes INTEGER! it wouldn't try to pass non-integers to EVEN?)</p>
<h2>What About Just Locking The WORD!s Used In Natives?</h2>
<p>I've written this up in the survey post as a possibility:</p>
<pre><code>&gt;&gt; test!: integer!

&gt;&gt; foo: func [x [test!]] []

&gt;&gt; test!: tag!
** Error: Cannot modify TEST! word, locked for use in a type spec
</code></pre>
<p>But I pointed out that it's trickier than it sounds:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1479">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/survey-of-redefining-datatype-word-s/1479/1">Survey of Redefining Datatype WORD!s</a>
</div>
<blockquote>
<p>Though it would have to be a "semantically deep lock". For instance, if it were legal to say:</p>
<pre><code> my-types!: [integer! tag!]
 foo: func [x [my-types!]] []
</code></pre>
<p>...if the way types were interpreted was such that it would pull in types that were grouped in a block like that, then it would have to reach through and lock INTEGER! and TAG! too. This same "deep lock" notion would need to apply to any functions that might be used.</p>
</blockquote>
</aside>
<h2>What About Recursive Typechecks?</h2>
<p>People would be able to write things something like:</p>
<pre><code> types-one!: &amp;[integer! types-two!]
 types-two!: &amp;[block! types-one!]
</code></pre>
<p>This is just a case you'd have to catch.  The typechecker would have to color the array nodes as it went.</p>
<p>(Saying this disproves the idea would be like saying you shouldn't make a spreadsheet with formulas because there can be cycles.)</p>
<h2>Time Has Passed And I Haven't Had Any Better Ideas</h2>
<p>Saving a typeset's definition as a list of words offers the desirable property that what's in a typeset is actually useful for HELP, and can be viewed meaningfully as "source".</p>
<p>If we argue that any word used this way has its meaning become locked, that doesn't mean the word can't have its meaning redefined in another context.  LIB can define INTEGER! one way, but you can have your module define it another.  You can call local variables INTEGER!.  etc.</p>
<p>Locking permits optimizations.  If a typeset says <strong><code>[integer! block!]</code></strong> and it can trust that the meanings of those words have been locked in the context, it could make some cache where it didn't have to look up the words.</p>
<p>I've been circumspect about making this jump.  But besides committing to 64 types and a bitset forever, I just don't see another solution.  Guess I'll give it a try.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300/10</link>
        <pubDate>Tue, 27 Sep 2022 02:13:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6467</guid>
      </item>
      <item>
        <title>Should DATATYPE! Be ANY-WORD! (such as @integer)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="10" data-topic="1177">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>To have clean, non overloaded way to describe datatypes, they would need a dedicated symbol for datatypes.</p>
</blockquote>
</aside>
<p>I think this turned out to be inevitable.  So what I'm working with right now is ampersand, as <strong><code>&amp;[xxx]</code></strong>.</p>
<p>At the moment it's not a <a href="https://forum.rebol.info/t/removing-from-legal-word-characters-any-objections/1180/13">full family of ampersand-things</a> (e.g. TYPE-XXX!).  It's just a rendering of datatype to look like a block! class.  But the idea would be to inch toward the whole family.</p>
<aside class="quote no-group" data-username="IngoHohmann" data-post="10" data-topic="1177">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>Actually I've never used "!" in words myself, so I wouldn't have a problem with enforcing that only types can have "!" in their name.</p>
</blockquote>
</aside>
<p>It's technically possible to remove exclamation points from legal ordinary word characters, and introduce it as a terminal sigil...like a SET-WORD!:</p>
<pre><code>type-word!
</code></pre>
<p>That could be generalized to the other types that carry sigils:</p>
<pre><code>[type block]!
(type group)!
type.tuple!
type/path!
</code></pre>
<p>But there seem to be a lot of reasons to be skeptical of this:</p>
<ul>
<li>
<p>Having types be indirectly referenced through WORD!s--as they were historically--allows for convenient aliasing.  In the Rebol2/Red emulation, we can simply say <strong>paren!: group!</strong> and it works.</p>
</li>
<li>
<p>If you're going to make something like ANY-WORD! refer to a typeset, it doesn't have any obvious separation from the way you refer to a single type.  Other things like type constraints (like EVEN!) also don't have the indirection to their underlying mechanic.</p>
</li>
<li>
<p>I've tended to favor creative uses of ! in terms or dialects...like !!WARNING!!.  And I like the idea of !! meaning breakpoint, or things like that.</p>
<ul>
<li>Though in the case of <strong><code>!</code></strong> and <strong><code>!!</code></strong> they could be exceptions as WORD!s, similar to how there's an exception for <strong><code>/</code></strong> not being a PATH!.</li>
</ul>
</li>
</ul>
<p>In any case, I think <code>&amp;</code> is the better move.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-datatype-be-any-word-such-as-integer/1177/13</link>
        <pubDate>Mon, 26 Sep 2022 09:43:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6464</guid>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>2 posts were split to a new topic: <a href="/t/the-typeset-representation-problem/1984">The TYPESET! Representation Problem</a></p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300/2</link>
        <pubDate>Mon, 26 Sep 2022 08:53:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6459</guid>
      </item>
      <item>
        <title>Where Should Isotope Tolerance Begin (and End)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was merged into an existing topic: <a href="/t/what-should-type-of-an-isotope-be/1983/3">What Should TYPE OF an Isotope Be?</a></p> ]]></description>
        <link>https://forum.rebol.info/t/where-should-isotope-tolerance-begin-and-end/1964/3</link>
        <pubDate>Mon, 26 Sep 2022 08:42:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6458</guid>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was merged into an existing topic: <a href="/t/what-should-type-of-an-isotope-be/1983/2">What Should TYPE OF an Isotope Be?</a></p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300/9</link>
        <pubDate>Mon, 26 Sep 2022 08:41:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6457</guid>
      </item>
      <item>
        <title>Where Should Isotope Tolerance Begin (and End)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was split to a new topic: <a href="/t/what-should-type-of-an-isotope-be/1983">What Should TYPE OF an Isotope Be?</a></p> ]]></description>
        <link>https://forum.rebol.info/t/where-should-isotope-tolerance-begin-and-end/1964/2</link>
        <pubDate>Mon, 26 Sep 2022 08:39:44 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6456</guid>
      </item>
      <item>
        <title>The TYPESET! Representation Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>2 posts were split to a new topic: <a href="/t/what-if-datatype-was-isotopic-tl-dr-bad-idea/1982">What If "DATATYPE" Was Isotopic (TL;DR: Bad Idea)</a></p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300/7</link>
        <pubDate>Mon, 26 Sep 2022 08:36:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6455</guid>
      </item>
      <item>
        <title>What Should TYPE OF an Isotope Be?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h2>How Might TYPE* Inform TYPE OF VOID and TYPE OF NULL?</h2>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1983">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>OF is a generic operation (the enfix form of REFLECT that quotes the word on its left. It's desirable to honor the VOID-in-NULL out convention for all the other reflectors that aren't TYPE... and it's desirable to error on NULL more generically.</p>
<pre><code>&gt;&gt; label of null
** Error: You didn't give anything

&gt;&gt; label of maybe null  ; MAYBE NULL is VOID 
; null
</code></pre>
<p>So if <strong>type of</strong> follows the same pattern as other <strong>xxx of</strong>, we'd surmise that you don't use TYPE OF to discern NULL and VOID. It errors on NULL input and gives you back NULL if you MAYBE it.</p>
</blockquote>
</aside>
<p>Above I suggest an XXX OF consistency, with TYPE OF NULL as an error and TYPE OF VOID is NULL.</p>
<p>If that were so, and TYPE* OF VOID is <em>not</em> NULL, then it would be the only case where TYPE* OF would change an answer from what the TYPE OF would say.</p>
<p>Does that suggest not allowing plain TYPE OF either NULL or VOID, and requiring you to use TYPE*, to get some kind of reified answer?  (This would introduce <strong><code>null!*</code></strong> and <strong><code>void!*</code></strong>)</p>
<p>Or does it suggest allowing NULL and not VOID?  (This would introduce <strong><code>null!</code></strong> with no <code>*</code>, and <strong><code>void!*</code></strong>)</p>
<pre><code>&gt;&gt; type of null
== &amp;[null]

&gt;&gt; type* of null
== &amp;[null]

&gt;&gt; type of void
** Error: Use TYPE* to take type of isotopes if intentional

&gt;&gt; type* of void
== ~&amp;[null]~
</code></pre>
<h2>But I've Always Been Uncomfortable With NULL!</h2>
<p><a href="https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658">When discussing why I made the <code>&lt;opt&gt;</code> tag instead of null!</a>, I said:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1658">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/revisiting-opt-in-the-func-spec-dialect/1658/1">Revisiting `&lt;opt&gt;` in the Func Spec Dialect</a>
</div>
<blockquote>
<p>If a TYPE OF operation can make a reified thing spring into existence out of the absence of a thing, I feel like something is out of whack.</p>
<p>There's a clear advantage if you're going to be chaining things.</p>
<pre><code>x: (type of select data item) else [
    fail "A reified NULL! datatype doesn't permit this kind of handling"
]
</code></pre>
<p>Though that's a more modern intuition about it; I wasn't thinking about that when <code>&lt;opt&gt;</code> was made.</p>
<p>I think one angle is that I felt like the optionalness was somehow a "big deal" and needed to jump off the page for the spec more. NULL! just blended in.</p>
<pre><code>foo: func [arg [null! integer! block!]] [...]
bar: func [arg [integer! block! group! path! null! word!]] [...]
</code></pre>
</blockquote>
</aside>
<h2>I Dislike The Idea Of TYPE* Changing Answers</h2>
<p>Imagine you had code like this:</p>
<pre><code> switch type of (...) [
    null [...]
    integer! [...]
 ]
</code></pre>
<p>But one day you realize the input could be a splice or something, and so <code>TYPE*</code> gets swapped in:</p>
<pre><code> switch type* of (...) [
    null [...]
    integer! [...]
    splice!* [...]
 ]
</code></pre>
<p>It seems to me that the meaning of NULL should not change, all things being equal.  But things are probably not equal.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/exploding_head.png?v=9" title=":exploding_head:" class="emoji only-emoji" alt=":exploding_head:"></p>
<h2>This Is Very Aggravating... but...</h2>
<p>I think I like TYPE OF NULL being NULL</p>
<ul>
<li>
<p>I like it even if it breaks a pattern in XXX OF where VOID input means NULL out, and NULL input is an error</p>
</li>
<li>
<p>TYPE feels like a fairly special kind of question, so it's probably okay</p>
</li>
</ul>
<p>Internally we need a way to put nulls and voids into typesets, and I can imagine usermode cases where this is useful as well.</p>
<ul>
<li>
<p>If TYPE* is able to give a reified answer of NULL!* and VOID!* this would provide some uses</p>
</li>
<li>
<p>This would imply that TYPE* OF NULL and TYPE OF NULL would be different answers</p>
</li>
</ul>
<p>It might be best to avoid a symbol in the type, to signify the weirdness of it.  But in the current design, NULL actually isn't an isotope...void is the isotope of NULL:</p>
<pre><code>&gt;&gt; type* of null
== &amp;[]

&gt;&gt; type* of void
== ~&amp;[]~
</code></pre>
<p>I suspect I'm missing something here.  But as with most things, I guess I just have to kind of try things and feel them out.</p>
<p>So what I'm going to try is a world where function parameters are powered by this <code>TYPE*</code> concept, give the same concept to usermode, and see what emerges from that.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983/3</link>
        <pubDate>Mon, 26 Sep 2022 07:31:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6454</guid>
      </item>
  </channel>
</rss>

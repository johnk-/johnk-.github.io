<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>libuv Integration Has Started...an I/O Renaissance</title>
        <dc:creator><![CDATA[@BlackATTR Black Attr]]></dc:creator>
        <description><![CDATA[ <p>Bravo !! Great to see sawdust piling up on the shop floor again !</p> ]]></description>
        <link>https://forum.rebol.info/t/libuv-integration-has-started-an-i-o-renaissance/1694#post_6</link>
        <pubDate>Sun, 02 Jul 2023 14:37:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6647</guid>
      </item>
      <item>
        <title>libuv Integration Has Started...an I/O Renaissance</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1694">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Right now the only time we call the event loop is in WAIT, and it's still using some ad hoc timer logic instead of libuv timers.</p>
</blockquote>
</aside>
<p>I've gotten rid of the "EVENT Extension"...instead moving WAIT into the libuv-based Network extension.  This is because WAIT on PORT! is now only used for waiting for incoming network connections on a server (and waiting for a time, but you can use SLEEP from the TIME extension if you don't want your build to include libuv networking.)</p>
<p>While doing so, I converted the event loop inside that WAIT to use libuv timers...instead of the decades-old tangled multi-platform timing logic.</p>
<p>This means it's finally the case that the language core itself doesn't need the <code>Reb_Device</code> datatype, or functions like Register_Device() or OS_Poll_Devices().</p>
<h2>
<a name="and-so-the-last-bit-of-host-kit-is-thus-gone-1" class="anchor" href="https://forum.rebol.info#and-so-the-last-bit-of-host-kit-is-thus-gone-1"></a>And So, The Last Bit Of "Host-Kit" is Thus Gone!</h2>
<p>...yet Ren-C is demonstrating itself doing more, on more platforms.  What's the difference in approach?</p>
<p>R3-Alpha aimed to be closed-source, hardcoding the implementations of things like WAIT and READ and WRITE, as a fixed body of natives.  These attempted to be extensible via the means of hookpoints that would be supplied as C code, with a grab-bag of structures and parameters to each function.  This was supposed to <a href="https://forum.rebol.info/t/back-to-personal-computing/186/5">avoid use of Rebol datatypes</a>, with the concept that the functionality could be used as its own independent OS.</p>
<p>Ren-C basically throws that out the window.  When you are packaging up a distribution of the language, you write your own natives...and any "extensibility" architectures are done through Rebol calls to those natives.</p>
<p>As an example: a fixed implementation of NOW is not based on a Rebol-defined "GetTime()" C API.  There are various implementations of NOW... which actually <em>is</em> the Ren-C "get-time-API".  If another extension wants the current time, it's supposed to use NOW to get it.</p>
<p>The implementations of READ of a URL vary so drastically between the WebAssembly build and the Desktop builds that URL reads are intercepted much earlier, and done via JavaScript fetch().  You really wouldn't want to convolute it so that network reads had to contort themselves in some way to fulfill an abstract C byte-level API.  It calls "rebol functions" that are actually the JavaScript equivalent of a native.</p>
<p>Anyway, the desktop builds are still a lower priority than Wasm, but it's nice to see the last bit of hostkit cruft finally gone from the core.</p> ]]></description>
        <link>https://forum.rebol.info/t/libuv-integration-has-started-an-i-o-renaissance/1694#post_5</link>
        <pubDate>Sat, 01 Jul 2023 22:42:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6646</guid>
      </item>
      <item>
        <title>Compiling ren-c with zig?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="1" data-topic="2017">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>They claim to be able to compile c-code using zig cc</p>
</blockquote>
</aside>
<p>Given that I'm back at coding with a bit more enthusiasm right now, I thought it would probably be worth it to take a crack at building Ren-C with Zig again.</p>
<p><strong>Lo and behold, I managed to generate an x86_64 executable on Linux via Zig.</strong>  Woo.  <img src="https://forum.rebol.info/images/emoji/twitter/partying_face.png?v=12" title=":partying_face:" class="emoji" alt=":partying_face:" loading="lazy" width="20" height="20"></p>
<p>It also had test parity with GCC builds (at the moment a lot of failures, but no crashes).</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2017">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I couldn't figure out how to get it to act like a C99 compiler. It defines <code>__cplusplus</code> but then doesn't provide the headers for C++ (like <code>&lt;string&gt;</code> or <code>&lt;type_traits&gt;</code>).</p>
</blockquote>
</aside>
<p>Some of this turned out to be my mistake.  I failed to notice the makefile was passing a "--std=c++17" and "-x c++" flag even though invoking zig in C mode (<strong>zig cc</strong>).</p>
<p>But I hacked through it in both C++ and C compilation modes.</p>
<aside class="quote no-group quote-modified" data-username="IngoHohmann" data-post="1" data-topic="2017">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>[Zig has] an impressive list of cross compilation targets, wasm among them.</p>
</blockquote>
</aside>
<p>While this may sound great, be prepared for a bit of disappointment...</p>
<p><strong>That cross-compilation comes from the fact that Zig is dependent on LLVM (~169 MiB), just as Emscripten is.</strong></p>
<p>There was a <a href="https://kristoff.it/blog/zig-new-relationship-llvm/">roadmap document in 2020</a> about letting go of the "training wheels".  And circa October 2022, an issue on their GitHub <a href="https://github.com/ziglang/zig/issues/13265">offers "reasons why one want an LLVM-less binary"</a>, painting an optimistic picture:</p>
<blockquote>
<ul>
<li>
<p>The executable is 4.4 MiB instead of 169 MiB.</p>
</li>
<li>
<p>Bootstrapping it only requires a C compiler instead of requiring a modern C++ compiler, Python 3, bash, and CMake (also C++).</p>
<ul>
<li>This would make it much easier to obtain a Zig compiler on a new operating system or a limited environment such as a calculator.</li>
</ul>
</li>
</ul>
</blockquote>
<p>But that's still some future vision.  They say currently <em>"Zig is not very useful without enabling LLVM extensions."</em>  I think this just means that they're like every other project (including Red, including Ren-C)... talking about a future thing when that future may be very very far off.</p>
<p>It certainly doesn't hurt to have Ren-C's deep vetting for standards show it building successfully on yet another compiler.  And if that compiler does perchance make a decision aiming in the same vicinity as Ren-C (e.g. "we're going to focus on Wasm, vs requiring to target every esoteric LLVM emitter") it may make a better choice than other toolchains.</p>
<p>But for the moment, their Wasm doesn't have the integration Emscripten provides, and it's not that much thinner so long as the LLVM dependency is there.</p> ]]></description>
        <link>https://forum.rebol.info/t/compiling-ren-c-with-zig/2017#post_4</link>
        <pubDate>Thu, 29 Jun 2023 08:13:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6645</guid>
      </item>
      <item>
        <title>Should ANY and ALL Vaporize VOID (or require ELIDE-IF-VOID ?)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I've written up how <a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">the evolution of invisibility gave rise to VOID vs. NIHIL</a>.</p>
<p>The default evaluator (and UPARSE) accept that void is "nothing" and can't be put in blocks.  But they don't vaporize VOID on a whim: it will still be the result of expressions whose last result is a void.</p>
<pre><code>&gt;&gt; 1 + 2 if false [&lt;a&gt;]
; void
</code></pre>
<p>On the other hand, the empty parameter pack of NIHIL truly vaporizes unless you pipe it around with ^META:</p>
<pre><code>&gt;&gt; 1 + 2 nihil
== 3
</code></pre>
<p>This means it's up to constructs to decide if they want to erase voids or not.  DELIMIT does, so you will see that reflected in things like UNSPACED:</p>
<pre><code>&gt;&gt; unspaced ["A" if false ["B"] "C"]
== "AC"
</code></pre>
<p>COMPOSE vaporizes void slots (and errors on null ones).  <a href="https://forum.rebol.info/t/vaporizing-failed-conditionals-in-reduce/1665">REDUCE is currently vaporizing VOID</a> because it seems like the default people want.</p>
<h2>
<a name="should-any-and-all-vaporize-voids-1" class="anchor" href="https://forum.rebol.info#should-any-and-all-vaporize-voids-1"></a>Should ANY and ALL Vaporize Voids?</h2>
<p>To me, this is a bit of a tough decision.</p>
<p>VOID is neither truthy nor falsey, and IF will reject it:</p>
<pre><code>&gt;&gt; if (if false [true]) [&lt;unreachable&gt;]
** Error: IF doesn't accept VOID as its condition argument
</code></pre>
<p>When there was no VOID/NIHIL distinction, then ANY and ALL were backed into a corner.  If they decided to error on void, you couldn't use an ELIDE or ASSERT in the middle of them.  If they didn't error on VOID then the risk was that you could write something like <strong><code>all [1 = 1, 2 = 2, value]</code></strong> and if VALUE was just incidentally void you'd get the 2 = 2 result as ~true~.</p>
<p>Today, things like ELIDE and ASSERT return NIHIL and can be safely vaporized by ANY and ALL, while retaining the choice to error on voids as not being true or false.  If you really want to erase voids, we can have something that converts voids to nihil called ELIDE-IF-VOID</p>
<pre><code>&gt;&gt; value: void

&gt;&gt; all [1 = 1, 2 = 2, value]
** Error: VALUE is VOID which is neither truthy nor falsey

&gt;&gt; all [1 = 1, 2 = 2, elide-if-void value]
== ~true~  ; isotope
</code></pre>
<h2>
<a name="things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2" class="anchor" href="https://forum.rebol.info#things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2"></a>Things Like <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">FOR-BOTH</a> Would Get More Awkward...</h2>
<p>I was fairly proud of this formulation:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        meta* for-each (var) blk1 body
        meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>(I wound up deciding that META would meta-raise everything--including pure null and void--so the asterisks were probably best included there for the alternative formulation.)</p>
<p>But if ALL and ANY errored on void, and you had to erase it, this would become:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        elide-if-void meta* for-each (var) blk1 body
        elide-if-void meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>If I put on my formalism hat, I can see how this is <em>safer</em>.  But I've made similar arguments about why I don't want this:</p>
<pre><code>&gt;&gt; compose [a (if false ['b]) c]
** Error: COMPOSE cannot erase VOID (use ELIDE-IF-VOID if intentional)

&gt;&gt; compose [a (elide-if-void if false ['b]) c]
== [a c]
</code></pre>
<p>It is admittedly a bit different in ANY and ALL's case, because they're mixing in a test for truthiness.  But erasing voids by default has other advantages in writing wild control constructs.</p>
<p>I'm really torn on this, as it's right on the edge.  <strong>But when all things are mostly equal, safety isn't as compelling as enabling creativity in my current view of the language.</strong>  I think I'm going to wait until I see a really bad consequence of vaporizing the voids here... it hasn't broken any real code yet, and it has proven its convenience.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-any-and-all-vaporize-void-or-require-elide-if-void/2040#post_1</link>
        <pubDate>Thu, 29 Jun 2023 02:09:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6643</guid>
      </item>
      <item>
        <title>Should PARSE Rules Always Be BLOCK!s ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1390">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I feel a twinge of prescriptivism in saying that you either use the <span class="mention">@xxx</span> syntax at your reference sites or you form your subrules as proper blocks -or- inert values (strings and binaries).</p>
<p>So I think this is the option we should go with.</p>
</blockquote>
</aside>
<p>While words-looking-up-to-words were prohibited (along with words looking up to integer, or group, etc.), I thought maybe supporting QUOTED! would be all right.  It seemed like variables holding quoted things were kind of rare, and it could help with efficiency.</p>
<pre><code>&gt;&gt; rule: first ['skip]
== 'skip

&gt;&gt; parse [skip skip skip] [some rule]
== skip
</code></pre>
<p>This optimization over <strong>rule: ['skip]</strong> is only going to be applicable when the user of the rule is using it abstractly...e.g. they don't know enough to know whether it's something complex that's got a lot of rules in it or if it's just matching a single value.  What we lose here is the optimization that the authors of such rules could avoid the overhead of a BLOCK! and still say <strong><code>rule</code></strong> undecorated vs. need to psychically choose between <strong><code>@rule</code></strong> and <strong><code>rule</code></strong> based on how the rule is expressed.</p>
<p>So this exception was carried over from PARSE3 to UPARSE.</p>
<p><em>But nowadays, QUOTED!s aren't so rare.</em>  You might be intending to actually match quoted skip, and giving an error could provide guidance to use the <code>@</code> operations.</p>
<p>Also, making these "optimized rules" isn't the most intuitive thing in the world.  e.g. the person making the rule has to quote the quoted somehow:</p>
<pre><code>rule: ''something
rule: first ['something]
</code></pre>
<p><strong>In practice, I've just about never used the QUOTED!-to-avoid-a-block optimization.</strong>  It's a very rare scenario...now that @ exists, that covers most cases in a much more clear way (because what you're matching in the variable can be as-is).  So it's an optimization for an almost-never-occuring case of using a rule written by someone else that has nothing to match but a single literal item.</p>
<p>Actually...I can't think of this having come up, <em>ever</em>.  Hence the potential for confusion of not catching when someone actually meant to match a QUOTED! is almost certainly too great.  I'm going to kill it.</p>
<p><sub>As usual...I'm glad we had this talk.  <img src="https://forum.rebol.info/images/emoji/twitter/stuck_out_tongue.png?v=12" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:" loading="lazy" width="20" height="20"></sub></p> ]]></description>
        <link>https://forum.rebol.info/t/should-parse-rules-always-be-block-s/1390#post_2</link>
        <pubDate>Mon, 26 Jun 2023 18:17:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6638</guid>
      </item>
      <item>
        <title>BLANK! (_) as SPACE in String-Oriented Dialects</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Experiments have run the gamut to where a plain BLANK! once would opt out of appending to a series, and you had to quote it to append it:</p>
<pre><code>experiment&gt;&gt; append [a b] _
= [a b]

experiment&gt;&gt; append [a b] quote _
== [a b _]
</code></pre>
<p>But the satisfying world we have now is that anything you can pick out of a block will append as-is to another block.  So adding a blank is additive:</p>
<pre><code>&gt;&gt; append [a b] _
== [a b _]
</code></pre>
<p>It feels like a decent fit to say that appending a blank to a string is additive...since VOID and such are available if you want to opt out:</p>
<pre><code>&gt;&gt; append "ab" _
== "ab "
</code></pre>
<p>Though it raises the question of what BINARY! should do:</p>
<pre><code>&gt;&gt; append #{0102} _
== ???
</code></pre>
<p>It seems that adding a UTF-8 representation is the story for ASCII:</p>
<pre><code>&gt;&gt; as binary! "AB"
== #{4142}

&gt;&gt; append #{0102} "AB"
= #{01024142}
</code></pre>
<p>But when it comes to integers, strings append the molded form...while binaries just add one byte, not the bytes of the formed string of the integer:</p>
<pre><code>&gt;&gt; append "ab" 10
== "ab10"

&gt;&gt; append #{0102} 10
== #{01020A}
</code></pre>
<p>A bit of a mixed bag, that could support arguments that BLANK! could be "the space of binaries" (e.g. #{00})</p>
<pre><code>&gt;&gt; append #{0102} _
== #{010200}
</code></pre>
<p>But I think that's not so useful.  It's more likely that the character representation of space is useful:</p>
<pre><code>&gt;&gt; to binary! #" "
== #{20}

&gt;&gt; append #{0102} _
== #{010220}
</code></pre>
<p>Ren-C FIND and PARSE mechanics already allows you to search for strings in BINARY!, implicitly looking for the UTF-8 representation.</p>
<h2>
<a name="what-if-_-was-really-the-canon-representation-of-space-chars-1" class="anchor" href="https://forum.rebol.info#what-if-_-was-really-the-canon-representation-of-space-chars-1"></a>What If _ Was Really The Canon Representation of Space Chars?</h2>
<pre><code>&gt;&gt; pick "ab " 3
== _

&gt;&gt; #" "
== _

&gt;&gt; char? _
== ~true~  ; isotope

&gt;&gt; space? _
== ~true~  ; isotope
</code></pre>
<p>I've mentioned that single character intents are on the rise... we could call quoted void (apostrophe) "blank" and it could be used in contexts where you want to say there's no value:</p>
<pre><code>&gt;&gt; blank? first [']
== ~true~  ; isotope

&gt;&gt; blank
== '
</code></pre>
<p>You'd still have _ as an evaluator-inert dialecting part that can't be redefined.  You just would need to use something like <strong>#</strong> or <strong>'</strong> or <strong>~</strong> in cases where you had a slot that could be either any character -or- some out of band thing.</p>
<p>Off the top of my head, I can see a few problems.  If _ became a character literal, it shouldn't be used for vacant spots in paths.  So let's say paths start using this "new blank":</p>
<pre><code>&gt;&gt; as block! first [/a]
== [' a]
</code></pre>
<p>Doesn't look too bad, but if you want to parse it you need double apostrophes to match those spots:</p>
<pre><code>parse [/a] [into path! ['' 'a]]
</code></pre>
<p>This is because a single apostrophe is matched as void, e.g. matches without advancing the parse position.  <a href="https://forum.rebol.info/t/parse-behavior-for-words-that-lookup-to-quoted/2038">And it wouldn't work if you used a word to reference the blank</a>:</p>
<pre><code>&gt;&gt; parse [/a] [into path! [blank 'a]]
** Error: To match a QUOTED! you must use @blank

&gt;&gt; parse [/a] [into path! [@blank 'a]]  ; would need to do this...
== a
</code></pre>
<p>But it's not awful, and at least it doesn't silently treat the quote as a vanishing rule.</p>
<p><strong>It's still kind of an interesting thought to make _ the literal char! of space.</strong>  Still inert, still usable in dialects.  It would leave <strong><code>'</code></strong> and <strong><code>~</code></strong> as "friendly nothing" and "unfriendly nothing".</p>
<pre><code>&gt;&gt; spread first [']  ; would return void

&gt;&gt; spread first [~]
** Error: Cannot spread meta-NONE
</code></pre>
<p>Either way, I think the conclusion here is that <strong>append #{0102} _</strong> should be <strong>#{010220}</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/blank-as-space-in-string-oriented-dialects/1885#post_6</link>
        <pubDate>Mon, 26 Jun 2023 17:39:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6636</guid>
      </item>
      <item>
        <title>ASSERT vs. [end]able FAIL</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="756">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If you think about it, a FAIL with no arguments doesn't have a lot of options for what to do besides report an error. So why not make it <code>&lt;end&gt;</code>-able (the same way HELP can accept either no arguments or one argument), and assume that a FAIL with no arguments is just a way of saying "fail here"?</p>
<p>There are other applications for this:</p>
<pre><code>switch type of x [
    integer! [...]
    text! [...]
    fail
]
</code></pre>
<p>That's more succinct than <code>switch ... [...] else [fail]</code>.</p>
</blockquote>
</aside>
<p>This five-year-old idea has been put to good use and feels like it has proven its mettle.</p>
<p>But reviewing old posts I realized that it does theoretically suffer from the <strong><a href="https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965">line continuation arity bug</a></strong>.</p>
<p>This is to say you might have some code like:</p>
<pre><code> blah blah blah
 more blah blah
</code></pre>
<p>And decide you're going to just throw a FAIL in the middle:</p>
<pre><code> blah blah blah
 fail
 more blah blah
</code></pre>
<p>Because you're used to the idea that FAIL can be used with no arguments.  Yet the <strong>more blah blah</strong> will be picked up as an argument to fail, as if you'd written:</p>
<pre><code> blah blah blah
 fail (more blah blah)
</code></pre>
<p>The consequences aren't quite as dire as when this was being used with the likes of RETURN...because FAIL generally stops execution anyway.  But it could lead to unexpected results.</p>
<p>I just wanted to reiterate that <code>&lt;end&gt;</code>-able constructs...cool as they seem...have this blind spot when code is broken across lines.</p> ]]></description>
        <link>https://forum.rebol.info/t/assert-vs-end-able-fail/756#post_2</link>
        <pubDate>Mon, 26 Jun 2023 07:19:35 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6635</guid>
      </item>
      <item>
        <title>Vaporizing Failed Conditionals In REDUCE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1665">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>min: null
max: _

&lt;&lt;BUNCH OF CODE THAT MUST SET MIN AND MAY OR MAY NOT SET MAX&gt;&gt;

uparse data [repeat (:[min max]) rule]
</code></pre>
<p>The reason I didn't say <strong><code>(min: ~)</code></strong> or <strong><code>(min: ~overwrite-me~)</code></strong> is because I wanted min to be "middlingly ornery". So I wanted to use it in expressions like <strong>any [min, ...]</strong> but I didn't want it to be able to be used as an opt out intention. This is the weird zone that NULL occupies and we're making the most of it.</p>
<p>Under this understanding...I'd be displeased if that turned into <strong><code>[repeat ([_]) rule]</code></strong>, because I'd have liked to have been told about the issue.</p>
</blockquote>
</aside>
<p>I feel like a bit of a broken record revisiting all these old posts from when NULL was the only non-valued state, that was trying to do double duty as both "soft failure" and "opt out".</p>
<p>But this is yet another solved case.  Nowadays NULL doesn't vaporize in REDUCE (it's an error), but VOID does vanish.  And you can convert NULL to void with MAYBE if that's what you want to do.</p>
<p>Ever since introducing this distinction, I haven't really seen problems with vaporizing voids...and the NULL erroring has caught many issues.  The abstract potential for problems with void opting out of REDUCE is there, but I haven't seen any problems.  It feels especially solid now that these behaviors are specific to constructs like REDUCE, and <a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">the evaluator doesn't vaporize VOID...just the much rarer NIHIL</a>.</p> ]]></description>
        <link>https://forum.rebol.info/t/vaporizing-failed-conditionals-in-reduce/1665#post_2</link>
        <pubDate>Mon, 26 Jun 2023 03:18:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6634</guid>
      </item>
      <item>
        <title>Function That Errors on NULL (But Passes Thru Everything Else)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="11" data-topic="1250">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The construct that has been committed is called MUST:</p>
<pre><code>&gt;&gt; must find "abc" "b"
== "bc"

&gt;&gt; must find "abc" "q"
** Error: MUST requires argument to not be NULL
</code></pre>
<p>But an issue that should make everyone happier is that NULL is becoming accepted fewer places.  For instance, APPEND of NULL is an error--not a no-op. You have to MAYBE it to turn it into a VOID.</p>
</blockquote>
</aside>
<p><em>Reviewing this two years later...</em></p>
<p>Technically what I say here is true: you don't have to ensure things aren't NULL any more, because you'll get an error anyway if you try to pass nulls as arguments.</p>
<p>Yet the landscape has shifted: <strong>now the issue (if there is still an issue) is having certain spots potentially be void, and opting out when you didn't mean to.</strong></p>
<p>Fortunately that means the map of the problematic territory has shrunk significantly.  There are fewer void-returning situations than there are null-returning situations.  But branching constructs are candidates for returning void.</p>
<pre><code>&gt;&gt; append [a b c] case [1 = 2 [&lt;d&gt;] 3 = 4 [&lt;e&gt;]]
== [a b c]
</code></pre>
<p>Does a VOID-sensing MUST make sense?  It's going to read a bit weirdly:</p>
<pre><code>&gt;&gt; append [a b c] must case [1 = 2 [&lt;d&gt;] 3 = 4 [&lt;e&gt;]]
** Error: MUST requires argument to not be VOID
</code></pre>
<p>I'd certainly prefer <strong>non void</strong> on the rare cases you would do this:</p>
<pre><code>append [a b c] non void case [1 = 2 [&lt;d&gt;] 3 = 4 [&lt;e&gt;]]
</code></pre>
<p>But furthermore, the design of functions like CASE and SWITCH allows you to tack on a FAIL if they reach the end, which seems more legible to me... same number of characters as MUST if you don't supply a message, but also having the option of giving a message:</p>
<pre><code>append [a b c] case [1 = 2 [&lt;d&gt;] 3 = 4 [&lt;e&gt;] fail]

append [a b c] case [1 = 2 [&lt;d&gt;] 3 = 4 [&lt;e&gt;] fail "your message here"]
</code></pre>
<p><strong>So I think the story here has a happy ending, which is that splitting out NULL and VOID intents (with a clear function for converting between them) has basically made MUST obsolete.</strong>  Constructs are plugging together naturally and giving errors at the right places.</p>
<p>NULL-sensing MUST winds up only having a purpose if you're generating nulls and not passing them anywhere.  But the only place I can think of that arising would be like an assert:</p>
<pre><code>str: "abc"
append str "de"
must find str "cd"
</code></pre>
<p>I'd rather read that as <strong>assert [find str "cd"]</strong>... particularly because assert is invisible.</p>
<h2>
<a name="long-story-short-im-killing-must-1" class="anchor" href="https://forum.rebol.info#long-story-short-im-killing-must-1"></a>Long Story Short: I'm Killing MUST</h2>
<p>I certainly wouldn't add it today.  That's a solid argument for deleting it.</p>
<p>It seems to me <strong>non null</strong> and <strong>non void</strong> are clearer for the few cases this comes up!</p> ]]></description>
        <link>https://forum.rebol.info/t/function-that-errors-on-null-but-passes-thru-everything-else/1250#post_12</link>
        <pubDate>Mon, 26 Jun 2023 02:34:49 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6633</guid>
      </item>
      <item>
        <title>Using Invisibles To Opt Out of Functions In a Chain</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="gchiu" data-post="1" data-topic="2036">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/gchiu/40/22_2.png" class="avatar"> gchiu:</div>
<blockquote>
<p>One idea for using invisibles is to chain functions where you make some functions disappear from the chain if they're not needed.</p>
</blockquote>
</aside>
<p>This is a creative idea... and I think this sort of creativity is what makes the language fun... having so many different ways to attack problems!</p>
<p>But in this particular case, you could actually use CHAIN to build the composite function, and it might be more obvious:</p>
<pre><code>imagemagick: func [
    data 
    /monochrome
    /sharpen
    /blur
    /pixelise
][
     ... code ..
    return run chain reduce [
        if sharpen [:sharpenf]
        if blur [:blurf]
        if pixelize [:pixelf]
    ] data
]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/using-invisibles-to-opt-out-of-functions-in-a-chain/2036#post_2</link>
        <pubDate>Sun, 25 Jun 2023 23:56:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6627</guid>
      </item>
      <item>
        <title>What should do of empty block (`DO []`) do?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I've done some pruning of dead-ends and tangents in this thread, to try and hone in on the real issues.  But this is the central point:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="17" data-topic="1426">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One blind spot in the above discussion is that it assumes NULL is the only variable state that cannot be put in blocks.</p>
<p>The attempts to make suggestions other than NULL for <strong>do []</strong> give "ornery" values like <strong>~void~</strong>...but in a world that still allows those values to be put in blocks. <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p>But with isotopes, there's a whole spectrum of states that are legal in variables but not blocks. We can very simply say that in constructs like DELIMIT or COMPOSE or REDUCE:</p>
<p><strong>NULLs error, VOIDs vaporize, and the MAYBE function lets you convert nulls to voids!</strong></p>
</blockquote>
</aside>
<p>In the intervening two years...things have evolved to where VOID is not an isotopic word, but a distinct non-valued state (which has its own quoted and isotopic forms).     And it's not just the product of <strong>do []</strong> but also any failed conditional.</p>
<pre><code>&gt;&gt; do []  ; since void has no representation, console prints nothing

&gt;&gt; if false [&lt;a&gt;]

&gt;&gt; if true [&lt;a&gt;]
== &lt;a&gt;
</code></pre>
<p>There's a lot of satisfying interplay, in terms of how isotopic voids are used to represent unset variables...and quoted and quasi voids are the <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/3">single-character intents of <strong><code>'</code></strong> and <strong><code>~</code></strong></a>.  Singing the praises of the details would be redundant on this old thread, but I hope I've pared it down to where one can grasp the thought process that led to the current abilities.</p>
<h2>
<a name="at-this-point-im-sure-about-do-returning-void-1" class="anchor" href="https://forum.rebol.info#at-this-point-im-sure-about-do-returning-void-1"></a>At This Point I'm Sure About <code>(do [])</code> Returning VOID</h2>
<h2>
<a name="however-2" class="anchor" href="https://forum.rebol.info#however-2"></a>...However...</h2>
<h2>
<a name="still-not-sure-if-reduce-if-false-x-should-vaporize-3" class="anchor" href="https://forum.rebol.info#still-not-sure-if-reduce-if-false-x-should-vaporize-3"></a>Still Not Sure If <code>(reduce [if false [&lt;x&gt;]])</code> Should Vaporize</h2>
<p>There's evidence suggesting that some of the motivating cases for Red's religiosity no longer apply to Ren-C.  e.g. <strong>set [a b c] reduce [expr1 expr2 expr3]</strong> is not how we operate... <a href="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634/10">SET-BLOCK! and parameter packs are much better and account for voids</a></p>
<p>But I don't know about whether the default should be <strong>reduce/exact</strong> vs. <strong>reduce/vanishable</strong>.  The feedback here suggests a lack of concern about the lax behavior, and the void vs. null distinction certainly puts a lot more control in the hands of the user.</p>
<p>Just wanted to come back and paint a picture of how far this has come!</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426#post_19</link>
        <pubDate>Sat, 24 Jun 2023 05:21:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6624</guid>
      </item>
      <item>
        <title>Invisibility Reviewed Through Modern Eyes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>The first idea of making constructs that would "vanish completely" leveraged a special kind of enfix function, that would receive the entire evaluated value of the left hand side:</p>
<pre><code> elide: enfix func [
     left [&lt;evaluate-all&gt; any-value!]
     right
 ][
     print ["ELIDE got left as" mold left]
     return left
 ]

 &gt;&gt; 1 + 2 + 3 comment [magic!]
 hi
 ELIDE got left as 6
 == 6  ; wow!
</code></pre>
<p>This was a workaround for the (seeming?) fundamental fact that you can't have such a thing as "invisible variables" or "invisible values".  <em>Certain functions just faked invisibility by repeating the previous value in the evaluator chain.</em></p>
<p>The possibilities seemed endless.  For instance, imagine something like this:</p>
<pre><code>case [
   conditionA [...code...]
   elide print "conditionA didn't succeed but running this"
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>To do that in Rebol2 or Red would be incredibly awkward.  e.g. using a condition that runs code but evaluates to false, and then a throwaway block for the never-executed branch:</p>
<pre><code>case [
   conditionA [...code...]
   (
       print "conditionA didn't succeed but running this"
       false
   ) [&lt;unreachable&gt;]
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>Similar awkwardness would arise in things like ANY and ALL, where you'd have to switch from using true and false based on which you were using...</p>
<pre><code>any [conditionA (print "vanish" false) conditionB]
all [conditionA (print "vanish" true) conditionB]
</code></pre>
<p>Beyond being awkward, it simply can't work if what you want to vanish is the last expression.  But ELIDE handled all these cases:</p>
<pre><code>any [conditionA elide print "vanish" conditionB]
all [conditionA elide print "vanish" conditionB]
any [conditionA conditionB elide print "vanish"]
all [conditionA conditionB elide print "vanish"]
</code></pre>
<h2>
<a name="it-was-a-neat-trickbut-problems-emerged-1" class="anchor" href="https://forum.rebol.info#it-was-a-neat-trickbut-problems-emerged-1"></a>It Was A Neat Trick...But Problems Emerged</h2>
<p>The trick of invisibility requiring a function to receive its left hand side meant a GROUP! or COMMA! would break these constructs, as there was no access to a previous value:</p>
<pre><code> &gt;&gt; 1 + 2 + 3 (elide print "hi")
 hi
 ELIDE got left as null
 == ~null~  ; not 6, d'oh!

 &gt;&gt; 1 + 2 + 3, elide print "hi"
 hi
 ELIDE got left as null
 == ~null~
</code></pre>
<p>Plus being enfix forced the invisible functions to execute in the same step as whatever came before them, causing unsuspected results:</p>
<pre><code>&gt;&gt; case [
        1 = 1 [print "branch"]
        elide print "reached here first :-("
        1 = 2 [fail "Unreachable"]
    ]
ELIDE got left as [print "branch"]
reached here first :-(
branch
</code></pre>
<p>There we see that when the evaluator visited the <strong>[print "branch"]</strong> block in the CASE it had to greedily run the ELIDE, which evaluates its argument and then yielded the code block as its result.  CASE ran that code after the elide...out of order from what was desired.</p>
<p>Issues seemed to keep compounding.  These invisible functions couldn't be reliably used with MAKE FRAME!, and people trying to simulate the evaluator's logic found it hard to detect and wrap them.  That led to major issues with UPARSE trying to implement combinators that acted like ELIDE.</p>
<p>So the enfix mechanism wasn't going to cut it.  But it was too late: having been able to try out and develop all kinds of invisible constructs convinced me of their value.  I had to try another way...</p>
<h2>
<a name="formalizing-a-void-state-and-corresponding-meta-state-2" class="anchor" href="https://forum.rebol.info#formalizing-a-void-state-and-corresponding-meta-state-2"></a>Formalizing a VOID State And Corresponding Meta State</h2>
<p>The seeming impossibility of having a "void value" was addressed with the idea of folding special treatment in the evaluator of voids, but offering a meta domain in which they could be handled safely.</p>
<pre><code>&gt;&gt; var: void
; void

&gt;&gt; 1 + 2 var
== 3

&gt;&gt; var: meta void
== '

&gt;&gt; 1 + 2 var
== '

&gt;&gt; 1 + 2 unmeta var
== 3
</code></pre>
<p>The concept of being able to pipe around and process "slippery" values in this meta domain (including unset states and other isotopes) wound up being very successful.</p>
<p>Evaluators like DO and UPARSE would specially preserve the last evaluative value in order to give the illusion of invisibility when voids were seen on the next step.  Other constructs got to make a choice as to whether they wanted to embrace voids as part of the mechanic, or think of them as errors:</p>
<pre><code>&gt;&gt; comment "comments returned void"  ; Note: console doesn't show void results

&gt;&gt; if comment "hi" [print "not tolerated in conditions"]
** Error: IF doesn't accept void as its condition argument

&gt;&gt; all [comment "begin" 1 + 2 10 + 20 comment "end"]
== 30

&gt;&gt; any [comment "begin" 1 + 2 10 + 20 comment "end"]
== 3
</code></pre>
<p>e.g. for the above to work, ALL has to hang on to the last evaluated result as it goes...in case the next evaluated result is a comment.  This allows the 30 to fall out.</p>
<h2>
<a name="a-flexible-approach-but-here-be-dragons-3" class="anchor" href="https://forum.rebol.info#a-flexible-approach-but-here-be-dragons-3"></a>A Flexible Approach... But... Here Be Dragons</h2>
<p>Something that concerned me early on was that what had started as a narrow ability of just a few functions (like COMMENT and ELIDE) was becoming a case where generalized execution could possibly return voids, leading to unexpected results.</p>
<pre><code>&gt;&gt; code: [comment "some arbitary code block"]

; ... then much later ...

&gt;&gt; result: (mode: &lt;reading&gt; do code)
== &lt;reading&gt;

&gt;&gt; result
== &lt;reading&gt;  ; oops
</code></pre>
<p>Increasing dependence on void as a "vanishing" alternative to the noisier null also raised the demand for void variables, with them becoming slippery to generate:</p>
<pre><code>&gt;&gt; parse [x] [rule: ['x (void) | 'y ([some "y"])]
== x

&gt;&gt; rule
== x  ; wanted void
</code></pre>
<p>VOID was becoming a victim of its own popularity.  When it was rare coming from only a few constructs like ELIDE and COMMENT it was rare to see problems.  Yet when every IF/CASE/SWITCH statement that didn't run a branch started returning voids, things got hairier.</p>
<p>There were also snags when making void isn't a parameter...but a product of something like the body on a MAP-EACH. At first it looks fine:</p>
<pre><code>map-each item [1 &lt;one&gt; 2 &lt;two&gt; 3 &lt;three&gt;] [
    maybe match tag! item  ; leaving it as NULL would be an error
]
== [&lt;one&gt; &lt;two&gt; &lt;three&gt;]
</code></pre>
<p>But what if you had something else in the loop body?</p>
<pre><code>map-each item [1 &lt;one&gt; 2 &lt;two&gt; 3 &lt;three&gt;] [
    append log spaced ["Logging:" item]
    maybe match tag! item  ; remember, void vanishes
]
== ["Logging: 1" "Logging: &lt;one&gt;" "Logging..." ...]
</code></pre>
<h2>
<a name="once-again-isotopes-to-the-rescue-4" class="anchor" href="https://forum.rebol.info#once-again-isotopes-to-the-rescue-4"></a>Once Again: Isotopes To The Rescue</h2>
<p>As part of <a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">solving the problem of multi-returns</a>, parameter pack isotopes were introduced.  These would "decay" to their first item, unless something handled the isotope specially.</p>
<pre><code>&gt;&gt; pack [1 + 2 10 + 20]
== ~['3 '30]~  ; isotope

&gt;&gt; a: pack [1 + 2 10 + 20]
== 3

 &gt;&gt; [a b]: pack [1 + 2 10 + 20]  ; SET-BLOCK! handles PACK! isotopes specially
 == 3

 &gt;&gt; a
 == 3

 &gt;&gt; b
 == 30
</code></pre>
<p>Unpacking the packs raised a question: <em><strong>What if the PACK! is Empty</strong></em>?  As far as variable assignment goes, it seems it can't do anything.  So erroring made the most sense:</p>
<pre><code>&gt;&gt; pack []
== ~[]~  ; isotope

&gt;&gt; a: pack []
** Error: No values available in empty parameter pack
</code></pre>
<p>Then there was a breakthrough of the next thought: <em><strong>Empty isotopic packs could be used as the vanishing intent!!</strong></em></p>
<pre><code>&gt;&gt; 1 + 2, pack []
== 3
</code></pre>
<p>This would mean VOID could be less "slippery" in the evaluator, being treated normally most of the time and falling out of expressions vs. vaporizing:</p>
<pre><code>&gt;&gt; 1 + 2, if false [&lt;a&gt;]  ; overall result is void (no console output)

&gt;&gt; 1 + 2, if true [&lt;a&gt;]
== &lt;a&gt;
</code></pre>
<h2>
<a name="empty-isotopic-packs-were-then-given-a-name-nihil-5" class="anchor" href="https://forum.rebol.info#empty-isotopic-packs-were-then-given-a-name-nihil-5"></a>Empty isotopic packs were then given a name: <strong>"NIHIL"</strong>
</h2>
<p>The terminology has varied over time.  I accomplished the distinction another way before isotopic packs, and at that time I called the distinction "impure invisibility" (non-vaporizing) vs. "pure invisibility" (vaporizing).</p>
<p>But I think the "impure" vs. "pure" terms just caused confusion.  This is where things stand today, and it seems comfortable:</p>
<pre><code>&gt;&gt; 1 + 2 void

&gt;&gt; 1 + 2 nihil
== 3

&gt;&gt; 1 + 2 null
== ~null~   ; isotope
</code></pre>
<h2>
<a name="i-think-this-is-a-comfortable-balance-6" class="anchor" href="https://forum.rebol.info#i-think-this-is-a-comfortable-balance-6"></a>I Think This Is A Comfortable Balance</h2>
<p>No matter what way you slice it, an expression that can truly vaporize is something that can make you uneasy.  Look at this CASE statement and imagine if FOO or BAR could vanish:</p>
<pre><code> case [
     foo [print "hi"]
     bar [print "bye"]
 ]
</code></pre>
<p>Sure... we can lament that if FOO comes back as NIHIL, it will wreck the geometry of the CASE completely.  After dropping the FOO it will treat [print "hi"] as a condition and use BAR as a code branch.</p>
<p><em>But if FOO is a function that takes a BLOCK! as a parameter, it will also wreck the geometry of the CASE completely!</em>  This is just the cost of doing business in the Rebol paradigm.</p>
<p>This modern model with NIHIL being an unstable isotope brings us back to where you can only get vanishing function calls--not vanishing variables.  FOO can be a variable holding VOID, but there's no risk of that wrecking the CASE statement...because CASE is not one of the constructs that willfully erases VOID.  Neither does the foundational evaluator (and nor does UPARSE)</p>
<p>So long as usage of NIHIL is judicious, I think this is about as terra firma as the rest of Rebol is.  And UPARSE stands as a great example of a system that has been able to build on meta-representation in order to be able to pipe around vanishing states using "special gloves" and build upon it to make new invisible behaviors...</p>
<pre><code>&gt;&gt; parse "aaabbb" [collect some keep "a", elide some "b"]
== ["a" "a" "a"]
</code></pre>
<p>It's rather satisfying.</p> ]]></description>
        <link>https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034#post_1</link>
        <pubDate>Fri, 23 Jun 2023 17:06:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6622</guid>
      </item>
      <item>
        <title>The Handling of NULL and VOID in UPARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h2>
<a name="okay-voided-variables-should-be-no-ops-in-uparse-1" class="anchor" href="https://forum.rebol.info#okay-voided-variables-should-be-no-ops-in-uparse-1"></a>Okay, voided variables should be no-ops in UPARSE</h2>
<p>This is consistent with how quoted voids work:</p>
<pre><code>&gt;&gt; parse [a b] ['a ' 'b]
== b
</code></pre>
<p>Or how voided expressions work in GET-GROUP! substitution:</p>
<pre><code>&gt;&gt; parse [a b] ['a 'b :(if false [[some 'c]])]
== b

&gt;&gt; parse [a b c c c] ['a 'b :(if true [[some 'c]])]
== c
</code></pre>
<p><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/4">And with more liberal policies for void variables via word access in the main evaluator</a>, extending this to WORD! references seems consistent:</p>
<pre><code>&gt;&gt; c-rule: if false [[some 'c]]

&gt;&gt; parse [a b] ['a 'b c-rule]
== b

&gt;&gt; c-rule: if true [[some 'c]]

&gt;&gt; parse [a b c c c] ['a 'b c-rule]
== c
</code></pre>
<h2>
<a name="a-quirky-maybe-combinator-is-probably-bad-news-2" class="anchor" href="https://forum.rebol.info#a-quirky-maybe-combinator-is-probably-bad-news-2"></a>A Quirky MAYBE Combinator Is Probably Bad News</h2>
<p>Not everything in the evaluator universe is going to have a PARSE parallel.  If you have a null rule, I guess you may just have to use a GET-GROUP! and call the evaluator's MAYBE.</p>
<pre><code>&gt;&gt; c-rule: null

&gt;&gt; parse [a b] ['a 'b :(maybe c-rule)]
== b
</code></pre>
<p>This will keep you from erroring on the null by turning the null into a void.</p>
<p>UPARSE has richer mechanisms to help the higher-order rules, to more intentionally express the R3-Alpha progress rule...which you could use:</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)))" [
        opt some further :(maybe prefix)
        some "a"
        opt some further :(maybe suffix)
     ]
== ")"
</code></pre>
<p>If you don't want PREFIX to be "ornery" when it's used in PARSE, then initialize it to void instead of null and this cleans up a bit:</p>
<pre><code>&gt;&gt; prefix: void, suffix: ")"

&gt;&gt; parse "aaa)))" [
        opt some further prefix
        some "a"
        opt some further suffix
     ]
== ")"
</code></pre>
<p>There are a lot of tools at one's disposal, and I don't think we need anything crazier than this.  I'm content enough with it, I think!</p> ]]></description>
        <link>https://forum.rebol.info/t/the-handling-of-null-and-void-in-uparse/2023#post_2</link>
        <pubDate>Fri, 23 Jun 2023 01:00:54 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6621</guid>
      </item>
      <item>
        <title>Shades of Distinction In Non-Valued Intents</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Void variables were deemed to be something it would be undesirable to have be "too friendly". So they were slated to be mean on WORD!-access...</p>
<pre><code>[2]  &gt;&gt; void-value
     ** Error: VOID-VALUE is void (use GET-WORD! or GET/ANY)

     &gt;&gt; append [a b] :void-value
     == [a b]
</code></pre>
</blockquote>
</aside>
<p><strong>So... I'm questioning the necessity of making accesses of void variables require a GET-WORD!.</strong></p>
<p>There's a certain amount of historical bias against "liberal voids" that dates back to the old-timey havoc that voids could wreak on code structure.  They'd just skip the evaluator ahead:</p>
<pre><code>old-ren-c&gt;&gt; append [a b c] void 'd
== [a b c d]
</code></pre>
<p>Those were the days when it had no way to represent in an object whatsoever.  A bit later, a voided variable meant an <em>unset</em> variable...so it couldn't be too easy to read them.  <a href="https://forum.rebol.info/t/how-became-quoted-void-and-became-quasi-void/1915/5">That was supplanted with the idea that unset variables are actually <em>void isotopes</em>,</a> completely distinct.</p>
<p>Today voids are meta-representible with a lone apostrophe:</p>
<pre><code>&gt;&gt; make object! [
    a: if false [10]
    b: void
    c: '
 ]
 == make object! [
     a: '
     b: '
     c: '
 ]
</code></pre>
<p>The main point of lingering concern is that void variables might be "too easy to make", and if you assign void to a variable you might wind up opting out of things you didn't mean to opt out of.</p>
<pre><code>var: case [
    conditionA [...]
    conditionB [...]
]  ; imagine none of the cases run

append [a b c] var  ; is this too easy to be a no-op?
</code></pre>
<p>But is that fear really justified, when you could have written:</p>
<pre><code>append [a b c] case [
    conditionA [...]
    conditionB [...]
]  ; again, imagine none of the cases run, no-op by design
</code></pre>
<p><a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880">The whole idea of void-in-null-out</a> is designed to limit the issues of error locality that historical "none propagation" had.  The odds of protecting someone are probably lower than interfering with legitimate void intent.</p>
<p>Some of the most "fearsome" motivating cases are no longer applicable.  For instance, REDUCE was historically used to assign variables itemwise...and a vanishing expression could wreak havoc:</p>
<pre><code> set [a b c] reduce [expr1 expr2 expr3]
</code></pre>
<p>Modern ideas like PACK don't vaporize voids... they preserve them in a meta state:</p>
<pre><code> &gt;&gt; meta pack [1 void 3]
 == ~['1 ' '3]~
</code></pre>
<p><a href="https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634/10">And the SET-BLOCK! and SET-WORD! unpacking logic is much more clever!</a></p>
<p>By and large people lobbied for the convenience of REDUCE being able to splice and evaporate expressions.  Cases where an exact number of expressions with no splices or evaporations are needed are less common, and could be handled with REDUCE/EXACT or other routine.</p>
<p><strong>And if UPARSE became void-friendly it would help with the issue of <a href="https://forum.rebol.info/t/the-handling-of-null-in-uparse/2023">dealing with NULL (and void) in UPARSE</a>.</strong>  Null rules would error, void rules would bypass without advancing the input.</p>
<p>While you can't skip voids as arguments, interstitial voids do still cause some oddness in the evaluator:</p>
<pre><code>&gt;&gt; x: if 1 &gt; 2 [print "not run"]

&gt;&gt; 10 + 20 x
== 30
</code></pre>
<p>But this oddness is really just kind of an epicycle of the rest of the oddness of what voids do inside COMPOSE or REDUCE or anything else.  Are these examples any scarier than one another?</p>
<pre><code> &gt;&gt; do [10 + 20 x]
 == 30

 &gt;&gt; reduce [1 + 2 x 10 + 20]
 == [3 30]
</code></pre>
<p><strong>Considered in total, I think it's time to be more accepting of the fluidity and power of void variables.</strong>  If you don't like them, don't make them.</p>
<p><em>(This might mean making constructs like CASE and SWITCH yield null when no branches are taken?  Or that could be a choice people make in their own base library.. to tweak voiding control structures to be nulling when no branches taken... so you'd have to say <strong>maybe case [...]</strong> to get voiding behavior)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604#post_4</link>
        <pubDate>Thu, 22 Jun 2023 23:51:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6620</guid>
      </item>
      <item>
        <title>Working With Truthy BLANK! (in SPLIT-PATH Tests)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>As a further note, <a href="https://github.com/red/red/issues/5024">I borrowed the tests for SPLIT-PATH from a Red issue</a>.</p>
<p><em>And I want to say how bad historical Rebol/Red SPLIT-PATH seems to be!</em></p>
<p>Instead of giving you a directory and an optional file, you get the last directory fragment if there is no file part:</p>
<pre><code>rebol2&gt;&gt; split-path %/c/rebol/tools/test/test.r
== [%/c/rebol/tools/test/ %test.r]  ; seems reasonable...

rebol2&gt;&gt; split-path %/c/rebol/tools/test/
== [%/c/rebol/tools/ %test/]  ; what?

rebol2&gt;&gt; split-path http://
== [http:/ %/]  ; seriously?
</code></pre>
<p><a href="https://github.com/red/red/issues/5024#issuecomment-1006032330">hiiamboris sums up my opinion</a>, which is that you should never get a directory back for the file part.</p>
<p>So that is the Ren-C behavior:</p>
<pre><code>&gt;&gt; [file dir]: split-path %/c/rebol/tools/test/
== ~null~  ; isotope

&gt;&gt; file
== ~null~  ; isotope

&gt;&gt; dir
== %/c/rebol/tools/test/
</code></pre>
<p>It uses multiple return values instead of returning a block.  So there had to be a decision about which would be the primary and secondary results.  It's a tough call, but I felt like splitting out the filename as the first result was probably the better option.  You can of course use "circling" to get the directory instead without having to name a variable:</p>
<pre><code>&gt;&gt; [_ @]: split-path %/c/rebol/tools/test/
== %/c/rebol/tools/test/
</code></pre>
<p>There was some debate about whether a null (none) signifier was better than coming back with an empty file like <strong>%""</strong> to help with joining the parts back together.  Historical #[none] doesn't have the voidability through MAYBE and just tends to create garbage.  Oldes complains about having to remember to write the likes of <strong>any [file %""]</strong> to work around the problems:</p>
<pre><code>rebol2&gt;&gt; join %/c/rebol/tools/test/ none
== %/c/rebol/tools/test/none  ; d'oh
</code></pre>
<p>But Ren-C has what I believe is just the right mix of caution on this... giving you a null that can be tested for truthiness, as well as alerting you to the absence if you try to use it...all while being able to easily MAYBE it into a void that can systemically act like emptiness:</p>
<pre><code>&gt;&gt; [file dir]: split-path %/c/rebol/tools/test/

&gt;&gt; combined: join dir file
** Script Error: Invalid use of ~null~ isotope

&gt;&gt; combined: join dir maybe file
== %/c/rebol/tools/test/

&gt;&gt; file: join file %".temp"
** Error: JOIN does not allow null for its BASE argument
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007#post_2</link>
        <pubDate>Thu, 22 Jun 2023 20:29:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6619</guid>
      </item>
      <item>
        <title>A Lot To UNPACK: (Replacing the SET of REDUCE BLOCK! Idiom)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1634">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>We can prototype the behavior by making PACK quote a SET-WORD! or SET-BLOCK! on its left, and combine that with the unpacking.</p>
</blockquote>
</aside>
<p>Circa 2023 we now have a PACK! representation simply as isotopic blocks, with the "unpacking" done by the internal implementation of SET-BLOCK!</p>
<pre><code>&gt;&gt; pack [1 + 2 10 + 20]
; first in pack of length 2
== 3

&gt;&gt; a: pack [1 + 2 10 + 20]
== 3

&gt;&gt; [b c]: pack [1 + 2 10 + 20]
== 3

&gt;&gt; b
== 3

&gt;&gt; c
== 30
</code></pre>
<p>It's much more freeform, and can be META'd and UNMETA'd into a quasiform...allowing you to put as much distance between the generation of the pack and the unpacking done by SET-WORD! or SET-BLOCK!</p>
<pre><code>&gt;&gt; [b c]: (print "No tight coupling of PACK with SET-BLOCK!", pack [1 + 2 10 + 20])
== 3

&gt;&gt; c
== 30

&gt;&gt; meta pack [1 + 2 10 + 20]
== ~['3 '30]~
</code></pre>
<p><strong>Hence the PACK! representation now underlies the entirety of multi-return mechanics.</strong>  <a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/12">This allows wrapping and composability options for multi-return that were not possible with the early implementations.</a></p>
<p>Due to its generality you can do interesting things that don't involve making a multi-return function at all, such as having some branches of a CASE return packs while others don't:  <em>(The /B indicates optionality, and you're okay with no value in that slot to unpack.)</em></p>
<pre><code>[a /b]: case [
    conditionA [1]
    conditionB [pack [2 3]]
    conditionC [4]
]
</code></pre>
<p>Neat though all of this is, questions are raised about <a href="https://forum.rebol.info/t/unstable-isotope-conundrums/2033">which constructs must--by necessity--decay packs to their first value</a>.  So there are still dragons to be slain here.</p> ]]></description>
        <link>https://forum.rebol.info/t/a-lot-to-unpack-replacing-the-set-of-reduce-block-idiom/1634#post_10</link>
        <pubDate>Thu, 22 Jun 2023 17:16:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6618</guid>
      </item>
      <item>
        <title>Unstable Isotope Conundrums</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>An unstable isotope is one that cannot be stored in a variable.  The clearest example of one of these is a PACK!.</p>
<p>Quick refresher: because functions receive their arguments in variables, you clearly cannot pass an unstable isotope to a function.  You instead use ^META parameters and get the quasiform.</p>
<pre><code>&gt;&gt; pack [3 4]
; first in pack of length 2
== 3

&gt;&gt; meta pack [3 4]
== ~['3 '4]~

&gt;&gt; [a b]: pack [3 4]
== 3

&gt;&gt; a
== 3

&gt;&gt; b
== 4
</code></pre>
<p><strong>But what about non-variable situations... like expressions that are being tested for being truthy or falsey?</strong></p>
<p>Right now, tests for truthiness throw the unstable state away.  For instance, ALL:</p>
<pre><code>&gt;&gt; all [1 2 pack [3 4]]
== 3
</code></pre>
<p>The PACK! formed by the PACK function is decayed to just 3 by the ALL, and then the 3 was tested as truthy.  If you wanted to get past this, you would have to meta-and-then-unmeta the pack:</p>
<pre><code>&gt;&gt; unmeta all [1 2 meta pack [3 4]]
; first in pack of length 2
== 3
</code></pre>
<p>But note that here, it's testing the meta-pack ~['3 '4]~ for truthiness, not the 3.  So if false were in the meta pack, it would still wind up truthy.</p>
<pre><code>&gt;&gt; all [1 2 meta pack [false false]]
== ~[~false~ ~false~]~
</code></pre>
<p>Whereas a regular pack would be decayed before the test:</p>
<pre><code>&gt;&gt; all [1 2 pack [false false]]
== ~null~  ; isotope
</code></pre>
<p>You might ask <em>"Why not just say all PACK!s are truthy, so you don't have to META and UNMETA them?"</em></p>
<p>Well just think about it: when you use a multi-returning function you may only be interested in the primary result...and even only be slightly aware that more results are available.  For instance: not everyone knows that today's FIND returns an additional output if you want it (it's the end of a match).</p>
<p><strong>Saying that packs must decay to test them for truthiness doesn't seem too baffling, but what about loop constructs that don't test for truthiness?</strong></p>
<p>Is this harmless?</p>
<pre><code>&gt;&gt; flag: true

&gt;&gt; meta while [flag] [flag: false, pack [3 4]]
== ~['3 '4]~
</code></pre>
<p>It seems all right, although this becomes a property that <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">has to be preserved by compositions like FOR-BOTH</a>. (As it so happens, the composition does work.)</p>
<p>But what about UNTIL?  In until the loop condition and the body are the same, and in order to exit the loop the body must be truthy...so you can't get a pack out:</p>
<pre><code>&gt;&gt; until [pack [3 4]]
== 3
</code></pre>
<p>And also... what about situations like CONTINUE/WITH or STOP/WITH.  If the /WITH parameter is a plain refinement and not a ^META one, then the information will be lost:</p>
<pre><code>&gt;&gt; cycle [stop/with pack [3 4]]
== 3
</code></pre>
<p>If CONTINUE and STOP were to follow in the footsteps of RETURN, they would need an added refinement like RETURN/FORWARD which distinguishes the case where you do want the meta parameter from where you don't (which is the current solution, vs. something like marking ^RETURN: as always being meta on the function definition).</p>
<h2>
<a name="maybe-test-decayd-value-preserve-pack-1" class="anchor" href="https://forum.rebol.info#maybe-test-decayd-value-preserve-pack-1"></a>Maybe Test DECAY'd Value, Preserve PACK! ?</h2>
<p>Constructs like ALL or UNTIL might decay only for the purposes of the truthiness test, but preserve the original PACK! for the actual return.</p>
<p>For instance could you do this?</p>
<pre><code>&gt;&gt; [a /b]: all [
       1 = 1
       2 = 2
       pack [3 4]
   ]
== 3

&gt;&gt; a
== 3

&gt;&gt; b
== 4
</code></pre>
<p>I've pointed out that PACKs with falsey items have to break the chain:</p>
<pre><code>&gt;&gt; [a /b]: all [
       1 = 1
       2 = 2
       pack [false 4]
   ]
== ~null~  ; isotope

&gt;&gt; a
== ~null~  ; isotope

&gt;&gt; b
== ~null~  ; isotope
</code></pre>
<p>If you didn't intend that you'd have to META the pack inside the ALL...and UNMETA outside as discussed (in this case with UNMETA* which passes through null as-is vs. erroring if the leading conditions resulted in a null outcome)</p>
<pre><code>&gt;&gt; [a /b]: unmeta* all [
       1 = 1
       2 = 2
       meta pack [false 4]
   ]
== ~false~  ; isotope

&gt;&gt; a
== ~false~  ; isotope

&gt;&gt; b
== 4
</code></pre>
<p>Taking this preservation to extremes would complicate a lot of places in the code.  For instance: IF tolerates function branches, and will pass on the condition to the branch:</p>
<pre><code>&gt;&gt; var: [a b c]

&gt;&gt; if var (func [x] [print ["var was" mold x]])
var was [a b c]
</code></pre>
<p>But what if you want to do this with a pack, and have the option of receiving it in that function?</p>
<pre><code> &gt;&gt; if pack [1 2] (func [x] [print ["var was" mold x]])
 var was 1

 &gt;&gt; if pack [1 2] (func [^x] [print ["meta var was" mold x]])
 meta var was ~[1 2]~

 &gt;&gt; if pack [false 2] (func [^x] [print ["meta var was" mold x]])
 ; void
</code></pre>
<p>Interesting though that may look, it changes IF to where it has to take its condition as a ^META parameter, otherwise it decays and can't be passed on.</p>
<p>I can't tell if this is a high-enough leverage piece of functionality to be worth complicating IF or not.</p>
<h2>
<a name="for-now-tempting-to-say-loop-protocol-cant-return-pack-2" class="anchor" href="https://forum.rebol.info#for-now-tempting-to-say-loop-protocol-cant-return-pack-2"></a>For Now, Tempting To Say "Loop Protocol" Can't Return PACK!</h2>
<p>It's not necessarily <em>hard</em> to make /WITH a ^META-refinement on CONTINUE and STOP... at least in terms of allowing PACK!.  <strong>continue/with raise error</strong> would cause some uncomfortable results.</p>
<p>Again, note there are ways to work around not processing unstable pack! isotopes by the /WITH itself, by META-ing on the inside and UNMETA-ing on the outside:</p>
<pre><code> &gt;&gt; cycle [stop/with meta pack [3 4]]
 == ~[3 4]~

 &gt;&gt; [a b]: unmeta cycle [stop/with meta pack [3 4]]
 == 3

 &gt;&gt; a
 == 3

 &gt;&gt; b
 == 4
</code></pre>
<p>Every time I see this, I do kind of wish up and down arrows were on our keyboards:</p>
<pre><code>  [a b]:  cycle [stop/with  pack [3 4]]
</code></pre>
<p>Caret-Meta only gets you half of this:</p>
<pre><code> [a b]: unmeta cycle [stop/with ^ pack [3 4]]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/unstable-isotope-conundrums/2033#post_1</link>
        <pubDate>Thu, 22 Jun 2023 17:09:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6617</guid>
      </item>
      <item>
        <title>Wrapping And Forwarding Multi-Returns</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1926">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><em>I'm concerned this could lead to counter-intuitive situations</em>, where this would be a multi-return:</p>
<pre><code> return some-function
</code></pre>
<p>...whereas this seemingly-innocent transformation would turn the code into a mono-return:</p>
<pre><code>x: some-function
return x
</code></pre>
<p>It feels like you'd want <em>some</em> kind of signal before having these act differently.</p>
</blockquote>
</aside>
<p>What I've tried for a while to address this was to add a /FORWARD refinement to RETURN.  If you don't use the refinement then it decays to just one value.  (This decay also means raised errors decay to trigger actual runtime failures, etc.)</p>
<p>But this adds a creeping complexity, where the concern starts showing up other places.  If you're doing a CATCH with a THROW, do you need THROW/FORWARD?</p>
<p>By contrast, the approach of assuming you want forwarding in such constructs lets you use a common DECAY primitive without contaminating them all with extra refinements.  In the scheme of things, I'm not sure that an accidental leakage of multi-return information is obviously a worse default than the accidental loss of multi-return function.</p>
<p>There may be ways that a type signature can help here: if your RETURN: spec says you return an integer and you try to return a PACK!, it could automatically decay and type check the decayed form.  (Though this wouldn't apply to the likes of CATCH and THROW, so that should be kept in mind.)</p>
<p>As for the decay on assignment... <em>it may come down to making people comfortable with the idea that if you go through a non-meta assignment to a single variable you may lose information.</em>  You always have to read <strong>x: some-function</strong> as <strong>x: decay some-function</strong> and appreciate that potential for data loss.   If you don't want to lose data:</p>
<pre><code>x: meta some-function
return unmeta x
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/wrapping-and-forwarding-multi-returns/1926#post_4</link>
        <pubDate>Thu, 22 Jun 2023 15:42:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6616</guid>
      </item>
      <item>
        <title>Line Continuation and Arity Bugs: Thoughts?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1965">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I don't think people will use passing arguments to continue too often, but <strong><code>continue/with value</code></strong> isn't terrible</p>
</blockquote>
</aside>
<p>A design loophole of this is that nulls at refinement callsites (currently) represent refinement revocation.</p>
<p>e.g. if you are to say:</p>
<pre><code> &gt;&gt; count: null
 == ~null~  ; isotope

 &gt;&gt; append/dup [a b c] [d e] count
 == [a b c [d e]]
</code></pre>
<p>Then it's as if the /DUP weren't present at all.  That <em>seems</em> sensible enough...</p>
<p>...but it would imply that <strong><code>(continue/with null)</code></strong> is a synonym for <strong><code>(continue)</code></strong>.</p>
<p>Yet the /WITH is supposed to be a fancy way of saying "pretend I completed the loop body /WITH this value".  To pick one example: you're not allowed to have the body of a MAP-EACH end in null:</p>
<pre><code>&gt;&gt; map-each x [1] [null]
** Error: Cannot append ~null~ isotope to collected MAP-EACH block
</code></pre>
<p>In practice we want CONTINUE with no /WITH to act as if the loop ended in a void--not as if it ended in a null.</p>
<p>For that outcome in the world of today, that suggests not erroring when the /WITH is null:</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 1 [continue]
       if x = 2 [continue/with null]  ; must be same as plain continue? :-/
       if x = 3 [continue/with void]  ; seems more synonymous w/plain continue
   ]
== []
</code></pre>
<p>It's a bit unsatisfying to have that /WITH of a null not acting like if the loop body ended in null and erroring.</p>
<p><strong>This makes me wonder if refinements should implement some kind of rule that makes null and void synonymous... or coupled in a way reminiscent of void-in-null-out.</strong></p>
<p>Perhaps even at callsites, the null state would be illegal:</p>
<pre><code> &gt;&gt; count: null
 == ~null~  ; isotope

 &gt;&gt; append/dup [a b c] [d e] count
 ** Error: Refinements at callsite can't be null, use e.g. MAYBE to get void

 &gt;&gt; maybe count
 ; void

 &gt;&gt; append/dup [a b c] [d e] maybe count
 == [a b c [d e]]
</code></pre>
<p>What it would mean would be you'd remove refinements from the interface using voids and not nulls.  It's a decision kind of in line with how removing elements from MAP! is now done with voids and not nulls, which I called <a href="https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995/2">"a hassle, but probably a good hassle"</a>...helping to prevent accidents.</p>
<h2>
<a name="upshot-would-be-no-non-meta-void-refinements-1" class="anchor" href="https://forum.rebol.info#upshot-would-be-no-non-meta-void-refinements-1"></a>Upshot would be no (non-^META) void refinements</h2>
<p>I can't really predict all the weird edges here, but this does suggest refinements can't be received as void in the body of a function in conventional code.</p>
<p>It wouldn't be the end of the road for distinguishing a callsite null from a callsite void with a ^META parameter--though that sounds like a low priority.  (<a href="https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783/4">See ~end~ for a solution in that vein</a> which would probably work here.)</p>
<p>And as far as frame mechanics go, maybe it would pay to be lenient and allow ~null~ and void as interchangeable ways for getting a null refinement.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
<p>So refinement revocation is going to be under scrutiny for a while as I look into this.</p> ]]></description>
        <link>https://forum.rebol.info/t/line-continuation-and-arity-bugs-thoughts/1965#post_3</link>
        <pubDate>Thu, 22 Jun 2023 07:18:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6615</guid>
      </item>
      <item>
        <title>APPLY II: The Revenge!</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I observe Red has published an implementation of APPLY with some seeming similarities:</p>
<p><a href="https://www.red-lang.org/2023/06/dynamic-refinements-and-function.html" class="inline-onebox">Red Programming Language: Dynamic Refinements and Function Application</a></p>
<p>But there are significant mechanical and usability differences.</p>
<p>Red inherits complexity from the fact that they didn't merge refinements and their arguments together.  This keeps them tied to problems that arise from ordering, and keeping the enablement of a refinement in sync with its value(s).  <em>It's clear to me that "multi-arg-refinements" has proven to be not worth it in the design vs. having a single unified nullable value for each named argument</em>...and this is only one of the many places that bear that out.</p>
<p>They do offer an idea how to create something like a FRAME!... but it's a higher-level usermode concept instead of the lower-level basis for APPLY-like abstractions.  The post gives an implementation called <strong><code>make-apply-obj-proto</code></strong>:</p>
<pre><code>red&gt;&gt; o-fctm: make-apply-obj-proto/with 'find/case/tail/match [series: [a b c] value: 'a]
== make object! [
    series: [a b c]
    value: 'a
    part: false
    length: none
    only: false
    case: true
    same: fal...

red&gt;&gt; apply-object :find o-fctm
== [b c]
</code></pre>
<p>Ren-C bakes this idea in as the core of function application.  You can build a FRAME! for the function (note the tail of the match is a multi-return...you can get both the begin and end in a single call...so there's no /TAIL here):</p>
<pre><code>&gt;&gt; f: make frame! :find/case/match
== make frame! [
    series: ~
    pattern: ~
    part: ~
    skip: ~
    reverse: ~
    last: ~
]
</code></pre>
<p>Notice /CASE and /MATCH didn't take arguments, so they have been specialized out of the frame as they were already mentioned as being in use.</p>
<p>Then you can fill in the frame with required (and optional) values:</p>
<pre><code>&gt;&gt; f.series: [a b c]
== [a b c]

&gt;&gt; f.pattern: 'a
== a
</code></pre>
<p>And it remembers what function it is for, so you can DO it without getting it mixed up.  As a nice bonus, the multi-return gives you the head and the tail if you want it:</p>
<pre><code>&gt;&gt; [begin end]: do f
== [a b c]

&gt;&gt; begin
== [a b c]

&gt;&gt; end
== [b c]
</code></pre>
<p>They say of <strong><code>make-apply-obj-proto</code></strong>: <em>"But you may see that this is verbose and inefficient, making a whole object just for a call like this. And you'd be right. It's just an example.  You don't want to recreate objects like this, especially in a loop. But you don't have to. You can reuse the object and just change the important values in it."</em></p>
<p>This is the opposite philosophy to Ren-C.  These frames are the foundation of function invocation...and so they are always built.  The keylist of the object lives with the function definition and is pointed to by the frame, and so each instance only takes up the cells of the arguments.</p>
<p><em>(Note: If you wanted something directly comparable to <strong><code>make-apply-obj-proto</code></strong> it really could just be an option passed to APPLY which gave back the frame it builds without calling it.)</em></p>
<p>Anyhow... I'm glad they've undertaken this... because it brings us closer to assembling comparable examples.  It lays bare the fact that when I undertake "complexity" it is because failure to design the system to handle relevant cases pushes that complexity onto the user...</p> ]]></description>
        <link>https://forum.rebol.info/t/apply-ii-the-revenge/1834#post_8</link>
        <pubDate>Thu, 22 Jun 2023 00:10:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6614</guid>
      </item>
      <item>
        <title>Should END-able constructs all use ^META parameters?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1783">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<ul>
<li>I think you should be able to make any parameter endable</li>
<li>It's probably best if NULL is used to represent that across the board.</li>
<li>This doesn't create conflation in the case of quoted arguments (you can't quote a NULL because nulls can't exist in the input array or variadic feed)</li>
<li>There won't be conflation for typed normal parameters, like <strong><code>arg [word! integer! &lt;end&gt;]</code></strong>
</li>
<li>If the conflation bothers you then you are officially a fancy-pants client... use <strong><code>^arg</code></strong>
</li>
</ul>
</blockquote>
</aside>
<p>This was the right spirit, but <a href="https://forum.rebol.info/t/match-in-rust-vs-switch/1835/5">given some further thought</a> I am proposing to go ahead and reserve the isotopic word of <strong>~end~</strong> for this purpose (and in general, go ahead and probably reserve all isotopic words for system use)</p>
<p><strong>If your argument is endable and not ^META, it will be something like this.</strong></p>
<pre><code>&gt;&gt; foo
Congratulations, you got an ~end~ isotope

&gt;&gt; foo ~end~
** Error: ~end~ is not a legitimate callsite argument

&gt;&gt; f: make frame! :foo
== make frame! [value: ~]

&gt;&gt; f.value: ~end~
&gt;&gt; do f
Congratulations, you got an ~end~ isotope
</code></pre>
<p><strong>If your argument is ^META and not endable, you can get this</strong></p>
<pre><code>&gt;&gt; bar
** Error: bar.value is not endable

&gt;&gt; bar ~end~
Congratulations, you got an ~end~ quasiform

&gt;&gt; f: make frame! :bar
== make frame! [value: ~]

&gt;&gt; f.value: ~end~
&gt;&gt; do f
** Error: bar.value is not endable

&gt;&gt; f: make frame! :bar
== make frame! [value: ~]

&gt;&gt; f.value: '~end~
&gt;&gt; do f
Congratulations, you got an ~end~ quasiform
</code></pre>
<p><strong>And if you have an endable ^META parameter, it meshes both possibilities together:</strong></p>
<pre><code>&gt;&gt; baz
Congratulations, you got an ~end~ isotope

&gt;&gt; baz ~end~
Congratulations, you got an ~end~ quasiform

&gt;&gt; f: make frame! :baz
== make frame! [value: ~]

&gt;&gt; f.value: ~end~
&gt;&gt; do f
Congratulations, you got an ~end~ isotope

&gt;&gt; f: make frame! :baz
== make frame! [value: ~]

&gt;&gt; f.value: '~end~
&gt;&gt; do f
Congratulations, you got an ~end~ quasiform
</code></pre>
<p>...under these rules <em>there is no conflation</em>...</p>
<p><strong>Functions only receive ~end~ isotopes on <code>&lt;end&gt;</code>-able parameters, but those isotopes can come from deliberate assignment in frames as well as an end encountered at the callsite.</strong></p> ]]></description>
        <link>https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783#post_4</link>
        <pubDate>Wed, 21 Jun 2023 20:13:27 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6613</guid>
      </item>
      <item>
        <title>MATCH in Rust vs. SWITCH</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="4" data-topic="1835">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>&gt;&gt; make frame! make varargs! [match integer!]
== make frame! [
    test: &amp;(integer)
    value: ~end~
]
</code></pre>
<p>If you notice something interesting there, when you tried to MAKE FRAME! on an "incomplete sentence" it didn't give you an error in the moment. Instead, it gave you a frame with an ~end~ isotope in the missing slot.</p>
<p>The trick--you may remember--is that frames can't actually take isotopes as arguments. So had there been an actual literal ~end~ there it would be an error condition...it would have to be a ^META parameter, in which case it would show up in the argument as a <em>quoted</em> ~end~ BAD-WORD!.</p>
</blockquote>
</aside>
<p><strong><code>&lt;sigh&gt;</code></strong></p>
<p>Things evolved to where "stable isotopes" are legal as function arguments...and WORD! isotopes are stable.  If they weren't, you'd have to use ^META arguments for ~null~, ~true~, and ~false~ isotopes (among other things, like splices)...which would create pain.  Things like equality operators (for instance) would have to take their arguments as meta.</p>
<p>The weird "edge" that remains is simply isotopic void, a.k.a. "none" or the ~ isotope.  Despite being stable (e.g. storable in variables) it signifies an unfulfilled parameter.  But unfulfilled parameters in FRAME! become null upon execution.</p>
<p>The weirdness is that you can't say <strong>if var = ~ [...]</strong> because the equality operator does not take meta parameters, hence it cannot receive a none as an actual argument.  To see if a variable is unset, you have to write <strong>if unset? 'var [...]</strong> or <strong>if none? :var [...]</strong> and it reaches its conclusion through other mechanisms... or you can do a meta-comparison against the quasiform and take it one level up:</p>
<pre><code>if ^var = '~ [...]  ; quoted tilde evaluates to quasi void, not isotopic void
</code></pre>
<h2>
<a name="can-end-be-implemented-with-another-weird-edge-1" class="anchor" href="https://forum.rebol.info#can-end-be-implemented-with-another-weird-edge-1"></a>Can End be Implemented With another "Weird Edge"?</h2>
<p>At first glance, I'm not particularly thrilled with special treatment for ordinary <strong>~end~</strong> when other word isotopes are legal in frames, but then again... they've shaped up to where ~null~ and ~true~ and ~false~ have baked in behavior.  (It's made me wary of assigning a truthy or falsey status to any other isotopic words).</p>
<p>We could effectively say all word isotopes are reserved for system use, and let people who want weird error-triggering use stable isotopic tags or something of that sort instead:</p>
<pre><code>&gt;&gt; widget: ~&lt;main not called yet&gt;~

&gt;&gt; widget
** Error: widget is isotopic tag: ~&lt;main not called yet&gt;~
</code></pre>
<p><code>~true~</code> and <code>~false~</code> and <code>~null~</code> could sneak by with non-meta forms, and the likes of ~end~ could be used in the meaning as above:</p>
<pre><code>&gt;&gt; make frame! make varargs! [match integer!]
== make frame! [
    test: &amp;(integer)
    value: ~end~
]
</code></pre>
<p>You'd get a frame that you can't actually invoke unless you turn those ~end~ into something else.  Just as with none (isotopic ~) you would have the blind spot of functions needing meta-parameters to handle end, with workarounds like doing a meta-access of variables you wanted to compare:</p>
<pre><code>if ^frame.value = '~end~ [...]
</code></pre>
<p>Or a specialized function which is tailored to do the test.  Presuming ~end~ is still "get-friendly":</p>
<pre><code>if end? frame.value [...]
</code></pre>
<p>So END? would have to take a ^META argument... and it should <em>not</em> be endable...unless you want:</p>
<pre><code>&gt;&gt; (end?)
== ~true~  ; isotope... but you don't want this, you want an error!
</code></pre>
<p>All other word isotopes would be illegal in FRAME! un-meta'd...but only at the moment of execution.  They'd be reserved for future use and meaning by the system.</p>
<p>If we're willing to go down this route, it may open up some interesting possibilities.  Like ~none~ isotopes could intentionally transform into none arguments without having to make them meta:</p>
<pre><code> unset: specialize :set [value: ~none~]
</code></pre>
<p>If it were understood that <em>"you shouldn't really trust word isotopes unless you meta them"</em>, you'd have a rigorous path (use a ^META parameter) as well as the path of convenience.</p>
<p>Hmmm.  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p> ]]></description>
        <link>https://forum.rebol.info/t/match-in-rust-vs-switch/1835#post_5</link>
        <pubDate>Wed, 21 Jun 2023 19:52:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6612</guid>
      </item>
      <item>
        <title>What Should TYPE OF an Isotope Be?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1983">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Maybe the ANY is enough to give the hint, and then other type constraints could be named things like <strong>is-even!</strong> or <strong>is-splice!</strong>. This would clue people to not write things like <strong>make is-logic! [...]</strong> or <strong>is-logic! = kind of value</strong>.</p>
</blockquote>
</aside>
<p>The "make all typesets start with ANY-" was a very early R3-Alpha compromise on how to tell that things like SERIES! were not fundamental types.  A Rebol2 newbie might say something like <strong>make series! [...]</strong> or <strong>if series! = type-of x</strong>.  The speedbump of the ANY- would give that a broken flow that you wouldn't <em>expect</em> to work: <strong>make any-series! [...]</strong>, <strong>if any-series! = type-of x</strong></p>
<p>Now that typesets are gone and only type constraints exist, the speedbump of the <strong>is-splice!</strong> isn't making me very happy.  It may be one of those "is the cure worse than the disease" situations... <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"> In C++ when you take a parameter by reference you don't indicate syntactically whether it's a concrete or abstract class.  You just find out if you try to instantiate an instance.  Some people name "interfaces" with a leading letter <code>I</code>... in some cases you do see things like <code>class ConcreteWidget : public AbstractWidget {...}</code></p>
<p>Here's the kind of thing I'm staring at with displeasure right now:</p>
<pre><code> appender: func [series [any-series!] value [void! any-element! is-splice!]] [
     ...
 ]
</code></pre>
<p>Following the pattern of the Rebol2 universe, the failure to distinguish gives us the cleaner-<strong>but</strong>-misleading read:</p>
<pre><code> appender: func [series [series!] value [void! element! splice!]] [
     ...
 ]
</code></pre>
<p>I lament not being able to just use functions, which is now the underlying mechanic and... <em>almost too good to pass up</em>.  It reduces the redundancy of needing both things like LOGIC? as well as (IS-)LOGIC!...and though it's technically still a naming convention, it's one that's well-established:</p>
<pre><code> appender: func [series [series?] value [void! element? splice?]] [
     ...
 ]
</code></pre>
<p>If there's no <strong>splice!</strong> then people won't be tempted to write <strong>if splice! = type of x</strong> or <strong>make splice!</strong>.</p>
<p>This would mess with the SWITCH/TYPE scenarios, unless they quoted their arguments vs. running the functions:</p>
<pre><code>switch/type x [
    logic? [...]  ; want to test x to see if it's a logic...not the [...] block!
    null? [...]
    even-integer? [...]
]
</code></pre>
<p>You'd have to suppress the evaluation if not, e.g. using BLOCK!... it works for MATCH e.g. <strong>match [logic?] x</strong>:</p>
<pre><code>switch/type x [
    [logic?] [...]
    [null?] [...]
    [even-integer?] [...]
]
</code></pre>
<p>Perhaps my bias of what "TYPE-WORD!" means is off, and it should mean "call this function with one value and process the logic result":</p>
<pre><code>switch/type x [
    &amp;logic? [...]
    &amp;null? [...]
    &amp;even-integer? [...]
]
</code></pre>
<p>Foundational types could then be defined as something weirder...since you'd rarely type them out...</p>
<pre><code>&gt;&gt; integer!
== &amp;(integer)
</code></pre>
<p>You could still define shorthands if you wanted.  <strong>is-logic!: &amp;logic?</strong> ... but it wouldn't come in the box.</p>
<p>Re-examining basing switch/type (or whatever that construct is called) take blocks doesn't actually <em>look</em> so bad... but there's a mechanical problem in that SWITCH has historically used blocks to indicate where the code was for common switch conditions, that would break down:</p>
<pre><code>switch/type x [
    block! group! [...]
    [even-integer?] [logic?] [...]
]
</code></pre>
<p>I have proposed addressing this with commas... which comes off as kind of annoying:</p>
<pre><code>switch/type x [
    block!, group! [...]
    [even-integer?], [logic?] [...]
]
</code></pre>
<p>Other languages throw in more syntax, which people like Shixin have expressed favored for clarity vs. the "fast and loose" Rebol style:</p>
<pre><code>switch/type x [
    block! group! =&gt; [...]
    [even-integer?] [logic?] =&gt; [...]
]
</code></pre>
<p>At one time I suggested that both be offered under different names... call one "choose" and the other "switch".  I dunno.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1983">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>&gt;&gt; parse ["abc" [d e f]] [some any-series!]
== [d e f]
</code></pre>
</blockquote>
</aside>
<p>So how bad, really, is it with my proposal about rethinking TYPE-WORD! (and by extension, TYPE-TUPLE!) to mean "use as type constraint" and swap around what fundamental types use?</p>
<pre><code>&gt;&gt; parse ["abc" [d e f]] [some &amp;series?]
== [d e f]
</code></pre>
<p>Remember, we're used to seeing functions with tics on them, like <strong><code>:series?</code></strong> ... e.g. <em>"I want the value of this function, I don't want you to call it"</em>.  What about the ampersand as a tic meaning "I want you to use this as a type constraint, not a combinator"?</p>
<p>This doesn't preclude someone saying <strong>any-series!: &amp;series?</strong> or <strong>series!!: &amp;series?</strong> or even <strong>series!: &amp;series?</strong> but how important would that ultimately seem to people?  Is this just something we're not used to yet that will feel natural when it comes up?  Isn't it nicer to have a fully generic mechanism to apply to any logic-returning function and be able to pull that out?</p>
<pre><code>&gt;&gt; parse [2 4 6 8] [some &amp;even?]
== 8
</code></pre>
<p>Might something other than an ampersand be less jarring for the TYPE-XXX forms?  There's not really much left, though...:</p>
<pre><code>&gt;&gt; parse [2 4 6 8] [some $even?]
== 8
</code></pre>
<aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="1983">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I lament not being able to just use functions, which is now the underlying mechanic and... <em>almost too good to pass up</em>. It reduces the redundancy of needing both things like LOGIC? as well as (IS-)LOGIC!...and though it's technically still a naming convention, it's one that's well-established:</p>
</blockquote>
</aside>
<p>I should point out that there will still be functions that test for concrete types, like <strong>integer?</strong>.  So people can use those functions in type specs, e.g. <strong>foo: func [x [integer?]] [...]</strong> instead of the type <strong>integer!</strong>.  That's a bit of an annoyance.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983#post_7</link>
        <pubDate>Wed, 21 Jun 2023 17:53:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6611</guid>
      </item>
      <item>
        <title>Should ANY-VALUE! Include Isotopes?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2026">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>But what if you want to exclude isotopes?</strong> We could have a name for the typeset excluding isotopes (perhaps ANY-CELL!). Or we could say that ANY-VALUE! doesn't include isotopes by default, and so you have to write <strong>[any-value! isotope!]</strong> if you want them... or just include the specific ones you intend (like <strong>[null! any-value!]</strong>.</p>
</blockquote>
</aside>
<p>Let me point out that it seems best if typechecking applies to the unescaped form.  So if you have a ^META argument which says it can accept a something unstable like a PACK!, that is written as <strong>func [^arg [integer! pack!]]</strong>, not <strong>func [^arg [quoted-integer! quasi-pack!]]</strong>.</p>
<p>As such, isotope! would have a different meaning for meta and non-meta parameters.  This suggests needing a distinction between <strong>stable-isotope!</strong> and <strong>any-isotope!</strong> <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>This raises a question about the meaning of <strong>func [^arg [any-value!]]</strong>.  Does that encompass unstable isotopes as well as stable ones?</p>
<p>A term that could subsume stable isotopes and array elements could be ANY-STABLE!, which would then leave ANY-VALUE! exclusively for things you can put in an array.  But I think this runs against the natural usage of the term "value"... if you ask <em>"what is the value of the variable"</em> and something like a ~true~ isotope is legitimate for a variable to hold, that's the variable's value.  I'd also say an object contains "keys" and "values".</p>
<p>But since a variable cannot hold things like a PACK! (block isotope) or a RAISED! (error isotope), it is probably best to avoid saying they are "values".  They're unstable isotopes.  What happens to an unstable isotope is that if they're not in the type checking of a ^META parameter, they decay... e.g. a pack will decay to its first item, and a raised will decay to causing an "untrappable" failure (exempting special functions like sys.util.rescue).</p>
<p>This points to the idea that if you want to take only things that go in BLOCK!s/GROUP!s, those need a name.  At the instant of writing I've called those ANY-CELL!</p>
<h2>
<a name="implementation-naming-issue-cell-datatype-is-superset-1" class="anchor" href="https://forum.rebol.info#implementation-naming-issue-cell-datatype-is-superset-1"></a>Implementation Naming Issue: Cell Datatype is Superset</h2>
<p>In the mechanical implementation itself, I used the name <code>Cell</code> as the base class of <code>Value</code>... not vice versa.  In OOP terms, this suggests all values are cells...but not all cells are values.</p>
<p>The distinction this was intended to draw was the difference between something that has all the information needed for binding (e.g. a variable's value) and a raw array element that can be imaged multiple times and places with different bindings.</p>
<p>This gives you partial type coverage--as a routine for writing an isotope can take the address of a <code>Value</code>, which prevents accidentally writing them into a block! or group!.  While writing something like an integer! can take the address of a <code>Cell</code> and work for either.  However, reading routines like testing to see if a value <em>contains</em> an isotope takes a cell.</p>
<p>So the naming doesn't line up with ANY-CELL! meaning ANY-ARRAY-ITEM!.  I don't feel like going into the code and giving another name to the base class, like <code>Element</code>.  And I don't like the idea of the implementation using the word "cell" to mean something different than what a user of the language would say it means.</p>
<p><em>Perhaps <strong><code>Element</code></strong> is a good name for things you can put in array slots, retaining <strong><code>Cell</code></strong> for the universal base class that applies to <strong><code>Element</code></strong> and <strong><code>Value</code></strong>?</em></p>
<p>I haven't needed in the implementation to specifically call out "Elements" distinctly from "Cells".  If I used my imagination I could probably think up some restrictions...for instance that you can't do pointer math on Cells without casting them to Element.  But really the core issue in the implementation has been that you are restricted from doing variable lookup on cells without combining them with "specifiers" to make "values".</p>
<p><strong>I think I'm happier with ANY-ELEMENT! or ELEMENT!</strong>.  This suggests maybe ANY-CELL! or CELL! could--in compliance with the implementation--subsume unstable isotopes.</p>
<p>I'm scratching my head over the usefulness of an Element subclass in the implementation itself (beyond the exposed typeset).  One of the problems is that Rebol guts are based on using common array routines for objects and function frames...and so even common-sense-sounding ideas like "you can't just increment a pointer to a variable to get to another variable" are subverted all over the place.</p>
<p>I'll have to keep thinking on it, but at least there's a bit of progress with the "element" term.  So append would accept <strong><code>[void! element! splice!]</code></strong>... with void resulting in a no-op, element adding a single item, and splice adding an array itemwise.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-any-value-include-isotopes/2026#post_2</link>
        <pubDate>Wed, 21 Jun 2023 16:28:46 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6610</guid>
      </item>
      <item>
        <title>Is there anything like parse in other languages?</title>
        <dc:creator><![CDATA[@BlackATTR Black Attr]]></dc:creator>
        <description><![CDATA[ <p>If I'm not mistaken, Perl and Java have something not far off from Rebol's grammar-based parsing. Not likely as commonly used as regular expressions, however. I'd wager that Javascript has a library for parsing grammars too.</p> ]]></description>
        <link>https://forum.rebol.info/t/is-there-anything-like-parse-in-other-languages/2032#post_3</link>
        <pubDate>Mon, 05 Jun 2023 02:17:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6609</guid>
      </item>
      <item>
        <title>Is there anything like parse in other languages?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>When most languages phrase this kind of functionality they do it under the name "parser combinators".</p>
<p>"Parsec" is one of the early ones in Haskell, and <a href="https://pythonhosted.org/parsec/">someone made a Python variant</a></p>
<p>Usage example:</p>
<aside class="onebox stackexchange" data-onebox-src="https://stackoverflow.com/questions/57368870/simply-using-parsec-in-python/57473088#57473088">
  <header class="source">

      <a href="https://stackoverflow.com/questions/57368870/simply-using-parsec-in-python/57473088#57473088" target="_blank" rel="noopener">stackoverflow.com</a>
  </header>

  <article class="onebox-body">
      <a href="https://stackoverflow.com/users/5080177/sighingnow" target="_blank" rel="noopener">
    <img alt="sighingnow" src="https://i.stack.imgur.com/3v8fY.png?s=256&amp;g=1" class="thumbnail onebox-avatar" width="256" height="256">
  </a>

<h4>
  <a href="https://stackoverflow.com/questions/57368870/simply-using-parsec-in-python/57473088#57473088" target="_blank" rel="noopener">Simply using parsec in python</a>
</h4>

<div class="tags">
  <strong>python, parsec, parser-combinators</strong>
</div>

<div class="date">
  
  answered by
  <a href="https://stackoverflow.com/users/5080177/sighingnow" target="_blank" rel="noopener">
    sighingnow
  </a>
  on <a href="https://stackoverflow.com/questions/57368870/simply-using-parsec-in-python/57473088#57473088" target="_blank" rel="noopener">07:31AM - 13 Aug 19 UTC</a>
</div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>
 ]]></description>
        <link>https://forum.rebol.info/t/is-there-anything-like-parse-in-other-languages/2032#post_2</link>
        <pubDate>Tue, 30 May 2023 16:32:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6608</guid>
      </item>
      <item>
        <title>Is there anything like parse in other languages?</title>
        <dc:creator><![CDATA[@johnk Johnk ]]></dc:creator>
        <description><![CDATA[ <p>I have been away for a while and I am missing parse. I was wondering if you know of any similar parsers in other languages like Python or R?</p> ]]></description>
        <link>https://forum.rebol.info/t/is-there-anything-like-parse-in-other-languages/2032#post_1</link>
        <pubDate>Thu, 25 May 2023 09:17:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6607</guid>
      </item>
      <item>
        <title>What Should TYPE OF an Isotope Be?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1983">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>One might ask why you can't avoid naming the type constraint entirely, and always speak in terms of functions. This means you would always have to write <strong>match [any-series?] value</strong> instead of <strong>match any-series! value</strong>. The reasoning is that we want to be able to write things like:</p>
<pre><code>&gt;&gt; parse ["abc" [d e f]] [some any-series!]
== [d e f]
</code></pre>
</blockquote>
</aside>
<p>It may be worth pointing out that in PARSE, we <em>could</em> always encode type matching intent via a MATCH instruction, and then have it quote a block argument:</p>
<pre><code>&gt;&gt; parse ["abc" [d e f]] [some match [any-series?]]
== [d e f]
</code></pre>
<p>But then, people would probably do something like:</p>
<pre><code>any-series!: [match [any-series?]]
</code></pre>
<p>This would be usable in PARSE but not elsewhere, e.g. SWITCH/TYPE wouldn't understand it.  :-/</p>
<p>So it seems that having a "type-flavored block" to encode these sets is the better answer.  Inside that block you can use function references like ANY-SERIES? and other type flavored blocks like ANY-SERIES! interchangeably.  As written, using the function form is slightly faster.</p> ]]></description>
        <link>https://forum.rebol.info/t/what-should-type-of-an-isotope-be/1983#post_6</link>
        <pubDate>Sat, 22 Apr 2023 22:28:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6604</guid>
      </item>
      <item>
        <title>Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Hi vnzio,<br>
If I weren't as busy as I am currently in daytime <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"><br>
Well I can tell you in a nutshell why REN-C is awesome. While there are a few R3 clones in development, this is the most active of them all. But REN-C is not R3 anymore. Many things R3 was troubled by were solved by Ren-C. REN-C is also even more a way to put R3 in a C project (or was it the other way around).<br>
REN-C also makes a lot of new constructs possible. <a href="https://forum.rebol.info/t/ren-cs-eloquence-in-the-face-of-fizzbuzz/904" class="inline-onebox">Ren-C's eloquence in the face of FizzBuzz</a> I used it to solve the 8 queens problem in a more Rebol way <a href="https://arnoldvanhofwegen.com/blog/eight-queens-problem-solved-with-ren-c/" class="inline-onebox">Eight queens problem solved with Ren-C | Arnold's Blog</a> And I got a MySQL module working (not in the mainline) for REN-C.<br>
As you can see on the forum, Brian, Hostilefork is the main development force, the other members on the forum are more critical followers and aiding in their own power, try to keep making sense <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=9" title=":wink:" class="emoji" alt=":wink:"> . There are lots of neat ideas that are implemented in REN-C and when these do not work out as planned, plans change and changes are made accordingly. This makes REN-C a dynamic project to follow. So not directly suitable for using in your day to day work, yet rather constant if you do not do very crazy stuff.<br>
And what makes it even better... it is a small community, you can work on anything you feel and that is okay and no large number of Nay-sayers (maintainers) telling you around. Mny things have not been done for REN-C like for name any (semi) large open source project.</p> ]]></description>
        <link>https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028#post_2</link>
        <pubDate>Tue, 18 Apr 2023 20:23:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6603</guid>
      </item>
      <item>
        <title>&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</title>
        <dc:creator><![CDATA[@vnzio Vnzio]]></dc:creator>
        <description><![CDATA[ <p>Yes<br>
I will try to present my interest, experiences, history and current wishes.<br>
It might take me a couple of days to put this in lucid form.<br>
A bientt</p> ]]></description>
        <link>https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029#post_3</link>
        <pubDate>Tue, 18 Apr 2023 14:41:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6602</guid>
      </item>
      <item>
        <title>&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</title>
        <dc:creator><![CDATA[@iArnold Arnold]]></dc:creator>
        <description><![CDATA[ <p>Hi vnzio,<br>
Welcome. Could you tell us more? Who you are in the Introductions category ( <a href="https://forum.rebol.info/t/about-the-introductions-category/1286" class="inline-onebox">About the Introductions category</a> ) why you consider Factor to be a good Foreign inspiration source for us to take notice?<br>
Best,<br>
Arnold</p> ]]></description>
        <link>https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029#post_2</link>
        <pubDate>Tue, 18 Apr 2023 13:52:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6601</guid>
      </item>
      <item>
        <title>&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</title>
        <dc:creator><![CDATA[@vnzio Vnzio]]></dc:creator>
        <description><![CDATA[ <p><a href="https://factorcode.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://factorcode.org/</a></p>
<aside class="onebox wikipedia" data-onebox-src="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1">
  <header class="source">

      <a href="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">en.wikipedia.org</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:200/124;"><img src="//upload.wikimedia.org/wikipedia/en/thumb/f/ff/NewFactorLogo.png/200px-NewFactorLogo.png" class="thumbnail" width="200" height="124"></div>

<h3><a href="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">Factor (programming language)</a></h3>

<p>Factor is a stack-oriented programming language created by Slava Pestov. Factor is dynamically typed and has automatic memory management, as well as powerful metaprogramming features. The language has a single implementation featuring a self-hosted optimizing compiler and an interactive development environment. The Factor distribution includes a large standard library.
 Slava Pestov created Factor in 2003 as a scripting language for a video game. The initial implementation, now referred to as JFa...</p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Google Tech Talk 2008</p><p><a href="https://www.youtube.com/watch?v=f_0QlhYlS8g">Factor: an extensible interactive language</a></p>

<p>Silicon Valley Forth Interest Group<br>
2022<br>
"Factor in 2022"</p><p><a href="https://www.youtube.com/watch?v=OLh61q4c4XE">2022-03-26 --- Factor in 2022 --- John Benediktsson &amp; Doug Coleman</a></p>
 ]]></description>
        <link>https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029#post_1</link>
        <pubDate>Mon, 17 Apr 2023 23:10:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6600</guid>
      </item>
      <item>
        <title>Issues with &quot;Invisibles&quot;: a truly disappearing COMMENT</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Early on, I wanted to avoid situations where an invisible could be in a position where it might look like it was an assignment:</p>
<pre><code>x: elide print "It's confusing when X gets [a]"
append [] 'a
</code></pre>
<p>Since the ELIDE vanished, the result of the APPEND is what X gets.  Confusing!</p>
<p>So at first, I figured it should be illegal to do that.  But I later backed off on ruling it out when I thought about a vanishing BREAKPOINT:</p>
<pre><code>x: breakpoint append [] 'a
</code></pre>
<p>Why shouldn't you be able to put a breakpoint wherever you want, I wondered?  So it became legal.</p>
<p>In the fever dream of making invisibles able to do anything, there were tests like this:</p>
<pre><code>unset 'x
unset 'y
unset 'z
x: 10
y: 1 comment [+ 2
    z: 30] + 7
did all [
    x = 10
    y = 8
    not set? 'z
]
</code></pre>
<p>But the same problems apply when a SET-WORD! is not present in the general case; the ability to bend the "shape" of the source so arbitraily has a big complexity cost in the interpreter.  It then has to be explained in terms of <a href="https://github.com/metaeducation/ren-c/blob/0b5b42003a4c181f38f3eb28e4378dc53d3a14f1/src/mezz/base-defs.r#L150">why COMMENT is ENFIX</a> and a litany of limitations where it doesn't work.  Documenting it is maddening...and it seems to have diminishing returns.</p>
<p><strong>Now I'm having serious second thoughts about the lenience.</strong>  I don't know this tradeoff is ultimately worth it; it becomes very slippery when you are dealing with constructs that you aren't necessarily noticing are invisible.</p>
<p>So I'm thinking that the error on invisibility for non-interstitials (e.g. assignment sources or argument slots) may make sense...to say that invisibility is something that can only happen in interstitial locations.</p>
<p>You can still get your breakpoint at odd positions, just introduce a GROUP! so it's not picked up:</p>
<pre><code>x: (breakpoint append [] 'a)
</code></pre>
<p>Of course, a group might interfere with something like a COMPOSE, so you might need to use DO or be otherwise creative:</p>
<pre><code>x: do [breakpoint append [] 'a]
</code></pre>
<p>We might lament the need to worry more about restructuring the code to accommodate the breakpoint in ways that could disrupt the code.  But with dialecting, the appearance of the word BREAKPOINT even just in itself could have caused a disruption.  It's the cost of doing business in this paradigm.</p> ]]></description>
        <link>https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405#post_9</link>
        <pubDate>Mon, 12 Apr 2021 16:40:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6628</guid>
      </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest posts</title>
    <link>https://forum.rebol.info</link>
    <description>Latest posts</description>
      <item>
        <title>The TYPESET! representation problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1300">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>There is a proposal on the table to <a href="https://forum.rebol.info/t/should-datatype-be-killed-off-in-favor-of-integer-word-etc/1177/8">apply the <strong>@[...]</strong> structural type</a> to the representation of datatypes:</p>
<pre><code>&gt;&gt; type of 10
== @[integer]  ; alternately @[integer!] ...?
</code></pre>
</blockquote>
</aside>
<p>I wanted to just sort of make a note on this (now-old) suggestion, based on things that have come along.</p>
<ul>
<li>
<p><strong>With SPREAD and isotopic blocks, you would no longer have to worry about how things like APPEND would deal with these</strong>:</p>
<pre><code>&gt;&gt; append [a b c] integer!
== [a b c @[integer!]]
</code></pre>
<p>Previously there was a lot of fretting involved about whether these blocks would be spliced by default, which would lose the datatypeness (e.g. give you <code>[a b c integer!]</code>)</p>
</li>
<li>
<p><strong>There is no need for a UPARSE interpretation of @[xxx] at this time.</strong>  What the @ rules mean generically is "match content as is":</p>
<pre><code> &gt;&gt; block: [some "a"]

 &gt;&gt; parse [[some "a"] [some "a"]] [tally @block]
 == 2
</code></pre>
<p>It uses WORD!, TUPLE!, and GROUP! of the @ form, which even lets it do SPREAD.</p>
<pre><code>&gt;&gt; block: [some "a"]

&gt;&gt; parse [some "a" some "a"] [tally @(spread block)]
== 2
</code></pre>
<p>But matching a block literally can be done with quoting if you need it:</p>
<pre><code>&gt;&gt; parse [some "a" some "a"] [tally '[some "a"]]
== 2

So it's not really necessary to have @[some "a"] as a synonym for that.
</code></pre>
</li>
<li>
<p><strong><a href="https://forum.rebol.info/t/shim-code-for-modal-arguments/1185">The modal parameters proposal is dead</a>, so there's less competition for the meaning of @[xxx].</strong></p>
</li>
<li>
<p><strong>Proposals for the @ branch types have also kind of fizzled.</strong>  There was at one point the idea that you could subvert branch result "corruption" in service of ELSE and then:</p>
<pre><code>&gt;&gt; if true [null]
== ~null~  ; isotope (so that ELSE knows not to run)

&gt;&gt; if true @[null]
; null
</code></pre>
<p>But this pretty much wrecks control construct composition; you can't build higher-level constructs that can keep track of whether branches in lower level constructs ran or not.  Also, Chris would think this is ugly anyway and not use it.  The current approaches focus on making null isotopes smarter</p>
</li>
<li>
<p><strong>We now have isotopic types to sort out issues with nonliteral matching.</strong>  So we could say:</p>
<pre><code>&gt;&gt; find ["a" @[integer!] 1 "b"] @[integer!]
== [@[integer!] 1 "b"]

&gt;&gt; matches @[integer!]
== ~@[integer!]~  ; isotope

&gt;&gt; find ["a" @[integer!] 1 "b"] matches @[integer!]
== [1 "b"]
</code></pre>
<p>The good realization here is that FIND doesn't have to be concerned about misinterpreting your block, when you were trying to use it for non-typeset reasons.  It only gives meaning to the isotopic form...otherwise it can handle it literally</p>
</li>
</ul>
<h2>So Is the @[datatype!] a Good Idea?  Bad Idea?</h2>
<p>It's important to remember that whatever this is, it just kind of gets the ball rolling.  It's about seeing a comfortable answer for simple questions, that's not ambiguous:</p>
<pre><code>&gt;&gt; type of 1020
== @[integer!]
</code></pre>
<p>You can't realistically generalize this.  A TYPESET! can't just be an @ BLOCK! with more things in it.  You're going to fall off the rendering cliff at some point, and just showing the address of it is probably about the best thing the console can show... to give you something back you can ask further questions of.</p>
<pre><code>&gt;&gt; ts: make typeset! [any-series! integer!]
== #[typeset! 0xCDEF1BC4]

&gt;&gt; pick #[typeset! 0xCDEF1BC4] text!
== ~true~  ; isotope
</code></pre>
<p>I think the sooner one accepts that direction, the more we can reason about the usefulness of leaning on an existing value class that has basic unambiguous rendering for the "type atoms".</p> ]]></description>
        <link>https://forum.rebol.info/t/the-typeset-representation-problem/1300/5</link>
        <pubDate>Sun, 28 Aug 2022 22:34:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6339</guid>
      </item>
      <item>
        <title>Better Answers than TRY and OPT For BLANK! &lt;=&gt; NULL</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Ever since the creation of null and blank, it's been desirable to go between them.</p>
<p>The word I first chose for NULL =&gt; BLANK! was TRY.  It would pass through anything else:</p>
<pre><code>&gt;&gt; try null
== _

&gt;&gt; try _
== _

&gt;&gt; try 1020
== 1020
</code></pre>
<p>The reverse operation of converting BLANK! =&gt; NULL was called OPT; again passing through everything else:</p>
<pre><code>&gt;&gt; opt _
; null

&gt;&gt; opt null
; null

&gt;&gt; opt 1020
== 1020
</code></pre>
<p>It may seem mysterious to ascribe such a trivial operation to a high-value word like TRY.  But it made sense at the time, because nulls were rather unfriendly:</p>
<pre><code>&gt;&gt; if not x: find "abc" "d" [print "Assignment goes okay..."]
Assignment goes okay...
; null

&gt;&gt; if not x [print "But word fetching has problems"]
** Error: X is NULL    
</code></pre>
<p>TRY provided a way to disarm the result:</p>
<pre><code>&gt;&gt; x: try find "abc" "d"
== _

&gt;&gt; if not x [print "Didn't find it"]
Didn't find it
</code></pre>
<p>But as it turned out: NULL was trying to do too many things, being fused with the notion of "unset variables".  It was a good start on having non-valued states... we just needed more!</p>
<p>Once VOID arrived it was no longer necessary to error on null variable accesses, and this particular usage of TRY was not necessary.</p>
<h2>But...It Was Actually On The Right Track...</h2>
<p>FIND is a bad demonstration.  But TAKE on empty block is actually a good one from that erroring-on-nulls era:</p>
<pre><code>&gt;&gt; x: take []
; null

&gt;&gt; if x [print "-some- error around here seems right..."]
** Error: X is NULL

&gt;&gt; x: try take []
== _

&gt;&gt; if x [print "-some- signal for saying it's okay seems right..."]
-some- signal for saying it's okay seems right...
</code></pre>
<p>But we see it's suboptimal, as now X is valued... and conflates with if we had written <strong><code>take [_]</code></strong>.  It also seems the need for the TRY in this case should have been independent of whether you stored the result in a variable or not.</p>
<p>Definitional errors come in and clean this mess up... so that TRY can defuse the take and give you the NULL state you want:</p>
<pre><code>&gt;&gt; x: take []
** Error: TAKE of EMPTY block, use TRY if you meant to do that

&gt;&gt; x: try take []
; null
</code></pre>
<h2>But Now How Do We Interconvert BLANK! and NULL?</h2>
<p>You're still going to come across situations where you pick a blank out of a block, where it's representing a null intent.  And it's illegal to compose or append nulls to blocks / etc, so how do you convert them?</p>
<p>Meet REIFY and DECAY.</p>
<pre><code>&gt;&gt; reify null
== _

&gt;&gt; decay _
; null
</code></pre>
<p>We actually have new members of this family: the conversion of isotopes to quasiforms.</p>
<pre><code>&gt;&gt; true
== ~true~  ;  isotope

&gt;&gt; append [a b c] true
** Error: Cannot append ~true~ isotope to block, use REIFY for quasiform

&gt;&gt; append [a b c] reify true
== [a b c ~true~]

&gt;&gt; append [a b c] as word! true
== [a b c true]
</code></pre>
<p>I think the words are a nice coupling...and even the same number of letters!</p>
<h2>What Will OPT Do Now?</h2>
<p>I'm not sure.  I'm actually pulling back a bit on the idea of saying that what happens in PARSE is a TRY... because in essence there's always a built-in "TRY" during parse.  Rules are raising definitional errors, but that's just swept under the rug by the parse process itself.  So OPT kind is kind of a different shade of meaning there.</p> ]]></description>
        <link>https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946/1</link>
        <pubDate>Sun, 28 Aug 2022 16:39:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6338</guid>
      </item>
      <item>
        <title>Thinking About Isotopes Logically: ~true~ and ~false~</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I just booted an isotopic true/false system... and...</p>
<h2>YES!  Isotopic ~true~ and ~false~ is The Answer (<em>for the Core</em>)</h2>
<p>Note that I don't think it's up to me to say whether any particular use case wants an IF statement to react to things.  The whole idea is that you can rig it up however you want.</p>
<p><strong>To pick an example: Some people may have a very good reason to have <em>their</em> IF consider integer 0 falsey when writing certain kinds of code.</strong>  I think that being able to "skin" the system in usermode so it does that--and runs that code in the same session as modules which don't do that--is a good goal to shoot for.</p>
<p><em>But the system needs a firm foundation for making those variations, and to hopefully inspire people not to change it when they see why the choice was made</em>.  And from what I'm seeing so far, this really does feel like it:</p>
<pre><code>&gt;&gt; true
== ~true~ ; isotope

&gt;&gt; false
== ~false~ ; isotope

&gt;&gt; if true [print "Works!"]
Works!

&gt;&gt; if false [print "As expected!"]
; void
</code></pre>
<p>There's huge benefit to isotopes not being able to be put in blocks...it forces some kind of triage.</p>
<pre><code>&gt;&gt; compose [a (1 = 1) b]
** Script Error: Invalid use of ~true~ isotope
</code></pre>
<p><strong>The tendency of historical Redbol to render #[true] and #[false] and #[none] indistinguishable from the WORD!s true, false, and none was not an accident:</strong> it was a crude attempt to limit the leakage of literal values that people <em>often</em> did not want to see.  But the results were outright misleading.</p>
<p>Here we get cued into a choice of how to shape our structures.  For instance: if you want the QUASI!-WORD! of ~true~, you can do that by reifying it:</p>
<pre><code>&gt;&gt; compose [a (reify 1 = 1) b]
== [a ~true~ b]
</code></pre>
<p>Or if you wanted the WORD! true, then you can go that direction as well:</p>
<pre><code>&gt;&gt; compose [a (as word! 1 = 1) b]
== [a true b]
</code></pre>
<p>And if someone thinks they have a really good reason to default one way or another, they can customize it.  But to me, erroring has the right level of agonsticism for the core.</p>
<p>Fitting into that balance is that ~true~ and ~false~ are the only isotopes that the core IF and friends will accept, so you still get a decent amount of safety:</p>
<pre><code>&gt;&gt; ~xxx~
== ~xxx~  ; isotope

&gt;&gt; if ~xxx~ [print "other isotopes still error"]
** Script Error: if needs condition as ^META for ~xxx~ isotope
</code></pre>
<p>The <code>~true~</code> and <code>~false~</code> QUASI!-words remain themselves truthy, for all the various good reasons they should be truthy (as the WORD!s true and false are as well).</p>
<pre><code>&gt;&gt; first [~false~]  ; getting unevaluated out of block, so not isotopic
== ~false~

&gt;&gt; if first [~false~] [print "plain unevaluated ~false~ is truthy"]
plain unevaluated ~false~ is truthy

&gt;&gt; decay first [~false~]
== ~false~  ; isotope

&gt;&gt; if decay first [~false~] [print "decayed ~false~ is falsey!"]
decayed ~false~ is falsey!
</code></pre>
<p><em>There are measurable feature benefits to having IF and CASE and ANY defaulting to testing an ANY-VALUE! like that for "is-ness".</em>  It solves many puzzles of trying to author generic block manipulation code cleanly.</p>
<h2>It's a Morale Boost On A Top-Of-The-Page Problem</h2>
<p>For years I've scrolled past the first steps of the boot process, and in the very early boot it has a bit that does an initialization of global cells holding true and false literals.</p>
<p>So right up when you step into main() you hit an essay about how #[true] and #[false] kind of suck, no literal notation has been chosen, along with all the historical question of the duality between the always-truthy true and false words with the literals...</p>
<p>It has been a chronic bummer to see it and lament that "we don't even know what to do with true and false!"  <em>But here is an answer that looks and functions better than anything before it.</em></p>
<p>It's hard to say when things are "fully solved" but this is feeling darn near close.  Which means the nest major step in the puzzle will be being able to achieve those customizations I speak of... e.g. to make INTEGER! of 0 falsey, but not have to rewrite every logic-oriented function in the system to do it...</p> ]]></description>
        <link>https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944/2</link>
        <pubDate>Sun, 28 Aug 2022 11:42:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6337</guid>
      </item>
      <item>
        <title>Minor (but nice!) %prot-http.r parsing improvements</title>
        <dc:creator><![CDATA[@BlackATTR Black Attr]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1945">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code class="lang-auto">parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [
        spec.method: [word! | ('post)]
        spec.path: opt [file! | url!]
        spec.headers: [block! | ([])]
        spec.content: [any-string! | binary! | (_)]
    ]
]
</code></pre>
</blockquote>
</aside>
<p>Wow, that cleans up beautifully! You say it's minor, and maybe it is, but it looks like the kind of brevity you'll be thanking yourself for again and again when you revisit the code in the future.</p> ]]></description>
        <link>https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945/2</link>
        <pubDate>Sat, 27 Aug 2022 17:49:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6336</guid>
      </item>
      <item>
        <title>Minor (but nice!) %prot-http.r parsing improvements</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Here's is R3-Alpha's <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/prot-http.r">PARSE-WRITE-DIALECT</a> from %prot-http.r</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set block word! (spec/method: block) | (spec/method: 'post)]
        opt [set block [file! | url!] (spec/path: block)]
        [set block block! (spec/headers: block) | (spec/headers: [])]
        [set block [any-string! | binary!] (spec/content: block) | (spec/content: none)]
    ]
]
</code></pre>
<p>You couldn't set paths in R3-Alpha parse, which is weird.  So things had to be captured into a temporary variable (it reused the input block for some reason).</p>
<p>Let's imagine that setting paths were legal:</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set spec/method word! | (spec/method: 'post)]
        opt [set spec/path [file! | url!]]
        [set spec/headers block! | (spec/headers: [])]
        [set spec/content [any-string! | binary!] | (spec/content: none)]
    ]
]
</code></pre>
<p>Let's do a quick transformation of this to PARSE3 in Ren-C:</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse3 block [  ; PARSE3 is R3-Alpha-compatible parse
        [set spec.method word! | (spec.method: 'post)]
        opt [set spec.path [file! | url!]]
        [set spec.headers block! | (spec.headers: [])]
        [set spec.content [any-string! | binary!] | (spec.content: _)]
    ]
]
</code></pre>
<ul>
<li>
<p>The TUPLE!s help us see we're not making function calls, which is nice</p>
</li>
<li>
<p>We have BLANK! which gives a nicer semiotic "we're nulling out this variable" look.</p>
</li>
<li>
<p>/LOCAL is a legitimate normal refinement, and <code>&lt;local&gt;</code> variables are truly local--you can't slip them in from the caller.  Because they are invisible, you can build function compositions that don't have to worry about colliding with their names.</p>
<ul>
<li>It also frees up /LOCAL to just be a typical refinement, like TIME/LOCAL</li>
</ul>
</li>
</ul>
<p>Now let's throw in some UPARSE, with the SET-WORD!s for assignment...</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [  ; PARSE is now UPARSE
        [spec.method: word! | (spec.method: 'post)]
        opt [spec.path: [file! | url!]]
        [spec.headers: block! | (spec.headers: [])]
        [spec.content: [any-string! | binary!] | (spec.content: _)]
    ]
]
</code></pre>
<p>It looks a little tighter...but then we also have the ability to factor the assignments out...</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [
        spec.method: [word! | ('post)]
        spec.path: opt [file! | url!]
        spec.headers: [block! | ([])]
        spec.content: [any-string! | binary! | (_)]
    ]
]
</code></pre>
<p>As it happens, that last line could just be <strong>opt [any-string! binary!]</strong>, because it would assign the result to NULL.</p>
<h2>But... That Raises a Question...</h2>
<p>What if the PARSE behavior for BLANK! was the same as in the evaluator, and it just produced NULL out of thin air but didn't match it?  Hence <code>_</code> would be a synonym for <code>(_)</code>.</p>
<p>Then these would be equivalent:</p>
<pre><code>spec.content: [any-string! | binary! | _]

spec.content: opt [any-string! | binary!]
</code></pre>
<p>You'd also be able to easily zero variables without entering a GROUP!.</p>
<pre><code>&gt;&gt; data: &lt;before&gt;

&gt;&gt; parse [x x x] [data: _ [some "y" (data: "Found some Y!")]]
; null

&gt;&gt; data
; null
</code></pre>
<p>I think the literal INTEGER! behavior has turned out to be a winner, where <code>3</code> is the same as <code>(3)</code>.  So maybe that would be good for blank too, given its new useful null-making behavior?  Dunno.</p> ]]></description>
        <link>https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945/1</link>
        <pubDate>Sat, 27 Aug 2022 17:38:07 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6335</guid>
      </item>
      <item>
        <title>Default Values And MAKE FRAME!</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1412">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>That Seems So Elegant... What's The Catch?</strong></p>
<ul>
<li>
<p>When doing a low-level build of a FRAME! for a function, you are on the hook for knowing the callsite parameter convention and doing what it takes to meet the expectation.</p>
<ul>
<li>So for a quoted (literal) parameter, you have to take that into account...since no callsite quoting is going on, you must do your own quoting in the assignment.</li>
</ul>
</li>
</ul>
</blockquote>
</aside>
<p>Okay... in practice this catch turns out to be <em>really annoying</em>.</p>
<p>Enough so that I think the frames should speak an "as-is" language.  Then the mechanics that turn parameters into ^META should be done by the function when it's called.</p>
<p>So let's revisit:</p>
<pre><code>greater-than-10: func [^x [integer!]] [
    if quasi? x [
        print ["Doing special thing for" mold x]
    ] else [
        x &gt; 10
    ]
]
</code></pre>
<p>I think what should happen in practice is that FUNC turns that into something like this, where you can annotate a lower-level FUNC* to say that isotopes are okay...and the body ^METAs the variables:</p>
<pre><code>greater-than-10: func* [x [integer! ~any-value~]] [
    x: ^x  ; This would be added by the higher level FUNC generator

    if quasi? x [
        print ["Doing special thing for" mold x]
    ] else [
        x &gt; 10
    ]
]
</code></pre>
<p>Here you'd get the behavior you'd expect for normal values:</p>
<pre><code>&gt;&gt; f: make frame! :greater-than-10
&gt;&gt; f.x: 20
== 20

&gt;&gt; do f
== #[true]
</code></pre>
<p>And if you wanted to pass an isotope, you'd assign isotopic values in the frame:</p>
<pre><code>&gt;&gt; f: make frame! :greater-than-10
&gt;&gt; [~f.x~]: ~asdf~
== ~asdf~  ; isotope

&gt;&gt; do f
Doing special thing for ~asdf~
</code></pre>
<h2>But What If Actually Want To Specialize To Void?</h2>
<p>You wouldn't be able to specialize voids by way of just a FRAME!.</p>
<pre><code>&gt;&gt; f: make frame! :set

&gt;&gt; f.value: ~
; void  (...meaningless, as it was already void...)

&gt;&gt; unset: make action! :f  ; not going to give you what you want

&gt;&gt; unset 'foo
; UNSET is missing its value argument
</code></pre>
<p>I'm not all that bummed out about this.  It was much more of a problem when you couldn't set things to NULL, because that inhibited removing refinements from the interface of functions.  This is a really narrow case...and I think some operation that just says "remove the parameter from the interface would probably do it.</p>
<pre><code>&gt;&gt; f: make frame! :set
&gt;&gt; protect/hide 'f.value  ; commit to the unset state
&gt;&gt; unset: make action! f
</code></pre>
<p>And SPECIALIZE could still do it, using the trick of assigning a special identity to each frame variable that it recognizes:</p>
<pre><code>unset: redescribe [
    {Clear the value of a word to an unset isotope (in its current context)}
](
    specialize :set [value: ~]  ; tricky case, but supported!
)
</code></pre>
<h2>What About Signaling END of Frame Input?</h2>
<p>I mentioned that the end of input could be NULL if the ^META parameters were always QUASI! / QUOTED! / BLANK!.</p>
<p>But at the frame currency level, this doesn't work if it's using plain values and not meta ones.  You have conflation of void, and then if you use NULL you're getting conflation with END.</p>
<p>Something that could solve these cases would be if there were "meta frames" where every value was interpreted as being meta.  <em>Could this be an application for isotopic frames??</em></p>
<p>Or a behavior for QUOTED! frames?</p>
<pre><code>&gt;&gt; f: make frame! :set
&gt;&gt; f.value: '~   ; meta void
&gt;&gt; make action! isotopic f  ; isotope status means unquote everything
</code></pre>
<p>I don't know about that, because I was thinking isotopic frames would auto-run from WORD!, and save you from having to make ACTION!s out of frames just to get that behavior.</p>
<p><strong>Anyway, long story short, I think the baseline mechanics of FRAME! has to be as-is.</strong>  Whatever else is an exception and should be handled specially.  If you want a ^META parameter, that should be something that happens after the function starts running.  This improves matters greatly.</p> ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame/1412/6</link>
        <pubDate>Sat, 27 Aug 2022 11:48:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6334</guid>
      </item>
      <item>
        <title>Should SET-WORD! Disallow Isotopic Assignments?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1919">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Historically, Rebol2 and R3-Alpha wouldn't let you assign UNSET! via a SET-WORD!, regardless of whether it was provided literally or through an evaluation. You had to use SET/ANY:</p>
</blockquote>
</aside>
<p>Something kind of interesting comes up with the nature of a void assignment, which is that it's fundamentally different from other "isotopic assignments".  Because there kind of "isn't any such thing as a void isotope":</p>
<pre><code>&gt;&gt; (1 + 2, ~something~)
== ~something~  ; isotope

&gt;&gt; (1 + 2, ~)
== 3
</code></pre>
<p>So really, these put the evaluator in different situations:</p>
<pre><code>&gt;&gt; 1 + 2 x: ~
== 3

&gt;&gt; 1 + 2 x: ~something~
; would be ~something~ isotope if we allowed it
</code></pre>
<p>I think it's pretty clear that assigning a variable voidness should not result in the variable being whatever was before it, e.g.</p>
<pre><code>&gt;&gt; 1 + 2 x: ~
== 3

&gt;&gt; x
== 3  ; this would be nonsense.
</code></pre>
<p>So what's actually being assigned in an evaluator sense is <em>staleness</em>.  And we can distinguish staleness, and tolerate it as something entirely different from trying to assign a "real isotope".</p>
<h2>Another Thought: Isotopic Assignment Syntax</h2>
<p>I had an idea for a syntax in SET-BLOCK!...including multi-returns...that would allow assigning isotopes.</p>
<pre><code>&gt;&gt; x: spread [1 2 3]
** Error: Cannot assign isotope BLOCK! using SET-WORD!

&gt;&gt; [~x~]: spread [1 2 3]
== ~[1 2 3]~  isotope
</code></pre>
<p>A bit weird, yes.  But it's less wordy than SET/ANY (I still don't know if I like /ANY as the name for that refinement):</p>
<pre><code>&gt;&gt; set/any 'x spread [1 2 3]
== ~[1 2 3]~  ; isotope
</code></pre>
<p>And now that the QUASI! and isotopic representations are generic you can use this with GROUP!s:</p>
<pre><code>&gt;&gt; [~(second [y x])~]: spread [1 2 3]
== ~[1 2 3]~  ; isotope
</code></pre>
<p><em>I really do think people should avoid putting isotopes in variables like this</em>--it's a fringe requirement, by design.  So if you're going to do it, I don't have a problem with it looking a bit dicey.</p>
<p>I definitely prefer it to other ideas like <strong><code>x.: spread [1 2 3]</code></strong>, for a number of reasons--but the visibility of what you are doing is certainly one of those reasons.</p>
<p>This could also allow you to permit isotopes in things like FOR-EACH over OBJECT!s that had isotopic states.</p> ]]></description>
        <link>https://forum.rebol.info/t/should-set-word-disallow-isotopic-assignments/1919/4</link>
        <pubDate>Sat, 27 Aug 2022 10:30:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6333</guid>
      </item>
      <item>
        <title>GET-BLOCK!, GET, and REDUCE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1183">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>R3-Alpha had what I had thought was a bizarre behavior:</p>
<pre><code>r3-alpha&gt;&gt; get 5 + 5
== 10
</code></pre>
<p>If something wasn't a WORD! or PATH! it would fall through. Unless it was an OBJECT!, in which case it would get the values of the object vs. the OBJECT! itself.</p>
</blockquote>
</aside>
<p>Maybe... not so bizarre?</p>
<p>I have proposed that our historical desire to ascribe a truthy and falsey state to values may be misguided, and in fact all ANY-VALUE! are truthy... with NULL as falsey.  With a little magic from ~true~ and ~false~ isotopic WORD!s, it can fill in the blanks with an additional "LOGIC!" concept...that is out-of-band from what can be found in blocks.</p>
<p>With this twist, it would mean that if you wanted to speak about testing values for their truthy/falseyness you wouldn't PICK or SELECT out of a block and test directly...but first go through a GET:</p>
<pre><code>&gt;&gt; if select [alpha: true beta: _] 'beta [
       print "The ANY-VALUE! of BLANK! would be truthy"
   ]
The ANY-VALUE! of BLANK! would be truthy

&gt;&gt; if get select [alpha: true beta: _] 'beta [
       print "GET of BLANK! could return null"
   ]
; void
</code></pre>
<p><em>It suggests this GET was what was missing all along.</em>  However, it raises some issues about the semantics of that GET...for instance, if you pass it a QUOTED! you probably want the thing unquoted, which R3-Alpha did not do:</p>
<pre><code>r3-alpha&gt;&gt; x: 10 
== 10

r3-alpha&gt;&gt; get select [alpha: true beta: 'x] 'beta
== 10  ; should "getting a value" imply a REDUCE-like step?
</code></pre>
<p>I don't think it should be evaluative, e.g. whatever this mode is doesn't run functions.  And presumably you'd have an error if it was a SET-WORD! or similar.</p>
<p>Does this suggest a difference between GET ANY-VALUE! and perhaps LOOKUP of a WORD! variable?</p>
<p>If you really are just trying to test for blankness or non-blankness, I feel like that should be what you say:</p>
<pre><code>&gt;&gt; if not blank? select [alpha: true beta: _] 'beta [
       print "This would not run."
   ]
; void
</code></pre>
<p>Anyway, I feel like the burden of interpreting these values should be upon the dialectee, because it seems there's no unified right answer.  From the system's perspective of "somethingness" or "nothingness" it makes the most sense to just say IF reacts to NULL and isotopes, <em>because that enables actual features that work</em>... vs. half-baked things that try to solve impossible problems and don't meet the needs half the time.</p> ]]></description>
        <link>https://forum.rebol.info/t/get-block-get-and-reduce/1183/8</link>
        <pubDate>Fri, 26 Aug 2022 10:07:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6332</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Question 3: Should BLANK! Evaluate to NULL ?</p>
</blockquote>
</aside>
<p>It occurs to me that if REDUCE and COMPOSE became more NULL-tolerant, they could implicitly REIFY.</p>
<pre><code>&gt;&gt; reduce [null, find "abc" "d"]
== [_ _]

&gt;&gt; reduce [_]
== [_]
</code></pre>
<p>So rather than BLANK! not having any evaluator behavior, it does...it evaluates to null.  But the system just considers it to be such a close kin to NULL that it doesn't mind turning it back into blank.</p>
<p><em>As cool as that is, I've become rather attached to finding out about NULLs, and being explicit when I didn't intend them.</em>  It catches bugs.</p>
<p>But there's no reason an R3C or similar couldn't take a different view:</p>
<pre><code>reduce: specialize :lib.reduce [predicate: :reify]
</code></pre>
<p>Or maybe I'm wrong about the default, and positives of the historical Redbol conflation outweigh the downsides even in code I use... and I should put in asserts if I really am not okay with the failure:</p>
<pre><code>&gt;&gt; reduce [null, must find "abc" "d"]
** Error...

&gt;&gt; reduce [null, must find "abc" "b"]
== [_ "bc"]
</code></pre>
<p>Or maybe it really is the sort of thing that one generally wants to decide on a per-module or per-function level.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:"></p>
<p>It depends on how you think of it.  The more you consider it a game--and not a medium for productive programming--the more it seems like erring on the side of lenience is right.</p>
<p>But the problem is, if <em>I</em> thought that way while developing then nothing would boot or work...every change would mysteriously bork the system.  You wouldn't see the advances at the pace you see them.  I depend on the alert-by-default tendencies to keep it going.  And I imagine people actually using it would need the same, though for modest Rebol2-style one-page scripts at small scale it may be a different story.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/6</link>
        <pubDate>Fri, 26 Aug 2022 09:28:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6331</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>Specifically BLANK! and its underscore literal is a huge win (this is from me, the ultra-conservative sceptic) in representing positive nothingness</p>
</blockquote>
</aside>
<p>Well, that's something.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>Hence you agree with <em>"Taking underscore away from the word pool does more good than harm."</em>  This seems to have reached a consensus.</p>
<p>But also...it is now allowed to <a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560">enclose weird words in vertical bars</a> as in Lisp, so you can have a WORD! whose spelling is underscore:</p>
<pre><code>&gt;&gt; w: |_|
== |_|

&gt;&gt; type of w
== #[datatype! word!]

&gt;&gt; to text! w
== "_"
</code></pre>
<p><em>(An important design deviation from Lisp is that leading and trailing spaces must be escaped... which biases <code>|</code> and <code>||</code> and <code>|||</code> etc. to being WORD!s of length 1, 2, and 3 respectively...and prohibits absolutely empty WORD!s, though we might have some escaping for that if it turns out to be some critical compatibility point with JSON or something.)</em></p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I do think that as it represents the known absence of a value in data, it should be falsey in the general flow that data primarily should determine that flow.</p>
</blockquote>
</aside>
<p>I'm trying to make a general engine... so it will be possible to do Redbol compatibility, and if you want different rules you should be able to have them.  But the core as I see it is the "default" distribution which should be based on what is reasonably determined the "best" and most coherent.</p>
<p>The way I see it, the substrate simply isn't set up to do this effectively</p>
<pre><code>&gt;&gt; if select [alpha: true beta: false] 'beta [
       print "This will print, because FALSE is a WORD!"
   ]
   This will print, because FALSE is a WORD!
</code></pre>
<p>I suggest that whatever peace is made with the above could be made with BLANK! more easily if it evaluated to NULL (and presumably would give NULL back from GET as well?), e.g.</p>
<pre><code>&gt;&gt; x: _
; null

&gt;&gt; get '_
; null

&gt;&gt; if get select [alpha: true beta: _] 'beta [
       print "GET of BLANK! could return null"
   ]
; void
</code></pre>
<p>(Note: This <a href="https://forum.rebol.info/t/get-block-get-and-reduce/1183/8">turns out to be complicated in a general sense</a>, but I think it's on the right track.  Consider GET as a placeholder for "the test that makes sense in your usage context".)</p>
<p>Then you have coverage for FALSE and anything you assign false to.  And I think the <a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">isotopic ~true~ and ~false~ story</a> looks like it may have the right stuff.  (Note that GET does not do evaluations by default...GROUP!s or groups in tuples...so you need to ask it to, hence this is somewhat safe.)</p>
<p>So lone IF comes down to <em>is an ANY-VALUE! available to answer whatever question I asked</em>.  A ~false~ isotope walks the line of being able to say "no" and a ~true~ isotope says "yes" but they sit in the netherspace of not being reified values...where all other isotopic WORD! cause an error.  It shapes the space to make tests when you have either a full ANY-VALUE! or a NULL actually useful.</p>
<p>Sidenote: If you want to not error on a failed select, <a href="https://forum.rebol.info/t/definitional-errors-as-blank-in-null-out-alternative/1880/7">there's now a more elegant answer</a>...and it depends on VOID.</p>
<pre><code>&gt;&gt; get select [alpha: true beta: _] 'gamma
** Error: GET doesn't accept NULL for its VAR argument (use MAYBE if intended)

&gt;&gt; maybe select [alpha: true beta: _] 'gamma
; void

&gt;&gt; get maybe select [alpha: true beta: _] 'gamma
; null
</code></pre>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I have this sense that the BLANK-NULL-VOID-ERROR story has too many actors with overlapping roles.</p>
</blockquote>
</aside>
<p>It is a work in progress...but...I believe there's plenty of evidence that things are pointing toward a solid outcome.</p>
<p>The proof comes from the code: the contrast between what the approaches without it can't do (and how catastrophically they regularly fall down) vs. what the approaches with them can do cleanly and correctly.</p>
<p>UPARSE is a giant piece of evidence, but I think there's quite a lot more.</p>
<div class="onebox lazyYT lazyYT-container" data-youtube-id="H6_eqxh-Qok" data-youtube-title="Too Many Notes" data-parameters="feature=oembed&amp;wmode=opaque">
  <a href="https://www.youtube.com/watch?v=H6_eqxh-Qok" target="_blank" rel="noopener">
    <img class="ytp-thumbnail-image" src="https://i.ytimg.com/vi/H6_eqxh-Qok/maxresdefault.jpg" title="Too Many Notes" width="690" height="388">
  </a>
</div>
 ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/5</link>
        <pubDate>Fri, 26 Aug 2022 06:36:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6330</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@rgchris Chris]]></dc:creator>
        <description><![CDATA[ <p>There's a lot to ponder here. I think on the one hand it's important to explore all of the possibilities, on the other it seems to be getting awfully convoluted and lacking a comprehensive narrative.</p>
<p>I'm not up to speed with much of what has changed in this realm for some time, so I apologise if this glosses over some since settled items, though judging by this post, there's much still unsettled.</p>
<p>For me (using the family name) Rebol's first obligation is to represent data—both in language and the way the language is interpreted in memory. Specifically BLANK! and its underscore literal is a huge win (this is from me, the ultra-conservative sceptic) in representing positive nothingness—that a thing exists but lacks assignation: <code>[name: "Thing" link: _]</code>. Despite that positivity, I do think that as it represents the known absence of a value in data, it should be falsey in the general flow that data primarily should determine that flow.</p>
<p>What it becomes in a dialect or within the general flow as distinct from NULL is of lesser importance as I see it. If NULL is the evaluator's ultimate representation of nothingness, then there should be a way to access that in internal dialects, such as SET-BLOCK! or PATH! and the like or it is not really fulfilling its role.</p>
<p>I have this sense that the BLANK-NULL-VOID-ERROR story has too many actors with overlapping roles. I don't have anything tangible to back that up with at this time.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/4</link>
        <pubDate>Fri, 26 Aug 2022 01:55:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6329</guid>
      </item>
      <item>
        <title>Weird Little Function: STEAL a Variable&#39;s Prior Value</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1943">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I'm sure I've seen places I could have used it if I thought of it.</p>
</blockquote>
</aside>
<p>I just found one in the %prot-http.r code, which I found while reviewing blank uses:</p>
<pre><code>; The port data has been accrued for the client and can be given back
; directly, not as a copy.  If the port data is BLANK!, this returns NULL.
;
return (opt port.data, elide port.data: _)
</code></pre>
<p>Not only does that show a good example of "we shouldn't have to be converting between blanks and nulls, just use NULL".  But it's an opportunity to steal:</p>
<pre><code>return steal port.data: _
</code></pre>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1943">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I wrote it as a variadic function for some reason (as a test, maybe?)</p>
</blockquote>
</aside>
<p>Ah, no.  It was to be able to work with constructs that do backwards quoting:</p>
<pre><code>steal x: default [20]
</code></pre>
<p>If STEAL consumes the X:, then DEFAULT won't see it.</p>
<p>Hence it peeks variadically long enough to see X: but does not consume it.  Then it does one unit of evaluation (to run the x: default [20]) but keeps itself on the stack.  This way it can return the original value.</p> ]]></description>
        <link>https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943/2</link>
        <pubDate>Fri, 26 Aug 2022 00:00:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6328</guid>
      </item>
      <item>
        <title>Thinking About Isotopes Logically: ~true~ and ~false~</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Here's an idea: what if <strong>~true~</strong> and <strong>~false~</strong> are examples of weird isotopic exceptions.</p>
<p>Let's say you could assign them to variables...and fetch them from variables...without erroring:</p>
<pre><code>&gt;&gt; true: ~true~
== ~true~  ; isotope

&gt;&gt; false: ~false~
== ~false~  ; isotope

&gt;&gt; obj: make object! [y: true, n: false]
== make object! [
     y: ~true~
     n: ~false~
]
</code></pre>
<p><em>(not being quoted in the assignment indicates they become their isotopic forms.)</em></p>
<p>This is typically not legal...accessing a WORD! isotope from a variable like true would be an error.  But these would be special (like how I'm suggesting isotopic ACTION! would be special in running the action from a word reference...)</p>
<p>Things that tested for truthiness would treat them as expected, considering the ~false~ isotope to be a falsey thing:</p>
<pre><code>&gt;&gt; any [true false]
== ~true~  ; isotope

&gt;&gt; all [true false]
; null
</code></pre>
<p><em>Being isotopes comes with a constraint</em>...you couldn't put them into blocks.  You'd have to ^META them (which would lose their special status, turning them into QUASI-WORD!s...that were truthy.</p>
<pre><code>&gt;&gt; ^ false
== ~false~

&gt;&gt; if ^ false [print "Meta false is truthy"]
Meta false is truthy
</code></pre>
<p>The functions TRUE? and FALSE? could then work on isotopic, non-isotopic, or word forms of TRUE and FALSE...but error if passed other values.</p>
<ul>
<li>
<p><strong>This should work for casual cases of just having variables that hold a true or false state...and gives a good appearance for knowing what you're looking at.</strong></p>
</li>
<li>
<p><strong>It builds on standard mechanisms, and hence if you need to promote the isotopic state into something that can be represented in a block you can do so... with the caveat that once you do, it will no longer reflect its logical property when used with IF and such.</strong></p>
<ul>
<li><strong>That's true for NULL being ^META promoted and put in blocks as well.</strong></li>
</ul>
</li>
</ul>
<p><strong>And crucially: Since you know isotopes can't be in blocks--and if we say BLANK! is truthy as well--then you'd be guaranteed to visit all the items in a block with code like this:</strong></p>
<pre><code>while [item: try take block] [
    print mold item
]
</code></pre>
<p>This is easily the best idea so far for dealing with the problem.</p> ]]></description>
        <link>https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944/1</link>
        <pubDate>Thu, 25 Aug 2022 23:34:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6327</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Question 3: Should BLANK! Evaluate to NULL ?</p>
</blockquote>
</aside>
<p>I worked up a test for this and I have to say that it looks very good.</p>
<p><em>Now that I've seen it, I don't want to go back.</em>  Ren-C aims for solid and pleasing parts... and the lone apostrophe doesn't have that solidity for something so fundamental.</p>
<p>So it means that we'll have to use <strong>#</strong> as a non-reducing placeholder, or find some other solution.  I'll keep thinking about making my space (character) dreams come true.</p>
<h2>But There Are Some Issues With Quoting To Work Out</h2>
<p>Previously in COMPOSE, it had this behavior:</p>
<pre><code>&gt;&gt; compose [x: (null)]
** Error: Can't use NULL in a GROUP! with no quotes

&gt;&gt; compose [x: '(null)]
== [x: ']

&gt;&gt; do compose [x: ']
; null

&gt;&gt; x
; null
</code></pre>
<p>That's pretty slick.  But if we ban quotes of nothing, we have a problem in this case.</p>
<p>BLANK! acts like a quoted void, but do we want it to appear as the result of a quoting operation?</p>
<pre><code>&gt;&gt; compose [x: '(null)]
== [x: _]
</code></pre>
<p>That doesn't feel right.  I asked to quote the thing that was in the group, so I expect a QUOTED! in that spot.</p>
<p>If we say that _ is the <em>actual</em> quoted representation of blank, that gives us confusing answers:</p>
<pre><code>&gt;&gt; type of first [_]
== #[datatype! quoted!]

&gt;&gt; quotes of first [_]
== 1

&gt;&gt; quotes of first ['_]
== 2
</code></pre>
<p><strong>This gives rise to the somewhat odd situation that quoted nulls <em>exist</em>, but they're just not the ^META form.</strong></p>
<pre><code>&gt;&gt; quote null
== '

&gt;&gt; meta null
== _
</code></pre>
<p>Curiously, both of them would be producing something that evaluates back to NULL.</p>
<p>Because I've only just tried this, I haven't fully absorbed what the downsides might be.  I'll look at it some more.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/3</link>
        <pubDate>Thu, 25 Aug 2022 20:45:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6326</guid>
      </item>
      <item>
        <title>Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was merged into an existing topic: <a href="/t/blank-2022-revisiting-the-datatype/1942/2">BLANK! 2022: Revisiting The Datatype</a></p> ]]></description>
        <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799/6</link>
        <pubDate>Thu, 25 Aug 2022 17:36:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6325</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1799">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799/5">Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</a>
</div>
<blockquote>
<p>Changing DEFAULT to not consider BLANK! is an obvious enough improvement to go ahead and do it</p>
</blockquote>
</aside>
<p>Hm.</p>
<p>We lose something here, which is the visual pleasingness of blanks:</p>
<pre><code>settings: make object! [
    alpha: "something"
    beta: _
    gamma: _
    delta: "something else"
    zeta: "yet another thing"
]
</code></pre>
<p>If you have to go to the WORD! for NULL... it's not worse than Rebol2/Red's NONE, but...</p>
<pre><code>settings: make object! [
    alpha: "something"
    beta: null
    gamma: null
    delta: "something else"
    zeta: "yet another thing"
]
</code></pre>
<p>...but...I don't care for that as much.</p>
<p>You can use a quoted null as a single apostrophe, but that's really slight and feels incomplete, beyond the already kind-of-incomplete-feeling all quoteds might give people:</p>
<pre><code>settings: make object! [
    alpha: "something"
    beta: '
    gamma: '
    delta: "something else"
    zeta: "yet another thing"
]
</code></pre>
<p>Your code editor could stylize that to make it more apparent.  And maybe we could say that's what you should do if you're the type to not want to type out NULL.</p>
<h2>Question 3: Should BLANK! Evaluate to NULL ?</h2>
<p>We could say that you can't QUOTE a NULL, only ^META it to a BLANK!.</p>
<pre><code>&gt;&gt; quote void
** Error: You can't quote voids.

&gt;&gt; quote null
** Error: You can't quote nulls.

&gt;&gt; meta void
== ~

&gt;&gt; meta null
== _
</code></pre>
<p>This would mean BLANK! would evaluate to NULL:</p>
<pre><code>&gt;&gt; _
; null
</code></pre>
<p>It would look better in object renderings.</p>
<pre><code>&gt;&gt; make object! [x: "abc" y: null z: "def"]
== make object! [
     x: "abc"
     y: _
     z: "def"
]
</code></pre>
<p>People looking for placeholders that don't reduce would have to use something else... but we have another candidate with the <strong><code>#</code></strong> which might be even better.  It acts as the NUL character:</p>
<pre><code>&gt;&gt; append #{FFFF} #
== #{FFFF00}
</code></pre>
<p>It wouldn't be the first time # was thought of as a "none" representation, R3-Alpha did that...but then didn't use it as the rendering:</p>
<pre><code>r3-alpha&gt;&gt; #   
== none
</code></pre>
<p><strong>I've always thought the single apostrophe was a bit slight.</strong>  So I like that aspect.</p>
<p>Giving BLANK! an evaluator behavior to produce nulls messes with its applications in things like UNSPACED and DELIMIT, which would be unfortunate.</p>
<p>That's not to say they couldn't be dialects and subvert the evaluator...but if people got used to using them for making nulls everywhere then they might be surprised to find another behavior.</p>
<p>It could suggest switching to # for it.</p>
<pre><code>&gt;&gt; unspaced ["A" # # "B"]
== "A  B"
</code></pre>
<p>The problem being that in the pattern of meaning, the # is codepoint 0 (because it has no string material).  You can't put that in strings, so right now that's an error.</p>
<p>There's periods... empty 2-element tuples:</p>
<pre><code>&gt;&gt; unspaced ["A" . . "B"]
== "A  B"
</code></pre>
<p>But I imagine that's something we'd want to make a WORD! exception, like slash, so that people can define it as some kind of operator.</p>
<p>You could quote the blanks:</p>
<pre><code>&gt;&gt; unspaced ["A" '_ '_ "B"]
== "A  B"
</code></pre>
<p>That's... not what I had in mind, but you have to delimit everything else to use it literally:</p>
<pre><code>&gt;&gt; unspaced ['A '_ '_ 'B]
== "A  B"
</code></pre>
<p><strong>The greater good of the system for visual appeal of NULL may mean making sacrifices on this BLANK! for spaces issue.</strong></p>
<h2>Note: It ALMOST gets us to the FOR-BOTH harmony...</h2>
<p>If BLANK! stayed falsey, then looking back at this:</p>
<pre><code>for-both: lambda ['var blk1 blk2 body] [
    unmeta all [
        meta for-each (var) blk1 body
        meta for-each (var) blk2 body
    ]
]
</code></pre>
<p>It's just one little teeny bit off... it produces a QUASI!-null for void, which does not vanish.</p>
<p>Before I said the WORD! form of META was distinct because it did not meta voids, but passed them through</p>
<pre><code>&gt;&gt; meta void
; void

&gt;&gt; ^ void
== ~

&gt;&gt; meta* void
== ~
</code></pre>
<p>So <strong>^</strong> was actually equivalent to <code>META*</code>.  It's a bit of a bend.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/2</link>
        <pubDate>Thu, 25 Aug 2022 17:35:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6324</guid>
      </item>
      <item>
        <title>Weird Little Function: STEAL a Variable&#39;s Prior Value</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>I don't know if it has the best name (suggestions?), but it's kind of interesting...</p>
<pre><code>&gt;&gt; x: 304
== 304

&gt;&gt; steal x: 1000 + 20
== 304

&gt;&gt; x
== 1020
</code></pre>
<p>I wrote it as a variadic function for some reason (as a test, maybe?) but you could write it in Redbol.  You could even use their lame ALSO.</p>
<pre><code>steal: func [
    {Red version}
    'var [set-word! set-path!]
    value [any-type!]
][
    also get var set var value
]
</code></pre>
<p>The Ren-C version of that reads a lot better:</p>
<pre><code>steal: lambda [
    {Ren-C version}
    'var [set-word! set-path!]
    value [any-value!]
][
    get var
    elide set var value
]
</code></pre>
<p>It naturally has the benefit of letting you break things across lines.  I feel like it's better to point out "this is the thing being erased".  And of course the mechanic is far more general.</p>
<p>I definitely like ANY-VALUE! better than ANY-TYPE!.</p>
<p>Anyway, I'm sure I've seen places I could have used it if I thought of it.  I'll keep my eyes open.</p> ]]></description>
        <link>https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943/1</link>
        <pubDate>Thu, 25 Aug 2022 16:27:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6323</guid>
      </item>
      <item>
        <title>Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Yup, good point.</p>
<p>Changing DEFAULT to not consider BLANK! is an obvious enough improvement to go ahead and do it--the truthy/falsey status notwithstanding.</p> ]]></description>
        <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799/5</link>
        <pubDate>Thu, 25 Aug 2022 16:08:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6322</guid>
      </item>
      <item>
        <title>Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>... and if blank! becomes truthy as per your other post there’s one less case to worry about.</p> ]]></description>
        <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799/4</link>
        <pubDate>Thu, 25 Aug 2022 15:53:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6321</guid>
      </item>
      <item>
        <title>Should END-able constructs all use ^META parameters?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1783">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But at least you could differentiate NULL from an end. The conflation of an invisible argument with the end doesn't seem that troubling to me, as the problem with HELP is fixed since it quotes and can tell when you say <strong>help ~void~</strong> vs. plain <strong>help</strong></p>
</blockquote>
</aside>
<p><strong>...but now...there is a solution!</strong></p>
<p>I've mentioned how we're now at a point where when you ^META things you always get something that's either QUOTED! or QUASI!, <a href="https://forum.rebol.info/t/the-meta-of-null-and-void/1941">because the edges of VOID and NULL are now spoken for</a></p>
<pre><code>&gt;&gt; meta null
== '

&gt;&gt; meta void
== ~
</code></pre>
<p>That leaves a ton of representations open for what an <code>&lt;end&gt;</code> could be... but of course the best one jumps out at us right away... NULL !</p>
<p><strong>NULL is now a viable ^META answer for "I couldn't even get you that meta argument you wanted"!</strong>  And it has just the right amount of orneryness.  Easy to check for, and you won't likely be passing it on to places</p>
<p>With that issue solved, we can come back to the original question:</p>
<h2>Should END-able constructs all use ^META parameters?</h2>
<p>I have reasons beyond the scope of this post, but:</p>
<ul>
<li>
<p>I think you should be able to make any parameter endable</p>
</li>
<li>
<p>It's probably best if NULL is used to represent that across the board.</p>
</li>
<li>
<p>This doesn't create conflation in the case of quoted arguments (you can't quote a NULL because nulls can't exist in the input array or variadic feed)</p>
</li>
<li>
<p>There won't be conflation for typed normal parameters, like <strong><code>arg [word! integer! &lt;end&gt;]</code></strong></p>
<ul>
<li>If the conflation bothers you then you are officially a fancy-pants client... use <strong><code>^arg</code></strong>
</li>
</ul>
</li>
</ul> ]]></description>
        <link>https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783/3</link>
        <pubDate>Thu, 25 Aug 2022 14:45:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6320</guid>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Long, long ago there was a datatype called NONE.  In historical Redbol, it had the bad habit of looking like a WORD!:</p>
<pre><code>rebol2&gt;&gt; 'none
== none

rebol2&gt;&gt; none
== none  ; same in R3-Alpha and Red
</code></pre>
<p>But it wasn't a word:</p>
<pre><code>rebol2&gt;&gt; type? 'none
== word!

rebol2&gt;&gt; type? none
== none!
</code></pre>
<p>It was a distinct type, which also happened to be falsey (while WORD!s are truthy):</p>
<pre><code>rebol2&gt;&gt; if 'none [print "Truthy word!"]
Truthy word!

rebol2&gt;&gt; if none [print "Falsey none!"]
== none
</code></pre>
<p>And as we can see, NONE!s served purposes of signaling "soft failures": branches that didn't run, or FINDs that didn't find, or SELECTs that didn't select... etc.</p>
<pre><code>rebol2&gt;&gt; find "abcd" "z"
== none

rebol2&gt;&gt; select [a 10 b 20] 'c
== none
</code></pre>
<h2>Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!</h2>
<ul>
<li>
<p><strong>NULL</strong> - a non-ANY-VALUE! state that couldn't be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use NULL.</p>
<pre><code>&gt;&gt; find "abcd" "z"
; null

&gt;&gt; select [a 10 b 20] 'c
; null

&gt;&gt; append [a b c] null
** Error: APPEND doesn't allow NULL
</code></pre>
</li>
<li>
<p><strong>VOID</strong> - the "isotopic" form of NULL, which represents the result of things that are effectively "no ops".  Unlike nulls, they will vanish in-between expressions, and when functions like APPEND get them as an argument they are treated as no-ops:</p>
<pre><code>&gt;&gt; if null [print "Doesn't print as NULL is falsey"]
; void

&gt;&gt; 1 + 2 if null [print "Voids disappear..."]
== 3

&gt;&gt; append [a b c] void
== [a b c]
</code></pre>
<p>Void is also the state of unset variables.</p>
<pre><code>&gt;&gt; unset 'foo
; void

&gt;&gt; get/any 'foo
; void
</code></pre>
</li>
<li>
<p><strong>BLANK!</strong> was represented by a lone underscore ( <strong><code>_</code></strong> ) and could be put into blocks:</p>
<pre><code>&gt;&gt; append [a b c] _
== [a b c _]
</code></pre>
<p>It retained the choice to be falsey:</p>
<pre><code>&gt;&gt; if _ [print "Won't print because blanks are falsey"]
</code></pre>
</li>
</ul>
<h2>Question One: Could BLANK! Just Be A WORD! ?</h2>
<p>You might wonder if you could just say:</p>
<pre><code>&gt;&gt; _: '_
== _
</code></pre>
<p>This would give you BLANK! as a WORD! that had the behavior of reducing to itself.</p>
<pre><code>&gt;&gt; reduce [_ 1 + 2 _]
== [_ 3 _]
</code></pre>
<p>That could be just a default, and you could redefine it to anything you wanted.  Generally speaking, people do like being able to define words as operators... and _ has historically been a WORD! (Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word).</p>
<p>But outside of being hardcoded as falsey, what makes BLANK! fairly "built in" is that in the path mechanics, it fills in the empty slots:</p>
<pre><code>&gt;&gt; to path! [_ a]
== /a

&gt;&gt; as block! 'a//b//c
== [a _ b _ c]
</code></pre>
<p>Alternately, we could get a "reified nothing" with a quoted null:</p>
<pre><code>&gt;&gt; to path! [' a]
== /a

&gt;&gt; as block! 'a//b//c
== [a ' b ' c]
</code></pre>
<p>But there's other places the blank is used, such as to opt-out of multi-returns.</p>
<pre><code>&gt;&gt; [_ pos]: transcode "abc def"
; void

&gt;&gt; pos
== " def"
</code></pre>
<p>So freeing it up to be an arbitrary variable feels kind of wrong, as if it were taken for dialects like multi-return you'd be unable to set it as a variable.</p>
<p>This may be an argument for using something like a TAG! instead, so you're not worrying about overlapping with user variables:</p>
<pre><code>[&lt;_&gt; pos]: transcode "abc def"
</code></pre>
<p>Similar arguments have led me to contemplate the dangers of using things like <strong><code>[a b ...]:</code></strong> in case someone has assigned a meaning to the ellipsis.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">  That might be a good reason to keep <strong><code>...</code></strong>  as a TUPLE! instead of a WORD! exception, because no one could assign it.</p>
<p><strong>I'm pretty sure we should keep _ reserved as a BLANK! datatype, not a WORD!.</strong>  People can still give it arbitrary meanings in dialects, they just can't assign values to it as a variable... and they can't do that with <strong><code>#</code></strong> either or <strong><code>&lt;a&gt;</code></strong> so I can live with it.  Taking it away from the word pool does more good than harm.</p>
<h2>Question Two: Does BLANK! Still Need To Be Falsey?</h2>
<p><em>My feeling is that having blank be falsey doesn't have all that much benefit.</em>  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:</p>
<pre><code>&gt;&gt; append [a b c] all [1 &lt; 2, 3 &lt; 4, _]
== [a b c _]  ; would seem nice, but gives error today since ALL is NULL
</code></pre>
<p>Thinking of BLANK! as being "null-like" in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:</p>
<pre><code>&gt;&gt; item: _

&gt;&gt; item: default [1 + 2]
== ???
</code></pre>
<p>In practice, I prefer the truly non-valued NULL (and its isotopic state of VOID) being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as "not being assigned"... as you'll get errors when you try to use it places (e.g. in APPEND).  Trying to use it to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)</p>
<p>Also, the asymmetry between BLANK! and NULL were part of a scheme to try and solve what Redbols called "NONE! propagation":</p>
<pre><code>&gt;&gt; second null
** Error: SECOND doesn't take NULL

&gt;&gt; try null
== _

&gt;&gt; second try null
== null
</code></pre>
<p><strong>We still want this general concept, but <a href="https://forum.rebol.info/t/definitional-errors-as-blank-in-null-out-alternative/1880/7">the new idea is that it's VOID which opts out</a> cleanly from these operations, and MAYBE is the operator that produces them.</strong></p>
<p>This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I've said "blanks are to blocks what space is to strings".  And space is truthy:</p>
<pre><code>&gt;&gt; if second "a b" [print "Space is truthy"]
Space is truthy

&gt;&gt; if second [a _ b] [print "So why shouldn't blank be truthy?"]
???
</code></pre>
<p><strong>So I Suggest The Removal of BLANK! From Being Falsey</strong>.  This creates some incompatibility in Redbol (which has been using NONE! as a blank substitute).  But it's something that can be worked around.</p> ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/1</link>
        <pubDate>Thu, 25 Aug 2022 13:50:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6319</guid>
      </item>
      <item>
        <title>Definitional Errors as BLANK!-in-NULL-out Alternative</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1880">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>The Achilles Heel: What if a Function Has Meaning for BLANK! ?</strong></p>
<p><strong>An Atomic-Age Solution <img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=9" title=":atom_symbol:" class="emoji" alt=":atom_symbol:"> Let TRY Defuse Isotopic Errors</strong></p>
</blockquote>
</aside>
<h2>NEVERMIND...I Have a Better Idea <img src="https://forum.rebol.info/images/emoji/twitter/bulb.png?v=9" title=":bulb:" class="emoji" alt=":bulb:"> ... USE VOID!</h2>
<p>VOID has all the properties we're looking for, here.  It's basically about as out-of-band as a definitional error is--at least for the kinds of functions we're talking about.</p>
<ul>
<li>
<p>It really isn't supposed to have meaning to any routine, so "no op" is about the best reaction to "hey, you got a void".</p>
</li>
<li>
<p>Like NULL, it can't be stored in blocks (in fact, <a href="https://forum.rebol.info/t/the-meta-of-null-and-void/1941">it is now the isotopic form of NULL</a>)</p>
</li>
<li>
<p>Unlike NULL, it's not easy to get out of variables...so if you manage to generate a void, you probably did it on purpose.</p>
</li>
<li>
<p>There's a nice operator for turning NULL into VOID called MAYBE.</p>
</li>
<li>
<p>Control constructs return VOID when none of their branches run, so there's a bunch of functions you can draw from that effectively "fold the MAYBE in"</p>
</li>
</ul>
<p>It looks like success to me:</p>
<pre><code>&gt;&gt; case [false [[a b c]]]
; void

&gt;&gt; second case [false [[a b c]]]  ; "opt out" gives you a first step w/o error
; null

&gt;&gt; first second case [false [[a b c]]]
** Error: FIRST doesn't take NULL as input (use MAYBE to opt out via VOID)

&gt;&gt; first maybe second case [false [[a b c]]]
; null

&gt;&gt; first second case [true [[a [b] c]]]
== b
</code></pre>
<p><strong><a href="https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912">This saves TRY for its higher calling</a></strong>... I think that story is that TRY shouldn't just be a simple matter of "return null on definitional error", but rather something that can return a no-op result if the asked for thing can't be done.</p>
<pre><code>&gt;&gt; unquote first ['abc]
== def

&gt;&gt; unquote first [def]
** Error: Can't unquote something with no quote marks on it

&gt;&gt; try unquote first [def]
== def</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/definitional-errors-as-blank-in-null-out-alternative/1880/7</link>
        <pubDate>Thu, 25 Aug 2022 12:24:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6318</guid>
      </item>
      <item>
        <title>Why (or why not) have UNSET! in Rebol-like Languages</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="113">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It's strange how uneducated minds work.</p>
</blockquote>
</aside>
<p>This GitHub Issue is one of the many places where you can see Red suffering: <a href="https://github.com/red/red/issues/5183">https://github.com/red/red/issues/5183</a></p>
<p>Whereas Ren-C is doing quite well: <a href="https://forum.rebol.info/t/incomplete-transcodes-actually-an-optimization-problem/1940" class="inline-onebox">Incomplete TRANSCODEs: Actually an Optimization Problem</a></p>
<p>It's kind of like I have a patent on zero (NULL), negative numbers (QUASI!), and <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">imaginary numbers (isotopes)</a>... and they're trying to do math without them.  <span class="hashtag">#goodluckwiththat</span> !</p> ]]></description>
        <link>https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/5</link>
        <pubDate>Thu, 25 Aug 2022 11:03:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6317</guid>
      </item>
      <item>
        <title>How to Subvert Voidification?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1304">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So there were two potential motivations you might want to mark a branch to subvert this:</p>
<ul>
<li>
<strong>honest</strong> - The <a class="mention" href="/u/rgchris">@rgchris</a> reason (<em>"don't corrupt my value...it's a NULL and I meant NULL"</em>)</li>
<li>
<strong>dishonest</strong> - A desire to communicate to an adjoining ELSE-or-THEN-like-construct that although you took a branch and ran code, you didn't take a branch...so it reacts as if you hadn't.</li>
</ul>
</blockquote>
</aside>
<p>I realized there's a new and interesting mechanism we can throw in here for the "honest uses"... that is to go through ^META mechanisms and then UNMETA it.</p>
<p>This is enabled by the new rules, <strong><a href="https://forum.rebol.info/t/the-meta-of-null-and-void/1941">where no ^META type is either NULL or VOID</a></strong>.</p>
<pre><code>&gt;&gt; ^(null)
== '

&gt;&gt; ^(void)
== ~
</code></pre>
<p>As I explain in the linked post, I had once thought that making ^META of NULL be NULL had an advantage, by letting things like ELSE react to a NULL despite its containment .  Yet having it be purely contained means that NULL and VOID are available for other meanings.</p>
<p>So CASE has it avaliable unambiguously for signaling purposes!</p>
<pre><code>wrapper: func [x y] [
    unmeta case [
        x &gt; y ^[wrapped x + y]
        x &lt; y ^[wrapped x - y]
    ] else ^[
       0
    ]
]
</code></pre>
<p>The branch form <strong>^[...]</strong> is supported by all branching constructs.  But we could also imagine CASE itself offering a ^META level overall by having using a meta block for its cases list:</p>
<pre><code>wrapper: func [x y] [
    unmeta case ^[
        x &gt; y [wrapped x + y]
        x &lt; y [wrapped x - y]
    ] else ^[
       0
    ]
]
</code></pre>
<p>While this won't likely be Chris's favorite method of doing things...<em><strong>it is interesting because it's an option that actually works, under my "honest" standard set above.</strong></em>  It acts with fidelity to running the ELSE on only cases where no branch gets taken.</p> ]]></description>
        <link>https://forum.rebol.info/t/how-to-subvert-voidification/1304/3</link>
        <pubDate>Thu, 25 Aug 2022 08:44:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6316</guid>
      </item>
      <item>
        <title>Q: Should ~ Be The Unevaluated Form of VOID ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <h3>Q: Should ~ Be The Unevaluated Form of VOID ?</h3>
<h1>YES!</h1>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/8555a2e5222dc45cea3ee83ad6b1069b882006b0.jpeg" data-download-href="https://forum.rebol.info/uploads/default/8555a2e5222dc45cea3ee83ad6b1069b882006b0" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/8555a2e5222dc45cea3ee83ad6b1069b882006b0_2_301x249.jpeg" alt="image" data-base62-sha1="j1wYFpyDX7Pew015FWqQtq3Pks0" width="301" height="249" srcset="https://forum.rebol.info/uploads/default/optimized/1X/8555a2e5222dc45cea3ee83ad6b1069b882006b0_2_301x249.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/8555a2e5222dc45cea3ee83ad6b1069b882006b0_2_451x373.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/8555a2e5222dc45cea3ee83ad6b1069b882006b0_2_602x498.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/8555a2e5222dc45cea3ee83ad6b1069b882006b0_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">700×580 65.9 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<h2>So "Unset Variables" Are Now Void</h2>
<p>^META of void is the <strong>~</strong> quasiform, which is quasi NULL</p>
<pre><code>&gt;&gt; quasi null
== ~

&gt;&gt; meta void
== ~

&gt;&gt; 1 + 2 ~
== 3
</code></pre>
<p>There's a special exemption in variable assignment to allow the assign of void</p>
<p>Then "none"--the invisible result we don't print in the evaluator--is isotopic BLANK!.</p>
<pre><code>&gt;&gt; mold quasi blank
== ~_~

&gt;&gt; unmeta quasi blank  ; will print nothing, because console ignores it

&gt;&gt; none  ; shorthand for constructing nones
</code></pre>
<p>It's ugly, but why worry about what it looks like if it doesn't get printed out?  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1915">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>&gt;&gt; var: ~
; void 

&gt;&gt; compose [&lt;a&gt; (get/any 'var) &lt;b&gt;]
== [&lt;a&gt; &lt;b&gt;]
</code></pre>
<p>This still makes me uneasy, because it doesn't feel "ornery" enough. You have a variable that may have potentially never been set, and are being very quiet about its usage.</p>
</blockquote>
</aside>
<p>I think it turns out that on the whole, being able to store void in variables gives the system a missing completeness.  It becomes roundabout when you can't.  If we think it's too easy to get void variables then that could be a special parameter, like <strong>get/any/void 'var</strong></p>
<p>I'll say that mechanically it was hard to figure out <em>how</em> to store voids in variables.  Think about it: if every time you write a void all it does is leave whatever's in the cell there, then "voids aren't values".</p>
<p>But as the system-wide support of voids expanded, the evaluator got more clever.  It has a running notion of whether a frame output cell is stale--where it can recover the output if no further evaluations are non-void.  Yet it can also tell if something has never been written.  So if something has never been written and is stale, then you can write this state into variables as well.</p>
<p>It's looking good now... with ~ being the meta of void and ' being the meta of null.  They both share the same "heart" signal (0 byte), and voids are basically null isotopes.  It works out well.</p> ]]></description>
        <link>https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915/4</link>
        <pubDate>Thu, 25 Aug 2022 07:26:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6315</guid>
      </item>
      <item>
        <title>Q: Should ~ Be The Unevaluated Form of VOID ?</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was split to a new topic: <a href="/t/the-meta-of-null-and-void/1941">The ^META of NULL and VOID</a></p> ]]></description>
        <link>https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915/2</link>
        <pubDate>Thu, 25 Aug 2022 07:06:21 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6314</guid>
      </item>
      <item>
        <title>Discouraging use of TRAP</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Recent experiences has only confirmed what I already know: <strong>intercepting arbitrary errors--of the non-definitional sort--is ALMOST NEVER a good idea.</strong></p>
<p>Definitional errors are pretty much the only kind you can react to.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1871">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Might We Make [TRAP] Look More "Special" To Discourage Use?  I thought at minimum we should move it to a place that shows it's more of a "system utility" than a "language feature".</p>
<p>So calling it <strong><code>SYS.UTIL.TRAP</code></strong> would be a step in that direction.</p>
<p>And as long as we're discouraging use of this, it seems a bit of a waste to take such a short name. It could be <strong><code>SYS.UTIL.TRAP-ANY-ERROR</code></strong> or similar, and then TRAP could be used for something should be used more often.</p>
</blockquote>
</aside>
<p>TRAP has a nice interface for use with definitional errors, when you don't want to use the enfix EXCEPT.</p>
<p>Its interface is reversed from ATTEMPT--instead of returning NULL on failure, it returns NULL on success... and on failure returns the error.  There's a secondary multi-return for the return product if you want it.  (ATTEMPT should probably have a secondary return result for the error, which would give good symmetry.)</p>
<p>Internally to the system in API calls, unpacking multi-returns from a C API call is tricky.  So I usually use something I've called ENTRAP.  This gives back a ^META return result overlaid with an ERROR!.  So you get:</p>
<ul>
<li>
<p>a plain ERROR! on failure</p>
</li>
<li>
<p>A QUASI! item like ~foo~ if the  result was an isotope</p>
<ul>
<li>This includes tilde (~) if the code evaluated to a VOID</li>
</ul>
</li>
<li>
<p>A QUOTED! if it was a normal evaluation</p>
<ul>
<li>This includes Lone-Apostrophe-Quote (<strong><code>'</code></strong>) if the code evaluated to a NULL</li>
</ul>
</li>
</ul>
<p>It's easy enough to test for errors.</p>
<pre><code>result: entrap [
    ...your code being trapped goes here...
]

if error? result [
    ...code responding to the result (an ERROR!)...
] else [
    ...process result (it's META'd)
]
</code></pre>
<p>You can't use it sensibly with THEN and ELSE (it would always run THEN).  Since it's a special construct we could pick a state to return NULL for... e.g. instead of quoted null, which might be convenient... but probably only if we were premissive and said UNMETA would turn NULL into NULL.  :-/  Probably not a good idea.</p>
<h2>So If All TRAPs Are Definitional, What's The "RESCUE" Operation?</h2>
<p>Other languages have gone with calling general exception catching of this sort "RESCUE".</p>
<p>So we could have something called SYS.UTIL.RESCUE.  The word sounds like it should have the interface of TRAP:</p>
<pre><code>sys.util.rescue [
    .. dangerous code
] then error -&gt; [
   ... "then" implies "if we rescued, then run this code w/error"
] else [
   ... it succeeded
]
</code></pre>
<p>That seems all right.  But having a version called ENRESCUE doesn't make too much sense.  :-/</p>
<p>Perhaps the meta behavior on these functions should just be controlled by a refinement.</p>
<pre><code>&gt;&gt; trap [1 / 0]
== make error! [...]

&gt;&gt; trap [1 + 2]
; no error

&gt;&gt; trap/meta [1 / 0]
== make error! [...]

&gt;&gt; trap/meta [1 + 2]
== '3 
</code></pre>
<p>Then the same refinement could be used with RESULT.</p>
<p>The error won't be ^META'd either way, so calling the refinement /META is a little confusing...but maybe not confusing enough to outweigh the benefit of reminding you that the result is meta'd in there.</p>
<h2>Not Sure, But... Overall Point is TRAP Should Be Definitional</h2>
<p>TRAP is a nice word with useful functionality, and we shouldn't sacrifice it for an error handling mechanism that is "unsafe at any speed".</p>
<p>I think SYS.UTIL.RESCUE sounds like it should suffice.  It's sort of a "yes, it's there, don't use it" kind of thing (due to the interception of typos and all the other reasons).</p> ]]></description>
        <link>https://forum.rebol.info/t/discouraging-use-of-trap/1871/3</link>
        <pubDate>Thu, 25 Aug 2022 05:38:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6313</guid>
      </item>
      <item>
        <title>VID/S or Spaces, from Red&#39;s hiiamboris</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>Boris's Red Spaces <a href="https://codeberg.org/hiiamboris/red-spaces/src/branch/master/stylesheets/glossy.red">now supports "style sheets" of a kind</a>, so you can make themes:</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/b27ed2ca33a3e45d1ca5134db0a850af3f048728.gif" data-download-href="https://forum.rebol.info/uploads/default/b27ed2ca33a3e45d1ca5134db0a850af3f048728" title="styled"><img src="https://forum.rebol.info/uploads/default/original/1X/b27ed2ca33a3e45d1ca5134db0a850af3f048728.gif" alt="styled" data-base62-sha1="pt2HS4RRFmLBtD3lcqu2BvcuWgM" width="690" height="429" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/b27ed2ca33a3e45d1ca5134db0a850af3f048728_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">styled</span><span class="informations">1102×686 833 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>I don't really have time (yet) with everything else going on to evaluate this stuff.  So I'd rather whatever audience Red can get hammers on it to filter out what's good.</p>
<p>(At some point I'll try my hand at a GUI dialect, but I'd like to be reacting to the polished and critiqued version of whatever evolves out of their world.)</p> ]]></description>
        <link>https://forum.rebol.info/t/vid-s-or-spaces-from-reds-hiiamboris/1886/3</link>
        <pubDate>Tue, 23 Aug 2022 07:41:22 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6312</guid>
      </item>
      <item>
        <title>Incomplete TRANSCODEs: Actually an Optimization Problem</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p><strong>Ren-C has a very slick multi-return interface for TRANSCODE.</strong>  The mere request of a "remainder" of data left indicates you're not trying to do a full scan.</p>
<p>Without the request, you get the whole thing:</p>
<pre><code>&gt;&gt; transcode "abc def"
== [abc def]

; ...or...

&gt;&gt; value: transcode "abc def"
== [abc def]

; ...or...

&gt;&gt; [value]: transcode "abc def"
== [abc def]
</code></pre>
<p>With the next position request, just one item and a remainder:</p>
<pre><code>&gt;&gt; [value pos]: transcode "abc def"
== abc

&gt;&gt; pos
== " def"

; ...or...

&gt;&gt; transcode/next "abc def" 'pos
== abc

&gt;&gt; pos
== " def"
</code></pre>
<p>You also know that you're at the end of the input when it returns null, with all the benefits of easy reactions to NULL with IF and ELSE and friends:</p>
<pre><code>&gt;&gt; [value pos]: transcode ""
; null
</code></pre>
<p>Writing foolproof loops to process items are a breeze:</p>
<pre><code>while [true]
    [item utf8]: transcode utf8 else [break]
    print mold item
 ]

; or for the THEN/ELSE haters out there (you know who you are :-P)

while [true]
    if null? [item utf8]: transcode utf8 [
        break
    ]
    print mold item
 ]
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=9" title=":+1:" class="emoji only-emoji" alt=":+1:"></p>
<h2>This Runs Circles Around Red and R3-Alpha</h2>
<p>For starters: neither support strings as input--because the scanner is built for reading UTF-8 files...and both R3-Alpha and Red unpack strings into fixed-width encodings.  So if you have string input, you have to pay for a copy encoded as UTF-8 via TO BINARY!.  (<a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">Ren-C's UTF-8 Everywhere</a> wins again!)</p>
<p>R3-Alpha unconditionally returns a block with the last element as a remainder, whether you ask for one item via /NEXT or not:</p>
<pre><code>r3-alpha&gt;&gt; transcode to binary! "abc def"
== [abc def #{}]

r3-alpha&gt;&gt; transcode/next to binary! "abc def"
== [abc #{20646566}]

r3-alpha&gt;&gt; transcode/next to binary! ""
== [#{}]
</code></pre>
<p>So if you were transcoding an entire input, you have to TAKE/LAST an always-empty binary off of the result.</p>
<p>But you are using /NEXT you have to PICK out the element from the start of the array and the remainder from the end.  But you need to notice the exception of no-value-produced where the block is length 1 instead of 2.</p>
<p>That's awkward, but as usual... <em>Red somehow manages to make an incompatible interface that is as much worse as it is better:</em></p>
<p>The better part is that if you don't ask for /NEXT you just get the block back, like in Ren-C:</p>
<pre><code>red&gt;&gt; transcode to binary! "abc def"
== [abc def]
</code></pre>
<p>But the /NEXT interface is outright broken:</p>
<pre><code>red&gt;&gt; transcode/next to binary! "abc def"
== [abc #{20646566}]

red&gt;&gt; transcode/next to binary! ""
== [[] #{}]
</code></pre>
<p>It might look better because you don't have to guess about which position to find the remainder in--it's always in the second slot.  But it has a fatal flaw: you can't distinguish the result state of scanning <code>"[]"</code> and any string with nothing but comments and whitespace.</p>
<p>Consider this very basic loop to scan one item at a time and print it:</p>
<pre><code>red&gt;&gt; utf8: to binary! "abc def"

red&gt;&gt; while [not tail? utf8] [
     set [item utf8] transcode/next utf8
     print mold item
]
abc
def
</code></pre>
<p>You get two items.  But what if you had something that was--say--a comment:</p>
<pre><code>red&gt;&gt; utf8: to binary! "; I'm just a comment"

red&gt;&gt; while [not tail? utf8] [
     set [item utf8] transcode/next utf8
     print mold item
]
[]
</code></pre>
<p>You get one spurious item.  (They chose BLOCK! for the item, but it wouldn't matter what it was--a NONE! would be just as bad, you're just losing the distinction between empty strings and <code>"#[none]"</code> then.)</p>
<p>If I were prescribing a solution for Red I'd say:</p>
<ul>
<li>
<p>Make /NEXT take a variable to write the next position into</p>
</li>
<li>
<p>Error on <code>#{}</code> input, so anyone doing a TRANSCODE/NEXT knows they are responsible for testing for TAIL? before they call (if they're not sure their input is non-empty)</p>
<ul>
<li>This way an empty remainder returned in the /NEXT variable will uniquely signal the reached-end state</li>
</ul>
</li>
<li>
<p>Make the synthesized product at the tail something ugly but assignable (so not an unset!)</p>
<ul>
<li>an ERROR! saying "end of input" is at least informative in case it winds up getting treated as an actual value somewhere</li>
</ul>
</li>
</ul>
<p>That would at least give them patterns like:</p>
<pre><code>if not tail? utf8 [  ; needed if you're not sure it's non-empty
    while [true] [
        item: transcode/next utf8 'utf8
        if tail? utf8 [break]
        print mold item
    ]
]
</code></pre>
<p><em>(Having NULL is clearly better as a non-valued state (with isotope states fleshing out the picture)...and my <a href="https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/2">bafflement at Nenad's blindness</a> when confronted with what should be clear as day is as relevant as it was 6-plus-years ago.  And of course we see they'd actually need SET/ANY to do this right if you were allowing #[unset!]...but Ren-C's design has no need of that.)</em></p>
<h2>Ren-C Also <em>Thrashes</em> R3-Alpha and Red In Error Handling</h2>
<p>Ren-C TRANSCODE has these potential behaviors:</p>
<ul>
<li>
<p>RETURN a BLOCK! (if plain TRANSCODE)</p>
</li>
<li>
<p>RETURN an ANY-VALUE! or NULL (if TRANSCODE/NEXT)</p>
</li>
<li>
<p>It can do a "hard FAIL"</p>
<ul>
<li>
<p>This would happen if you asked something fundamentally incoherent...like asking to TRANSCODE a with input that was non-UTF-8...like a GOB!, or something like that</p>
</li>
<li>
<p>Such errors are only interceptible by a special SYS.UTIL.ENTRAP method--they are not supposed to be easy to gloss over and unlikely to have meaningful mitigation.  So only special sandboxing situations (like writing consoles that print out the error) are supposed to trap them.</p>
</li>
</ul>
</li>
<li>
<p>It can RETURN an <em>isotopic ERROR!</em> ("raised error") if something went wrong in the transcoding process itself</p>
<ul>
<li>
<p>This would be something like a syntax error, like  if you asked <strong>transcode "a bc 1&amp;x def"</strong></p>
</li>
<li>
<p>These will be promoted to a hard FAIL if the immediate caller doesn't do something to specially process them.</p>
</li>
<li>
<p>You can casually ignore or intercept these, because you can be confident that it was a formal return result of the thing you just called--not some deeper problem like a random typo or other issue.</p>
</li>
</ul>
</li>
</ul>
<p>I won't rehash the entire <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">"why definitional errors are foundational"</a> post, but TRANSCODE was one of the first functions that had to be retrofitted to use them.</p>
<pre><code>&gt;&gt; transcode "a bc 1&amp;x def" except e -&gt; [print ["Error:" e.id]]
Error: scan-invalid
</code></pre>
<p><strong>The definitionality is extremely important!</strong>  I spent a long time today because in the bootstrap shim I had a variation of transcode...parallel to this in R3-Alpha:</p>
<pre><code>r3-alpha&gt;&gt; transcode: func [input] [
               prnit "My Transcode Wrapper"  ; oops, typo
               return transcode input
           ]

r3-alpha&gt;&gt; if not attempt [transcode to binary! "abc def"] [print "Bad input"]
Bad input
</code></pre>
<p><em><strong>But the input isn't bad!!!</strong></em>  This leads to a nightmare of trying to figure out what was going wrong.  I had just one of those nightmares today in the bootstrap executable when tinkering with the shim implementation of TRANSCODE.  A bug in the shim was leading to silently skipping work that should have been done, because the caller wanted to be tolerant of bad transcode input.</p>
<p>There's simply no practical way of working on code of any complexity without something like definitional failures, and experience has proven this day after day.</p>
<h2>Getting Incomplete Results Via R3-Alpha's /ERROR</h2>
<p>R3-Alpha offered this feature:</p>
<pre><code>/error -- Do not cause errors - return error object as value in place
</code></pre>
<p>The intended use is that you might want the partial input of what had been successfully scanned so far.  If the code went and raised an error, you could trap that error.  But you wouldn't have any of the scanned items.</p>
<p>It would put it any ERROR! as the next-to-last item in the block, with the remainder after that:</p>
<pre><code>&gt;&gt; transcode/error to binary! "a bc 1&amp;x def"
== [abc make error! [
    code: 200
    type: 'Syntax
    id: 'invalid
    arg1: "pair"
    arg2: "1&amp;x"
    arg3: none
    near: "(line 1) a bc 1&amp;x def"
    where: [transcode]
] #{20646566}]

&gt;&gt; to string! #{20646566}
== " def"  ; wait...why isn't 1&amp;x part of the "remainder"
</code></pre>
<p>It's clumsy to write the calling code (or to read it...testing to see if the next-to-last-item is an ERROR! and reacting to that.</p>
<p><em>(Also: What if there was some way to represent ERROR! values literally in source?  This would conflate with such a block that was valid...but just incidentally had an ERROR! and then a BINARY! in the last positions.)</em></p>
<p>But the thing that had me most confused about it was the remainder.  Notice above you don't get  <code>1&amp;x</code> as the start of the stuff it couldn't understand.</p>
<p>Was it trying to implement some kind of recoverable scan?  What would that even mean?  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:"></p>
<p><strong>Ultimately I think this was just a leaking of an implementation detail as opposed to any reasonable attempt at recoverable scanner.</strong>  It only didn't tell you where the exact tail of the successfully scanned material was because it did not know.</p>
<p>The scanning position is based on token consumptions, and so if you started something like a block scan and it saw a <strong>[</strong> then it forgets where it was before that.  Then if something inside the block goes bad, it will just give you a remainder position somewhere inside that--<em>completely forgetting about how many nesting levels it was in</em>.</p>
<p>So what you were getting was a crappier implementation of scanning one by one, and remembering where you were before the last bad scan:</p>
<pre><code>pos: input
error: null
block: collect [
   while [true] [
       keep [# pos]: transcode pos else [
           break
       ] except e -&gt; [
           error: e
           break
       ]
   ]
]
</code></pre>
<p>That gives you a proper version, setting error if something happened and giving you the block intact.</p>
<h2>So Finally... We See It's An Optimization Problem</h2>
<p>Question is if there's some way of folding this into TRANSCODE, so it's doing the looping and collecting efficiently for you.</p>
<p>But this interface wants to get back a "remainder".  And I kind of hate to sacrifice the property that TRANSCODE's asking for a remainder means scan one element.  :-/</p>
<p>I guess we <em>could</em> say that there's a logical process you follow:</p>
<ul>
<li>
<p>The output parameter is called REST (instead of NEXT)</p>
</li>
<li>
<p>An additional output parameter is added for ERROR</p>
</li>
<li>
<p>If you ask for the REST and <em>don't</em> ask for an ERROR, that suggests you want to encode a single item</p>
<ul>
<li>
<p>You could have just intercepted the error if you wanted it</p>
</li>
<li>
<p>Nothing is lost because there wouldn't be any partial results to miss (if you're only doing one item, there will always be zero items completed before it)</p>
</li>
</ul>
</li>
<li>
<p>If you ask for the REST and <em>do</em> ask for an error, then it assumes you must not want the one-item-only semantics after all.</p>
</li>
</ul>
<p>It's a little bit awkward because it conflates partial output with fully successful output</p>
<pre><code>&gt;&gt; [block rest error]: transcode "a bc"
== [a bc]

&gt;&gt; error
; null

&gt;&gt; [block rest error]: transcode "a bc 1&amp;x def"
== [a bc]  ; no indication something failed

&gt;&gt; error? error  ; you'd have to remember to check this
== #[true]
</code></pre>
<p>That's not a deal breaker, and Ren-C makes it easy to work with, using <a href="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587">circling an output in multi-return</a> to make it the primary return result:</p>
<pre><code>&gt;&gt; [block rest @error]: transcode "a bc"
; null

&gt;&gt; [block rest @error]: transcode "a bc 1&amp;x def"
== make error! [...]
</code></pre>
<p><strong>What's much more jarring to me is the flipping back and forth of whether you're asking for a full transcode or not.</strong></p>
<pre><code>&gt;&gt; x: transcode "abc def"
== [abc def]

&gt;&gt; [x y]: transcode "abc def"
== abc

&gt;&gt; [x y z]: transcode "abc def"
== [abc def]
</code></pre>
<p>Ick.  Should I be willing to bend on the transcode "requested parameter" behavior in this case, by adding a /ONE refinement?</p>
<pre><code>&gt;&gt; [block rest]: transcode "abc def"
== [abc def]

&gt;&gt; rest
== #{}  ; kind of useless, but honest

&gt;&gt; [block rest]: transcode/one "abc def"
== abc

&gt;&gt; rest
== " def"
</code></pre>
<p>That would make me feel grief, as it loses one of the first showcases of return value sensitivity.  <em>And it irks me to think that the beauty is ultimately being given up for the sake of what amounts to an optimization.</em></p>
<h2>Answer For Now: Kill Off /ERROR</h2>
<ul>
<li>
<p>The answer /ERROR has been giving back in error cases for the remainder is sketchy, and I don't want to figure out how to fix it.</p>
</li>
<li>
<p>You can get the behavior reliably just by intercepting errors going one transcode item at a time.</p>
</li>
<li>
<p>This is a good opportunity to write tests of item-by-item scanning with error handling</p>
</li>
<li>
<p>Red added a bunch of refinements on transcode [/next /one /prescan /scan /part /into /trace], and they didn't pick up /error themselves</p>
</li>
</ul>
<p>Speaking of adding lots of refinements: I also want to get away in general from investments in weird C scanner code and hooks (<em>especially</em> if it's just an optimization).</p>
<p>What we should be investing in is more fluid mixture of PARSE of strings/binary with the scanner.  e.g. we should have ways of knowing what line number you're at during the parse for any combinator, and just generally pushing on that.  Adding TRANSCODE parameters up the wazoo isn't a winning strategy.</p> ]]></description>
        <link>https://forum.rebol.info/t/incomplete-transcodes-actually-an-optimization-problem/1940/1</link>
        <pubDate>Mon, 22 Aug 2022 15:09:13 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6311</guid>
      </item>
      <item>
        <title>Matching Characters in BINARY! PARSE</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>If you don’t break the rule to give back the rule, then it is in your hands what you want to get back. Blank, or space character, or one character string.</p> ]]></description>
        <link>https://forum.rebol.info/t/matching-characters-in-binary-parse/1935/2</link>
        <pubDate>Mon, 22 Aug 2022 10:05:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6310</guid>
      </item>
      <item>
        <title>Optimizing TRANSCODE Usage in String/Binary PARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>As written, the DATATYPE! combinator in UPARSE may do wasteful value loading when operating on string input.</p>
<p>Consider this case.</p>
<pre><code>&gt;&gt; parse "[some big block ...] 10" [collect some [keep integer! | block!]]
== [10]
</code></pre>
<p><em>Pretty impressive that it works.</em>  (Red will only do this on BINARY! input, but Ren-C's UTF-8 everywhere allows it to do it on strings too!)</p>
<p>But at the combinator level, it's wasteful.  What happens is:</p>
<ul>
<li>
<p>Hitting the INTEGER! combinator, causing it to scan the next element, loading <strong><code>[some big block ...]</code></strong> as a series into memory.</p>
<ul>
<li>It then checks the type, notices it's not an integer, and the INTEGER! combinator gives back a rejection...so the BLOCK! combinator goes to the next alternate.</li>
</ul>
</li>
<li>
<p>It hits the BLOCK! combinator and scans the block again.</p>
<ul>
<li>
<p>This time it matches, so the parser returns success and the synthesized block</p>
</li>
<li>
<p><em>But the block isn't actually desired</em>, so it is thrown away</p>
</li>
</ul>
</li>
<li>
<p>The next iteration scans the INTEGER! and keeps it.</p>
</li>
</ul>
<h2>Why Does It Work This Way?</h2>
<p>It's based on TRANSCODE, and does basically exactly what I said:</p>
<pre><code>[item remainder]: transcode input except e -&gt; [return raise e]

if datatype != type of item [
    return raise ["Could not TRANSCODE" datatype "from input"]
]
return item
</code></pre>
<p>If we could pass in a datatype to TRANSCODE when using the /NEXT option (e.g. requesting a remainder, as we are above) then it could short-circuit and we wouldn't need that test.</p>
<h2>Red Has Looked At This Kind of Problem</h2>
<p>There are a bunch of new arguments to Red's TRANSCODE function:</p>
<pre><code>USAGE:
     TRANSCODE src

DESCRIPTION: 
     Translates UTF-8 binary source to values.
     Returns one or several values in a block. 

ARGUMENTS:
     src          [binary! string!]
     {UTF-8 input buffer; string argument will be UTF-8 encoded.}

REFINEMENTS:
     /next        =&gt; Translate next complete value (blocks as single value).
     /one         =&gt; Translate next complete value, returns the value only.
     /prescan     =&gt; Prescans only, do not load values. Returns guessed type.
     /scan        =&gt; Scans only, do not load values. Returns recognized type.
     /part        =&gt; Translates only part of the input buffer.
         length       [integer! binary!] "Length in bytes or tail position."
     /into        =&gt; Optionally provides an output block.
        dst          [block!] 
     /trace       =&gt; 
        callback     [function! [
                        event [word!]
                        input [binary! string!]
                        type [word! datatype!]
                        line [integer!]
                        token
                        return: [logic!]
                      ]] 

RETURNS:
    [block!]
</code></pre>
<p>I'm not sure exactly how useful the /PRESCAN option is (what good is a "guess" of the type?)  But the /SCAN option would offer some bit of efficiency.</p>
<p>It would mean instead of one call to TRANSCODE followed by a datatype test, there'd be two calls</p>
<ul>
<li>
<p>The first as TRANSCODE/SCAN to get the datatype (but not synthesize a value from it)</p>
</li>
<li>
<p>A second call to scan again and get the value</p>
</li>
</ul>
<p>We assume the idle mode of scanning without producing anything can be fast.</p>
<p>I would suggest the scan feature be <strong>transcode/types</strong> so it worked more generally, not just with /NEXT.</p>
<pre><code>&gt;&gt; transcode/types [1 a [b]]
== [#[datatype! integer!] #[datatype! word!] #[datatype! block!]]
</code></pre>
<p><sub><em>(When I figure out the story of datatypes, there are going to be a lot of forum posts fixing up the above ugly notation.)</em></sub></p>
<h2>But What About The Synthesis Of Unused Values?</h2>
<p>This is a bit of a pickle.  <em>We don't know if you're going to use the product or not.</em></p>
<p>UPARSE's design has values bubbling out the top, and no line of communication to be aware of whether what it produces will be used:</p>
<pre><code>&gt;&gt; uparse "[a] (b)" [block! group!] 
== (b)
</code></pre>
<p>You might think that when the block! rule is going to be run, UPARSE could notice it wasn't at the end and send some kind of signal to the BLOCK! combinator that it doesn't have to synthesize an output.  But there's no a-priori psychic power saying that GROUP! hasn't been configured to evaluate to void.  Until the combinator gets looked up and run, it's potentially the same situation as this:</p>
<pre><code>&gt;&gt; uparse "[a] (b)" [block! void] 
== [a]
</code></pre>
<h2>It Seems We Have Two Choices</h2>
<ol>
<li>
<p>We can assume that a plain DATATYPE! intends to synthesize a value, and use a different combinator to say you only want to match the type:</p>
<pre><code>&gt;&gt; uparse "[a b c]" [scan block!]
== #[datatype! block!]  ; cheap (but useful) return value, no series synthesis

&gt;&gt; uparse "[a b c]" [block!]
== [a b c]
</code></pre>
</li>
<li>
<p>We can reverse it and say that by default it does the cheap thing, and you have to explicitly ask to get the expensive thing:</p>
<pre><code>&gt;&gt; uparse "[a b c]" [block!]
== #[datatype! block!]

&gt;&gt; uparse "[a b c]" [scan block!]
== [a b c]
</code></pre>
</li>
</ol>
<p>Looked at in isolation, it might seem like (2) would be the obvious winner.</p>
<p>The thorn is that this would be a pretty notable divergence from how array parsing works, which I would basically call non-negotiable:</p>
<pre><code>&gt;&gt; uparse [[a b c]] [x: block!]

&gt;&gt; x
== [a b c]
</code></pre>
<p>So is there actually an option 3?</p>
<ol start="3">
<li>
<p>Make lone datatype! an error, and have two distinct operations for transcoding:</p>
<pre><code>&gt;&gt; uparse "[a b c]" [block!]
** Error: On string input, use either TRANSCODE BLOCK! or SCAN BLOCK!

&gt;&gt; uparse "[a b c]" [transcode block!]
== [a b c]

&gt;&gt; uparse "[a b c]" [scan block!]
== [a b c]
</code></pre>
</li>
</ol>
<p>Urg.  That kind of sucks.</p>
<p><strong>I think the answer is to accept option (1) being suboptimal performance, allowing those who are performance-minded to tune it.</strong>  There's no overt harm by scanning things you throw away, it's just wasteful.</p> ]]></description>
        <link>https://forum.rebol.info/t/optimizing-transcode-usage-in-string-binary-parse/1939/1</link>
        <pubDate>Sun, 21 Aug 2022 19:10:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6309</guid>
      </item>
      <item>
        <title>Different Dialect Behavior For Literal vs. Fetched Items</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1348">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>You know the QUASI! things didn't evaluate, so they had to be inert and have no quote level (hence a quasiform for them exists).</p>
</blockquote>
</aside>
<p>Hmmm...technically you don't need the QUASI!, if you remember that everything quoted is one level quoted higher than it actually is. Hmm.</p>
<pre><code>&gt;&gt; block: reduce/weird [1 1 + 2 first [~a~ b c] first [''d ''e]]
== [1 '3 '~a~ '''d]
</code></pre>
<p>That again has the round-trip property that if you reduce it you get the block back.</p>
<pre><code>&gt;&gt; reduce block
== [1 3 ~a~ ''d]

&gt;&gt; reduce [1 1 + 2 first [~a~ b c] first [''d ''e]]
== [1 3 ~a~ ''d]  ; same
</code></pre>
<p>So even simpler.  The QUOTED! bit is the evaluated bit, and remove it to get the actual value.  If it's not quoted it was inert in the input.</p>
<p>As long as you know what you're doing and don't forget what the quoted bit or its absence means, that seems pretty good.</p> ]]></description>
        <link>https://forum.rebol.info/t/different-dialect-behavior-for-literal-vs-fetched-items/1348/5</link>
        <pubDate>Sun, 21 Aug 2022 12:39:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6307</guid>
      </item>
      <item>
        <title>Updated Parse Machine</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>5 posts were split to a new topic: <a href="/t/binding-issues-raised-by-chriss-parse-machine/1937">Binding Issues Raised by Chris's PARSE-MACHINE</a></p> ]]></description>
        <link>https://forum.rebol.info/t/updated-parse-machine/1475/2</link>
        <pubDate>Sun, 21 Aug 2022 11:55:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6306</guid>
      </item>
      <item>
        <title>Different Dialect Behavior For Literal vs. Fetched Items</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="IngoHohmann" data-post="3" data-topic="1348">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>The weird block looks really weird, though.</p>
</blockquote>
</aside>
<p>Actually...it could cost no more than the block otherwise would, if it made the unevaluated things QUASI!, and the evaluated things added a level of QUOTED!:</p>
<pre><code>&gt;&gt; block: reduce/quasi [1 1 + 2 first [~a~ b c] first [''d ''e]]
== [~1~ '3 '~a~ '''d]
</code></pre>
<p>You know the QUASI! things didn't evaluate, so they had to be inert and have no quote level (hence a quasiform for them exists).</p>
<aside class="quote no-group" data-username="IngoHohmann" data-post="3" data-topic="1348">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>Being able to get at that information is good, I think, especially if it's already available.</p>
</blockquote>
</aside>
<p>Exposing it as a bit is pretty fiddly API-wise, and its hidden-ness makes me nervous.</p>
<p>While the above may look weird, it's actually rather elegant.  And as a client of the service, I'd rather be able to do a for-each over the values and examine a property of a value directly, vs. needing some strange position-based API to read invisible bits scribbled on things.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:"></p>
<p>It's easy enough to UNQUASI and UNQUOTE things--easier than extracting items from blocks or groups.  And as I say, it's cheap.</p>
<p><em>(I have to say...seeing how these parts all serve their niches is getting to be very pleasing.  I'm also increasingly satisfied with QUASI as a name...as we see here it's more than just an isotope producer.  That's one role, but it's also a quote-like operator that can only be used exactly once on non-quoted non-NULL things.)</em></p> ]]></description>
        <link>https://forum.rebol.info/t/different-dialect-behavior-for-literal-vs-fetched-items/1348/4</link>
        <pubDate>Sun, 21 Aug 2022 11:37:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6305</guid>
      </item>
      <item>
        <title>Notation for Outputs in Function Specs</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>GET-WORD! has a fair amount of contention for it already.  Right now it means "colon escapable literal".</p>
<p>A plain literal argument (indicated by a quote mark) is unescapable:</p>
<pre><code>&gt;&gt; unescapable: func ['x] [print mold x]

&gt;&gt; x: 10

&gt;&gt; unescapable x
x

&gt;&gt; unescapable :x
:x

&gt;&gt; unescapable (1 + 2)
(1 + 2)

&gt;&gt; unescapable :(1 + 2)
:(1 + 2)
</code></pre>
<p>But using the prefix colon seemingly semiotically asks for the escape:</p>
<pre><code>&gt;&gt; escapable: func [:x] [print mold x]

&gt;&gt; x: 10

&gt;&gt; escapable x
x

&gt;&gt; escapable :x
10

&gt;&gt; escapable (1 + 2)
(1 + 2)

&gt;&gt; unescapable :(1 + 2)
3
</code></pre>
<p>This is a more coherent version of what R3-Alpha and Red do (they backwardsly use 'x for escapable and :x for unescapable, and because there's no GET-GROUP! they have to make plain groups do escaping).</p>
<p>But I've wondered if that should instead be <strong>':x</strong> instead, where <strong>:x</strong> could be used for a generalized subversion of callsite evaluation:</p>
<p><a href="https://forum.rebol.info/t/beating-repend-a-new-parameter-convention/1673" class="inline-onebox">Beating REPEND: A New Parameter Convention?</a></p>
<p>Things are sort of fibrillating in that space right now, with potential new meanings for GET-WORD!, so it all is about to come under review.</p>
<p>But I was happy enough with the <span class="mention">@word</span> for outputs that I went ahead and did it.  So far I give it a stamp of approval, so I'll see if this happiness wears of or persists!</p> ]]></description>
        <link>https://forum.rebol.info/t/notation-for-outputs-in-function-specs/1414/6</link>
        <pubDate>Sun, 21 Aug 2022 11:23:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6304</guid>
      </item>
      <item>
        <title>Different Dialect Behavior For Literal vs. Fetched Items</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>Being able to get at that information is good, I think, especially if it's already available.<br>
The weird block looks really weird, though.</p> ]]></description>
        <link>https://forum.rebol.info/t/different-dialect-behavior-for-literal-vs-fetched-items/1348/3</link>
        <pubDate>Sun, 21 Aug 2022 11:21:33 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6303</guid>
      </item>
      <item>
        <title>Notation for Outputs in Function Specs</title>
        <dc:creator><![CDATA[@IngoHohmann Ingo Hohmann]]></dc:creator>
        <description><![CDATA[ <p>How about using get-word?<br>
Get-words have the connotation of getting something out already.</p>
<pre><code class="lang-auto">foo: func [:out in] [...]
</code></pre> ]]></description>
        <link>https://forum.rebol.info/t/notation-for-outputs-in-function-specs/1414/5</link>
        <pubDate>Sun, 21 Aug 2022 11:13:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6302</guid>
      </item>
      <item>
        <title>Updated Parse Machine</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>2 posts were split to a new topic: <a href="/t/errors-on-locked-binding/1936">Errors on "Locked" Binding?</a></p> ]]></description>
        <link>https://forum.rebol.info/t/updated-parse-machine/1475/9</link>
        <pubDate>Sun, 21 Aug 2022 11:02:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6301</guid>
      </item>
      <item>
        <title>The R3C Branch (&quot;Chris&#39;s Rebol&quot; or &quot;Rebol 3 Conservative&quot;)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="rgchris" data-post="7" data-topic="1858">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I'm uncomfortable with new considerations for the <code>/refinement</code> form.</p>
</blockquote>
</aside>
<p>Hopefully you're warming up a bit to the generalized paths and tuples, and how they can be COMPOSE'd with pieces spliced, etc.  I mentioned there was a long way to go on mechanics, but progress has proceeded one hard-won fight at a time...</p>
<p>Example: Tonight while firming up the idea that <a href="https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821/2">BLANK! is matched literally in PARSE for arrays</a>, I found it instantly applicable to a significant step ahead in processing refinement-y things:</p>
<pre><code>&gt;&gt; refinement-rule: [subparse path! [_ word!]]

&gt;&gt; parse [/foo] [refinement-rule]
== foo
</code></pre>
<p><a href="https://forum.rebol.info/t/should-arity-2-into-in-uparse-actually-just-be-parse/1864">SUBPARSE is basically like "INTO AHEAD"</a>, so it parses into the rule product of its first argument.  (The first rule doesn't have to be a pattern on the input series, it could be a GROUP! that synthesizes any arbitrary series or sequence.)</p>
<p>So recall that:</p>
<pre><code>&gt;&gt; as block! /foo
== [_ foo]
</code></pre>
<p>Also, that BLOCK! rules evaluate to the last matched thing.</p>
<p>NewPath has come, and seen, and is now conquering.  <img src="https://forum.rebol.info/images/emoji/twitter/crossed_swords.png?v=9" title=":crossed_swords:" class="emoji" alt=":crossed_swords:">  What about composing paths where a slash before an array spreads it out?</p>
<pre><code>&gt;&gt; parse 'a/[b c]/d//[e f] [collect some [keep [spread [_ any-array!] | &lt;any&gt;]]]
== [a [b c] d e f]
</code></pre>
<p>When you see <strong><code>/foo</code></strong> and <strong><code>foo/</code></strong> fitting into this general mechanism it makes it worth figuring out how to negotiate their new nature.</p> ]]></description>
        <link>https://forum.rebol.info/t/the-r3c-branch-chriss-rebol-or-rebol-3-conservative/1858/9</link>
        <pubDate>Sun, 21 Aug 2022 09:49:42 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6300</guid>
      </item>
      <item>
        <title>Different Dialect Behavior For Literal vs. Fetched Items</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1348">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>&gt;&gt; unspaced ["a" _ "b"]
"a b"

&gt;&gt; var: _

&gt;&gt; unspaced ["a" var "b"]
** Error: Can't Turn Evaluative BLANK! Into Space

&gt;&gt; unspaced ["a" maybe var "b"]
"ab"

&gt;&gt; unspaced compose ["a" (var) "b"]
"a b"
</code></pre>
</blockquote>
</aside>
<p>This seems pretty nice on the surface.  But there's a bit of a technical problem with it.</p>
<p><strong>Imagine you are the person who is implementing UNSPACED.</strong>  One likely thing you might do would be to run through a REDUCE step, and then join the parts together:</p>
<p>But these make the same product:</p>
<pre><code>&gt;&gt; reduce ["a" _ "b"]
== ["a" _ "b"]

&gt;&gt; reduce ["a" var "b"]
== ["a" _ "b"]
</code></pre>
<p>In order to raise an error, you have to know if a value was literal or the product of an evaluation.</p>
<p>Deriving this information yourself is a hassle.  You might think you could step through the block and literally examine each blank before doing an eval step, and if it's a blank you just skip over it.  But then you have trouble like enfix operators that consume their left hand side and are able to take blanks, and so if you consume the blanks without deferring to lookahead you get mangled results.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>Inside the system it's a little easier--there actually is an internal flag on cells that can track whether they were evaluative products or not.  But this feature has been kind of closely guarded and not exposed to usermode, because it's such a sneaky invisible property.</p>
<p><em><strong>Is it time to expose the evaluated bit... like the NEW-LINE flag is exposed???</strong></em>  This would let you snoop the results of something like a REDUCE and know if something was an evaluative product.</p>
<pre><code>&gt;&gt; block: reduce [1 2 + 3]
== [1 5]

&gt;&gt; evaluated? block
== #[false]

&gt;&gt; evaluated? next block
== #[true]
</code></pre>
<p>I am presenting it as a property of block positions...not of values themselves, because all values are evaluative if you get them as a function result--because the function evaluated!</p>
<pre><code>&gt;&gt; first block
== 1

&gt;&gt; evaluative-value? first block
== #[true]  ; e.g. it came from running FIRST
</code></pre>
<p>(You might try to argue that it's only certain blessed evaluator functions like REDUCE that fiddle the bit, but the problem is you have to consider how this bit is produced in the first place.  That would be something that doesn't exist today and may not be coherent.  I'm talking about something that already does exist and works.)</p>
<p>I'm somewhat reticent to expose this bit.  But if you read the arguments in the post above, it leans toward saying that this is a legitimate piece of information to want to know.</p>
<p>Less dodgy might be asking REDUCE to do something to augment the products of the array to indicate their evaluatedness?</p>
<pre><code>&gt;&gt; reduce/weird [1 2 + 3]
== [[1] (5)]
</code></pre>
<p>Everything that's an evaluative product could be put in a group, and everything that's not could be put in a block.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:">  Not the most efficient concept in the universe, but also not the least (single blocks and groups are about as optimized as they can be).  Internal routines could leverage the bit more efficiently and this could just be for usermode to avoid invisible state.</p>
<p>Anyway...more to think about.</p> ]]></description>
        <link>https://forum.rebol.info/t/different-dialect-behavior-for-literal-vs-fetched-items/1348/2</link>
        <pubDate>Sun, 21 Aug 2022 08:35:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6299</guid>
      </item>
      <item>
        <title>Matching Characters in BINARY! PARSE</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>In Rebol2, you can't match a character (or string) against a binary!:</p>
<pre><code>rebol2&gt;&gt; to binary! " "
== #{20}

rebol2&gt;&gt; parse #{20} [" "]
== false

rebol2&gt;&gt; parse #{20} [#" "]
== false
</code></pre>
<p>In Red and R3-Alpha, you can do both...</p>
<pre><code>red&gt;&gt; parse #{20} [" "]
== true

red&gt;&gt; parse #{20} [#" "]
== true
</code></pre>
<p>But their unicode model means they really don't know what they're doing in any general sense, and I'm sure whatever's under the hood is incoherent:</p>
<pre><code>red&gt;&gt; to binary! "Æ"
== #{C386}

red&gt;&gt; parse #{C386} ["Æ"]
== false
</code></pre>
<p>Ren-C is much more coherent!</p>
<pre><code>&gt;&gt; did parse #{C386} ["Æ"]
== #[true]
</code></pre>
<h2>So the PARSE Succeeds, but... what should it return?</h2>
<p>Right now a parse on a string returns the <em>rule</em> when it matches.</p>
<pre><code>&gt;&gt; rule: "cd"

&gt;&gt; result: parse "abcd" ["ab" rule]
== "cd"

&gt;&gt; append result "ef"
== "cdef"

&gt;&gt; rule
"cdef"
</code></pre>
<p><strong>This is clearly correct, because you don't want it to make a copy if it doesn't know if you're going to use the copy.</strong>  Basic rule matching should not produce a new series.</p>
<p>The same logic applies to BINARY!...but should it give you the string as a string, or aliased to its binary form?</p>
<pre><code>&gt;&gt; parse #{C386} ["Æ"]
== "Æ"  ; option 1

&gt;&gt; parse #{C386} ["Æ"]
== #{C386}  ; option 2
</code></pre>
<p>I think the answer is that you should match it as whatever form it was in the rule.</p>
<p>But then...how about something like BLANK!, which acts equivalently to space if the input is a string... or BLANK! if it's an array?</p>
<pre><code>&gt;&gt; parse [_] [_]
== _

&gt;&gt; parse " " [_]
== ???

&gt;&gt; parse #{20} [_]
== ???
</code></pre>
<p>If we're going with the idea of rule as being primacy, then the language of the match should be the same as the language of the rule... e.g. the above all return blank.</p>
<p>But this is something of a gray area, IMO.  I feel like blank is acting as a stand-in for space and should probably be looked at as if you said space.</p>
<pre><code>&gt;&gt; parse " " [_]
== #" "

&gt;&gt; parse #{20} [_]
== #" "  ; instead of 32
</code></pre>
<p>So this is what I'm going with, unless someone has a really good argument for something else.</p> ]]></description>
        <link>https://forum.rebol.info/t/matching-characters-in-binary-parse/1935/1</link>
        <pubDate>Sun, 21 Aug 2022 05:43:45 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6298</guid>
      </item>
      <item>
        <title>Calling Ren Functions From Redbol</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>When you <strong><code>import @redbol</code></strong> the environment for your module is skinned with the Redbol definitions.  But it can run concurrently with non-Redbol modules in the same session.  This is very cool.</p>
<p>I've nudged it a little further into cool by having the definition of LIB in Redbol be the initial state of the Redbol definitions, and then REN is the Ren-C's version of LIB.</p>
<pre><code>&gt;&gt; import @redbol

&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append/only [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] ren/spread [d e]
== [a b c d e]

&gt;&gt; append: does [print "Overwritten"]
== #[action! {append} []]

&gt;&gt; append
Overwritten

&gt;&gt; lib/append [a b c] [d e]
== [a b c d e]
</code></pre>
<p><em>Pretty slick.</em></p>
<h2>But IMPORT is Ultimately Not The Right Mechanism</h2>
<p>Because it's done using import, Redbol does not "clear out" the space of all the Ren-Cisms.</p>
<p>In fact, I didn't actually have to say <strong>ren/spread</strong> because the spread definition is still available:</p>
<pre><code>&gt;&gt; ren/append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>It's non-viable to ask Redbol to remove every Ren-C definition.  Instead, there needs to be a way to get a Redbol-using module to start from a fully clean slate where it explicitly exports everything it wants to make available.  This doesn't have to be that much work, it can just be a list of words in a block, with possible renamings:</p>
<pre><code>redbol-inherit [even?, odd?, value?: unset? ...]
</code></pre>
<h2>These Challenges Are Great For Vetting</h2>
<p>I don't throw softballs.  This is all truly attempting to live up to the hype of a language that you can bend and redefine at will, without constantly tripping over your own changes--and being able to build on top of existing functionality without being forced to rewrite it too.</p>
<p>Although things move slowly... the arrow of progress is in the right direction.</p> ]]></description>
        <link>https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934/1</link>
        <pubDate>Sat, 20 Aug 2022 21:05:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6297</guid>
      </item>
      <item>
        <title>Why We Allow *Direct* Isotope Assignments (e.g. variable: ~)</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <p>A post was merged into an existing topic: <a href="/t/undefined-vs-null-in-javascript/1826/2">undefined vs. null in JavaScript</a></p> ]]></description>
        <link>https://forum.rebol.info/t/why-we-allow-direct-isotope-assignments-e-g-variable/1206/2</link>
        <pubDate>Sat, 20 Aug 2022 18:48:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6296</guid>
      </item>
      <item>
        <title>Notation for Outputs in Function Specs</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1414">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>What If <code>@WORD</code> Was Used Instead?</p>
</blockquote>
</aside>
<p>I tried this out to see what I thought, going through the system and absorbing the impact.  It's good in most ways and only a little bit off in others.</p>
<p><strong>The thing that bothers me the most is that there's a phenomenon already associated with multi-returns and the @ symbol, and that's <a href="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587">circling the return result you want to use</a></strong>.  While set-words have no conflict in "return domain mindspace".</p>
<p>Also, there's something to be said for the function spec being less jarring... kind of like how quoted words being less jarring is good.  If you're not specifically tending to the spec of the function, then you want it to look kind of english-like.  This pushes it away from that.</p>
<p><strong>But there's a very major benefit I hadn't thought of.</strong>  Consider what happens in a function where the parameters <em>aren't</em> labeled:</p>
<pre><code>foo: func [out: in] [...]
foo: func [@out in] [...]
</code></pre>
<p>It feels like in a dialect, something with a SET-WORD! should have a thing always after it that it relates to assigning.  So having something that's naming a field in the function that doesn't need anything to the right of it has kind of a bad feel for a parameter.</p>
<p>That makes it feel like it pushes things over the edge to "we should change it".</p> ]]></description>
        <link>https://forum.rebol.info/t/notation-for-outputs-in-function-specs/1414/4</link>
        <pubDate>Sat, 20 Aug 2022 17:05:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6295</guid>
      </item>
      <item>
        <title>Notation for Outputs in Function Specs</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1414">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But dialect-wise, I think a SET-WORD! makes more sense:</p>
</blockquote>
</aside>
<p>In practice, I've found that having the colon at the end of the parameter makes it harder to see when something is an output.  Look at transcode for example, of how it's hard to see:</p>
<pre><code>transcode: native [
    {Translates UTF-8 source (from a text or binary) to values}
    return: "Transcoded value (or block of values)"
        [any-value!]
    next: "Translate one value and give back next position"
        [text! binary!]
    relax: "Try to trap errors and skip token (toplevel only)"
        [error!]
    source "If BINARY!, must be Unicode UTF-8 encoded"
        [text! binary!]
    /file "File to be associated with BLOCK!s and GROUP!s in source"
        [file! url!]
    /line "Line number for start of scan, word variable will be updated"
        [integer! any-word!]
    /where "Where you want to bind words to (default unbound)"
        [module!]
]
</code></pre>
<p>At a glance it's a bit easy to miss.</p>
<p><em>Not only that, there's no universal rule that outputs have to be in the front of the parameter list.</em>  (This is so you can add outputs to functions after the fact in compositions built on top of existing functions.)</p>
<h2>What If <span class="mention">@WORD</span> Was Used Instead?</h2>
<p>The ergonomics seem better, they jump off the page:</p>
<pre><code>transcode: native [
    {Translates UTF-8 source (from a text or binary) to values}
    return: "Transcoded value (or block of values)"
        [any-value!]
    @next "Translate one value and give back next position"
        [text! binary!]
    @relax "Try to trap errors and skip token (toplevel only)"
        [error!]
    source "If BINARY!, must be Unicode UTF-8 encoded"
        [text! binary!]
    /file "File to be associated with BLOCK!s and GROUP!s in source"
        [file! url!]
    /line "Line number for start of scan, word variable will be updated"
        [integer! any-word!]
    /where "Where you want to bind words to (default unbound)"
        [module!]
]
</code></pre>
<p>Your eye can just jump down to where the normal parameters begin.</p>
<p>It feels more coherent to use a different "part of speech" for RETURN: (or whatever it is) because it's really a completely different beast.</p>
<p>If there are no multi-returns, then the result would abut right up against the other parameters...but if RETURN: or RESULT: or whatever is the only colon-oriented thing you see then that's a special keyword so I don't think it's a problem.  You won't confuse it because you know the word is called result--the part of speech isn't the cue.</p>
<h2>Or Is The Answer To Rely On Syntax Highlighting?</h2>
<p>If one wants to argue that a SET-WORD! is the right semantic thing, and that something that makes SET-WORD! stand out as bold is a better answer vs. messing with the parameter convention.</p> ]]></description>
        <link>https://forum.rebol.info/t/notation-for-outputs-in-function-specs/1414/3</link>
        <pubDate>Sat, 20 Aug 2022 10:53:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6294</guid>
      </item>
      <item>
        <title>Notation for Outputs in Function Specs</title>
        <dc:creator><![CDATA[@hostilefork Hostile Fork]]></dc:creator>
        <description><![CDATA[ <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1414">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>But What About The Deviant RETURN:</strong>?</p>
<p>It's a bit confusing to have RETURN: work different than other things specified by SET-WORD!. This could be avoided by using a different convention, e.g. <strong><code>&lt;return&gt; [integer!]</code></strong> to stress the difference.</p>
</blockquote>
</aside>
<p>So we have a new reason to start questioning RETURN:.   And that is how actions that lack RETURN functions might nevertheless want to document their potential <em>return product</em>.</p>
<pre><code>intsum: lambda [x [integer!] y [integer!]] [x + y]
</code></pre>
<p>We could just say that you put <strong><code>return: [integer!]</code></strong> in the spec anyway, and understand that there's no actual return function.  But I feel like it's good to reinforce that there isn't.</p>
<p>So this suggests maybe even having it be something like <strong><span class="hashtag">#returns</span></strong> or <strong><span class="hashtag">#result</span></strong></p>
<pre><code>intsum: lambda [
    #result [integer!]
    x [integer!]
    y [integer!]
][
    x + y
]
</code></pre>
<p>Or we could think about dropping a label entirely, and saying you just understand the first block is a description of the result:</p>
<pre><code>intsum: lambda [
    [integer!]
    x [integer!]
    y [integer!]
][
    x + y
]
</code></pre>
<p>But the speedbump on that is that it flies in the face of my preferred syntax, which is to put the parameter label before the type spec.  This provides a good rhythm that you don't need to break when you have refinements with no arguments.</p>
<p>You'd have to put it after, or it would be considered part of the function description.</p>
<pre><code>intsum: lambda [
    {An Integer Sum Expressed as a Lambda}
    [integer!] "Result is the sum of first and second"
    x "The first value"
        [integer!]
    y "The second value"
       [integer!]
][
    x + y
]
</code></pre>
<p>I guess my thought is that SET-WORD! looks nice, and result: is a pretty value-neutral thing that would help you not be confused by tying it up to a RETURN operation which the function might not have.</p>
<pre><code>intsum: lambda [
    {An Integer Sum Expressed as a Lambda}
    result: "Result is the sum of first and second"
        [integer!]
    x "The first value"
        [integer!]
    y "The second value"
        [integer!]
][
    x + y
]
</code></pre>
<h2>Mechanically, New Ideas Are Coming</h2>
<p>It may be that the way to typecheck a lambda in the event you want that is to use another component:</p>
<pre><code>intsum: typechecked [integer!] lambda [
    {An Integer Sum Expressed as a Lambda}
    x "The first value"
        [integer!]
    y "The second value"
        [integer!]
][
    x + y
]
</code></pre>
<p>And it's just that FUNCTION comes and rolls that all together for you.  Which is an interesting thought, and maybe a more coherent way to think about it!</p> ]]></description>
        <link>https://forum.rebol.info/t/notation-for-outputs-in-function-specs/1414/2</link>
        <pubDate>Sat, 20 Aug 2022 10:40:07 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-6293</guid>
      </item>
  </channel>
</rss>

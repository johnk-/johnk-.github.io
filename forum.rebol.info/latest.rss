<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest topics</title>
    <link>https://forum.rebol.info/latest</link>
    <description>Latest topics</description>
    
      <lastBuildDate>Mon, 09 May 2022 18:20:50 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/latest.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Key Exchange Methods in Ren-C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Cryptography</category>
          <description><![CDATA[
            <p>Having given a summary of <a href="https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808/">Checksums and Secure Hashes</a>, I thought I'd follow up with a quick description of something you're likely not as familiar with: <strong>Key Exchanges</strong>.</p>
<p>There's old quote I like (but can't find a source for):</p>
<blockquote>
<p>"The shared secret is capital.  We may spend it or squander it."</p>
</blockquote>
<p>An example of taking advantage of a shared secret is when people want to share an encrypted .ZIP file.  If you and your friend both know the encryption password that no one else knows...then you could put the file on a public server for your friend to download.  If you trust the encryption, the fact it was public would not matter.</p>
<p><strong>But what if the situation is that your friend has a password that only they know... and you have a password that only you know?</strong>  That wouldn't seem to help with the .ZIP file scenario, because it expects the same password to decrypt as was used to encrypt it.</p>
<p>Key Exchange is a way of taking your individual "passwords" and coming to an agreement on a third "password" that only the two of you know.  Amazingly enough, you can carry out the conversation where you establish the shared password in public.</p>
<h2>Creating one Shared Secret from two Non-Shared Secrets</h2>
<p>For educational purposes, people use paint-mixing as an analogy for key exchange.  It's really "multiplying big prime numbers" instead of mixing paint, but it's visual and easy to see.</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png" data-download-href="https://forum.rebol.info/uploads/default/184fa9035c24ffa1250e324b61acaa3915f7757e" title="image"><img src="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_345x500.png" alt="image" data-base62-sha1="3t485Do7kYfAw6HMsMv5klePtsq" width="345" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_345x500.png, https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png 1.5x, https://forum.rebol.info/uploads/default/original/1X/184fa9035c24ffa1250e324b61acaa3915f7757e.png 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/184fa9035c24ffa1250e324b61acaa3915f7757e_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">480√ó695 28 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>This assumes everyone in the world has some kind of weird "common paint".  This paint isn't white (because if you mixed it with something that would be too easy to guess at the precise shade you had mixed it with).  And it isn't black (because mixing might just get you something too dark to measure well).</p>
<p>But the key point to absorb is what the diagram says: <strong>we assume that mixture separation is expensive</strong>.  Once you've mixed the common paint with your secret color, it produces a new shade that no one else knows how to make exactly.</p>
<p>When you and your friend exchange your mixtures you cleverly go to your private lairs and each add your secret color to the other's mixture.  <strong>Now both of you have the same weird color, and this is a secret you share.</strong></p>
<h2>Ren-C Supports Diffie-Hellman Key Exchange</h2>
<p>I oversimplified this by saying you each start with a "password"...because that made it sound like you could just pick a phrase out of your head.  In reality, choosing your secret involves some tricky math...to make sure your secret paint color is a <em>good</em> secret paint color.  You don't pick these--you ask the computer to generate it.</p>
<p>To get the ball rolling, you need to specify what kind of "common paint" to use.  You make that by picking two suitable prime numbers, a modulus and a base.  Then you can ask for a unique random secret to be generated.</p>
<p>For the sake of education, I've made it possible to use <em>relatively bad</em> paint mixes with the /INSECURE refinement.  It won't allow numbers that are so broken the process won't work (for instance: non-primes, or primes that don't meet the basic requirements of the algorithm).  This lets you work with small enough numbers that you can see for yourself what's going on more easily.</p>
<p>So let's use a modulus of 9 and a base of 3:</p>
<pre><code>&gt;&gt; mine: dh-generate-keypair/insecure #{09} #{05}
== make object! [
    modulus: #{09}
    generator: #{05}
    private-key: #{07}
    public-key: #{05}
]

&gt;&gt; theirs: dh-generate-keypair/insecure #{09} #{05}
== make object! [
    modulus: #{09}
    generator: #{05}
    private-key: #{05}
    public-key: #{02}
]
</code></pre>
<p>So privately, my secret is 7... and their secret is 5.  But we want to come to an agreement on a new number while only sharing with the public my "mixture" of 5 and their mixture of 2.</p>
<pre><code>&gt;&gt; my-shared: dh-compute-secret mine theirs.public-key
== #{02}

&gt;&gt; their-shared: dh-compute-secret theirs mine.public-key
== #{02}
</code></pre>
<p>So here you see each of us could come to a common agreement of 2.  You can follow through the math on the <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">Wikipedia page</a> if you want...but it's enough to know that it works.</p>
<p>What makes for a good (big!) modulus and base to use?  You don't really need to come up with them yourself, although <a href="https://security.stackexchange.com/a/103924">there are algorithms for it</a>.  There are papers that publish some good choices--and we should probably provide a way to default to well-known ones, like maybe accept either an object or an ISSUE!</p>
<pre><code>&gt;&gt; dh-generate-keypair #RFC-3526
; ...or...
&gt;&gt; dh-generate-keypair make object [base: ..., modulus: ...]
</code></pre>
<p>But the main thing to know is that <strong>both sides have to agree on the "common paint" to use</strong>, in order to come to the same conclusion.  So <code>dh-compute-secret</code> won't work unless the same numbers were used here.</p>
<h2>We Also Support Elliptic Curve Key Exchange (ECHDE)</h2>
<p>Modern Internet Transport Security has moved on from traditional Diffie Hellman to trickier math.  But the premise is the same.</p>
<p>In the interface, we only support two "common paints" for this method: "secp256r1" and "curve25519".  There's no option for small answers here:</p>
<pre><code>&gt;&gt; mine: ecc-generate-keypair 'curve25519
== make object! [
    public-key: make object! [
        x: #{121413C34DC265025F24CBEBBA6065B9
             75F1BFA6E493D07A0F4776FAE03DC245}
        y: #{00000000000000000000000000000000
             00000000000000000000000000000000}
    ]
    private-key: #{610A8D99A72500B3A2E8A1FD714FA412
                   17F0A0EA5EDFC9CFBDAE0425E199DC70}
]

&gt;&gt; theirs: ecc-generate-keypair 'curve25519
== make object! [
    public-key: make object! [
        x: #{10D65366D8C9229591C99903D3B5EB0F
             57709AD27E37989E4782050D2B9B2B93}
        y: #{00000000000000000000000000000000
             00000000000000000000000000000000}
    ]
    private-key: #{7C3262BF6028B049EEDC6C37E37A8261
                   EA4DF31F16E4D534D92A7EF11D974618}
]
</code></pre>
<p>But it works the same way; you come to the same conclusion when combining your partner's public portion with your private portion:</p>
<pre><code>&gt;&gt; my-secret: (
    ecdh-shared-secret 'curve25519 mine.private-key theirs.public-key
)
== #{E27891074A60250580B8F2C7CB2448A9AA491C97161D7C8D381348D90E438025}

&gt;&gt; their-secret: (
    ecdh-shared-secret 'curve25519 mine.private-key theirs.public-key
)
== #{E27891074A60250580B8F2C7CB2448A9AA491C97161D7C8D381348D90E438025}

&gt;&gt; my-secret = their-secret
== #[true]
</code></pre>
<h2>Would Average Users Ever Need Key Exchange Functions?</h2>
<p>Right now, the main reason most people would care whether the language has these key exchanges is because without them you can't do TLS.  So no reading or writing over HTTPS.</p>
<p>You really only need key exchanges when protocols are trying to establish private channels of communication.  So notably, some cryptographic protocols (like Bitcoin) don't need key exchanges...because they're carrying out their work in public.</p>
<ul>
<li>
<p><strong>It would be neat if we could democratize the creation of cryptographic protocols</strong>.  I think giving people easier and more transparent access to these kinds of things could foster some grassroots innovation, where people would build <em>exactly the security they needed</em> into a program's design...no more and no less.</p>
<ul>
<li>This would stand in contrast to today's methods, where "security" is accomplished by standing on top of a mountain of protocols (using a literal zoo of cryptographic algorithms) to tunnel and log in somewhere that they are "safe"...and putting more data than they need to in that place.</li>
</ul>
</li>
<li>
<p><strong>But even "simple" cryptography is tricky to reason about, and people are lazy.</strong>  I myself am pretty guilty of doing things like falling back on my GitHub password and resetting my keys instead of doing a good job of filing them in safe places.</p>
<ul>
<li>Convincing people their programs should be "organic and locally sourced"... by tailor-making the protocols and asking their users to keep track of files, is going to be a hard sell to those who are happy to use OAuth and leave this all up to Google.</li>
</ul>
</li>
</ul>
<p>So pessimistically speaking, I don't know that we're going to be able to market easy-to-use key exchange to anyone as a killer feature.  It's a nice thought, and I certainly like having it available to tinker with.  But I'd be surprised if anyone reading this has an idea how to use it in something they're working on.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/key-exchange-methods-in-ren-c/1809">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/key-exchange-methods-in-ren-c/1809</link>
          <pubDate>Mon, 09 May 2022 18:20:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1809</guid>
          <source url="https://forum.rebol.info/t/key-exchange-methods-in-ren-c/1809.rss">Key Exchange Methods in Ren-C</source>
        </item>
        <item>
          <title>Checksums and Secure Hashes in Ren-C</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Cryptography</category>
          <description><![CDATA[
            <p>I thought I'd write up a quick post about algorithms that take in a bunch of bytes--like a BINARY!--and produce a (usually) shorter "fingerprint" of that data.</p>
<ul>
<li>
<p>It's not hard to make an <em>insecure</em> hash...like taking the first couple of letters of a string: <code>"DICKENS" =&gt; DI</code>.  That might be useful if you're trying to divide book authors into drawers of an old-fashioned library card catalog.</p>
</li>
<li>
<p>But it's easy to find another string that would make the same "DI" fingerprint, like "DIABOLICAL" or "DIR^/FORMAT C:"</p>
</li>
<li>
<p>If you were using a fingerprint to trust something was what it was supposed to be, the easiness of generating these "collisions" is a liability!! <img src="https://forum.rebol.info/images/emoji/twitter/skull_and_crossbones.png?v=9" title=":skull_and_crossbones:" class="emoji" alt=":skull_and_crossbones:"></p>
</li>
<li>
<p>Secure hashes do complicated "one-way functions" in math to make it <em>really hard</em> on today's computers to fabricate any binary sequence--even garbage--that will give you the same fingerprint as any other input.</p>
</li>
</ul>
<p>You've certainly seen web pages that redirect you off to download a file, but beforehand give you some bytes of what the file should securely hash to.  <sub>(And you've probably never checked to make sure they match.)</sub></p>
<h2>If the Fingerprint is Shorter than the data, <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">COLLISIONS EXIST!</a>
</h2>
<p>You obviously can't give every 500mb file in the universe a unique fingerprint that's 32-bits, 128-bits, 512-bits, 2048-bits etc.</p>
<p>So the concept behind a secure hash is just supposed to be you can't find a collision until we're all dead and no one cares.  Less grimly: we might pair a hash with an expiration date to say not to trust a hash after a very conservative guess at how long it would take for computers to advance enough to break it.</p>
<p>When this hope falls apart (e.g. if any researcher can show two inputs that generate the same fingerprint) it's generally considered that the "secure" part of that hash is broken...for the purposes of whatever time-bubble you're living in.</p>
<h2>We Have Four Secure Hashes in the Box Right Now...</h2>
<p>It shouldn't be surprising that longer fingerprints correlate with being harder to find collisions:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'md5
== #{3717A787E2F16310EA51DC0308E88803}  ; considered vulnerable

&gt;&gt; checksum/method {DICKENS} 'sha1
== #{DFE5DD61B2B19C319DBC4F44328CDF8D24366F88}  ; considered vulnerable

&gt;&gt; checksum/method {DICKENS} 'sha256
== #{52A095CF1F0319EF44FF9134AAD2EF5E2BFE1A48307DCB0AD0408F1CE393C950}

&gt;&gt; checksum/method {DICKENS} 'sha512
== #{
E8DBC26DE28FAA1BC2A6A3E1BC6DD22C1ECB3FD0D5FCBBFB69BC63C6AAC6A9CE
FB76294EFFB0522D4C90A5E5829233FC5BC5B811AE6684A6EA632ECB3FF88DA1
}

&gt;&gt; checksum/method {DICKENS} 'ripemd160         ; bitcoin uses this one
== #{ADC86945BE4CEF31F0CFCAF66775E1DA5160F877}  ; ...no one knows why
</code></pre>
<p>But longer isn't <em>intrinsically</em> better...there might be a weakness to exploit in the method used by a longer hash which isn't present in shorter ones.  However, a bunch of mathematicians look at this stuff and we would generally hope that we'd be getting what we pay for--more bytes meaning more security (unless they're from the NSA and trying to punk us).</p>
<h2>We Also Have Three <em>Insecure</em> Hashes...</h2>
<p>These are fine when you're doing something that is not supposed to be protecting against adversarial attacks.  They're smaller to store and much cheaper to calculate...but it's trivial to find other input data that would produces the same 32-bit result:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'crc32
== #{FB05F0BC}  ; used to very gzip files (among other places)

&gt;&gt; checksum/method {DICKENS} 'adler32
== #{0202D207}  ; used by zlib deflate and inflate
</code></pre>
<p>If you want a <em>really</em> cheapskate insecure checksum, we include the one that is in TCP packets on the internet:</p>
<pre><code>&gt;&gt; checksum/method {DICKENS} 'tcp
== #{CA32}
</code></pre>
<hr>
<blockquote>
<p><strong>Fun Corner</strong>: Let's find a collision!</p>
<pre><code>&gt;&gt; until [
    string: copy {}
    repeat (random 10) [append string make char! 64 + random 26]
    #{CA32} = checksum/method string 'tcp
]
== #[true]

&gt;&gt; print string
AOGTDDN

&gt;&gt; checksum/method {AOGTDDN} 'tcp
== #{CA32}
</code></pre>
<p>That wasn't so hard, but... if you can find collisions for any of the <em>secure</em> hashes above (even the relatively-weak MD5 or SHA1) <em>you will be famous!</em></p>
</blockquote>
<h2>We're Primed To Make <strong>STREAMING</strong> Secure (or Insecure) Hashes !</h2>
<p>R3-Alpha did not have fancy modern hashes like SHA256 or SHA512.  But also the code it used was copy-pasted out of a library that required you to have all the data at once.</p>
<p>Hence if you have a multi-gigabyte DVD .iso file that you want to checksum, you have to read that into a multi-gigabyte BINARY! to process it.</p>
<p>But since Ren-C is leveraging the cryptography of the <a href="https://github.com/Mbed-TLS/mbedtls">pure C library known as mbedTLS</a>, the foundations are there to stream in little blobs at a time...and it is generalized so we can just flip on or off any hashes we care about.  <a href="https://forum.rebol.info/t/what-is-a-port/617/5">If we only knew how to express streaming with PORT!s (or whatever)</a>.</p>
<p>And also, the CRC32 and ADLER32 algorithms we have "for free" by including Zlib are now set up in a way that the insecure hashes can be streamed too.</p>
<h2>
<img src="https://forum.rebol.info/images/emoji/twitter/globe_with_meridians.png?v=9" title=":globe_with_meridians:" class="emoji" alt=":globe_with_meridians:"> <em>"How Does This Tie Into The Web Repl Story"?</em> <img src="https://forum.rebol.info/images/emoji/twitter/globe_with_meridians.png?v=9" title=":globe_with_meridians:" class="emoji" alt=":globe_with_meridians:">
</h2>
<p>I really want to have a laser focus on whether investing effort into something is going to be something that pays off or not, and to me a part of that payoff question is "will people using the web build care".</p>
<p><strong>Right now the web build does not include the CHECKSUM function at all.</strong>  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>That is too bad, because I do believe that putting secure hashes into the hands of users at the Web Repl prompt (as well as other basic crypto parts) would be a great playground.</p>
<p>But it would be rather heavyweight to push secure hashing into the default .wasm being pulled down on every site if it didn't use it.  This is why I really want to get "Wasm extensions" working, that can be dynamically loaded.  There's something called "side modules" that I have meant to explore but haven't.</p>
<p>Anyway, I hope this summary gives a little insight into where this is at, and perhaps educational for those who don't have experience with the difference between secure/insecure hashing.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808</link>
          <pubDate>Mon, 09 May 2022 04:04:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1808</guid>
          <source url="https://forum.rebol.info/t/checksums-and-secure-hashes-in-ren-c/1808.rss">Checksums and Secure Hashes in Ren-C</source>
        </item>
        <item>
          <title>Dropping RC4 Support from the Crypto Extension</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Cryptography</category>
          <description><![CDATA[
            <p>I pretty sure no one out there is using it, but the RC4 cipher has been deprecated for a pretty long time now.  Per Wikipedia:</p>
<blockquote>
<p>In <a href="https://en.wikipedia.org/wiki/Cryptography">cryptography</a>, <strong>RC4</strong> (Rivest Cipher 4 also known as <strong>ARC4</strong> or <strong>ARCFOUR</strong> meaning Alleged RC4, see below) is a <a href="https://en.wikipedia.org/wiki/Stream_cipher">stream cipher</a>. While it is remarkable for its simplicity and speed in software, multiple vulnerabilities have been discovered in RC4, rendering it insecure.</p>
</blockquote>
<p>The insecurity of RC4 led the IETF to <a href="https://tools.ietf.org/html/rfc7465">prohibit RC4 for TLS use in 2015</a></p>
<p>However, the original cryptography code (mostly from AxTLS) had an RC4 function, and it was in mbedTLS 2.  So I went ahead and kept it working.</p>
<p>It is now dropped from mbedTLS 3.  So in the scheme of things, time to let it go.</p>
<h2>Code Being Dropped</h2>
<p>The files arc4.h and arc4.c from mbedTLS are now gone, and this was the crypt module code for supporting it:</p>
<pre><code>static void cleanup_rc4_ctx(const REBVAL *v)
{
    struct mbedtls_arc4_context *ctx
        = VAL_HANDLE_POINTER(struct mbedtls_arc4_context, v);
    mbedtls_arc4_free(ctx);
    FREE(struct mbedtls_arc4_context, ctx);
}


//
//  export rc4-key: native [
//
//  "Encrypt/decrypt data (modifies) using RC4 algorithm."
//
//      return: [handle!]
//      key [binary!]
//  ]
//
REBNATIVE(rc4_key)
//
// !!! RC4 was originally included for use with TLS.  However, the insecurity
// of RC4 led the IETF to prohibit RC4 for TLS use in 2015:
//
// https://tools.ietf.org/html/rfc7465
//
// So it is not in use at the moment.  It isn't much code, but could probably
// be moved to its own extension so it could be selected to build in or not,
// which is how cryptography methods should probably be done.
{
    CRYPT_INCLUDE_PARAMS_OF_RC4_KEY;

    struct mbedtls_arc4_context *ctx = TRY_ALLOC(struct mbedtls_arc4_context);
    mbedtls_arc4_init(ctx);

    REBSIZ key_len;
    const REBYTE *key = VAL_BINARY_SIZE_AT(&amp;key_len, ARG(key));
    mbedtls_arc4_setup(ctx, key, key_len);

    return Init_Handle_Cdata_Managed(
        D_OUT,
        ctx,
        sizeof(struct mbedtls_arc4_context),
        &amp;cleanup_rc4_ctx
    );
}


//
//  export rc4-stream: native [
//
//  "Encrypt/decrypt data (modifies) using RC4 algorithm."
//
//      return: &lt;none&gt;
//      ctx "Stream cipher context"
//          [handle!]
//      data "Data to encrypt/decrypt (modified)"
//          [binary!]
//  ]
//
REBNATIVE(rc4_stream)
{
    CRYPT_INCLUDE_PARAMS_OF_RC4_STREAM;

    REBVAL *data = ARG(data);

    if (VAL_HANDLE_CLEANER(ARG(ctx)) != cleanup_rc4_ctx)
        rebJumps ("fail [{Not a RC4 Context:}", ARG(ctx), "]");

    struct mbedtls_arc4_context *ctx
        = VAL_HANDLE_POINTER(struct mbedtls_arc4_context, ARG(ctx));

    REBVAL *error = nullptr;

    REBSIZ length;
    REBYTE *output = VAL_BINARY_SIZE_AT_ENSURE_MUTABLE(&amp;length, data);
    const REBYTE *input = output;
    IF_NOT_0(cleanup, error, mbedtls_arc4_crypt(
        ctx,
        length,
        input,  // input "message"
        output  // output (same, since it modifies)
    ));

  cleanup:
     if (error)
        rebJumps ("fail", error);

    return rebNone();
}
</code></pre>
<p>...and here is the very basic test, also being removed...</p>
<pre><code>ctx: rc4-key as binary! "Deprecated Algorithm"
data: as binary! "But Implemented Anyway"
rc4-stream ctx data
data = #{0C4E2F3BD157EA7214C33F280BE4D9DF1DFB580563A6}</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dropping-rc4-support-from-the-crypto-extension/1807">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dropping-rc4-support-from-the-crypto-extension/1807</link>
          <pubDate>Mon, 09 May 2022 01:32:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1807</guid>
          <source url="https://forum.rebol.info/t/dropping-rc4-support-from-the-crypto-extension/1807.rss">Dropping RC4 Support from the Crypto Extension</source>
        </item>
        <item>
          <title>About the Cryptography category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Cryptography</category>
          <description><![CDATA[
            <p>Discussion of things related to cryptography, which includes low level primitives (ciphers, hashes, and key exchange) as well as higher-level protocols such as TLS.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-cryptography-category/1806">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-cryptography-category/1806</link>
          <pubDate>Mon, 09 May 2022 01:11:25 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1806</guid>
          <source url="https://forum.rebol.info/t/about-the-cryptography-category/1806.rss">About the Cryptography category</source>
        </item>
        <item>
          <title>REPL Querying</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>It might be worthwhile to take some inspiration from this:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/ellie/atuin" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://opengraph.githubassets.com/dca1958aebeb424b5526f3fa3c903c51716ab4f22eb7cd64a50259c3d4288398/ellie/atuin" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/ellie/atuin" target="_blank" rel="noopener">GitHub - ellie/atuin: üê¢ Magical shell history</a></h3>


  <p><span class="label1">üê¢ Magical shell history. Contribute to ellie/atuin development by creating an account on GitHub.</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>I'd like us to start using the <a href="https://github.com/hostilefork/replpad-js/blob/master/storage.md">persistence features</a> to remember previous sessions, and perhaps make it easier to <strong>curate past Repl interactions into scripts</strong>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/repl-querying/1804">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/repl-querying/1804</link>
          <pubDate>Sat, 07 May 2022 19:11:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1804</guid>
          <source url="https://forum.rebol.info/t/repl-querying/1804.rss">REPL Querying</source>
        </item>
        <item>
          <title>LOGIN Magazine Historical Covers</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Offtopic</category>
          <description><![CDATA[
            <p>Those who are interested in Rebol history might be interested in these magazine covers.  I am trying to delete files off a computer and had them, and if they have any relevance they are better backed up as part of the forum backups:</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4.jpeg" data-download-href="https://forum.rebol.info/uploads/default/5385218e7af6c5e52f7dee3c114207f08668bbe4" title="rebol-login-nov-2001"><img src="https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_353x500.jpeg" alt="rebol-login-nov-2001" data-base62-sha1="bUQRrNKBWgwSAqtWhtOVp1zs0ks" width="353" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_353x500.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_529x750.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_706x1000.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/5385218e7af6c5e52f7dee3c114207f08668bbe4_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">rebol-login-nov-2001</span><span class="informations">1448√ó2048 534 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/19d65a0ef0878828180a88f3257fae3cc465db94.jpeg" data-download-href="https://forum.rebol.info/uploads/default/19d65a0ef0878828180a88f3257fae3cc465db94" title="rebol-login-sep-2002"><img src="https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_353x500.jpeg" alt="rebol-login-sep-2002" data-base62-sha1="3GzbmOscS1RVPpGqNNJcrWd2PY0" width="353" height="500" srcset="https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_353x500.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_529x750.jpeg 1.5x, https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_706x1000.jpeg 2x" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/19d65a0ef0878828180a88f3257fae3cc465db94_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">rebol-login-sep-2002</span><span class="informations">1448√ó2048 488 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/login-magazine-historical-covers/1803">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/login-magazine-historical-covers/1803</link>
          <pubDate>Fri, 06 May 2022 19:45:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1803</guid>
          <source url="https://forum.rebol.info/t/login-magazine-historical-covers/1803.rss">LOGIN Magazine Historical Covers</source>
        </item>
        <item>
          <title>DO vs. IMPORT and &quot;Console-Extending Applications&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p>During the module reworking, I roughly embraced the R3-Alpha distinction made in the header between two categories:</p>
<hr>
<pre><code>Rebol [Type: Script ...]  ; first category
</code></pre>
<ul>
<li>
<p>You would run these "Scripts" with DO</p>
</li>
<li>
<p>Performing a DO could have side effects, but should be isolated...not allowed to leak changes into the caller's environment</p>
<ul>
<li>This was a new rule I imposed as a default (because "Isolate" was made more economical, and I wanted to see how much we could get away with)</li>
</ul>
</li>
</ul>
<hr>
<pre><code>Rebol [Type: Module ...]  ; second category
</code></pre>
<ul>
<li>
<p>An "ideal" module would not have any "side-effects"...because the concept was that no matter how many times you run IMPORT you will only get one copy of that module in memory.</p>
<ul>
<li>Notably, if you run an IMPORT on a module that has already been loaded before...that will not run any code in the module body...it will just give you the MODULE! object that it already made.</li>
</ul>
</li>
</ul>
<hr>
<p><strong>We probably shouldn't be surprised that there are things that don't fit neatly into these categories!</strong></p>
<hr>
<h2>"Console-Extending Applications"</h2>
<p>So these add some functions to your environment, but also tend to have some side effects.  Like:</p>
<ul>
<li>
<p><strong><a class="mention" href="/u/gchiu">@gchiu</a>'s chess program</strong> - It wants to display a board, show you some help, and add various chess-related behaviors to the console.  But to add those commands which "contaminate" the calling environment, you have to say <strong>import</strong>.  On the other hand, by displaying a board and showing help, it sort of violates that "no side-effects" rule.</p>
<ul>
<li>He is working on another prescription-generating application that lets you automate a pop-up window that works in a similar way.</li>
</ul>
</li>
<li>
<p><strong>The ReplPad interactivity test</strong> - This test adds OKAY and NOPE to the vocabulary... where it's actually the typing of those words that runs commands which advance the console through steps in some way and instructs you on what to look for.</p>
<ul>
<li>
<p>If you don't use IMPORT, you don't get the commands added as commands to the context...</p>
</li>
<li>
<p>...but if you DO use IMPORT, you can only run through the test once... because doing it again will not load the code that prints out the instructions and launches it...</p>
</li>
</ul>
</li>
</ul>
<h2>Should DO allow you to EXPORT ?</h2>
<p>The nice thing about the word DO is it sounds pretty unambiguous, that you want to run something that has side effects.</p>
<p>But I do like the default of not leaking into the enclosing environment.</p>
<p>It seems like allowing scripts to export symbols could be a lazy compromise...which would let you ask to run something (vs. just bringing in a cached copy if previously loaded).</p>
<p>Yet this raises the question of what sort of behavior you'd expect from something that extends the console if you DO it multiple times.</p>
<p>There's also some things to think about regarding how modules will only load once, with respect to debugging.  If you have a complex multi-module project running and want to tweak something--reload it and retry without losing your current interpreter state, that's rather complicated semantically.</p>
<p>We might also consider the idea that there's a new script type.  Something like <strong><code>Rebol [Type: Commands ...]</code></strong> for lack of a better name.  Maybe this would by default give you a new console session separate from the one you were in?</p>
<p>Much more work is needed on binding and modules, to try and figure out how to deliver a good experience.  So hopefully if I don't die in a tornado here in Tennessee, I will work on that soon.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/do-vs-import-and-console-extending-applications/1802">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/do-vs-import-and-console-extending-applications/1802</link>
          <pubDate>Fri, 06 May 2022 19:42:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1802</guid>
          <source url="https://forum.rebol.info/t/do-vs-import-and-console-extending-applications/1802.rss">DO vs. IMPORT and &quot;Console-Extending Applications&quot;</source>
        </item>
        <item>
          <title>Suppressing verbosity in the replpad</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Emscripten</category>
          <description><![CDATA[
            <p>I am developing a replpad app but I want the users to go straight to a URL and start the app.  I'd rather that they didn't have to type</p>
<pre><code>import @rx
</code></pre>
<p>when a lot of module stuff is sent to the console interrupting the interface, eg</p>
<pre><code>`== make module! [
    alpha: make bitset! #{00000000000000007FFFFFE07FFFFFE0}  
    rx: '#[action! {rx} [drug]]  
    ...  
</code></pre>
<p>`</p>
<p>Maybe <code>http://hostilefork.com/media/shared/replpad-js/@rx</code> would be better and if a module is provided then verbose mode is automatically suppressed.</p>
<p>Anyway, suggestions for a standardised way to run our apps?</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801</link>
          <pubDate>Thu, 28 Apr 2022 09:49:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1801</guid>
          <source url="https://forum.rebol.info/t/suppressing-verbosity-in-the-replpad/1801.rss">Suppressing verbosity in the replpad</source>
        </item>
        <item>
          <title>Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p><code>~null~</code> isotopes are a novel solution shaped to solve a specific problem.  As a reminder of what the goal is...</p>
<h1>The Goal is to Please <a class="mention" href="/u/rgchris">@rgchris</a> <em>AND</em> Please me</h1>
<p>NULL is the signal of "soft failure".  It's a unique result reserved for when a branch fails, or when a loop is halted by a BREAK, when PARSE fails...etc.</p>
<p>Its property of not being storable in blocks makes it critical to disambiguating this historical problem:</p>
<pre><code>redbol&gt;&gt; third [a b #[none]]
== #[none]

redbol&gt;&gt; third [a b]
== #[none]
</code></pre>
<p>In a language that prides itself on letting you work with code structure, <em>this is the tip of the iceberg of the problems that null solves</em>, and you will find the distinction's utility across the board (obviously, in tools like COMPOSE).  It facilitates rigorous analysis and rearrangements...without needing to drop to C or write convoluted code:</p>
<pre><code>&gt;&gt; third [a b _]
== _

&gt;&gt; third [a b]
; null
</code></pre>
<p>Hence NULL has taken the place of blank ("none!") in many places, one of which is the unique result of failed conditionals.</p>
<p>But unlike the elements in a block, a branch that evaluates isn't required to be non-NULL.  Which leads us to the long running question of what to bend NULL branches to so they don't conflate with the branch-not-taken result.</p>
<h2>Chris has (rightly) expressed concern</h2>
<p>At times I've said that it's not that big a deal that branches can't evaluate to NULL and get distorted.  "You didn't have a NULL before, so why get so worked up about control constructs not returning it?"</p>
<p>But the now-pervasive nature of NULL means it can't be avoided.  So:</p>
<p><em>"How do you express branching code which wants to do some work but also produce NULL as an evaluative product?"</em></p>
<p>Conflation was not a problem, e.g. in Rebol2:</p>
<pre><code>rebol2&gt;&gt; exampler: func [x] [
     print "returning sample or none if not found"
     case [
         x = &lt;string&gt; [print "sample string" {hello}]
         x = &lt;integer&gt; [print "sample integer" 3]
         x = &lt;none&gt; [print "sample none" none]
     ]
  ]

rebol2&gt;&gt; exampler &lt;string&gt;
returning sample or none if not found
sample string
== "hello"

rebol2&gt;&gt; exampler &lt;blatz&gt;
returning sample or none if not found
== #[none]

rebol2&gt;&gt; exampler &lt;none&gt;
returning sample or none if not found
sample none
== #[none]
</code></pre>
<p>However NULL is now the basic currency of "soft failure".  As such it would not be uncommon to be in the situation where a branching decision process would want to intentionally return NULL as part of the work it does.</p>
<p>Without something like the isotope decay mechanism, unpleasant convolutions would be needed, for instance surrounding anything that wanted to tunnel a NULL with a CATCH and THROW'ing it:</p>
<pre><code>x: catch [
    throw switch 1 + 2 [
        1 [print "one" 1]
        2 [print "two", &lt;two&gt;]
        3 [print "three", throw null]
     ]
]
</code></pre>
<p>Definitely not good.  But regarding the pleasing-me-part, remember I am trying to avoid this situation:</p>
<pre><code>&gt;&gt; case [
     true [
          print "case branch"
          if 1 &gt; 2 [print "failed inner"]
     ]
   ] else [
     print "else branch"
   ]

case branch
else branch  ; ugh
</code></pre>
<p>I don't want the CASE branch to evaluate to NULL just because the failed IF inside the branch was NULL.  That would mean the ELSE tied to the CASE runs even though the code for the branch ran.</p>
<h2>Enter Isotopes</h2>
<p>One thing null isotopes have in common with NULL (like all BAD-WORD! isotopes) is that they can't be put in blocks.  But they have been automatically "decaying" into regular NULL when stored into variables.</p>
<pre><code>&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; x: ~null~
== ~null~  ; isotope  &lt;-- note the overall expression is still an isotope

&gt;&gt; x
; null
</code></pre>
<p>The twist is that they are <em>different enough</em> from true NULL such that a THEN or an ELSE can consider them a situation where the branch did not run:</p>
<pre><code>&gt;&gt; if false [&lt;ignored&gt;]
; null

&gt;&gt; if true [null]
== ~null~  ; isotope

&gt;&gt; if true [null] else [print "This won't run"]
== ~null~  ; isotope
</code></pre>
<p>The reason functions like ELSE can "see" the isotope is that they don't take an ordinary parameter on their left.  They take a ^META argument.  These can see the distinction between a ~null~ isotope and a "true" NULL.</p>
<p><strong>I'd largely say this has been working well...certainly better than its conceptual predecessors.</strong>  It makes piping NULL out of branches trivially easy, when the fear of conflation is not a problem.</p>
<pre><code>&gt;&gt; x: switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
== ~null~

&gt;&gt; x
; null
</code></pre>
<p>The automatic decay in variable storage prevents you from needing an explicit operation to turn ~null~ isotopes into pure nulls:</p>
<pre><code>&gt;&gt; x: decay switch 1 + 2 [
     1 [print "one" 1]
     2 [print "two", &lt;two&gt;]
     3 [print "three", null]
   ]
three
; null
</code></pre>
<h1>But <a class="mention" href="/u/rgchris">@rgchris</a> Would Likely Want any <em>NORMAL</em> arg decay</h1>
<p>At the very moment I am writing this, ~null~ isotopes are like all other BAD-WORD! isotopes and not accepted as normal parameters.</p>
<p><strong>They <em>could</em> decay to pure NULL for all normal args.</strong>  But let me explain a bummer of what we lose in that bargain.</p>
<p>It takes away a safety idea I had with functions like MATCH.</p>
<pre><code>&gt;&gt; match [&lt;opt&gt; integer!] 3
== 3

&gt;&gt; match [&lt;opt&gt; integer!] "notaninteger"
; null

&gt;&gt; match [&lt;opt&gt; integer!] null
== ~null~  ; isotope
</code></pre>
<p>The idea was that it could say "yes, this matched" but if ~null~ isotopes were tested, they'd give an error:</p>
<pre><code>&gt;&gt; if (match [&lt;opt&gt; integer!] null) [print "Yes it matched!"]
** Error: IF does not accept ~null~ isotopes without a ^META condition
</code></pre>
<p>Were MATCH to have passed through a plain NULL it would have succeeded in the match but not run the branch.  So it's nice to get the warning on the isotope.</p>
<p><strong>Or it could just return a ~matched~ isotope</strong>.  But this loses the following nice isotopic property:</p>
<pre><code>&gt;&gt; x: match [&lt;opt&gt; integer!] null else [fail "NO MATCH"]
== ~null~  ; isotope

&gt;&gt; x
; null
</code></pre>
<p>In fact I instituted other decaying variants for ~blank~ and ~false~</p>
<pre><code>&gt;&gt; y: match [blank!] _ else [fail "NO MATCH!"]
== ~blank~  ; isotope

&gt;&gt; y
== _

&gt;&gt; z: match [logic!] 1 = 2 else [fail "NO MATCH!"]
== ~false~  ; isotope

&gt;&gt; z
== #[false]
</code></pre>
<h1>So What To Do About MATCH and its bretheren?</h1>
<p>Seems the options are:</p>
<ol>
<li>
<p><em>Don't worry about it.</em>  If you write <strong>match [logic!] 1 = 2</strong> you get back <strong>#[false]</strong> and should you write an expression like <strong>if (match [logic!] 1 = 2) [print "Match!]</strong> you get what you deserve.</p>
</li>
<li>
<p><em>Use a different isotope.</em>  Let's say that <strong><code>match [&lt;opt&gt;] null</code></strong> is simply <strong>~matched~ (isotope)</strong>.  It wouldn't have the decaying property, but would have the invalidness property.</p>
</li>
<li>
<p><em>Have a MATCH/FALSEY variant.</em>  Let plain <strong>match</strong> on a falsey thing trigger an error and if you write <strong>if match/falsey ...</strong> then you clearly do know what you're doing so it becomes like case (1).</p>
</li>
<li>
<p><em>Make all conditional arguments take ^META arguments for their conditions.</em>  This would put the responsibility for checking for isotopes on them, and they'd uniquely disallow them before UNMETA'ing them and then testing for truth/falsehood.</p>
</li>
</ol>
<p>Option (4) is too taxing...impacting not just the interface to IF but the implementation of CASE and any conditional construct.</p>
<p><strong>I think I like (3) because it punts the ball down the road a bit.</strong></p>
<p>But this might still not suit Chris.</p>
<h1>Should Non-Meta Arguments Decay Null isotopes?</h1>
<p>The "auto-decay" of ~null~ isotopes means no variable can ever hold a NULL isotope.  And there's also a rule that no <em>normal</em> parameter can ever be passed an isotope, only ^META parameters.</p>
<p>In the beginning, it seemed useful if normal arguments would automatically decay null isotopes:</p>
<pre><code>&gt;&gt; foo: func [x] [if null? x [print "Yup, it's null"]]

&gt;&gt; foo if true [null]
Yup it's null

&gt;&gt; metafoo: func [^x] [
    case [
        null? x [print "regular null"]
        x = '~null~ [print "null isotope"]
        true [print "something else"]
     ]
   ]

&gt;&gt; metafoo if false [null]
regular null

&gt;&gt; metafoo if true [null]
null isotope
</code></pre>
<p>There is a manual DECAY operator which could be used, but would not meet that wish:</p>
<pre><code>&gt;&gt; ~null~
== ~null~  ; isotope

&gt;&gt; decay ~null~
; null

&gt;&gt; ~blank~
== ~blank~  ; isotope

&gt;&gt; decay ~blank~
== _

&gt;&gt; ~false~
== ~false~  ; isotope

&gt;&gt; decay ~false~
== #[false]
</code></pre>
<h1>Should DECAY Conflation Be A Customization?</h1>
<p>Another avenue of satisfaction could be to say that you simply customize your environment with some definitions to make auto-decaying constructs:</p>
<pre><code>switch: chain [:switch | :decay]
case: chain [:case | :decay]
...

&gt;&gt; case [true [null]]
; null

&gt;&gt; case [false [10]]
; null
</code></pre>
<p>I don't like it, but if someone isn't going to use ELSE (or is willing to accept this very easily unintentional conflation if they do) it could be an option.</p>
<p><strong>I really do believe the ability to tell from outside the construct if a branch has been taken is an interesting property, which even those who think they won't use ELSE or THEN can leverage, especially when building constructs atop each other.</strong>  But this isn't something that can be appreciated without usage, or trying to write something like UPARSE generically in usermode.</p>
<h1>Should function RETURN decay by default?</h1>
<p>Continuing along these lines, this has to do with the pattern of:</p>
<pre><code>foo: func [x] [
    return switch x [
         1 [print "one", #one]
         2 [print "two", null]
         3 [print "three", &lt;three&gt;]
    ]
]

&gt;&gt; foo 1 + 2
two
== ???   ; should this be ~null~ isotope or just NULL
</code></pre>
<p>Also, should it matter whether there's a RETURN there or not?  Is this something the type spec should distinguish?</p>
<p>Right now there's a refinement called /ISOTOPE on RETURN which asks it not to decay.</p>
<p><strong>If all non-^META parameters decay by default, then it seems isotopic decay is the right default for RETURN even though it takes a ^META parameter and returns non-decaying isotopes.</strong></p>
<h2>As Always, A Lot To Think About</h2>
<p>Want to get this posted because it's preventing me from making new drafts (Discourse won't let you have multiple top-level post drafts in-flight for some reason).</p>
<p>Will keep mulling it all over.</p>
<p><em>"A designer knows he has achieved perfection not when there is nothing left to add, but when there is nothing left to take away."</em></p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799</link>
          <pubDate>Thu, 07 Apr 2022 04:14:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1799</guid>
          <source url="https://forum.rebol.info/t/conflation-vs-safety-return-and-the-finer-points-of-null-isotopes/1799.rss">Conflation vs. Safety, RETURN and the Finer Points of ~null~ Isotopes</source>
        </item>
        <item>
          <title>Rebmu History Removed from File (is History: a good idea?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p>When I started Rebmu I followed along the pattern of having seen people put <strong><code>History:</code></strong> in the headers of files.  And as it got longer, I kind of questioned the value of it.</p>
<p>I'm not sure what the "best practices" for history is, but it's a lot of stuff to skip over when you're trying to get to the meat of a file.  It warrants its own discussion topic (which I guess can be discussed here, with the extracted history).</p>
<pre><code>History: [
    0.1.0 [10-Jan-2010 {Sketchy prototype written to cover only the
    Roman Numeral example I worked through when coming up with the
    idea.  So very incomplete, more a proof of concept.}]

    0.2.0 [22-Jun-2010 {Language more complete, includes examples.
    Ditched concept of mushing symbols like + and - into single
    character operators is removed due to realization that A+
    B+ C+ etc. are more valuable in the symbol space than one
    character for AD.}]

    0.3.0 [24-Jun-2010 {Made backwards compatible with Rebol 2.
    Note that things like CN for continue or PERCENTAGE! datatype
    were added in Rebol 3.  You can use these in your Rebmu programs
    but they will only work if using Rebmu with an r3 interpreter.
    Also did several name tweaks like instead of AA for AND~ it's
    now A~ along with other consistencies.}]

    0.5.0 [16-Feb-2014 {Version bump to indicate growing maturity
    of the language.  Abandon Rebol 2 support.  Rebmu files now
    have proper Rebol ecology headers.}]

    0.6.0 [6-Apr-2014 {Large cleanup creating incompatibility with
    most all previous Rebmu code solutions.  Examples have been updated
    in GitHub.  Major theme was removing the custom IF/UNLESS/EITHER
    implementation and some clearer names.}]

    0.7.0 [15-Sep-2015 {Project revisited to incorporate new ideas and
    decisions from the Ren/C effort.  Incorporates the rebol-proposals
    module to work with experimental language features instead of
    having its own "incubator" project.  "Mu library" features removed
    in favor of embracing the language default more closely.}]
]</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rebmu-history-removed-from-file-is-history-a-good-idea/1798">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebmu-history-removed-from-file-is-history-a-good-idea/1798</link>
          <pubDate>Mon, 07 Mar 2022 08:22:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1798</guid>
          <source url="https://forum.rebol.info/t/rebmu-history-removed-from-file-is-history-a-good-idea/1798.rss">Rebmu History Removed from File (is History: a good idea?)</source>
        </item>
        <item>
          <title>Symbols and Mushing in Rebmu</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p>There are symbols like &amp; and | which were applied somewhat haphazardly in the original Rebmu, as experiments.</p>
<p>For instance, <strong>&amp;</strong> was a shortcut for DOES.</p>
<pre><code>phi: does [print "hi"]
=&gt;
PHI &amp;[print "hi"]
</code></pre>
<p>(There've been murmurs of other uses for &amp;, but no hard decisions on it yet...and even if it were used for HTML characters like <strong>&amp;nbsp</strong>, it might remain free standalone as a symbol.)</p>
<p>For a time, <strong>|</strong> in Ren-C was not something you could redefine as a WORD!, it was its own datatype "BAR!".  But that has been replaced by the successful COMMA!, retaking it as a word.  It was used in function definition, and some of the contractions I've suggested as things like <strong><code>fqC[...]</code></strong> =&gt; <strong>function [a b c] [...]</strong> were contracted as simply <strong><code>c|[...]</code></strong></p>
<p>There was a handling of dots which allowed a quick way of doing redefinitions:</p>
<pre><code>     .[aBCdEF] =&gt; .[a bc d ef] =&gt; a: :bc d: :ef
</code></pre>
<p>There's still some back-and-forth on the handling of lone dot.  I like it being a reduced case of a TUPLE! in some sense...because it makes it easier to write generic fusing code for things like JOIN.  But putting into the new SYMBOL! class (which cannot appear in TUPLE! or PATH!) might have advantages, and helpers to count the dots might serve just as well.</p>
<p>I'm not sure what the in-language default function for plain dot will be, but it's likely that it will not be more powerful than either <strong>.a</strong> or <strong>a.</strong> enough to justify that <strong>a.a</strong> should be interpreted as <strong>a . a</strong>.</p>
<p>It's important to look at the specifics of mushing with symbols as they have no case, so the breakapart rules are different.  I've diagrammed some of these before.</p>
<pre><code>a+b =&gt; a+b  ; compatibility with all lowercase code
a+B =&gt; a+ b  ; favors breaking to the left, vs. a +b
</code></pre>
<p>I'll delve into these justifications, but since I'm deleting the old definitions of things like <strong>a&amp;</strong> and <strong>a|</strong> I wanted to put a placeholder topic for discussing it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/symbols-and-mushing-in-rebmu/1797">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/symbols-and-mushing-in-rebmu/1797</link>
          <pubDate>Mon, 07 Mar 2022 08:08:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1797</guid>
          <source url="https://forum.rebol.info/t/symbols-and-mushing-in-rebmu/1797.rss">Symbols and Mushing in Rebmu</source>
        </item>
        <item>
          <title>Rebmu&#39;s FUNQTION (FQ): Dialecting Function Definition Itself</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <blockquote>
<p>After writing this I realized I had <a href="https://forum.rebol.info/t/function-mu-rebmus-function-generator-dialect/1379">already written a post about this in 2020</a>, but... here it is again, I guess!  Maybe I said it better or worse this time?</p>
</blockquote>
<p><em>(Note: FQ is pronounced EFF-QUEUE, say it carefully. <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:">)</em></p>
<p>So in Rebmu, <strong>FN</strong> is a superset of <strong>FUNC</strong> (itself a synonym for <strong>FUNCTION</strong>).</p>
<p>It doesn't do anything <em>terribly</em> tricky because its arguments are both evaluative.  So you can pass it specs and bodies that are variables.  Here's a useless example of taking advantage of that with a spec in a variable:</p>
<pre><code>; define a spec which takes two arguments
S[xY]   ; =&gt; s: [x y]

; define function A that adds X and Y.
AfnS[adXy]  ; =&gt; a: fn s [ad x y]
            ; =&gt; a: function s [add x y]

; define function M that multiplies X and Y
MfnS[mpXy]  ; =&gt; m: fn s [mp x y]
            ; =&gt; m: function s [multiply x y]
</code></pre>
<p><em>...but what might a Code-Golf-Dialected FUNQTION (FQ) Do, unbound by rote evaluation of its parameters?</em>  Let's use our imagination...</p>
<h2>A Quoted Spec could permit Spec Compression</h2>
<p>How about if you gave a WORD! that was a letter and a number, you'd get 3 args starting with that letter?</p>
<pre><code>fqR3[adMPrSt]
; =&gt; fq r3 [ad mp r s t]
; =&gt; fn [r s t] [ad mp r s t]
; =&gt; function [r s t] [add multiply r s t]
; =&gt; function [r s t] [add (multiply r s) t]
</code></pre>
<p>That's a three character savings vs. having to express the block for <strong>[r s t]</strong> explicitly with a plain function:</p>
<pre><code>fn[rSt][adMPrSt]
</code></pre>
<p>If you didn't include a number that might be a different memoization of what the arguments were, such as:</p>
<pre><code>fqA[...] =&gt; fn [a] [...]
fqB[...] =&gt; fn [a b] [...]
fqC[...] =&gt; fn [a b c] [...]

fqX[...] =&gt; fn [z y x] [...]
fqY[...] =&gt; fn [z y] [...]
fqZ[...] =&gt; fn [z] [...]
</code></pre>
<p>The idea being that you need to sort of spread out your variable names in code golf, for instance when working with nested functions.  From a tactical standpoint one might be served to throw in curveballs:</p>
<pre><code>fqM[...] =&gt; fn [m j z] [...]
</code></pre>
<p>Though that lessens the readability/learnability.  Anyway, what else...?</p>
<h2>Variadically Quoted Bodies Could Circumvent Brackets</h2>
<p>Let's say if it found a word in the slot where the body block would ordinarily be, it would treat that as a function that should be called.</p>
<p>To make it easier, let's just think about this un-Rebmu'd:</p>
<pre><code>foo: func [x y z] [any [x y z]]

bar: funq [x y z] any [x y z]
</code></pre>
<p>If FUNQ is variadic and quoting its body slot, it could notice the body does not contain a block but a WORD!.  Seeing that function is ANY, it could count the number of parameters ANY needs and pick them up from the callsite.</p>
<p><em>Such mechanics are within reach using today's FRAME!s</em>, in fact <a href="https://forum.rebol.info/t/looking-into-a-usermode-pointfree/1236">they are used by things like POINTFREE</a>...itself clearly useful in Rebmu.</p>
<h2>What Else Might FQ do?</h2>
<p>There's also things like GROUP!s, and <strong>fq(x)...</strong> could imply a completely different thing from <strong>fq[x]...</strong>, suggesting a mode switch in how the ensuing information is interpreted.</p>
<p>Or <strong>fqX(...)</strong> and <strong>fqX[...]</strong> could be completely different.  What about strings?  How might string interpolation fit into all of this?</p>
<pre><code>ZfqC{Implicit printing of $a and $b and $c?}
; =&gt; z: fn [a b c] [print interpolate {Implicit print of $a and $b and $c}]
</code></pre>
<p>Maybe the implicit printing is different, like FP, and FQ with a string simply interpolates it.</p>
<p><strong>Hopefully you get the drift.</strong>  I'm talking about making Rebmu a powerhouse showcase of what Ren-C is driving at.</p>
<p>How can quoting, variadics, frames, interpolation, and all of that be applied to dialecting the act of function definition itself?</p>
<h1><code>[insert your ideas here]</code></h1>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rebmus-funqtion-fq-dialecting-function-definition-itself/1796">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebmus-funqtion-fq-dialecting-function-definition-itself/1796</link>
          <pubDate>Mon, 07 Mar 2022 07:07:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1796</guid>
          <source url="https://forum.rebol.info/t/rebmus-funqtion-fq-dialecting-function-definition-itself/1796.rss">Rebmu&#39;s FUNQTION (FQ): Dialecting Function Definition Itself</source>
        </item>
        <item>
          <title>What was REBMU-WRAP (and why we no longer need it)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p>As I bring the Rebmu dialect up to date I'll try and talk about any teachable moments that it provides.</p>
<p>Let's look at one of the earliest weird functions, REBMU-WRAP:</p>
<pre><code>rebmu-wrap: function [refined [path!] args [block!]] [
    func args compose [
        (refined) (args)
    ]
]
</code></pre>
<p>It was designed to make it (slightly) easier to define something like <code>APO</code> as a synonym for <code>APPEND/ONLY</code>.</p>
<pre><code>APO: rebmu-wrap 'append/only [series value]
</code></pre>
<p>So that turns into effectively:</p>
<pre><code>APO: func [series value] [
    append/only series value
]
</code></pre>
<p><strong>Basically this was an incredibly weak way to save a few characters while making a partial specialization.</strong>  Some of its weaknesses:</p>
<ol>
<li>
<p>You still have to specify the number and names of arguments the specialization takes.</p>
</li>
<li>
<p>If you make a mistake at the time of definition (like mentioning an unavailable refinement) you don't get the error until the call.</p>
</li>
<li>
<p>The other refinements are missing from the wrapped function, e.g. you can't invoke <code>apo/part</code> or <code>apo/dup</code>.</p>
</li>
<li>
<p>You don't inherit anything about the original function's parameter conventions; e.g. if an argument were quoted you'd get the parameter name word you passed for it.</p>
</li>
<li>
<p>Performance-wise you generate a whole new function call...path evaluation...argument evaluation...</p>
</li>
<li>
<p>Your new function doesn't have any HELP... etc. etc.</p>
</li>
</ol>
<h2>How To Make This Better in Classical "Redbol"?</h2>
<p>Let's put yourself in the mind of someone thinking about how I was at that time, <em>who wanted to use the same strategy but merely address (1) and (2)</em>.  So to be able to write the slightly shorter hand:</p>
<pre><code>APO: rebmu-wrap 'append/only
APD: rebmu-wrap 'append/dup
APDP: rebmu-wrap 'append/dup/part
APPD: rebmu-wrap 'append/part/dup  ; ...etc.
</code></pre>
<p>This version of REBMU-WRAP would need to analyze the spec, presumably with WORDS-OF:</p>
<pre><code>r3-alpha&gt;&gt; words-of :append
== [series value /part length /only /dup count]
</code></pre>
<p>So you might try something like the following nightmare...<strong>which took me at least an hour to write and debug!</strong> (probably more like two, because of the glitch of trying to mutate the spec in place and needing to notice when the insertion position matches the position a refinement argument is being moved from):</p>
<pre><code>rebmu-wrap: func [refined [path!] /local spec body pos insert-pos item] [
    if not any-function? (action: get first refined) [
        do make error! "first element of path must refer to a function"
    ]
    spec: words-of :action
    body: reduce [refined]
    insert-pos: spec  ; find where refinement args should be inserted
    while [all [not tail? insert-pos not refinement? insert-pos/1]][
        append body insert-pos/1
        insert-pos: next insert-pos
    ]
    foreach refinement-name (next refined) [
        if not pos: find spec to-refinement refinement-name [
            do make error! "missing or duplicate refinement specified"
        ]
        take pos  ; drop refinement from spec
        while [all [not tail? pos not refinement? pos/1 pos != insert-pos]] [
             insert-pos: insert insert-pos item: take pos
             append body item
        ]
    ]
    func ?? spec ?? body
]
</code></pre>
<p>If you try this in R3-Alpha, yes it does indeed work for (1) and (2). I put in the probes so you can see the spec and body of the new function:</p>
<pre><code>r3-alpha&gt;&gt; apo: rebmu-wrap 'append/only
spec: [series value /part length /dup count]
body: [append/only series value]

r3-alpha&gt; apd: rebmu-wrap 'append/dup
spec: [series value count /part length /only]
body: [append/dup series value count]

r3-alpha&gt;&gt; apdp: rebmu-wrap 'append/dup/part
spec: [series value count length /only]
body: [append/dup/part series value count]

r3-alpha&gt;&gt; appd: rebmu-wrap 'append/part/dup
spec: [series value count length /only]
body: [append/part/dup series value count]
</code></pre>
<p>It gets a head-start on (3) by leaving the refinements that haven't been partially specialized on the spec, but they're ignored in the call.</p>
<h2>That's A Lot Of Work for Something That Still Sucks! <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">
</h2>
<p>When you think of everything it entails to get (3) and (4), you are going to either need to COMPOSE your invocation on each call -or- change methodology to use APPLY.  But even if you are aware of APPLY it doesn't make this a trivial exercise, and doesn't help with (5) or (6).</p>
<p><strong>...and this is why I never even tried to write such things (before)... instead trying to add core interpreter features for partial specialization.</strong></p>
<h2>The Happy New World of Partial Specialization <img src="https://forum.rebol.info/images/emoji/twitter/sun_with_face.png?v=9" title=":sun_with_face:" class="emoji" alt=":sun_with_face:">
</h2>
<p>In today's Ren-C, all you have to do is get a function as a path, and you have (1) (2) (3) (4) (5).</p>
<pre><code>ren-c&gt;&gt; ap: :append
 == #[action! {ap} [series value /part /dup /line /only]]

ren-c&gt;&gt; ap [a b c] [d e]
== [a b c d e]

ren-c&gt;&gt; apo: :append/only
== #[action! {apo} [series value /part /dup /line]]

ren-c&gt;&gt; apo [a b c] [d e]
== [a b c [d e]]

ren-c&gt;&gt; apo/dup [a b c] [d e] 2  ; e.g. demonstrating (3)
== [a b c [d e] [d e]]
</code></pre>
<p>The new function call is just as efficient as the original (you might think of it moreso since there's no path processing, e.g. <strong>apo</strong> is faster than invoking <strong>ap/only</strong>!)</p>
<p>You don't get the HELP inherited automatically (it has an associated cost), but there is a function that will do it if you want to... you say <strong>inherit-meta :apo :append</strong> and then <strong>help apo</strong> will have the help strings copied into its meta information.</p>
<p>So that's some assistance with (6), but do remember that it's not a perfect world when talking about how to automatically write meaningful adjusted help.  If any parameter descriptions refer to the argument you specialized out, it's no longer on the interface, so they may not make sense!</p>
<p><em>(Note: Now that refinements are their own arguments, you can't tell by parameter list alone if a refinement is a 0 or 1 arg case.  It's determined by the typeset: if the typeset is empty--no types accepted--it is a 0 arg refinement.  Something to ponder if this can be done better, but see all the other nice things...like caching the label of the function name for stack traces, etc.)</em></p>
<h2>So long, REBMU-WRAP...</h2>
<p>...but I wanted to write this up just to show a good example of how early experiences playing with Rebmu led me to question Rebol, and want to shore up its abilities.</p>
<blockquote>
<p>"Beware of the Turing tar-pit in which <strong>everything is possible but nothing of interest is easy</strong>."</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-was-rebmu-wrap-and-why-we-no-longer-need-it/1795">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-was-rebmu-wrap-and-why-we-no-longer-need-it/1795</link>
          <pubDate>Mon, 07 Mar 2022 06:06:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1795</guid>
          <source url="https://forum.rebol.info/t/what-was-rebmu-wrap-and-why-we-no-longer-need-it/1795.rss">What was REBMU-WRAP (and why we no longer need it)</source>
        </item>
        <item>
          <title>About the Rebmu category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Rebmu</category>
          <description><![CDATA[
            <p>Rebmu is a dialect for solving <a href="https://en.wikipedia.org/wiki/Code_golf">Code Golf challenges</a>, where the goal is to express the source code for solving a puzzle in the fewest characters of source code possible.  See the README here:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="32" height="32">
      <a href="https://github.com/hostilefork/rebmu" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/345;"><img src="https://opengraph.githubassets.com/1d67e812b647b23547cabb9d53af90f2917089ce3978ae8f525e7b31a26b475d/hostilefork/rebmu" class="thumbnail" width="690" height="345"></div>

<h3><a href="https://github.com/hostilefork/rebmu" target="_blank" rel="noopener">GitHub - hostilefork/rebmu: Microscopic Rebol Dialect ("mooshed") for Code Golf</a></h3>


  <p><span class="label1">Microscopic Rebol Dialect ("mooshed") for Code Golf</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Significant design points in Ren-C were inspired by wanting to make the implementation and bending of Rebmu more effective.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-rebmu-category/1794">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-rebmu-category/1794</link>
          <pubDate>Mon, 07 Mar 2022 04:15:56 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1794</guid>
          <source url="https://forum.rebol.info/t/about-the-rebmu-category/1794.rss">About the Rebmu category</source>
        </item>
        <item>
          <title>(No) Alternative Local Notation in the Func Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <h1>TL;DR:</h1>
<p>When using a spec in FUNCTION (remember <a href="https://forum.rebol.info/t/abbreviations-as-synonyms/1211">FUNC is a synonym now</a>):</p>
<ul>
<li>
<p><strong>if you want to specify locals you say <code>[... &lt;local&gt; x y z ...]</code></strong> (/LOCAL is a normal refinement like any other in Ren-C.</p>
</li>
<li>
<p><strong>there is no longer a datatype-based shortcut for locals as a way to save the trouble of finding <code>&lt;local&gt;</code> in specs and inserting at the right point</strong>.</p>
<ul>
<li>
<p>Once you could toss random SET-WORD!s anywhere in a spec, like <strong><code>[a b c: d]</code></strong> and it would act like <strong><code>[a b d &lt;local&gt; c]</code></strong>.  This feature was to make higher-level function generators easier to write, to save them from having to find <code>&lt;local&gt;</code> in the spec...add it if not there...and do everything at the right point.</p>
</li>
<li>
<p>When multi-returns began using SET-WORD! this was changed to be <strong><code>[a b .c d]</code></strong> just to move it out of the way.</p>
</li>
<li>
<p>What this was trying to achieve has been obsoleted by newer and better methods, which actually entwine with the idea that <em>you should never know what local variables a function you are composing on top of has</em>.</p>
</li>
</ul>
</li>
</ul>
<h1>More Explanation</h1>
<p>Long ago, when I was looking at some of the higher-level function generators (like FUNCT on top of FUNCTION) I was struck by how tricky it was to get the adaptations written correctly.</p>
<p>We can look at <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28">FUNCT from R3-Alpha</a> and see some of that complexity, even just to try and add some local variables.</p>
<p>It had to check to see if there was already a /LOCAL, and add it if not:</p>
<pre><code>; Copy the spec and add /local to the end if not found
unless find spec: copy/deep spec /local [append spec [
	/local ; In a block so the generated source gets the newlines
]]
</code></pre>
<p><em>Bear in mind that specifying /LOCAL twice would be a duplicate refinement error, and /LOCAL did not have to be at the end of a spec.</em>  Things were tricky, because there were "private refinements".  These refinements were an artifact of how help worked--they were not shown--but weren't actually private.</p>
<p>So you had to be careful, to insert things after local but not after the private refinements, or they'd be arguments to those refinements:</p>
<pre><code>; Collect all set-words in the body as words to be used as locals, and add
; them to the spec. Don't include the words already in the spec or object.
insert find/tail spec /local collect-words/deep/set/ignore body either with [
   ...
]
</code></pre>
<p><strong>I wanted to take better advantage of datatypes, so I adopted the TAG! <code>&lt;local&gt;</code> in the spec so that /LOCAL could be used like any other refinement... e.g. GET-TIME/LOCAL or GET-LANGUAGE/LOCAL.</strong>  This is an idea preserved to this day, and I think it's a better move (though LET has been developing as the more viable general option for making locals).</p>
<p>But another concept I had was to make SET-WORD! in the dialect be another way to put a local anywhere in the spec.  So if you were writing code munging function specs you could just throw local variables on:</p>
<pre><code>foo: func [a b c: d] [...]

&lt;= equivalent to =&gt;

foo: func [a b d &lt;local&gt; c] [...]
</code></pre>
<p>But the idea was that <code>&lt;local&gt;</code> itself was transformed into the SET-WORD!, so the only language you needed to understand was that of the SET-WORD!s:</p>
<pre><code>&gt;&gt; foo: func [a b d &lt;local&gt; c] [...]

&gt;&gt; spec-of :foo
== [a b d c:]
</code></pre>
<p>When multi-returns came about and took SET-WORD!s, this idea was bumped around to be done with TUPLE!s with leading blanks like <strong>.c</strong></p>
<h1><a href="https://www.youtube.com/watch?v=2q9MaEKHakY">... but Everything Changed <img src="https://forum.rebol.info/images/emoji/twitter/robot.png?v=9" title=":robot:" class="emoji" alt=":robot:"> ...</a></h1>
<p>I've been marching toward something more like <a href="https://forum.rebol.info/t/seeing-all-action-s-as-variadic-frame-makers/1002">"Seeing all ACTION!s as Variadic Frame Makers?"</a></p>
<p>Function composition tools operate on FRAME!s using tools like ADAPT, SPECIALIZE, AUGMENT, ENCLOSE, etc.  There is no API for getting at the locals <em>because when you build on top of a function you can't see them, they're not part of the interface...they are sealed inside.</em>   This is good because you can build on top of a function without worrying about the details of the parts from which it was composed.</p>
<p>The migration to where <a href="https://forum.rebol.info/t/pure-and-refined-simplifying-refinements-to-one-or-zero-args/1120">refinements are their own arguments</a> has been key in making function calls easier to model as an object.</p>
<p><strong>In this world we do not need a representation for locals in the spec to add them...because the entire concept of how FUNCT was written is gone.</strong>  If you want to add locals you use tools like AUGMENT and don't worry about it.</p>
<h1>There Are Still (many) Problems To Solve</h1>
<p>Consider that you can do something like ask for a FRAME! of something like APPEND, then enumerate the keys:</p>
<pre><code>&gt;&gt; f: make frame! :append

&gt;&gt; for-each key f [print mold key]
return
series
value
part
dup
line
only
</code></pre>
<p>There are a lot of questions to answer about the unique nature of the main function's RETURN.  Although other multi-returns have to be on the interface, should you be able to put a variable in that return?  Consider that you could use multi-return with append today:</p>
<pre><code>&gt;&gt; [var]: append "abc" "d"
== "abcd"

&gt;&gt; var
== "abcd"
</code></pre>
<p>So should you be able to preload the frame with <strong>f.return: 'var</strong> and get the same effect?  This is competitive with the notion that RETURN is a concept of a local variable to the action, that holds an action that returns specifically from that action... so the responsibilities are somewhat murky for this distinguished result.</p>
<p>But we can also see that if we only look at object keys, we don't know which things are refinements or which are not...if they are refinements we don't know if they are 0-arg or 1-arg form, we don't know what types they take... or are they <code>&lt;end&gt;</code>-able.  <strong>I believe getting at this information should be done by means other than analysis of some spec block you filter out for description strings/etc. so that is on the right track.</strong>  But it's still a long road.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793</link>
          <pubDate>Sat, 05 Mar 2022 20:33:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1793</guid>
          <source url="https://forum.rebol.info/t/no-alternative-local-notation-in-the-func-spec-dialect/1793.rss">(No) Alternative Local Notation in the Func Spec Dialect</source>
        </item>
        <item>
          <title>My Summary of the Big Picture</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>I wrote this to someone in a GitHub issue and thought it was pretty salient:</p>
<blockquote>
<p>What has drawn people to Rebol historically has varied. But a large number who praised it and used it were less interested in the language itself, rather the properties of the executable. It was small, and you could run on any OS without installing anything else...it came with a GUI built in.</p>
<p>But when serious language theorists look at Rebol, they notice it is riddled with design holes. The language itself wasn't <em>composable</em> the way one might like languages to be: mixing constructs in new ways that weren't specifically accounted for never worked. It was more like a "scriptable app" that had a few features that pleased its userbase...and had to be extended by the designer every time a new need came up.</p>
<p>So put briefly: If you don't understand what these holes are, then you won't appreciate the many issues that Ren-C is trying to solve. Starting from scratch inevitably makes the same mistakes.</p>
<p>Once you know that historical Rebol was fundamentally broken, there are basically 3 choices:</p>
<ol>
<li>Inventory and address the holes one at a time and try to fix or mitigate them</li>
<li>Ignore the holes and just hope that if you add enough features and integration no one will notice</li>
<li>Turn away and run from the crackpots using it, and work with a more solidly designed language</li>
</ol>
<p>(1) is Ren-C's hard-chosen path. Energy is spent on identifying certain patterns in source that users <em>must</em> be able to write and have work, if the language is to justify its existence at all. While it would be nice if stack traces were beautiful and if building the sources was 100% easy, all of that would be meaningless if the punch line was <em>"oh, and the language this is all supporting doesn't actually work"</em></p>
<p>(2) is chosen by people like Red and <a href="https://github.com/Oldes/Rebol3">Oldes's branch of R3-Alpha</a>, as well as some clones that have popped up over the years.</p>
<p>(3) is probably the most sensible choice, but if I didn't think there was some promise in the language I wouldn't be pursuing (1).</p>
</blockquote>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/my-summary-of-the-big-picture/1792">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/my-summary-of-the-big-picture/1792</link>
          <pubDate>Fri, 18 Feb 2022 19:37:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1792</guid>
          <source url="https://forum.rebol.info/t/my-summary-of-the-big-picture/1792.rss">My Summary of the Big Picture</source>
        </item>
        <item>
          <title>Turning a Blind Eye to Evaluator &quot;Abuse&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>I've gotten kind of attached to the current look and behavior of AND and OR, which allow short-circuiting even though one would not think the language could (should?) be able to.</p>
<p>It doesn't require simple variables be in a GROUP! on the right hand side.</p>
<pre><code>&gt;&gt; if true and true [print "True"] else [print "False"]
True
</code></pre>
<p>...but a function call has to be.</p>
<pre><code>&gt;&gt; foo: func [x] [
      print "Calling foo!"
      return x &gt; 1000
   ]

&gt;&gt; if false and foo 1020 [print "True!"] else [print "False"]
** Error: words/tuples can't be ACTION! as right hand of OR, AND, XOR

&gt;&gt; if false and (foo 1020) [print "True"] else [print "False"]
False

&gt;&gt; if true and (foo 1020) [print "True!"] else [print "False"]
Calling foo!
True
</code></pre>
<p><em>Note that if the thing to the left of the AND is false, it does not run the code in the GROUP! on the right.</em>  This requires that the right hand side be a quoted parameter convention.</p>
<p>Alternatively we could not quote it, and require the right hand side be in a block:</p>
<pre><code>&gt;&gt; if true and [true] [print "True"] else [print "False"]
True

&gt;&gt; if false and [foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p><strong>But I don't like that.</strong></p>
<p>Alternatively we could say we don't offer this and you always use ALL...maybe with COMMA! and maybe not:</p>
<pre><code>&gt;&gt; if all [true true] [print "True"] else [print "False"]
True

&gt;&gt; if all [false, foo 1020] [print "True"] else [print "False"]
False
</code></pre>
<p>I just don't think that looks as natural.</p>
<h2>It's Like I Said In <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">"Speaking With Tics"</a>...</h2>
<p>If you think seeing a GROUP! on the right of AND and OR that doesn't unconditionally evaluate at the callsite is weird, why are you comfortable with <strong><code>for-each x [1 2 3] [...]</code></strong>?  That didn't unconditionally evaluate x.  Do you expect it to be <strong><code>for-each 'x</code></strong> instead?</p>
<aside class="quote no-group">
<blockquote>
<p>The quoted parameter convention exists to save you the trouble of quoting the callsites. <em>If this isn't what that's for, then what <strong>is</strong> it for?</em></p>
</blockquote>
</aside>
<p>It's just too nice to be able to say things like <strong><code>if var1 and var2 or (a &gt; b) [...]</code></strong>.</p>
<p>To me, part of what makes the language special is the ability to bend the evaluator to how we want to read code, vs bending code to fit the evaluator.  The existence of mechanics like quoted parameters are there to let this happen.</p>
<p><em>You don't have to use it.</em>  And the ability to switch it to where AND is a prefix operator that does bitwise math is the magic of the freedom of choice.  You can choose to change the definition even on a module-by-module basis, or on a function-by-function basis.</p>
<p>Further: if you're not bending the language, you're probably not really using it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791</link>
          <pubDate>Fri, 18 Feb 2022 18:34:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1791</guid>
          <source url="https://forum.rebol.info/t/turning-a-blind-eye-to-evaluator-abuse/1791.rss">Turning a Blind Eye to Evaluator &quot;Abuse&quot;</source>
        </item>
        <item>
          <title>Shall we CONTINUE?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>At some point I added the ability of CONTINUE to take a parameter.  The idea was that CONTINUE with a parameter would act the same as if the loop body had completed with that value.  One place this is most useful is MAP-EACH:</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 2 [continue &lt;twenty&gt;] else [x * 10]
   ]
== [10 &lt;twenty&gt; 30]
</code></pre>
<p>But what should CONTINUE with no argument do?  In the MAP-EACH case, I think it should pretty obviously not add anything to the output.</p>
<pre><code>&gt;&gt; map-each x [1 2 3] [
       if x = 2 [continue] else [x * 10]
   ]
== [10 30]
</code></pre>
<h2>Nice.  But what about "ordinary" loops?</h2>
<p>How about WHILE or REPEAT or FOR-EACH?  If we wanted it to be novel, it could say "don't change the pending overall result from whatever the last loop iteration would have returned":</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
]
== 20
</code></pre>
<p>Although I like that in theory, it would break the loop composition rules unless loops were allowed to be invisible.  :-/</p>
<p>Think about the <a href="https://forum.rebol.info/t/what-should-do-of-empty-block-do-do/1426/18">code I've previously written down</a> to implement FOR-BOTH:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    unmeta all [
        meta for-each var blk1 body
        meta for-each var blk2 body
    ]
]
</code></pre>
<p>That FOR-BOTH could not have a CONTINUE that would run in the body of the second FOR-EACH and carry over a value from the first FOR-EACH.</p>
<p>Given that we'd be setting a standard that would be difficult to follow, I think the answer has to be:</p>
<pre><code>&gt;&gt; for-each x [1 2 3] [
     if x = 3 [continue] else [x * 10]
   ]
== ~none~  ; isotope
</code></pre>
<h2>What about UNTIL and CONTINUE TRUE?</h2>
<p>I've given a rule that CONTINUE passed a parameter effectively jumps to the end of the loop body as if it had finished with that value.  But in UNTIL, the loop's body also is the condition.  So what about:</p>
<pre><code>&gt;&gt; until [print "A" if true [continue true] else [&lt;unreachable&gt;]] print "B"
A
B
</code></pre>
<p>It seems to make a certain amount of sense.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/shall-we-continue/1790">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/shall-we-continue/1790</link>
          <pubDate>Wed, 16 Feb 2022 04:10:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1790</guid>
          <source url="https://forum.rebol.info/t/shall-we-continue/1790.rss">Shall we CONTINUE?</source>
        </item>
        <item>
          <title>About the Semantics category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>While the "Internals" discusses the bits and bytes of how things are implemented, this category is for discussing things design questions of the language... like what <strong>do []</strong> should return.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-semantics-category/1789">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-semantics-category/1789</link>
          <pubDate>Wed, 16 Feb 2022 03:48:39 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1789</guid>
          <source url="https://forum.rebol.info/t/about-the-semantics-category/1789.rss">About the Semantics category</source>
        </item>
        <item>
          <title>REBOL 1 Manual</title>
          <dc:creator><![CDATA[DefinitionalUsername]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I was reading about some of the design choices in REBOL, and came upon Joe Marshall's writings where he talks about the changes between REBOL 1 and 2 (missing continuations, changed scoping rules, absence of tail recursion, etc.). This made me curious about the differences between the two version; however, I can't find anything related to REBOL 1 on the internet (save for a Scheme compiler).</p>
<p>Will it be possible to share the manual/guide/documentation for REBOL 1 here? It is a piece of history, and it'll be a shame if it just disappears.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebol-1-manual/1788">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebol-1-manual/1788</link>
          <pubDate>Mon, 14 Feb 2022 03:29:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1788</guid>
          <source url="https://forum.rebol.info/t/rebol-1-manual/1788.rss">REBOL 1 Manual</source>
        </item>
        <item>
          <title>Could Ren-C and Red Interoperate (and if so, *should* they?)</title>
          <dc:creator><![CDATA[Cplus]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>When this year can we expect to see full "message passing" inter-operability between Ren-C and Red?</p>
<p>The very basics - MOLD and SAVE are almost in place.</p>
<p>The "binary" equivalent with some form of compatible REBBIN is surely not that hard to agree between the two sets of developers.</p>
<p>Fuller, fluid, message passing - for example the seamless invoking of functions and continuations within a running instance of the other language would be an important demonstration of the REBOL cousins' languages abilities to do what they have stated is a desired characteristic of their respective dialects of REBOL.</p>
<p>This would also harness the strengths of both dialects - for each has been focused these last few years on different arenas. Together, they have the makings of a formidable whole.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787</link>
          <pubDate>Fri, 04 Feb 2022 19:20:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1787</guid>
          <source url="https://forum.rebol.info/t/could-ren-c-and-red-interoperate-and-if-so-should-they/1787.rss">Could Ren-C and Red Interoperate (and if so, *should* they?)</source>
        </item>
        <item>
          <title>Belated 2021 Post-Mortem + New Years 2022 Vision ü§π</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Announcements</category>
          <description><![CDATA[
            <h1>Happy 2022!</h1>
<p><strong>...and I Hope Your New Year's Was Better Than Mine...</strong> <img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji" alt=":man_facepalming:"></p>
<p>Though I've spent most of the last few New Years Days (and this last one) traveling and in some hotel...I've usually gotten myself a nice supply of beer, and worked start-to-finish through a post.  I talk about what worked and didn't work, and where things might go next.  Although it generally takes the greater part of a day to write those, it's in some ways kind of a fun thing to write...and I was always pleased to beat Red to the punch with accomplishments I found more impressive.</p>
<p><em>This year felt unfortunately different.</em>  I had a big wave of pessimism for all kinds of reasons--ranging from personal relationships, to my new laptop screen getting cracked when it was in my bag...to just a general feeling that the world is going to hell in a handbasket.</p>
<p><strong><img src="https://forum.rebol.info/images/emoji/twitter/skull.png?v=9" title=":skull:" class="emoji" alt=":skull:"> ...But It's Not As Grim As All That... <img src="https://forum.rebol.info/images/emoji/twitter/potato.png?v=9" title=":potato:" class="emoji" alt=":potato:"></strong></p>
<p>After eating a ridiculous potato from <a href="https://stpeterising.com/home/2021/9/16/a-loaded-baked-potato-restaurant-the-half-baked-potato-is-coming-soon-to-downtown-st-pete">A Hipster Potato Restaurant In St. Petersburg</a>--and inadvisedly drinking 2 Sugar-Free Red Bulls--my stomach and brain weren't going to sleep for a long time.</p>
<p>Though traveling makes retrieving a repaired laptop on an extended warranty difficult, I still had my old laptop with me.  So I dug it out, and found an unfinished post about a seemingly-esoteric point about invisible evaluations and void isotopes.  <a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782">Some deep realizations clicked into place</a>.  Those realizations led to a proud thought:</p>
<p><strong>2021 was the year of invention for BAD-WORD!s, "isotopes", and ^META.  While the older invention of NULL was akin to mathematicians inventing zero to solve previously hard problems... <em>isotopes and meta-transformations are like the invention of imaginary numbers</em>.</strong></p>
<p>Having that energy boost put me on a slight incline toward positive thinking.  Enough so that I'm pushing out a New Year's post before the calendar ticks over to February... here goes:</p>
<h2>UPARSE Is Already a Big Success Story</h2>
<p>Many who use Rebol got addicted because of PARSE.  But people who work with other languages and parser combinators have wondered what the big deal is.  Though Rebol's PARSE is a literate alternative to simple RegEx scenarios, it's weak at building high level structures from smaller simpler parsers--<em>there are too many inconveniences in writing reusable rules</em>.</p>
<p>UPARSE stands for <a href="https://github.com/metaeducation/ren-c/blob/26752e701d9585a7dd5bb1c4cb2e78c901908c5b/src/mezz/uparse.reb"><em>(U)sermode PARSE</em></a> and to me it deals Rebol back in the parsing game:</p>
<ul>
<li>
<p>It keeps the classic feel of PARSE alive, while bringing its power up to the level of combinators in other languages.  Arbitrary values can be synthesized from processing the input, instead of just data captures at the level of the input series.</p>
</li>
<li>
<p>You can come up with "new keywords" without waiting for someone to do so.  These are expressed as ordinary functions with multiple return values, and hence can be optimized as natives.</p>
</li>
<li>
<p>The behavior of values of certain datatypes themselves can be overridden, to bend parsing to entirely different meanings.</p>
</li>
<li>
<p>It has a <a href="https://github.com/metaeducation/ren-c/blob/26752e701d9585a7dd5bb1c4cb2e78c901908c5b/tests/parse/examples/maxmatch.parse.test.reb">generic architecture for rolling back the effects of combinators</a>, with a default behavior that lets the average combinator author avoid the details if they just want any failure to roll back everything in the order it was done.</p>
</li>
<li>
<p>As a proof of its flexibility, a Rebol2/Red-compatible combinator set is defined.</p>
</li>
</ul>
<p><strong>But besides the combinators, the usermode implementation of the UPARSE engine itself that composes and runs them is as much of the story as anything else.</strong>  Rebol has had a shaky history of giving usermode code the same perceptive power as what could be done from C...and that can be as basic as how to tell the difference between <strong>[a b #[none]]</strong> and <strong>[a b]</strong> with looking at the result of THIRD of the block.  All these upgrades come into the mix in UPARSE...from FRAME! mechanics and specializations to ^META and isotopes and generic quoting.</p>
<p>On the downside: it hasn't been optimized much yet, so the performance is abysmal...and a lot of work is left to do on error messages.  But seeing how to build a dialect in this way--where it's not like you have to be a C programmer, but you can wire together the pieces--is the "Minecraft of Programming" I talk about.</p>
<h2>The <a href="https://forum.rebol.info/t/the-new-ren-c-github-action-run-natively-run-on-web/1562">Ren-C GitHub Action</a> Has Been Amazing</h2>
<p>Although it required me gritting my teeth through some JavaScript programming, we now have a turnkey way to install an up to date interpreter with a line of code on a cloud runner for Mac, Linux, and Windows...as well as run automation of the latest web build.</p>
<p>It's a big force multiplier, and it's helped with testing the <a href="https://forum.rebol.info/t/whitespace-interpreter-revisited/1482">Whitespace Interpreter Dialect</a> and the <a href="https://forum.rebol.info/t/uscii-seen-with-new-eyes/1713">USCII Dialect</a>...both of which received major updates this year.  When Redbol examples are given they often risk merely showing the language is capable of generic computation and if you put enough hours into it then you might get something that sort-of-works.  But I feel these are approaching good examples of the form--where they lay out the particular power and composability that Ren-C has been angling for.</p>
<h2>
<a href="https://forum.rebol.info/t/devices-are-gone-but-what-were-they/1692">Devices are Gone</a> and <a href="https://forum.rebol.info/t/libuv-integration-has-started-an-i-o-renaissance/1694">now it's all libUV</a>
</h2>
<p>I think that libUV pretty much represents the objectives of what Carl might have wanted a device layer to be.  Not only is it pure C code that can be built with things like the TinyC compiler, it compiles for esoteric platforms like Haiku.  It's something Rebol might well have used had it been around.</p>
<p>And the web build doesn't use libUV at all--accomplishing its network reads and such through completely different mechanisms.  So it shows the language is staying pure and repurposeable on platforms that don't have threads or whatever dependencies libUV requires.  A simple stripped down version could just offer C stdio (for instance).</p>
<p>There's a long way to go for our usage of libUV to live up to its potential.  But it gives the foundations for doing things like a <a href="https://forum.rebol.info/t/semantics-of-read-and-tcp-streams-past-and-future/1733">good version of async IO, where you code in a synchronous style</a>.  (I've explained that I think the old WAIT/AWAKE model really <a href="https://forum.rebol.info/t/the-weirdness-of-wait/1703">represented a dead end</a>, and so it had to be ripped out).</p>
<h2>
<a href="https://forum.rebol.info/t/the-sea-of-words/1564"><em>Sea of Words</em></a> and Customizable Modularization Arrives</h2>
<p>What was supposed to be unique about Rebol's modules was that the code that processed headers would be like a dialect.  That dialect was processed by usermode code, and you could write your own spin on it if you had some other idea of how you wanted modularization to work.</p>
<p>It's early yet to really say for sure how the mechanics behind this will evolve.  But there have been big steps taken--and the personal success I feel is how the test dialect can create modules out of individual tests.  So the test files are really making thousands upon thousands of isolating contexts, and when the tests are done running the user context is not contaminated at all.  This makes the tests less subject to weird side effects from each other...keeps things tidy...and is overall good for the garbage collector as well.</p>
<p>Disconnecting the use of words from the creation of variables is good for all the reasons I cite.  I've been very happy with that idea, though what "attachment" to a context means has design work to do.  Make no mistake--this is a process of invention--and so it's going to be weird and take time.</p>
<h2>
<a href="https://forum.rebol.info/t/get-set-vs-pick-poke-whats-the-difference/1719">PICK and POKE and Pathing Are Resolved</a> (I Think)</h2>
<p>I've struggled since very early on to tame "path dispatch", which was very oddly shaped.  I'm not going to rehash all of the thought process.  But I'm pleased with the outcome, and I think it will generalize well to extension types.</p>
<h2>First Try At String Binding + Interpolation</h2>
<p>It isn't there yet, but it has been prototyped.  I've written up a post about where I think binding/scoping has to go:</p>
<p><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751" class="inline-onebox">Rebol And Scopes: Well, Why Not?</a></p>
<p>There are still no easy answers.  But there's good news about having so many complex codebases in play (like UPARSE, whitespace dialect, etc.) that are not throwing softballs at the language.  If new binding concepts add functionality but don't break any of that, that's a good sign it may be good.</p>
<h2>...A Lot Of Other Stuff Happened...</h2>
<p>This is just a mini list of some of the things I find most notable to call out. As usual, you can scroll through posts or commit logs to see more.</p>
<p>But I also got the chance to visit <a class="mention" href="/u/blackattr">@BlackATTR</a> and meet his family and dogs, so that was fun.  We got some work done on his QUERY dialect, but more to go.</p>
<p>I managed to get ODBC and webserver bugs fixed for <a class="mention" href="/u/gchiu">@gchiu</a> so he could do a demo, and to put it on GitHub Actions with tests.</p>
<hr>
<h1>What Hangs in the Balance for 2022?</h1>
<p>I mentioned my bad New Years, and reading <a href="https://www.red-lang.org/2021/12/2021-winding-down.html">Red's New Years post</a> did not help, because it felt so incredibly <em>cyclic</em>.  Seeing them start a New Year by long-windedly plagiarizing <a href="https://forum.rebol.info/t/back-to-personal-computing/186">Back to Personal Computing</a>... <em>again</em>... made me fear their man-years of toil without heeding advice or warnings has grown no audience for either their work, nor Ren-C's inventions.  Their formerly active YCombinator group had a collective yawn about it...<a href="https://news.ycombinator.com/item?id=29758024">one comment</a> at time of writing, so they seem to be slipping off the radar...even though they are much less research-oriented and more "give-the-people-what-they-want-right-now" oriented (in theory).</p>
<p>Apologies to Gregg Irwin for ranting at him.  <strong>But we/I sadly can't count on Red to keep an audience alive for Redbols, as the old guard moves on and new people aren't there to replace them.</strong>  And I'm not a marketer, especially since I fundamentally disagree with the way social media power structures work.  So Ren-C's cool creations are at high risk of not even making it to <a class="mention" href="/u/blackattr">@BlackATTR</a>'s "bad"-case outcome of becoming <em>"a museum piece like the Antikythera mechanism."</em></p>
<p><em>(Makes me think of the <a href="https://en.wikipedia.org/wiki/Conservation_status">species extinction risk scale</a>.  Sure, the source code is on GitHub, and the topic list of this forum seems to be on the Internet Archive...but if you click through to individual pages there's nothing about the post contents.  Should we do a scrape of the data here and put it elsewhere?)</em></p>
<p>I have always been able to consider the notion that Rebol's fundamental idea is flawed and it <em>should</em> die out.  In fact: I started out getting involved in Rebol <em>to prove to Reichart that it was bad</em>, and using it for Qtask was misguided.  My attempts to construct that proof ran up against the fact that its odd plasticity and choice to throw out the rulebook on what a computer language is-or-should-be gave it a slippery yet timeless nature...like English itself.</p>
<p><strong>But given the bus-factor-of-one nature of Ren-C, I should probably be thinking more about how to communicate that to new audiences, vs. going too deeply into an engineering project where I try to re-graft Ren-C onto a Go-like runtime model.</strong></p>
<p>So maybe I need to be better about making YouTube videos, packaging demos, and showing off the existing infrastructure.  <strong>When I look at other WebAssembly language projects, we actually still compare favorably.</strong>  And maybe I'm too quiet about it for fear of looking a fool for all the things that I know aren't working right.  Still...my confidence increases as I've been moving the architecture around to try and steer away from the obviously bad ideas, in a way that new people coming in would be able to shore up missing pieces.</p>
<h2>...Predictions Are Hard To Make</h2>
<p>It probably looks as if I've been notoriously bad at predicting what things are going to get accomplished.  I'd wanted 2021 to hopefully be when stacklessness got integrated, and I wanted to see progress on debugging.  And it may seem like none of that happened.</p>
<p>But sometimes progress is subtle.  There were major barriers to making R3-Alpha's PARSE architecture stackless, but the UPARSE design is much more amenable to it.  So I think the answer will just be that we'll skip stackless PARSE3 and just assume UPARSE is the future of PARSE.</p>
<p>And when it comes to debugging, I demonstrated some <a href="https://forum.rebol.info/t/getting-hooks-into-events-during-parse/1640/5">impressive tracing in UPARSE</a> that works today...which is the sort of thing a user can customize.  Understanding how dialect authors are going to be able to hook and trace their dialects ties in a lot to seeing a big picture of how the evaluator itself might be traced, so all of this really does plug together.</p>
<p>Nevertheless, I feel skeptical of making new predictions.  Especially because here in 2022: <em>Realistically speaking, so long as I'm traveling and trying to find a new home base it's hard to get very much done.</em>  I've chosen to travel in Florida because things are open for business despite the existence of coronavirii...and that aligns with my belief that being vaccinated and boostered is enough to have a social life.  That means I am out maskless indoors doing a fair number of things with people...and changing locations every few days.  It may be a while before I can really focus on coding.</p>
<h2>So Let's Put Predictions On Hold, at least until I have a <img src="https://forum.rebol.info/images/emoji/twitter/derelict_house.png?v=9" title=":derelict_house:" class="emoji" alt=":derelict_house:">
</h2>
<p>One thing that's been working so far, it's my mandate on continuous integration and keeping all the things that are supposed to work, working, as new experiments are tried.  This is not a natural habit for the personality type that programs in Rebol.  People drawn to the language are not <em>"correct-by-construction"</em> folks, more like Larry The Cable Guy "Git-R-Done" mentality.</p>
<p>I want to keep developing <a class="mention" href="/u/blackattr">@BlackATTR</a>'s QUERY and make it part of that "everything is kept working" strategy.</p>
<p>All of <a class="mention" href="/u/gchiu">@gchiu</a>'s projects, as well.  And my USCII, Whitespacers, <code>hostilefork.com</code> itself, etc.  Anything I can convince <a class="mention" href="/u/giuliolunati">@giuliolunati</a> to put in a GitHub workflow, as well!</p>
<p>I want to re-commit to <a href="http://rebmu.hostilefork.com/">Rebmu</a>, also, and make it part of the CI tests.  It might seem like I am always putting this off--even though I claim to say it's one of the big motivators, the <em>"great code golf game in the sky"</em> that I say I'm pursuing.  (When have you seen me solve a puzzle or develop it lately?)  But it's actually in the back of my mind, always.</p>
<p>It was nice with Whitespace to actually draw some attention from a curator of <a href="https://github.com/wspace/corpus">collections of implementations of whitespace</a>... <a class="mention" href="/u/aarchi">@aarchi</a>.  He said he found it to be one of the more interesting examples, and that's always been my goal with this.  To build on the novelty of the medium and give people a new tool to think.  (Recently re-watching that movie <a href="https://www.youtube.com/watch?v=8Fc-7SuebTQ">"Arrival"</a> and the "language/weapon/tool" bit.)</p>
<p>I'm a few minutes from February so I'll just close by saying: continue automating, continue examples, and maybe do a bit more YouTube evangelism.  I'll keep frittering with the mechanics.  And get my laptop fixed (!)</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786</link>
          <pubDate>Tue, 01 Feb 2022 04:49:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1786</guid>
          <source url="https://forum.rebol.info/t/belated-2021-post-mortem-new-years-2022-vision/1786.rss">Belated 2021 Post-Mortem + New Years 2022 Vision ü§π</source>
        </item>
        <item>
          <title>Understanding Definitional Scoping</title>
          <dc:creator><![CDATA[DefinitionalUsername]]></dc:creator>
          <category>First Steps</category>
          <description><![CDATA[
            <p>I just started learning Red/Rebol, and I was having trouble understanding the scoping rules. I did read the <a href="https://stackoverflow.com/a/21964858" rel="noopener nofollow ugc">Stack Overflow</a> and <a href="https://en.wikibooks.org/wiki/Rebol_Programming/Advanced/Bindology" rel="noopener nofollow ugc">Bindology</a>, and I think I somewhat understand, but I'm not sure! I'd be grateful if someone can confirm the my deductions about the following code from the SE post:</p>
<pre><code class="lang-auto">rebol []

a: 1

func-1: func [] [a]

inner: context [
    a: 2
    func-2: func [] [a]
    func-3: func [/local a] [a: 3 func-1]
]

reduce [func-1 inner/func-2 inner/func-3]
</code></pre>
<ol>
<li>
<strong>Compile-time:</strong> First, when the code is compiled, a list of top-level names is created. <em>(<code>a</code>, <code>func-1</code>, <code>inner</code>)</em>
</li>
<li>
<strong>Load-time:</strong> When the code is loaded, context <strong>A</strong> is created with those symbols as members. Also, the entire code is walked through, and every occurrence of those symbols is bound to these entries. <em>(e.g., <code>a</code> inside <code>func-2</code> would be bound to the top-level <code>a</code>)</em>
</li>
<li>
<strong>Run-time:</strong> When <code>a: 1</code> is executed, the value <code>1</code> is stored in the <code>a</code>'s slot in the context.</li>
<li>The <code>func</code> keyword after <code>func-1:</code> creates a new function, and assigns it to <code>func-1</code>. However, it leaves the binding of <code>a</code> intact.</li>
<li>The <code>context</code> keyword after <code>inner:</code> creates a new context <strong>B</strong>, walks over all the block, collecting all new symbols, and inserts those in the new object.</li>
<li>
<code>a: 2</code> assigns value <code>2</code> in <code>a</code>'s slot in the new context.</li>
<li>
<code>func</code> after <code>func-2:</code> creates a function while keeping <code>a</code>'s new binding intact, and assigns it to <code>func-2</code>'s slot.</li>
<li>
<code>func</code> after <code>func-3:</code> creates a function and creates a new context <strong>C</strong> in which <code>a</code> is inserted and bound.</li>
<li>Upon execution of <code>reduce</code>, <code>func-1</code> returns <code>1</code> from context <strong>A</strong>, <code>func-2</code> return <code>2</code> from context <strong>B</strong>, and <code>func-3</code> executes <code>func-1</code> which returns <code>1</code> from context <strong>A</strong> again.</li>
</ol>
<p>So, now,  a few questions:</p>
<ul>
<li>Is the above correct? If it is,</li>
<li>How does the <code>context</code> keyword determine which set-words it should create a slot for? i.e.,
<ul>
<li>if <code>a: 2</code> didn't exist, will it still create the slot for <code>a</code> due to <code>a: 3</code> deep inside?</li>
<li>What about if <code>a:3</code> didn't exist either? Will the new context contain a slot for <code>a</code> just due to <code>a</code> inside <code>func-2</code>'s body?</li>
</ul>
</li>
<li>Did <code>context</code> bind <code>a</code> in <code>[/local a]</code> too, before <code>func</code> was executed?</li>
<li>When a new context is created, does it copy existing symbols or bindings from the older context? If not,</li>
<li>Is there a parent-child relationship between contexts, or are they free-standing? Given a context, can I chase some pointer to its parent or child?</li>
</ul>
<p>Sorry for so many questions, I think I am getting extra confused since I already have programming experience and need to unlearn some stuff before being able to grok Rebol.</p>
<p>Thank you.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/understanding-definitional-scoping/1785">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/understanding-definitional-scoping/1785</link>
          <pubDate>Sat, 22 Jan 2022 08:13:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1785</guid>
          <source url="https://forum.rebol.info/t/understanding-definitional-scoping/1785.rss">Understanding Definitional Scoping</source>
        </item>
        <item>
          <title>Should END-able constructs all use ^META parameters?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>R3-Alpha and Rebol2 could only have functions that were "endable" if the argument they took was quoted.  This feature was added primarily for HELP, so that you could say either:</p>
<pre><code>&gt;&gt; help
; (would display generic HELP usage information)

&gt;&gt; help topic
; (would display help for the given topic)
</code></pre>
<p>It was a <em>very limited form of variadic-ness</em>...generally used only in console-oriented commands (HELP, LS).  You couldn't write a function that was evaluative, like:</p>
<pre><code>redbol&gt;&gt; printer 1 + 2
3

redbol&gt;&gt; printer
You called the PRINTER function with no arguments
    ; ^-- not possible to accomplish with an otherwise evaluative argument!
</code></pre>
<p>Being able to handle getting to the end of input was entwined with taking quoted arguments.</p>
<h2>Ren-C added <code>&lt;end&gt;</code>-able Evaluative Parameters</h2>
<p>To facilitate certain demos in Ren Garden, Ren-C could mark an ordinary parameter as being <code>&lt;end&gt;</code>-able.  This would mean that the argument would show up as being NULL if the end was reached before an argument was seen.</p>
<p>This was--however--ambiguous with if you actually passed an evaluative NULL.</p>
<pre><code>ren-c&gt;&gt; printer 1 + 2
3

ren-c&gt;&gt; printer
You called the PRINTER function with no arguments

ren-c&gt;&gt; printer null  
You called the PRINTER function with no arguments  ; d'oh
</code></pre>
<p><strong>This kind of ambiguity wasn't new...the Redbol version had it.</strong>  The signal for quoted parameters that were endable-and-missing was to make the parameter an UNSET!.  Which meant they couldn't tell the difference between <strong>help #[unset!]</strong> and just-plain-help:</p>
<pre><code>red&gt;&gt; help #[unset!]
To use HELP, supply a word or value as its
argument:

    help insert
    help system
    help system/script

To view all words that...
</code></pre>
<p><strong>Interestingly enough, Ren-C has a solution for this with quoted parameters, because NULL cannot appear literally in source...so it can't be at the callsite.  Thus NULL can represent a missing quoted argument.</strong>  Which is neat.</p>
<h2>^META parameters can do <code>&lt;end&gt;</code> another way...</h2>
<p>A meta parameter is quoted, but will be a plain non-quoted BAD-WORD! if the callsite was passing an isotope.  With the <a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782">recent design concept that suggests ~void~ isotopes are "pure" and equivalent to the full absence of a value</a>, you get evaluative endability without needing a separate feature.</p>
<p>So if our PRINTER took a ^META argument:</p>
<pre><code>&gt;&gt; printer 1 + 2
3
; (it actually received '3, quoted)

&gt;&gt; printer
You called the PRINTER function with no arguments
; (it actually received ~void~, not quoted)
</code></pre>
<p>The ambiguity is still there, though...</p>
<pre><code>&gt;&gt; printer ~void~
You called the PRINTER function with no arguments
; (again, it actually received ~void~, not quoted)
</code></pre>
<p>If you're following the details then I pointed out that supermeta parameters would be necessary to implement something that would know the difference in the suggested model.</p>
<p><strong>But at least you could differentiate NULL from an end.</strong>  The conflation of an invisible argument with the end doesn't seem that troubling to me, as the problem with HELP is fixed since it quotes and can tell when you say <strong>help ~void~</strong> vs. plain <strong>help</strong></p>
<h2>Killing off <code>&lt;end&gt;</code> as a core parameter flag would simplify things...</h2>
<ul>
<li>
<p>If a quoted parameter tolerates NULL as one of its legal types that's sufficient to say it is "endable"</p>
</li>
<li>
<p>If an evaluative parameter needs to detect endability, it could be your job to make it a ^META parameter and look for void, and unquote it to handle other results.</p>
</li>
</ul>
<p>The code and typeset flags for <code>&lt;end&gt;</code> could then be scrapped.</p>
<p>If someone really liked the NULL conflating version of endability they could write something to do it in usermode.</p>
<p><strong>You'd have to see the code to understand why I would think throwing away <strong><code>&lt;end&gt;</code></strong> is worth it.</strong> The way the type checking is done frames have to be filled first, which means if a function doesn't want an actual null but wants just ends to reflect as null... or wants an actual null but doesn't want ends reflected as null... hidden bits need to be grafted onto these nulls at the time of frame fulfillment to say whether it's an "endish" null or a regular null.  Various parts of the system then need to test a NULL for this invisible property.  <strong>^META parameters pull such invisible state into the light.</strong></p>
<p><strong>Basically take my word for it: meta is much cleaner, and offers a way to expose these distinctions to the user--so I think the odds are that <code>&lt;end&gt;</code> and its current mechanics need to die.</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783</link>
          <pubDate>Fri, 21 Jan 2022 17:01:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1783</guid>
          <source url="https://forum.rebol.info/t/should-end-able-constructs-all-use-meta-parameters/1783.rss">Should END-able constructs all use ^META parameters?</source>
        </item>
        <item>
          <title>Pure vs. Impure Invisibility: Do We Need Both?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>"Invisibles" <a href="https://forum.rebol.info/t/issues-with-invisibles-a-truly-disappearing-comment/405">were conceived 4 years ago</a>...long before BAD-WORD!s, isotopes, ^META parameters, etc.</p>
<p>The terminology needs a bit of an update, because I want to make a distinction between two different kinds:</p>
<ul>
<li>
<p><strong>IMPURE INVISIBLITY</strong> is when a special state (like a ~void~ isotope) is discarded in contexts where it's assumed to represent an invisible intent.</p>
<p>Remember that plain BAD-WORD!s (unevaluated) are normal values and can be in blocks.</p>
<pre><code>&gt;&gt; first [~void~]
== ~void~
</code></pre>
<p>But an evaluated ~void~ becomes an isotope, and operations like ALL are willing to tolerate that as a signal of invisible intent it should discard:</p>
<pre><code>&gt;&gt; ~void~
== ~void~  ; isotope

&gt;&gt; all [10 + 20, ~void~]
== 30
</code></pre>
<p>Unfortunately, this is extra work that ALL must do, since ~void~ isotopes are valid evaluative products.  Every construct that wants to integrate impure invisibility bears the burden.</p>
</li>
<li>
<p><strong>PURE INVISIBILITY</strong> is an evaluator feature when a function call can truly erase arbitrary code, such as to the right of a SET-WORD!:</p>
<pre><code>&gt;&gt; y: elide (1 + 2 print "Erased!" 3 + 4) 10 + 20
Erased!
== 30

&gt;&gt; y
== 30
</code></pre>
<p>This can only be done when a function like ELIDE specially says that it is not expected to return any result at all.  Otherwise it's not clear whether <strong>y:</strong> is supposed to get the <code>~void~</code> isotope or something after it.</p>
<p>(Over time I embraced the odd idea that just saying RETURN and not giving it an argument would be the way of being purely invisible...which has the interesting property that <strong><code>(return some-other-function ...)</code></strong> can actually chain cases where the other function is sometimes purely invisible and sometimes not!  This insight arose because of the frustrating fact that C/C++ cannot do such chains... if you say <strong><code>return some_other_function(...);</code></strong> and then change the other function from returning <code>int</code> to <code>void</code>, it will complain that you cannot use <code>return</code> with an argument inside of void functions...even if that function itself returns void.)</p>
</li>
</ul>
<h2>Why Not Make "Impure" Invisibility Act "Pure" ("Semipure?")</h2>
<p>The existence of the ^META types and operators raises an interesting theoretical option...that a ~void~ isotope could be treated as pure by the evaluator, and it's your responsibility to use meta operations if you wanted to see it:</p>
<pre><code>&gt;&gt; 1 + 2 ~void~
== 1 + 2

&gt;&gt; x: ~void~ 1 + 2
== 3

&gt;&gt; x
== 3

&gt;&gt; y: ^ ~void~ 1 + 2
== 3

&gt;&gt; y
== ~void~
    ; ^-- not an isotope
</code></pre>
<p>Pondering the potential implications of this form of thinking, it would mean there wouldn't be a form of invisibility that could beat a ^META operation:</p>
<pre><code>&gt;&gt; z: ^ comment ["hi"] ~something~
== ~something~  ; isotope

&gt;&gt; z
== ~void~
   ; ^-- the COMMENT was seen by the ^META, instead of bypassed
   ; (today COMMENT's status as a purely invisible construct means you
   ; would get Z as a non-isotope ~something~)
</code></pre>
<p><strong>Note that since parameters to functions are allowed to be meta if they need to be, changing a parameter from normal to meta would break commenting constructs.</strong>  This is not too surprising, as if you have <code>my-function comment "hi" 1 + 2</code> and change MY-FUNCTION's argument to be quoted instead of evaluated, that's another kind of parameter change that would break the commenting feature.</p>
<p>Meta parameters should be used very sparingly--far more sparingly than quoted parameters--so this may not be a problem.  I notice that a function like RETURN (which takes its argument meta so it can return isotopes) could still chain an invisible function, as it would receive ~void~ as a measure of what an isotope was.</p>
<h2>If Truly Pure Invisibility Is Not Implemented, Would People Just Reinvent it with Variadics in a Less Efficient Way Than The Current Evaluator Internals Do It?</h2>
<p>Let's say someone writes:</p>
<pre><code>foo: func [] [return comment "hi" 1 + 2]
</code></pre>
<p>Today this returns 3 due to comment's "purely invisible" status, RETURN takes its argument as a ^META parameter.  If we decide meta parameters are allowed to see the "semipure" void isotopes described above, then it would just be like you'd written:</p>
<pre><code>foo: func [] [return comment "hi"]
</code></pre>
<p><strong>That would make it seem like COMMENT is unreliable.</strong>  True, if you take a quoted argument you expect COMMENT to break in such cases as well...but meta parameters are evaluative and so it's a bit different.</p>
<p>Perhaps it should be just the <strong>^</strong> operator at the callsite that has the special vision, and meta parameters are evaluated and discard the void isotopes.  This would mean you only have to learn the rule that <strong>^ comment "hi"</strong> breaks the invisibility.</p>
<p><em>(Here we wind up with <strong>^</strong> either being a built-in thing the user has no way to write themselves, or invent a "supermeta" parameter flag to say "I can see void isotopes, too".)</em></p>
<h2>Either way, "Impure Invisibility" Is MUCH Easier To Work With</h2>
<p>The easy meta-transformations between ~void~ isotopes and plain ~void~ BAD-WORD! allow you to work with an invisible function gracefully...even when you don't know if it's invisible or not.</p>
<p>Early problems cropped up with pure invisible COMMENT like this:</p>
<pre><code>&gt;&gt; f: make frame! :comment
&gt;&gt; f.discarded: "Ignore Me"

&gt;&gt; x: do f   y: 1 + 2
== 3

&gt;&gt; x
== 3  ; this could seem surprising, but maybe not?
</code></pre>
<p>But the new world does have at least <em>an</em> answer, meta your result and you can test for void cases and handle them as you wish.</p>
<pre><code>&gt;&gt; x: ^ do f  y: 1 + 2
== 3

&gt;&gt; x
== ~void~

; alternately could have said `[^x]: do f  y: 1 + 2`
</code></pre>
<p>Yet it's still uncomfortable to imagine that an operation like DO could vanish, which is why DO tried to use void isotopes as a proxy for its return value.  A ~void~ isotope could then be semantically interpreted or converted to pure invisibility on an as-needed basis.</p>
<h2>"If You Don't Know What You're Doing, Then Do It Meta"</h2>
<p>My urge to build safety into the system is driven by wanting to enable people to write generic code.</p>
<p>...but... trying to protect people from <strong><code>do f</code></strong> from vanishing when <strong><code>f</code></strong> is a FRAME! for the COMMENT function may be misguided.  That protection could be breaking the very cool trick they are trying to perform.</p>
<p>And there's a real complexity cost to having a distinction between pure and impure invisibility.  If you allow that distinction then impure invisibility has a meta form (a plain ~void~ BAD-WORD!) while pure invisibility doesn't have one.  The powerful tool of META therefore offers no answers for a purely invisible function.</p>
<p>Maybe things like DO should have a switch to say <strong>do/vanishable</strong> and that's the right protection, otherwise they error if they could vanish.  Same with <strong>unmeta</strong>?</p>
<p>Or maybe there's a better finesse, to say that the evaluator has some generalized protection which notices when you might have meant for an invisible result to be used, and there's generic mitigation for such cases.  Like with <strong><code>x: do f  y: 1 + 2</code></strong>, if it notices the potential for misunderstanding you can say <strong><code>x: vanishable do f y: 1 + 2</code></strong>...and you'd be provoked to decide if you wanted to use VANISHABLE or ^ based on what you were actually trying to accomplish.</p>
<p><em>That actually sounds like a really clever mitigation, if a word or symbol were picked for it!</em></p>
<hr>
<p><strong>This post has been in draft form for a while, as I let it turn over in my head.  But I think I am turning to feeling that void isotopes cannot be stored in variables but are something whose existence can only be philosophically imagined by seeing a meta state register as a plain ~void~ BAD-WORD!.  This is bolstered by the idea that function frames cannot receive isotopes, and parallels to the idea that ~null~ isotopes cannot be stored in variables either (though they decay to ordinary NULL)</strong></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782</link>
          <pubDate>Fri, 21 Jan 2022 09:19:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1782</guid>
          <source url="https://forum.rebol.info/t/pure-vs-impure-invisibility-do-we-need-both/1782.rss">Pure vs. Impure Invisibility: Do We Need Both?</source>
        </item>
        <item>
          <title>JS testing with Cypress.io</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>I will eventually have to port my Red GUI database front end and so I was looking for testing tools.  I came across <a href="https://cypress.io">https://cypress.io</a> which seems to be fully featured though it may be more demanding of JS knowledge than I have.</p>
<p>Anyway, here's a short script to open up the replpad, and start the chess demo though I had to increase the default timeout from 4 to 5 seconds</p>
<blockquote>
<p>describe('Test the replpad', () =&gt; {<br>
it('Visits Replpad', () =&gt; {<br>
cy.visit(<code>'http://hostilefork.com/media/shared/replpad-js/'</code>)<br>
cy.get('.input').type('do &lt;chess&gt;{enter}')<br>
})<br>
})</p>
</blockquote>
<p>So, it opens a browser instance to the replpad, waits until loading is complete, and then waits until the dom has the <code>.input</code> element present.  It then types the chess command.  The chess board then pops up.</p>
<p>Here's a quick <a href="https://filiphric.com/cypress-basics-selecting-elements">tutorial</a> on how to select elements.</p>
<p>Installation is just simply</p>
<pre><code>npm install cypress --save-dev
</code></pre>
<p>but of course on Windows, you'll need to install node.js</p>
<p>And there's <a href="https://docs.cypress.io/guides/continuous-integration/github-actions#Basic-Setup">information</a> on how to use with GitHub actions</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/js-testing-with-cypress-io/1778">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/js-testing-with-cypress-io/1778</link>
          <pubDate>Tue, 21 Dec 2021 06:56:27 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1778</guid>
          <source url="https://forum.rebol.info/t/js-testing-with-cypress-io/1778.rss">JS testing with Cypress.io</source>
        </item>
        <item>
          <title>Cggong</title>
          <dc:creator><![CDATA[cggong]]></dc:creator>
          <category>Introductions</category>
          <description><![CDATA[
            <p>I'm building a C GUI application with GTK and Ren-C, a client for some social media websites, which would support filtering of posts based on keywords and rules.<br>
I explored various ways of doing networking. R3 networking seems more complex than R2. While the additions in R3 and Ren-C should helpful for many use cases, currently my use case only needs the ability to download a web page.<br>
I'm planning to use libcurl for now. To put things in perspective a little bit, in order to read a URL in libcurl, it would take a callback function with <a href="https://curl.se/libcurl/c/CURLOPT_WRITEFUNCTION.html" rel="noopener nofollow ugc">CURLOPT_WRITEFUNCTION</a>. Whenever new data arrives from the network, the callback function would be called, similar to the behavior of read mentioned in the top post.<br>
Using Rebol doesn't seem to reduce much complexity here, so I wouldn't mind using C for now...</p>
            <p><small>18 posts - 4 participants</small></p>
            <p><a href="https://forum.rebol.info/t/cggong/1776">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/cggong/1776</link>
          <pubDate>Wed, 15 Dec 2021 02:35:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1776</guid>
          <source url="https://forum.rebol.info/t/cggong/1776.rss">Cggong</source>
        </item>
        <item>
          <title>WHILE [Cold Feet]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p><strong>I'm really certain that ANY should not be a looping construct in PARSE.</strong>  Rebol's use of ANY everywhere else means "any one of", not "any number of".  That applies to the ANY short-circuit-OR operation, to the ANY-XXX! types, and it can come up in PARSE such as:</p>
<pre><code>parse block [some any-value!]
</code></pre>
<p>I like the shorthand for this this that works across series types with the TAG! combinator:</p>
<pre><code>uparse block [some &lt;any&gt;]
</code></pre>
<p>This meaning <em>any one element</em>.  It gets at that English concept that operators like <strong><code>*</code></strong> (or <strong><code>&lt;*&gt;</code></strong>) just don't have.</p>
<p>Plus, the "zero-or-more matches of a rule" interpretation doesn't jibe with how we use ANY in English:</p>
<ul>
<li>"Do you have ANY bananas?"</li>
<li>"Yes."</li>
<li>"Cool.  Can I have one, then?"</li>
<li>"No, sorry.  I don't have ANY."</li>
</ul>
<h2>But I'm Not Happy With Bending WHILE For This</h2>
<p>It seemed appealing at first to say that WHILE would be standardized in the language as arity-1, both in PARSE and in ordinary code loops.  This would make UNTIL and WHILE line up, and LOOP could take the arity-2 role that WHILE used to have.</p>
<p>But I've been lamenting <strong><a href="https://en.wikipedia.org/wiki/While_loop">just how universally WHILE is arity-2 in pretty much every language</a></strong> and that LOOP doesn't really quite cut it while reading.  :-/</p>
<p>Sorry for the flux, but I want to move back to <strong>while [condition] [body]</strong> as it was.  However going through the process has spurred thought...</p>
<h2>An Observation: OPT SOME &lt;=&gt; WHILE</h2>
<p>It has in the past occurred to me that PARSE's WHILE (or ANY) was really OPT SOME.  It's three more characters to say it:</p>
<pre><code>while pattern
opt some pattern
</code></pre>
<p><em>(Note: This is only true in modern Ren-C, as previously the progress requirement differentiated these...that is now broken out into FURTHER.)</em></p>
<p>...but although it's more characters, "optionally some number of occurrences of the pattern" is pretty literally what you are talking about.  In the UPARSE model of synthesized values it's kind of less confusing, because it's clearer what it returns in the case of nothing...the same thing OPT always returns when a rule doesn't match: NULL.</p>
<p>Anyway, I'm feeling remorse and a wish to go back to WHILE for arity-2 loops in the language.  But I don't want to go back to ANY in PARSE.</p>
<h2>Is OPT SOME really so bad?</h2>
<p><strong>I've gotten to wondering if there is a reason we don't have a separate word for "zero or more" in English.  You actually have to write out "zero or more" to convey that intent... <em>maybe because the intent is too weird for a single word</em>.</strong></p>
<p>When you just write WHILE it may be that you have a case that's actually supposed to be a SOME but it hasn't really bit you yet.  If you're willing to tolerate between 1 and a million of something, the case of no things being there is distinguished...and calling attention to the fact that the rule you have may not match at all can be an asset.</p>
<p>I actually think OPT SOME offers an advantage, because it encourages you to look at it and decide if the OPT belongs there or not.  It may feel kind of like a wart, but maybe it's a helpful wart.</p>
<p>(It reminds me a bit of the UNLESS vs. IF NOT situation.  Many people felt UNLESS is actually obfuscating nearly everywhere it's used, and that it's better to break it apart even if that means two words instead of one.)</p>
<h2>Trying Out The Change, I Noticed...</h2>
<p>I actually did find a difference how I read the code.  "This entire next section may not be relevant... <em>none</em> of it could match and it would go on."  That weight of the OPT is felt more heavily when the word is there than the WHILE...which if you <em>frequently</em> expect the thing to be there, you may assume it will <em>always</em> be there for at least one instance.</p>
<p>You also can see redundancy in OPT more clearly.  Things like:</p>
<pre><code>opt [
    while [...]
]
</code></pre>
<p>Stand out more if they look like:</p>
<pre><code>opt [
   opt some [...]
]
</code></pre>
<p>I think some things really do read more clearly.  You can look at this as removing 0 or more newlines at the head of a series via a WHILE:</p>
<pre><code>parse series [
    remove [while newline]
    ...
]
</code></pre>
<p>Or rephrase that with OPT SOME:</p>
<pre><code>parse series [
    remove [opt some newline]
    ...
]
</code></pre>
<p>But I think it reads clearest when you bring the OPT outside, to say you're <em>optionally removing some newlines</em>:</p>
<pre><code>parse series [
    opt remove [some newline]
    ...
]
</code></pre>
<h2>More Distinct</h2>
<p>ANY and WHILE both had the problem that they had analogues in imperative code.  But if SOME remains a PARSE keyword, then this helps better intuit the difference...so the code looks more differentiable.</p>
<h2>Compression Is Possible By Other Avenues</h2>
<p>I noticed a particularly laborious substitution in %make-zlib.r which extracts the headers and code for zlib using parse, because it often was parsing C code and looking for the pattern <strong><code>while whitespace</code></strong>.  This would happen multiple lines in a row and multiple times on a line.  When it became <strong><code>opt some whitespace</code></strong> it got more annoying.</p>
<p>But this is kind of a problem anytime you repeat something over and over.  Maybe that pattern should have been <strong><code>ws*: [opt some whitespace]</code></strong> and then it would just be <strong><code>ws*</code></strong> to mean "any number of whitespace characters here, including zero".</p>
<h2>A Motivated Individual Can Overrule It</h2>
<p>Remember, UPARSE is going to let you be the judge.  If you want your own keywords, you can have them.  Maybe you like MANY (some parser combinators seem to think that 0...N is "many" and 1...N is "some").  Maybe you don't care if WHILE is different.  Maybe you don't want to use the ANY parse abstraction that I think is more interesting.</p>
<h2>I'm Trying It Out</h2>
<p>One can argue there's a bit of a 1984-newspeak to it ("you don't need words like better or worse, use plus-good and un-good and double-plus-ungood").  But we're sort of asking a programming language to be more "nuanced" in its wording than English, which has evolved to be pretty much where the brain is at.  I've shown some concrete benefits here to breaking out the OPT so you can see its relationship to the other OPTs you have and move it around.</p>
<p>I do know I'm getting cold feet on the WHILE &lt;=&gt; LOOP change.  And I don't think the arity of WHILE in PARSE should be different from the arity of WHILE in the language, it's jarring.</p>
<p>I'm giving it a shot in the bootstrap and rebmake to see what kind of thoughts it inspires.  So far it seems to be around equally good and bad...and since the bad is just largely unfamiliarity which should wear off...that points to a win, especially since it means retaking WHILE.</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/while-cold-feet/1772">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/while-cold-feet/1772</link>
          <pubDate>Sun, 12 Dec 2021 05:02:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1772</guid>
          <source url="https://forum.rebol.info/t/while-cold-feet/1772.rss">WHILE [Cold Feet]</source>
        </item>
        <item>
          <title>Old Parse Tutorial</title>
          <dc:creator><![CDATA[Brett]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <blockquote>
<p>This is an old tutorial which originally appeared on <a href="http://codeconscious.com">codeconscious.com</a>. It has been posted here in the expectation that <a href="http://codeconscious.com">codeconscious.com</a> will be decommissioned early 2022. Other old articles on REBOL can be found at <a href="https://web.archive.org/web/*/https://codeconscious.com/rebol/">REBOL by codeconscious.com on archive.org</a></p>
</blockquote>
<h1>Introduction</h1>
<blockquote>
<p>Note: This article is a revised version written for open sourced Rebol (Rebol 3), the original Rebol 2 version is here: <a href="https://codeconscious.com/rebol/parse-tutorial.html">Parse Tutorial for Rebol 2</a>.</p>
</blockquote>
<p>If you want to extract data from strings (like HTML, TXT, CSV, etc.) consider Parse.</p>
<p>If you want to just check some user data against a specific format consider using Parse.</p>
<p>If you want to validate some message written in your new dialect use Parse.</p>
<p>Parse is useful.</p>
<p>Parse is quick.</p>
<p>Parse operates on string, binary and block input.  Using Parse you can process these types of input in some way, overlaying the input with new meaning. That is you have a string or block and you are perhaps identifying fields of records, tokens of a language or even identifying sections of a message protocol.</p>
<p>This document is a very rough show by example description of Parse with a few warnings thrown in.</p>
<h1>Parse Dialect</h1>
<p>You give Parse a rule block containing instructions to follow written in the Parse dialect. These instructions allow you to utilise Parse to interpret custom external formats or protocols. These instructions can be as simple or as complex as you need. A simple example would be to check that some input against postal code format. A sophisticated example is Rebol's URL parser (help sys/*parse-url/rules).</p>
<p>The instructions are written using the Parse dialect and tell Parse how to read through your input. In actual fact, the instructions describe the patterns that the input should take. Parse attempts to match the input against your patterns. Parse will return a TRUE result if your instructions accurately describe the input. If your instructions fail to describe the input (or looking at it the other way, the input fails to follow your rules) Parse will return FALSE. You also have the ability to carry out normal Rebol operations as Parse traverses the input and your rules.</p>
<p>It is very important to realise that the keywords of the Parse dialect are interpreted by Parse in a specific way and should be considered as being different in meaning to Rebol words when used at the console.</p>
<h2>Let's start at the end</h2>
<pre><code>&gt;&gt; input-string: {}
&gt;&gt; parse input-string [end]
== true
</code></pre>
<p>Ah success! Here I am parsing an empty string. My rule says to Parse "check that we are at the end". The result is of course TRUE because the string was empty to begin with.</p>
<p>This is similar in normal Rebol script to:</p>
<pre><code>&gt;&gt; tail? input-string
== true
</code></pre>
<h2>Baby steps</h2>
<p>Next up, let's test that a string matches our expectations:</p>
<pre><code>&gt;&gt; input-string: "fox"
== "fox"
&gt;&gt; parse input-string ["fox" end]
== true
</code></pre>
<p>We successfully tested that the input started with "fox" and then finished. Ok, no big deal.</p>
<p>But reflect a moment. This is a sequence - first "fox" then END. As Parse traverses the input</p>
<p>and your rule block, it keeps track of a current position for both. So at the start, the current position in the input is at the head of the string. After the rule "fox" was matched the current position in the input string will be directly after the "x" of "fox".</p>
<p>In this example, this happens to be the tail of the string, so the very next match rule END will succeed.</p>
<p>We do not always have to supply an END in the rule block. You can omit it in the last example because Parse effectively slaps one on at the end anyway.</p>
<pre><code>&gt;&gt; parse input-string ["fox"]
== true
</code></pre>
<p>While you can do this for simple examples, remember you'll likely need to add it in</p>
<p>explicitly for more complex rules.</p>
<p>Ok, back to the example again. In an ordinary Rebol session the above example is similar to the following:</p>
<pre><code>&gt;&gt; input-string: find/match input-string "fox"
== ""
&gt;&gt; tail? input-string
== true
</code></pre>
<p>Note that the ordinary Rebol code examples through this article are provided to help learn Parse. There are enough important differences between the Parse examples and the ordinary code examples that you cannot alway treat them as exactly equivalent.</p>
<h2>Failures / challenges</h2>
<p>For contrast let's look at an unsuccessful match:</p>
<pre><code>&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string ["fox"]
== false
</code></pre>
<p>The meaning of this is pretty obvious. Hang on though, what actually happens when Parse encounters a failure with one of the rules? Well it backtracks the input to the point it was at when the rule started. So in Rebol code what happens is actually more like this:</p>
<pre><code>input-string: "dog"
If position: Find/match input-string "fox" [input-string: position]
Tail? input-string
</code></pre>
<p>Keep this little idea in the back of your mind, it becomes more meaningful with more complex rules.</p>
<h2>Optional matching and Compound Rules</h2>
<p>What if we want to check for a number of common pet alternatives?</p>
<p>Let's accept a "dog" or a "cat" or indeed a "bird":</p>
<pre><code>&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string ["dog" | "cat" | "bird"]
== true
</code></pre>
<p>In ordinary Rebol this is like coding:</p>
<pre><code>input-string: any [
    find/match input-string "dog"
    find/match input-string "cat"
    find/match input-string "bird"
]
tail? input-string
</code></pre>
<p>Now, Rebol can be pretty concise and the ANY function definitely helps in writing concise code, but you can see already that the Parse dialect is looking to be better suited to matching than ordinary scripting.</p>
<p>Reflecting on this a bit. We have here a more interesting rule, a compound rule. Our compound rule is composed of three subrules. Each of the three subrules here are very basic but subrules are allowed to be compound rules themselves. The basic rules perform the lowest level matching of the input, the compound rules check the overall structure/grammar of your data.</p>
<p>Back to options. What about something that may or may not exist at all? Using OPT we can indicate that a bird could be big or just leave it out:</p>
<pre><code>&gt;&gt;  input-string: "bigbird"
== "bigbird"
&gt;&gt;  parse input-string [opt "big" "bird"]
== true
&gt;&gt; input-string: "bird"
== "bird"
&gt;&gt; parse input-string [opt "big" "bird"]
== true
</code></pre>
<p>There are more Parse options such as NOT which give you greater flexibility in specifying your rules. We'll cover this later.</p>
<h2>Spaces and Split</h2>
<p>Parse treats spaces like any other character. Note that Rebol 3 acts differently here to Rebol 2 as whitespace is now parsed by default without needing the /ALL refinement</p>
<pre><code>&gt;&gt;  input-string: "black dog"
== "black dog"
&gt;&gt;  parse input-string ["black" " " "dog"]
== true
</code></pre>
<p>There are constants defined for common characters such as SPACE, NEWLINE and TAB which can be used instead.</p>
<pre><code>&gt;&gt;  parse input-string ["black" space "dog"]
== true
</code></pre>
<p>To make things easier we can use the SPLIT function to pre-process the input string. SPLIT breaks up the string based on a given delimeter or other rules.</p>
<pre><code>&gt;&gt; parse split "brown dog" " " ["brown" "dog"]
== true
</code></pre>
<p>If we look at the output of split we see the following.</p>
<pre><code>&gt;&gt; split "brown dog" " "
== [ "brown" "dog" ]
</code></pre>
<p>In this case split is returning a block of strings simplifying our work with Parse.</p>
<h1>Blocks, repetition and more</h1>
<p>Using Parse for strings is good, but using parse on native Rebol datatypes really shows its power.</p>
<p>Rebol has a rich set of datatypes which simplify parsing data, and code.</p>
<p>This mode is used when the value to be parsed is actually a block not a string. You use this mode when you have already loaded data into Rebol values. You write Parse instructions in a rule block using the parse dialect in a similar way to that described for parsing strings except when parsing blocks the semantics are different and you have a couple more keywords to use.</p>
<p>This is the mode of Parse that deserves the attention of anyone using Rebol. The reason is that you are free to store your data in a form understandable by yourself and others and yet is still computer readable.</p>
<h2>First steps parsing blocks</h2>
<p>As we move from strings to blocks we can start to use some of the Rebol datatypes to make our lives much easier.</p>
<pre><code>&gt;&gt; parse [1234.16] [number!]
== true
</code></pre>
<p>Processing dates and times are a good example. You can see how the datatypes support a wide range of input formats. It is worth noting for Americans that Rebol always assumes day/month/year order.</p>
<pre><code>&gt;&gt; parse [12/Dec/2012 2:30pm ] [date! time!]
== true
</code></pre>
<p>There are many more datatypes although that does not stop you from using strings for datatypes which do not map to Rebol types.</p>
<pre><code>&gt;&gt; parse [&lt;div&gt; "Hello" http://rebol.com $1.00 &lt;/div&gt; bob@test.com ] [ tag! "Hello" url! money! tag! email!]
== true
</code></pre>
<h2>Repetition - known range of occurrences</h2>
<p>Time for some more compound rules.</p>
<p>Here's how to check for exactly two dogs.</p>
<pre><code>&gt;&gt; parse "dogdog" [2 "dog"]
== true
</code></pre>
<p>I can specify between 1 and 4 Zs (inclusive) too:</p>
<pre><code>&gt;&gt;  parse "Zzzz" [1 4 "z"]
== true
</code></pre>
<p>Note that by default Parse is not case sensitive unless you want it to be by using the /CASE refinement:</p>
<pre><code>&gt;&gt; parse/case "ZZ" [2 "Z"]
== true
</code></pre>
<p>This is also very powerful for parsing blocks:</p>
<pre><code>&gt;&gt; parse [ http://rebolsource.net http://rebol.org http://rebol.com ] [ 3 url! ]
== true
</code></pre>
<h2>Repetition again <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"> - unknown number of occurrences</h2>
<p>What if we grab a net and go prawning? We may not know how many prawns are caught by the net when we catch them:</p>
<pre><code>&gt;&gt; loop random 100 [append input-string: "" "prawn"]
== "prawnprawnprawnprawn"
&gt;&gt; parse input-string [some "prawn"]
== true
</code></pre>
<p>Excellent, we have some prawns but we don't know how many.</p>
<p>The SOME keyword means "match one or more of the following". Again it is a compound rule because I could have as easily done this if it was "raining cats and dogs":</p>
<pre><code>&gt;&gt; input-string: "dogdogcatdogcat"
== "dogdogcatdogcat"
&gt;&gt; parse input-string [some [ "dog" | "cat"] ]
== true
</code></pre>
<p>If it fines up:</p>
<pre><code>&gt;&gt; input-string: {}
== ""
&gt;&gt; parse input-string [some [ "dog" | "cat"]  ]
== false
</code></pre>
<p>It returns false because SOME requires at least one instance to be matched. If however, we don't actually care whether we get some or not we can use ANY:</p>
<pre><code>&gt;&gt; input-string: {}
== ""
&gt;&gt; parse input-string [any [ "dog" | "cat" ] ]
== true
&gt;&gt; input-string: "dog"
== "dog"
&gt;&gt; parse input-string [any [ "dog" | "cat"] ]
== true
</code></pre>
<p>Here is another example of one of those Rebol words with a new meaning in the context of Parse. In ordinary Rebol ANY is a function that return the first non-false or non-none value in the block it is given. In Parse, by contrast, ANY is a keyword that introduces a compound rule that means, "match zero or more of the following".</p>
<p>Repetition works equally well for blocks:</p>
<pre><code>&gt;&gt; parse [Fibonacci 1 1 2 3 5 8 13] [some [number! | word!] ]
== true
</code></pre>
<h2>Moving right along...</h2>
<p>Sometimes we really couldn't care less what lies between things of interest.</p>
<p>This example does not "skip c" it reads "match a, skip a character, match c, tail?".</p>
<pre><code>&gt;&gt; parse {abc} ["a" skip "c" end]
== true
</code></pre>
<p>You want to skip 5 characters? Use repetition:</p>
<pre><code>&gt;&gt; parse {1234567890} ["123" 5 skip "90" end]
== true
</code></pre>
<p>Sometimes we don't know how much is in between but we do know what is the next interesting bit:</p>
<pre><code>&gt;&gt; input-string: {1234 fox}
== "1234 fox"
&gt;&gt; parse input-string [thru "fox" end]
== true
</code></pre>
<p>This is like the Rebol code of:</p>
<pre><code>&gt;&gt; input-string: find/tail input-string "fox"
== ""
&gt;&gt; tail? input-string
== true
</code></pre>
<p>We can stop where fox starts using TO:</p>
<pre><code>&gt;&gt;  input-string: "1234 fox"
== "1234 fox"
&gt;&gt;  parse input-string [to "fox" "fox" end]
== true
</code></pre>
<p>And the Rebol code that performs similarly:</p>
<pre><code>input-string: {1234 fox}
input-string: find input-string "fox"
input-string: find/match input-string "fox"
tail? input-string
</code></pre>
<p>We can skip to the end as well:</p>
<pre><code>&gt;&gt;  parse {123456} ["123" to end end]
== true
</code></pre>
<p>This says "match 123, move to the tail, test tail". Pretty obvious we would get a true result if you think of it in these terms.</p>
<p>While we're here how about a warning. The rule [to end] moves to the tail and reports</p>
<p>success every time.</p>
<h2>All these characters</h2>
<p>Charset. Stands for character set. It is a bitset which makes it fast for pattern matching operations.</p>
<p>Let's say you only want to check that your input contains the digits 0 to 9.</p>
<pre><code>&gt;&gt; digit: charset [#"0" - #"9"]
</code></pre>
<p>Now parse can use this directly as a pattern matching instruction. It will match one character (byte) only of those in the set 0 - 9.</p>
<pre><code>&gt;&gt; parse {1} [digit]
== true
</code></pre>
<p>Naturally enough you can use these in compound rules too:</p>
<p>An Australian postcode consists of 4 numeric digits so:</p>
<pre><code>&gt;&gt; parse {2069} [4 digit]
== true
</code></pre>
<p>Charsets (bitsets) are sets and you can apply the set operations union, intersection, exclude, etc</p>
<p>on them:</p>
<pre><code>letter: charset [#"a" - #"z" #"A" - #"Z"]
digit: charset [#"0" - #"9"]
letter-or-digit: union letter digit
valid-name: [letter any letter-or-digit]
&gt;&gt;  parse {1abc} valid-name
== false
&gt;&gt;  parse {rebol} valid-name
== true
&gt;&gt;  parse {xyz1234} valid-name
== true
</code></pre>
<p>Maybe you want everything but digits:</p>
<pre><code>&gt;&gt; parse {A} [not digit skip]
== true
</code></pre>
<p>Notice how we needed to SKIP forward as NOT simply inverses the following rule and does not advance the input.</p>
<p>This is different from the Rebol 2 approach of creating a COMPLEMENT of a charset. This may work in some situations, but will not always give you the desired result due to the use of UNICODE in Rebol 3.</p>
<h2>But I want some information from it!</h2>
<p>Up to this point I've concentrated on the various matching functionality of Parse. Of course though you want to extract information from your data. The keyword of note for this purpose is COPY. Also of use is the ability to execute Rebol code within the Parse rules (actions) and thereby set and maintain Rebol variables (eg. Counters) using that code.</p>
<p>Ok COPY.</p>
<p>Copy is really really simple really. It is a compound rule that takes two arguments a variable and a subrule. Whatever input the subrule matches gets copied into the variable. If the subrule doesn't match anything (fails) COPY returns the failure but leaves the variable unchanged.</p>
<p>Here the subrule is to match an "A" which obviously fails.</p>
<pre><code>&gt;&gt; parse {123} [copy some-text "A"]
== false
&gt;&gt; some-text
** Script error: some-text has no value
</code></pre>
<p>Here the subrule is a simple skip:</p>
<pre><code>&gt;&gt; parse {123} [copy some-text skip to end]
== true
&gt;&gt; some-text
== "1"
</code></pre>
<p>And here the subrule is to match nothing NONE which is always successful so copy copies that which was matched...an empty string:</p>
<pre><code>&gt;&gt; parse "123" [copy some-text none]
== false
&gt;&gt; some-text
== ""
</code></pre>
<p>Another way of getting data is by using SET:</p>
<pre><code>&gt;&gt; parse [ $100 ] [ set wallet money! ]
== true
&gt;&gt; wallet
== $100
</code></pre>
<h2>Bring on the code (actions)</h2>
<p>Ordinary Rebol code can be used inside the parse dialect via the use of "(" and ")" i.e. a Paren! series:</p>
<pre><code>&gt;&gt; parse {} [(print "some code just executed") end]
some code just executed
== true
</code></pre>
<p>Obviously this is very handy. Even nicer is that it runs according to its placement in the rule. Note though that even if the rule ultimately fails your code may have already run:</p>
<pre><code>&gt;&gt; parse {123} [
     "1" (print "found 1!")
     "2" (print "found 2!")
     "A" (print "found an A!")
    end
]
found 1!
found 2!
== false
</code></pre>
<p>So the upshot is you can maintain counters and take actions based on your Parse rules.</p>
<p>During development it can be useful to put print statements in these allowing you to see what is happening.</p>

<h1>Advanced section</h1>
<h2>Repeated Repetition</h2>
<p>Now that I've introduced repetition and compound rules, what happens if I create a compound rule made up of nested repetition rules? Hmm, tricky.</p>
<p>This next example put Parse into a spin - an infinite loop. The escape key will not work, but you can break out with Ctrl+c:</p>
<pre><code>&gt;&gt; input-string: {}
== {}
&gt;&gt; parse input-string [while [any "dog"] ]
</code></pre>

<p>To understand why this infinite loop happens you need to know when the ANY rule returns success and when it completes.</p>
<p>Here's the major answer: WHILE ALWAYS returns success.</p>
<p>WHILE will keep calling its subrule while that subrule returns success regardless of if the input position advances. WHILE gives up on receipt of bad news (failure) but it itself always returns success. Now if WHILE always receives a success because it's subrule in fact is another WHILE or ANY... Well I think that explains it.</p>
<p>Remember OPT. It always returns success just like WHILE. So putting an OPT inside an WHILE is bound to lead to trouble as well.</p>
<p>The point then is that your repetition compound rules must be carefully written because of the possibility of creating these infinite loops. It is not a bug in Rebol, it is consequence of having a flexible Parse dialect.</p>
<p>Sometimes these infinite loops start only after traversing lots of other complex rules and therefore can become hard to catch. I create these loops less often now since I started considering how I want Parse's input position to move. When writing your rules consider how the input is consumed by the rules.</p>
<p>That's part of the reason why I've been demonstrating the Rebol code similar to the various Parse examples.</p>
<p>Not all combinations of repetition rules create infinite loops:</p>
<pre><code>&gt;&gt;  input-string: {}
== ""
&gt;&gt;  parse input-string [while [some "dog"] ]
== true
</code></pre>
<p>This last example is ok because the SOME does not always return success - it must consume some input. If SOME does not have at least one success it</p>
<p>returns a failure result. So you can see that at some point, given that we can assume that the input is</p>
<p>finite, the overall rule must terminate.</p>
<p>Quoting Ladislav, "The dangerous rules are rules, that don't consume any input, yet they return success."</p>
<p>There is another way to escape when you don't want your rule to progress further - the BREAK keyword. BREAK terminates the rule when it is encountered.</p>
<p>This could be used to improve performance by stopping evaluation of unnecessary rules.</p>
<pre><code>&gt;&gt; parse [1 2 end 3 4 5 7 8 9] [some [integer! | 'end break]]
== false
</code></pre>
<p>This rule will exist as soon as it reaches the end keyword improving the performance.</p>
<h2>Debugging parse rules</h2>
<p>The ?? command is invaluable in debugging Parse rules.</p>
<pre><code>&gt;&gt; parse "dog" [ ?? "d" ?? [ "i" | "o" ] ?? "g" ?? ]
"d": "dog"
["i" | "o"]: "og"
"g": "g"
end!: ""
== true
</code></pre>
<p>It displays the next rule and the current position in the series being parsed.</p>
<h2>The current index and manipulating it</h2>
<p>Parse maintains a reference to the input. The reference is a series and so has a current index.</p>
<p>Some special Parse dialect syntax allows you to get and set this reference. You use a set-word and get-word syntax respectively.</p>
<p>In this example I set the word "mark" to the input series at the current index that Parse has, don't worry about the false - it is just saying we didn't get all the way through the input:</p>
<pre><code>&gt;&gt;  parse {123456} ["123" mark:]
== false
&gt;&gt; mark
== "456"
</code></pre>
<p>I can manipulate the current index that Parse uses too:</p>
<pre><code>&gt;&gt;  parse {1234567} ["123" mark: (mark: next next mark) :mark "67"]
== true
</code></pre>
<p>To explain. First "123" is matched, then the word mark is set to the reference.</p>
<p>Then the Rebol code between the parentheses is evaluated. This code manipulates the reference we hold by two characters. I return this modified reference to Parse using the get-word syntax. Parse seeing the get-word syntax knows that it must update it's reference to that given. Finally I match the "67".</p>
<h2>More Block examples ...</h2>

<p>An example that shows what can be achieved is Carl Sassenrath's stock transaction example which you can see below. Now what if "sell 300 shares at $89.08" came in via email?</p>
<p>If you study this example you will see that Carl, in a very small space, has created a small interpreter that parses, validates and performs computations. This is very powerful technology that is easily underestimated because it is so small and simple.</p>
<pre><code>rule: [
    set action ['buy | 'sell]
    set number integer!
    'shares 'at
    set price money!
    (either action = 'sell [
            print ["income" price * number]
            total: total + (price * number)
        ] [
            print ["cost" price * number]
            total: total - (price * number)
        ]
    )
]
total: 0
parse [sell 100 shares at $123.45] rule
print ["total:" total]
total: 0
parse [
    sell 300 shares at $89.08
    buy 100 shares at $120.45
    sell 400 shares at $270.89
] [some rule]
print ["total:" total]
</code></pre>
<p>Another powerful example of this is the VID dialect of Rebol/View 2. VID describes in a<br>
effective but simple way what should appear on screen. VID is actually a block using normal<br>
Rebol values such as words and strings. The LAYOUT function of Rebol/View 2 takes a VID<br>
block as an argument to construct the visual objects. Layout uses Parse to process the<br>
VID specification.</p>
<h1>Special situations</h1>
<h2>When you do NOT want to match a pattern</h2>

<p>NOT does not consume input, so you can use it one ore more times before matching something else:</p>
<pre><code>&gt;&gt; parse "bird" [not "big" "bird"]
== true
</code></pre>
<p>One situation where you might do this is when you have a sub rule that might "consume" something needed by an enclosing rule.</p>
<p>For my example, I'll Parse a block rather than text but the concept still applies.</p>
<p>I want to Parse the following block, and print out every word, but if I encounter a bar ("|") I'll print out the text "**********":</p>
<pre><code>my-block: [ the quick brown fox | jumped | over the lazy]
</code></pre>
<p>This next bit of code will not work. If you try it you will see that no "*" is printed, instead you will see the "|":</p>
<pre><code>single-word: [set item word! (print mold item)]
phrase: [some single-word]
parse my-block [ phrase some ['| (print "**********") phrase] ]
</code></pre>
<p>The thing to note is that the bar "|" is a word too. Therefore the bar is "consumed" by the rule called SINGLE-WORD.</p>
<p>So one way to solve this is to give SINGLE-WORD some indigestion (make it fail) when it encounters a bar.</p>
<p>You can force a rule to fail using the FAIL keyword but here we use AND and NOT to make the rule fail under a specific condition.</p>
<p>To make it clear what is happening here, I wrap SINGLE-WORD with a rule I call WORD-EXCEPT-BAR. The</p>
<p>purpose of this new rule is to fail if it finds the "|" word otherwise it goes ahead and runs SINGLE-WORD.</p>
<p>I've added comments to clarify how WORD-EXCEPT-BAR works:</p>
<pre><code>word-except-bar: [
    and not '| ; Without advancing the input position, is this not a bar?
    single-word ; Match single-word
]
</code></pre>
<p>The point to note here is that the rule AND NOT '| is a "guard" - it guards the next rule from consuming input under a specific condition.</p>
<p>I also need to modify PHRASE to call WORD-EXCEPT-BAR.</p>
<pre><code>phrase: [some word-except-bar]
</code></pre>
<p>Another way to describe the PHRASE rule, as it is now, is "a rule that matches a series of words which does not contain the word |."</p>
<p>To finish off I'll create a function to call parse with the correct rule and</p>
<p>wrap the whole lot in an object just to be tidy:</p>
<pre><code>word-parsing-object: context [
    single-word: [set item word! (print mold item)]
    word-except-bar: [and not '| single-word]
    phrase: [some word-except-bar]
    set 'parse-words func[ a-block [block!] ] [
        parse a-block [phrase some ['| (print "**********") phrase] ]
    ]
]
</code></pre>
<p>Here is a test run:</p>
<pre><code>&gt;&gt; parse-words [the quick brown fox | jumped | over the lazy]
the
quick
brown
fox
**********
jumped
**********
over
the
lazy
== true
</code></pre>
<p>In summary in this section I have demonstrated how one can match a specific pattern even when a more general pattern (that includes the specific pattern) gets to see the input first.</p>
<h2>Why didn't you just write...</h2>
<pre><code>parse-words: func [a-block [block!]] [
    parse a-block [
        some [
            '| (print "**********") |
            set item word! (print mold item)
        ]
    ]
]
</code></pre>
<p>That is the better way to solve the problem, but the point is to demonstrate the concept of preventing a subrule from consuming certain input and how to use AND as a guard. There are situations when you need these ideas.</p>
<h2>The BREAK keyword</h2>

<p>From RT's changes document:</p>
<pre><code>When the BREAK word is encountered within a rule block, the block is
immediately terminated regardless of the current input pointer.
Expressions that follow the BREAK within the same rule block will not
be evaluated.
</code></pre>
<p>BREAK is usually used with repetition. In this example the SOME rule is exited early:</p>
<pre><code>&gt;&gt; parse "X" [some [ (print "*Break*") break] "X"]
*Break*
== true
</code></pre>
<p>Here again the SOME rule is exited early just like the previous example. In this case the rule that SOME is processing is referred to by a word:</p>
<pre><code>&gt;&gt; rule-to-break: [(print "*Break*") break]
== [(print "*Break*") break]
&gt;&gt; parse "X" [some rule-to-break "X"]
*Break*
== true
</code></pre>
<h1>Related toolset</h1>
<p>I have written "Parse Analysis Toolset" to help learn and analyse the way Parse works. The Explain-parse function of the toolset should help with learning Parse. The script has related documentation. You can find the script and a linkg to the documentation at:</p>
<p><a href="http://www.rebol.org/cgi-bin/cgiwrap/rebol/view-script.r?script=parse-analysis.r">parse-analysis.r (at REBOL.org Script Library)</a></p>
<p>One more program I've made can return a parse tree of your input:</p>
<p><a href="http://www.rebol.org/cgi-bin/cgiwrap/rebol/documentation.r?script=load-parse-tree.r">load-parse-tree.r (at REBOL.org Script Library)</a></p>
<h1>Comments</h1>
<p>Parse is a key component Rebol. Rebol is promoted as a messaging<br>
language. Messages can come in many formats (syntaxes). Parse allows<br>
you to define the syntax of a message so that you can interpret the message and transform<br>
it to something else or act on it directly. That may sound complex, but it isn't really.</p>
<p>What are messages? Lots of things can be considered as messages. Basically if you can<br>
put it into a file and the format of the file has some rule to it, then I think you have<br>
a message. You don't have to put it in a file though to use Parse. Rebol's networking<br>
functions use Parse to interpret many of the internet protocols that Rebol provides<br>
access to.</p>
<p>With Rebol you can define a mini-language for a specific purpose - a dialect. Outside Rebol this would be called a domain-specific language or DSL.</p>
<p>Parse helps you to validate and process such dialects. You might want to design a dialect for creating web pages on your internet site. Or perhaps for controlling a special device you have attached to your computer.</p>
<h1>Acknowledgement</h1>
<p>Thank you to John Kenyon for his initiative, edits and effort as we updated this article from the original.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/old-parse-tutorial/1771">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/old-parse-tutorial/1771</link>
          <pubDate>Sun, 12 Dec 2021 00:08:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1771</guid>
          <source url="https://forum.rebol.info/t/old-parse-tutorial/1771.rss">Old Parse Tutorial</source>
        </item>
        <item>
          <title>DEFAULT with PATH!...What Does It *Mean*?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The ability to have random side-effects in paths creates all kinds of nasty potentials.</p>
<p>That is why I made a way to say you only allow paths to contain evaluations if you also ask for an "invariant" representation of the path to be returned...that you could use in place of a path for further assignments.</p>
<pre><code>&gt;&gt; var: 'x

&gt;&gt; path: 'obj/(print "side effect" var)

&gt;&gt; set path 30
** Error: PATH contains GROUP!s, must request /STEPS output (can use #)

&gt;&gt; [value steps]: set path 30
side effect
== 30

&gt;&gt; steps
== @[obj x]
</code></pre>
<p>You can then use STEPS instead of the path.  e.g. <strong>set @[obj x]</strong> will act like <strong>set 'obj/x</strong>.  (The reason a BLOCK! is used is because not all datatypes would be legal in paths...a GROUP! could evaluate to anything, like an OBJECT!...which is a perfectly valid thing to set in a MAP! for instance.)</p>
<h2>This "Invariant" Form Was Intended For Things Like DEFAULT</h2>
<p>The concept was that even if you have evaluations on the left hand side, you will be able to capture where it got the value or absence-of-value from...and then in the event you need to write it back because a default is necessary, you don't have to run the evaluation again:</p>
<pre><code>&gt;&gt; n: 5

&gt;&gt; data.(n: n + 1): default [10]
</code></pre>
<p>Internally, DEFAULT can make a GET request of <strong>data.(n: n + 1)</strong> and get back STEPS with a fixed value for N, like <strong><code>@[data 6]</code></strong>.  If it discovers that the value is set to blank and needs defaulting, it can then use the steps instead of the path as the basis for the SET...so N is not changed twice.</p>
<h2>But Other Things Can Change...</h2>
<p>All kinds of changes can happen between the GET and the SET in DEFAULT.  What about this?</p>
<pre><code>&gt;&gt; data.(n: n + 1): default [data: ~gone~, 10]
</code></pre>
<p>We've prevented running imperative code and getting side effects from the path...but the side effects can come from other places.  <strong>Anything you do between the GET and the SET can make the "invariant" steps not so invariant.</strong></p>
<p>Let's say DATA was a BLOCK! at the outset.  Should the <strong><code>@[...]</code></strong> steps have actually stored a reference to the block instead of the WORD! data, so that changes to the variable couldn't redirect the invariant reference?</p>
<p>That doesn't work for immediate types.  Let's say you have:</p>
<pre><code>&gt;&gt; time: 4:00

&gt;&gt; path: 'time.(if true ['hour])

&gt;&gt; [# steps]: set path 12
== 12

&gt;&gt; steps
== @[4:00 hour]
</code></pre>
<p>Now you can't use that steps to go back and change the original time, because 4:00 is an immediate value.  You need to get at the object the time lives in.  You'd wind up with a 3-element steps in that case:</p>
<pre><code>&gt;&gt; steps
== @[make object! [...] time hour]
</code></pre>
<h2>If Nothing Is Going To Be Perfect... Should We Shortcut It?</h2>
<p>Let's say you have a path like:</p>
<pre><code>obj1.obj2.(if true [obj3]).obj4.date.time
</code></pre>
<p>We could say that the "steps" for this path are:</p>
<pre><code>@[obj1 obj2 obj3 obj4 date time]
</code></pre>
<p>But is that empirically more desirable than just noticing when we cross the line from non-immediate values into immediate values, and preserving only as much as we need?</p>
<pre><code>@[(make object! [...this is obj4...]) date time]
</code></pre>
<p>That's enough to write back to obj4...but it is fully disconnected from the path that was initially being represented.  <strong>But which is more suitable for the intent of something like DEFAULT?</strong></p>
<h2>My Head Hurts <img src="https://forum.rebol.info/images/emoji/twitter/face_with_head_bandage.png?v=9" title=":face_with_head_bandage:" class="emoji" alt=":face_with_head_bandage:">
</h2>
<p>...and it's not because of a booster shot.  It's because this is crazy, and way past the point of being fun.</p>
<p>What started out as a nice idea for taming GROUP!s in PATH!s becomes a real headache.</p>
<p><strong>So I'm going to leave well enough alone, and say that this does only that.</strong>  If you want to prune a path to get better invariants, that's on you:</p>
<p>For example:</p>
<pre><code>(obj1.obj2.obj3.obj4).date.time: default [...]
</code></pre>
<p>When you do this, then when DEFAULT asks for steps it will get 4 items in the block:</p>
<pre><code>&gt;&gt; steps
== @[(make object! [...]) date time]
</code></pre>
<p>It has latched onto the object, and so you can say inside the body of the defaulting code things like <strong><code>obj1: null</code></strong> or <strong>obj1.obj2.obj3: []</strong> and the assignment will apply to what it was looking at, because those names aren't in the steps.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/default-with-path-what-does-it-mean/1770">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/default-with-path-what-does-it-mean/1770</link>
          <pubDate>Sat, 11 Dec 2021 23:58:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1770</guid>
          <source url="https://forum.rebol.info/t/default-with-path-what-does-it-mean/1770.rss">DEFAULT with PATH!...What Does It *Mean*?</source>
        </item>
  </channel>
</rss>

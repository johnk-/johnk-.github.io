<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest topics</title>
    <link>https://forum.rebol.info/latest</link>
    <description>Latest topics</description>
    
      <lastBuildDate>Thu, 29 Jun 2023 02:09:57 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/latest.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Should ANY and ALL Vaporize VOID (or require ELIDE-IF-VOID ?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've written up how <a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">the evolution of invisibility gave rise to VOID vs. NIHIL</a>.</p>
<p>The default evaluator (and UPARSE) accept that void is "nothing" and can't be put in blocks.  But they don't vaporize VOID on a whim: it will still be the result of expressions whose last result is a void.</p>
<pre><code>&gt;&gt; 1 + 2 if false [&lt;a&gt;]
; void
</code></pre>
<p>On the other hand, the empty parameter pack of NIHIL truly vaporizes unless you pipe it around with ^META:</p>
<pre><code>&gt;&gt; 1 + 2 nihil
== 3
</code></pre>
<p>This means it's up to constructs to decide if they want to erase voids or not.  DELIMIT does, so you will see that reflected in things like UNSPACED:</p>
<pre><code>&gt;&gt; unspaced ["A" if false ["B"] "C"]
== "AC"
</code></pre>
<p>COMPOSE vaporizes void slots (and errors on null ones).  <a href="https://forum.rebol.info/t/vaporizing-failed-conditionals-in-reduce/1665">REDUCE is currently vaporizing VOID</a> because it seems like the default people want.</p>
<h2>
<a name="should-any-and-all-vaporize-voids-1" class="anchor" href="https://forum.rebol.info#should-any-and-all-vaporize-voids-1"></a>Should ANY and ALL Vaporize Voids?</h2>
<p>To me, this is a bit of a tough decision.</p>
<p>VOID is neither truthy nor falsey, and IF will reject it:</p>
<pre><code>&gt;&gt; if (if false [true]) [&lt;unreachable&gt;]
** Error: IF doesn't accept VOID as its condition argument
</code></pre>
<p>When there was no VOID/NIHIL distinction, then ANY and ALL were backed into a corner.  If they decided to error on void, you couldn't use an ELIDE or ASSERT in the middle of them.  If they didn't error on VOID then the risk was that you could write something like <strong><code>all [1 = 1, 2 = 2, value]</code></strong> and if VALUE was just incidentally void you'd get the 2 = 2 result as ~true~.</p>
<p>Today, things like ELIDE and ASSERT return NIHIL and can be safely vaporized by ANY and ALL, while retaining the choice to error on voids as not being true or false.  If you really want to erase voids, we can have something that converts voids to nihil called ELIDE-IF-VOID</p>
<pre><code>&gt;&gt; value: void

&gt;&gt; all [1 = 1, 2 = 2, value]
** Error: VALUE is VOID which is neither truthy nor falsey

&gt;&gt; all [1 = 1, 2 = 2, elide-if-void value]
== ~true~  ; isotope
</code></pre>
<h2>
<a name="things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2" class="anchor" href="https://forum.rebol.info#things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2"></a>Things Like <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">FOR-BOTH</a> Would Get More Awkward...</h2>
<p>I was fairly proud of this formulation:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        meta* for-each (var) blk1 body
        meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>(I wound up deciding that META would meta-raise everything--including pure null and void--so the asterisks were probably best included there for the alternative formulation.)</p>
<p>But if ALL and ANY errored on void, and you had to erase it, this would become:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        elide-if-void meta* for-each (var) blk1 body
        elide-if-void meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>If I put on my formalism hat, I can see how this is <em>safer</em>.  But I've made similar arguments about why I don't want this:</p>
<pre><code>&gt;&gt; compose [a (if false ['b]) c]
** Error: COMPOSE cannot erase VOID (use ELIDE-IF-VOID if intentional)

&gt;&gt; compose [a (elide-if-void if false ['b]) c]
== [a c]
</code></pre>
<p>It is admittedly a bit different in ANY and ALL's case, because they're mixing in a test for truthiness.  But erasing voids by default has other advantages in writing wild control constructs.</p>
<p>I'm really torn on this, as it's right on the edge.  <strong>But when all things are mostly equal, safety isn't as compelling as enabling creativity in my current view of the language.</strong>  I think I'm going to wait until I see a really bad consequence of vaporizing the voids here... it hasn't broken any real code yet, and it has proven its convenience.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-any-and-all-vaporize-void-or-require-elide-if-void/2040">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-any-and-all-vaporize-void-or-require-elide-if-void/2040</link>
          <pubDate>Thu, 29 Jun 2023 02:09:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2040</guid>
          <source url="https://forum.rebol.info/t/should-any-and-all-vaporize-void-or-require-elide-if-void/2040.rss">Should ANY and ALL Vaporize VOID (or require ELIDE-IF-VOID ?)</source>
        </item>
        <item>
          <title>Invisibility Reviewed Through Modern Eyes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The first idea of making constructs that would "vanish completely" leveraged a special kind of enfix function, that would receive the entire evaluated value of the left hand side:</p>
<pre><code> elide: enfix func [
     left [&lt;evaluate-all&gt; any-value!]
     right
 ][
     print ["ELIDE got left as" mold left]
     return left
 ]

 &gt;&gt; 1 + 2 + 3 comment [magic!]
 hi
 ELIDE got left as 6
 == 6  ; wow!
</code></pre>
<p>This was a workaround for the (seeming?) fundamental fact that you can't have such a thing as "invisible variables" or "invisible values".  <em>Certain functions just faked invisibility by repeating the previous value in the evaluator chain.</em></p>
<p>The possibilities seemed endless.  For instance, imagine something like this:</p>
<pre><code>case [
   conditionA [...code...]
   elide print "conditionA didn't succeed but running this"
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>To do that in Rebol2 or Red would be incredibly awkward.  e.g. using a condition that runs code but evaluates to false, and then a throwaway block for the never-executed branch:</p>
<pre><code>case [
   conditionA [...code...]
   (
       print "conditionA didn't succeed but running this"
       false
   ) [&lt;unreachable&gt;]
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>Similar awkwardness would arise in things like ANY and ALL, where you'd have to switch from using true and false based on which you were using...</p>
<pre><code>any [conditionA (print "vanish" false) conditionB]
all [conditionA (print "vanish" true) conditionB]
</code></pre>
<p>Beyond being awkward, it simply can't work if what you want to vanish is the last expression.  But ELIDE handled all these cases:</p>
<pre><code>any [conditionA elide print "vanish" conditionB]
all [conditionA elide print "vanish" conditionB]
any [conditionA conditionB elide print "vanish"]
all [conditionA conditionB elide print "vanish"]
</code></pre>
<h2>
<a name="it-was-a-neat-trickbut-problems-emerged-1" class="anchor" href="https://forum.rebol.info#it-was-a-neat-trickbut-problems-emerged-1"></a>It Was A Neat Trick...But Problems Emerged</h2>
<p>The trick of invisibility requiring a function to receive its left hand side meant a GROUP! or COMMA! would break these constructs, as there was no access to a previous value:</p>
<pre><code> &gt;&gt; 1 + 2 + 3 (elide print "hi")
 hi
 ELIDE got left as null
 == ~null~  ; not 6, d'oh!

 &gt;&gt; 1 + 2 + 3, elide print "hi"
 hi
 ELIDE got left as null
 == ~null~
</code></pre>
<p>Plus being enfix forced the invisible functions to execute in the same step as whatever came before them, causing unsuspected results:</p>
<pre><code>&gt;&gt; case [
        1 = 1 [print "branch"]
        elide print "reached here first :-("
        1 = 2 [fail "Unreachable"]
    ]
ELIDE got left as [print "branch"]
reached here first :-(
branch
</code></pre>
<p>There we see that when the evaluator visited the <strong>[print "branch"]</strong> block in the CASE it had to greedily run the ELIDE, which evaluates its argument and then yielded the code block as its result.  CASE ran that code after the elide...out of order from what was desired.</p>
<p>Issues seemed to keep compounding.  These invisible functions couldn't be reliably used with MAKE FRAME!, and people trying to simulate the evaluator's logic found it hard to detect and wrap them.  That led to major issues with UPARSE trying to implement combinators that acted like ELIDE.</p>
<p>So the enfix mechanism wasn't going to cut it.  But it was too late: having been able to try out and develop all kinds of invisible constructs convinced me of their value.  I had to try another way...</p>
<h2>
<a name="formalizing-a-void-state-and-corresponding-meta-state-2" class="anchor" href="https://forum.rebol.info#formalizing-a-void-state-and-corresponding-meta-state-2"></a>Formalizing a VOID State And Corresponding Meta State</h2>
<p>The seeming impossibility of having a "void value" was addressed with the idea of folding special treatment in the evaluator of voids, but offering a meta domain in which they could be handled safely.</p>
<pre><code>&gt;&gt; var: void
; void

&gt;&gt; 1 + 2 var
== 3

&gt;&gt; var: meta void
== '

&gt;&gt; 1 + 2 var
== '

&gt;&gt; 1 + 2 unmeta var
== 3
</code></pre>
<p>The concept of being able to pipe around and process "slippery" values in this meta domain (including unset states and other isotopes) wound up being very successful.</p>
<p>Evaluators like DO and UPARSE would specially preserve the last evaluative value in order to give the illusion of invisibility when voids were seen on the next step.  Other constructs got to make a choice as to whether they wanted to embrace voids as part of the mechanic, or think of them as errors:</p>
<pre><code>&gt;&gt; comment "comments returned void"  ; Note: console doesn't show void results

&gt;&gt; if comment "hi" [print "not tolerated in conditions"]
** Error: IF doesn't accept void as its condition argument

&gt;&gt; all [comment "begin" 1 + 2 10 + 20 comment "end"]
== 30

&gt;&gt; any [comment "begin" 1 + 2 10 + 20 comment "end"]
== 3
</code></pre>
<p>e.g. for the above to work, ALL has to hang on to the last evaluated result as it goes...in case the next evaluated result is a comment.  This allows the 30 to fall out.</p>
<h2>
<a name="a-flexible-approach-but-here-be-dragons-3" class="anchor" href="https://forum.rebol.info#a-flexible-approach-but-here-be-dragons-3"></a>A Flexible Approach... But... Here Be Dragons</h2>
<p>Something that concerned me early on was that what had started as a narrow ability of just a few functions (like COMMENT and ELIDE) was becoming a case where generalized execution could possibly return voids, leading to unexpected results.</p>
<pre><code>&gt;&gt; code: [comment "some arbitary code block"]

; ... then much later ...

&gt;&gt; result: (mode: &lt;reading&gt; do code)
== &lt;reading&gt;

&gt;&gt; result
== &lt;reading&gt;  ; oops
</code></pre>
<p>Increasing dependence on void as a "vanishing" alternative to the noisier null also raised the demand for void variables, with them becoming slippery to generate:</p>
<pre><code>&gt;&gt; parse [x] [rule: ['x (void) | 'y ([some "y"])]
== x

&gt;&gt; rule
== x  ; wanted void
</code></pre>
<p>VOID was becoming a victim of its own popularity.  When it was rare coming from only a few constructs like ELIDE and COMMENT it was rare to see problems.  Yet when every IF/CASE/SWITCH statement that didn't run a branch started returning voids, things got hairier.</p>
<p>There were also snags when making void isn't a parameter...but a product of something like the body on a MAP-EACH. At first it looks fine:</p>
<pre><code>map-each item [1 &lt;one&gt; 2 &lt;two&gt; 3 &lt;three&gt;] [
    maybe match tag! item  ; leaving it as NULL would be an error
]
== [&lt;one&gt; &lt;two&gt; &lt;three&gt;]
</code></pre>
<p>But what if you had something else in the loop body?</p>
<pre><code>map-each item [1 &lt;one&gt; 2 &lt;two&gt; 3 &lt;three&gt;] [
    append log spaced ["Logging:" item]
    maybe match tag! item  ; remember, void vanishes
]
== ["Logging: 1" "Logging: &lt;one&gt;" "Logging..." ...]
</code></pre>
<h2>
<a name="once-again-isotopes-to-the-rescue-4" class="anchor" href="https://forum.rebol.info#once-again-isotopes-to-the-rescue-4"></a>Once Again: Isotopes To The Rescue</h2>
<p>As part of <a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">solving the problem of multi-returns</a>, parameter pack isotopes were introduced.  These would "decay" to their first item, unless something handled the isotope specially.</p>
<pre><code>&gt;&gt; pack [1 + 2 10 + 20]
== ~['3 '30]~  ; isotope

&gt;&gt; a: pack [1 + 2 10 + 20]
== 3

 &gt;&gt; [a b]: pack [1 + 2 10 + 20]  ; SET-BLOCK! handles PACK! isotopes specially
 == 3

 &gt;&gt; a
 == 3

 &gt;&gt; b
 == 30
</code></pre>
<p>Unpacking the packs raised a question: <em><strong>What if the PACK! is Empty</strong></em>?  As far as variable assignment goes, it seems it can't do anything.  So erroring made the most sense:</p>
<pre><code>&gt;&gt; pack []
== ~[]~  ; isotope

&gt;&gt; a: pack []
** Error: No values available in empty parameter pack
</code></pre>
<p>Then there was a breakthrough of the next thought: <em><strong>Empty isotopic packs could be used as the vanishing intent!!</strong></em></p>
<pre><code>&gt;&gt; 1 + 2, pack []
== 3
</code></pre>
<p>This would mean VOID could be less "slippery" in the evaluator, being treated normally most of the time and falling out of expressions vs. vaporizing:</p>
<pre><code>&gt;&gt; 1 + 2, if false [&lt;a&gt;]  ; overall result is void (no console output)

&gt;&gt; 1 + 2, if true [&lt;a&gt;]
== &lt;a&gt;
</code></pre>
<h2>
<a name="empty-isotopic-packs-were-then-given-a-name-nihil-5" class="anchor" href="https://forum.rebol.info#empty-isotopic-packs-were-then-given-a-name-nihil-5"></a>Empty isotopic packs were then given a name: <strong>"NIHIL"</strong>
</h2>
<p>The terminology has varied over time.  I accomplished the distinction another way before isotopic packs, and at that time I called the distinction "impure invisibility" (non-vaporizing) vs. "pure invisibility" (vaporizing).</p>
<p>But I think the "impure" vs. "pure" terms just caused confusion.  This is where things stand today, and it seems comfortable:</p>
<pre><code>&gt;&gt; 1 + 2 void

&gt;&gt; 1 + 2 nihil
== 3

&gt;&gt; 1 + 2 null
== ~null~   ; isotope
</code></pre>
<h2>
<a name="i-think-this-is-a-comfortable-balance-6" class="anchor" href="https://forum.rebol.info#i-think-this-is-a-comfortable-balance-6"></a>I Think This Is A Comfortable Balance</h2>
<p>No matter what way you slice it, an expression that can truly vaporize is something that can make you uneasy.  Look at this CASE statement and imagine if FOO or BAR could vanish:</p>
<pre><code> case [
     foo [print "hi"]
     bar [print "bye"]
 ]
</code></pre>
<p>Sure... we can lament that if FOO comes back as NIHIL, it will wreck the geometry of the CASE completely.  After dropping the FOO it will treat [print "hi"] as a condition and use BAR as a code branch.</p>
<p><em>But if FOO is a function that takes a BLOCK! as a parameter, it will also wreck the geometry of the CASE completely!</em>  This is just the cost of doing business in the Rebol paradigm.</p>
<p>This modern model with NIHIL being an unstable isotope brings us back to where you can only get vanishing function calls--not vanishing variables.  FOO can be a variable holding VOID, but there's no risk of that wrecking the CASE statement...because CASE is not one of the constructs that willfully erases VOID.  Neither does the foundational evaluator (and nor does UPARSE)</p>
<p>So long as usage of NIHIL is judicious, I think this is about as terra firma as the rest of Rebol is.  And UPARSE stands as a great example of a system that has been able to build on meta-representation in order to be able to pipe around vanishing states using "special gloves" and build upon it to make new invisible behaviors...</p>
<pre><code>&gt;&gt; parse "aaabbb" [collect some keep "a", elide some "b"]
== ["a" "a" "a"]
</code></pre>
<p>It's rather satisfying.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034</link>
          <pubDate>Fri, 23 Jun 2023 17:06:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2034</guid>
          <source url="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034.rss">Invisibility Reviewed Through Modern Eyes</source>
        </item>
        <item>
          <title>Unstable Isotope Conundrums</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>An unstable isotope is one that cannot be stored in a variable.  The clearest example of one of these is a PACK!.</p>
<p>Quick refresher: because functions receive their arguments in variables, you clearly cannot pass an unstable isotope to a function.  You instead use ^META parameters and get the quasiform.</p>
<pre><code>&gt;&gt; pack [3 4]
; first in pack of length 2
== 3

&gt;&gt; meta pack [3 4]
== ~['3 '4]~

&gt;&gt; [a b]: pack [3 4]
== 3

&gt;&gt; a
== 3

&gt;&gt; b
== 4
</code></pre>
<p><strong>But what about non-variable situations... like expressions that are being tested for being truthy or falsey?</strong></p>
<p>Right now, tests for truthiness throw the unstable state away.  For instance, ALL:</p>
<pre><code>&gt;&gt; all [1 2 pack [3 4]]
== 3
</code></pre>
<p>The PACK! formed by the PACK function is decayed to just 3 by the ALL, and then the 3 was tested as truthy.  If you wanted to get past this, you would have to meta-and-then-unmeta the pack:</p>
<pre><code>&gt;&gt; unmeta all [1 2 meta pack [3 4]]
; first in pack of length 2
== 3
</code></pre>
<p>But note that here, it's testing the meta-pack ~['3 '4]~ for truthiness, not the 3.  So if false were in the meta pack, it would still wind up truthy.</p>
<pre><code>&gt;&gt; all [1 2 meta pack [false false]]
== ~[~false~ ~false~]~
</code></pre>
<p>Whereas a regular pack would be decayed before the test:</p>
<pre><code>&gt;&gt; all [1 2 pack [false false]]
== ~null~  ; isotope
</code></pre>
<p>You might ask <em>"Why not just say all PACK!s are truthy, so you don't have to META and UNMETA them?"</em></p>
<p>Well just think about it: when you use a multi-returning function you may only be interested in the primary result...and even only be slightly aware that more results are available.  For instance: not everyone knows that today's FIND returns an additional output if you want it (it's the end of a match).</p>
<p><strong>Saying that packs must decay to test them for truthiness doesn't seem too baffling, but what about loop constructs that don't test for truthiness?</strong></p>
<p>Is this harmless?</p>
<pre><code>&gt;&gt; flag: true

&gt;&gt; meta while [flag] [flag: false, pack [3 4]]
== ~['3 '4]~
</code></pre>
<p>It seems all right, although this becomes a property that <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">has to be preserved by compositions like FOR-BOTH</a>. (As it so happens, the composition does work.)</p>
<p>But what about UNTIL?  In until the loop condition and the body are the same, and in order to exit the loop the body must be truthy...so you can't get a pack out:</p>
<pre><code>&gt;&gt; until [pack [3 4]]
== 3
</code></pre>
<p>And also... what about situations like CONTINUE/WITH or STOP/WITH.  If the /WITH parameter is a plain refinement and not a ^META one, then the information will be lost:</p>
<pre><code>&gt;&gt; cycle [stop/with pack [3 4]]
== 3
</code></pre>
<p>If CONTINUE and STOP were to follow in the footsteps of RETURN, they would need an added refinement like RETURN/FORWARD which distinguishes the case where you do want the meta parameter from where you don't (which is the current solution, vs. something like marking ^RETURN: as always being meta on the function definition).</p>
<h2>
<a name="maybe-test-decayd-value-preserve-pack-1" class="anchor" href="https://forum.rebol.info#maybe-test-decayd-value-preserve-pack-1"></a>Maybe Test DECAY'd Value, Preserve PACK! ?</h2>
<p>Constructs like ALL or UNTIL might decay only for the purposes of the truthiness test, but preserve the original PACK! for the actual return.</p>
<p>For instance could you do this?</p>
<pre><code>&gt;&gt; [a /b]: all [
       1 = 1
       2 = 2
       pack [3 4]
   ]
== 3

&gt;&gt; a
== 3

&gt;&gt; b
== 4
</code></pre>
<p>I've pointed out that PACKs with falsey items have to break the chain:</p>
<pre><code>&gt;&gt; [a /b]: all [
       1 = 1
       2 = 2
       pack [false 4]
   ]
== ~null~  ; isotope

&gt;&gt; a
== ~null~  ; isotope

&gt;&gt; b
== ~null~  ; isotope
</code></pre>
<p>If you didn't intend that you'd have to META the pack inside the ALL...and UNMETA outside as discussed (in this case with UNMETA* which passes through null as-is vs. erroring if the leading conditions resulted in a null outcome)</p>
<pre><code>&gt;&gt; [a /b]: unmeta* all [
       1 = 1
       2 = 2
       meta pack [false 4]
   ]
== ~false~  ; isotope

&gt;&gt; a
== ~false~  ; isotope

&gt;&gt; b
== 4
</code></pre>
<p>Taking this preservation to extremes would complicate a lot of places in the code.  For instance: IF tolerates function branches, and will pass on the condition to the branch:</p>
<pre><code>&gt;&gt; var: [a b c]

&gt;&gt; if var (func [x] [print ["var was" mold x]])
var was [a b c]
</code></pre>
<p>But what if you want to do this with a pack, and have the option of receiving it in that function?</p>
<pre><code> &gt;&gt; if pack [1 2] (func [x] [print ["var was" mold x]])
 var was 1

 &gt;&gt; if pack [1 2] (func [^x] [print ["meta var was" mold x]])
 meta var was ~[1 2]~

 &gt;&gt; if pack [false 2] (func [^x] [print ["meta var was" mold x]])
 ; void
</code></pre>
<p>Interesting though that may look, it changes IF to where it has to take its condition as a ^META parameter, otherwise it decays and can't be passed on.</p>
<p>I can't tell if this is a high-enough leverage piece of functionality to be worth complicating IF or not.</p>
<h2>
<a name="for-now-tempting-to-say-loop-protocol-cant-return-pack-2" class="anchor" href="https://forum.rebol.info#for-now-tempting-to-say-loop-protocol-cant-return-pack-2"></a>For Now, Tempting To Say "Loop Protocol" Can't Return PACK!</h2>
<p>It's not necessarily <em>hard</em> to make /WITH a ^META-refinement on CONTINUE and STOP... at least in terms of allowing PACK!.  <strong>continue/with raise error</strong> would cause some uncomfortable results.</p>
<p>Again, note there are ways to work around not processing unstable pack! isotopes by the /WITH itself, by META-ing on the inside and UNMETA-ing on the outside:</p>
<pre><code> &gt;&gt; cycle [stop/with meta pack [3 4]]
 == ~[3 4]~

 &gt;&gt; [a b]: unmeta cycle [stop/with meta pack [3 4]]
 == 3

 &gt;&gt; a
 == 3

 &gt;&gt; b
 == 4
</code></pre>
<p>Every time I see this, I do kind of wish up and down arrows were on our keyboards:</p>
<pre><code>  [a b]: ↓ cycle [stop/with ↑ pack [3 4]]
</code></pre>
<p>Caret-Meta only gets you half of this:</p>
<pre><code> [a b]: unmeta cycle [stop/with ^ pack [3 4]]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/unstable-isotope-conundrums/2033">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/unstable-isotope-conundrums/2033</link>
          <pubDate>Thu, 22 Jun 2023 17:09:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2033</guid>
          <source url="https://forum.rebol.info/t/unstable-isotope-conundrums/2033.rss">Unstable Isotope Conundrums</source>
        </item>
        <item>
          <title>Is there anything like parse in other languages?</title>
          <dc:creator><![CDATA[johnk]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I have been away for a while and I am missing parse. I was wondering if you know of any similar parsers in other languages like Python or R?</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/is-there-anything-like-parse-in-other-languages/2032">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/is-there-anything-like-parse-in-other-languages/2032</link>
          <pubDate>Thu, 25 May 2023 09:17:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2032</guid>
          <source url="https://forum.rebol.info/t/is-there-anything-like-parse-in-other-languages/2032.rss">Is there anything like parse in other languages?</source>
        </item>
        <item>
          <title>&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</title>
          <dc:creator><![CDATA[vnzio]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p><a href="https://factorcode.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://factorcode.org/</a></p>
<aside class="onebox wikipedia" data-onebox-src="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1">
  <header class="source">

      <a href="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">en.wikipedia.org</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:200/124;"><img src="//upload.wikimedia.org/wikipedia/en/thumb/f/ff/NewFactorLogo.png/200px-NewFactorLogo.png" class="thumbnail" width="200" height="124"></div>

<h3><a href="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">Factor (programming language)</a></h3>

<p>Factor is a stack-oriented programming language created by Slava Pestov. Factor is dynamically typed and has automatic memory management, as well as powerful metaprogramming features. The language has a single implementation featuring a self-hosted optimizing compiler and an interactive development environment. The Factor distribution includes a large standard library.
 Slava Pestov created Factor in 2003 as a scripting language for a video game. The initial implementation, now referred to as JFa...</p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Google Tech Talk 2008</p><p><a href="https://www.youtube.com/watch?v=f_0QlhYlS8g">Factor: an extensible interactive language</a></p>

<p>Silicon Valley Forth Interest Group<br>
2022<br>
"Factor in 2022"</p><p><a href="https://www.youtube.com/watch?v=OLh61q4c4XE">2022-03-26 --- Factor in 2022 --- John Benediktsson &amp; Doug Coleman</a></p>

            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029</link>
          <pubDate>Mon, 17 Apr 2023 23:10:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2029</guid>
          <source url="https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029.rss">&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</source>
        </item>
        <item>
          <title>Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</title>
          <dc:creator><![CDATA[vnzio]]></dc:creator>
          <category>Offtopic</category>
          <description><![CDATA[
            <p>Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</p>
<p>???</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028</link>
          <pubDate>Mon, 17 Apr 2023 22:47:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2028</guid>
          <source url="https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028.rss">Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</source>
        </item>
        <item>
          <title>Should ANY-VALUE! Include Isotopes?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So if you don't put any type restrictions on a parameter, it will allow isotopes:</p>
<pre><code> &gt;&gt; foo: func [x] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p>And right now, that is a synonym for ANY-VALUE!.</p>
<pre><code> &gt;&gt; foo: func [x [any-value!]] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p><strong>But what if you want to exclude isotopes?</strong>  We could have a name for the typeset excluding isotopes (perhaps ANY-CELL!).  Or we could say that ANY-VALUE! doesn't include isotopes by default, and so you have to write <strong>[any-value! isotope!]</strong> if you want them... or just include the specific ones you intend (like <strong>[null! any-value!]</strong>.</p>
<p>Right now I'm going the route of saying ANY-CELL! is the narrower set of values that do not include isotopes.  Is there a better term for saying something can be put into an array vs. not?</p>
<p><em>"10 is an integer! which is legal to use as a cell, while ~null~ isotopes are not legal as cells, but can be variable values"</em></p>
<p>It seems shorter and cleaner than ANY-REIFIED!  or something like that.  I don't know any better options.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-any-value-include-isotopes/2026">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-any-value-include-isotopes/2026</link>
          <pubDate>Fri, 14 Apr 2023 21:37:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2026</guid>
          <source url="https://forum.rebol.info/t/should-any-value-include-isotopes/2026.rss">Should ANY-VALUE! Include Isotopes?</source>
        </item>
        <item>
          <title>TRY... *again* :roll_eyes:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I have proposed a concept for TRY as trapping definitional errors and turning them into nulls, like this:</p>
<pre><code>&gt;&gt; take []
** Error: you can't take from an empty block (stopping further code)

&gt;&gt; try take []
== ~null~  ; isotope
</code></pre>
<p>And I'll just give a reminder that as this is trapping <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">definitional errors</a>.  So failures from deeper inside code would not be caught... only errors that are returned by contract from the function being called.</p>
<pre><code>&gt;&gt; try compose [(1 / 0)]
** Error: division by zero (e.g. COMPOSE itself didn't raise the error)
</code></pre>
<p><em>I'll remind everyone that it's a very slippery slope to trap "deep errors", and this is why the deep error trapping concept is <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871/3">hidden away as <code>sys.util.rescue</code></a>)</em></p>
<h2>Why Return NULL From TRY (vs. void) ?</h2>
<p>The decision to return null is to make the result falsey so it can be acted on:</p>
<pre><code>while [item: try take block] [
    ...
]

all [
    try take block  ; if this fails we don't want to keep going
    ...
]
</code></pre>
<p>In the vernacular I use, I call NULL "soft failure".  So TRY "converts a definitional failure into soft failure", passing through all other results as-is.</p>
<h2>Comparison with similar word MAYBE</h2>
<p>The MAYBE operation was defined as something that converts nulls to voids, and passes through everything else.  If you didn't know that, it's easy to see not intuiting what the difference between <strong>try take block</strong> and <strong>maybe take block</strong> would be.</p>
<p>You can get some odd-looking combinations with this, e.g.</p>
<pre><code> &gt;&gt; block1: [a b c]
 &gt;&gt; block2: []

 &gt;&gt; append block1 maybe try take block2
 == [a b c]
</code></pre>
<p>Which makes one wonder if MAYBE could be used to trap definitional errors as well as nulls and turn them into voids, so you could just write <strong>append block1 maybe take block2</strong>.</p>
<p>So it raises the question: are there null-returning operations that also return definitional errors, where one would want to suppress the null but not the error?  There's not enough experience for me to say yet.</p>
<h2>Usage in PARSE as opposed to OPT?</h2>
<p>I've wondered if TRY and MAYBE could have parallel meanings in PARSE, where you use TRY to continue but get NULL and MAYBE to skip things:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" maybe some "b"]
== "a"

&gt;&gt; parse "aaa" [some "a" var: try some "b"]
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; var
== ~null~  ; isotope
</code></pre>
<p>Seeing the two operations as being very similar--only one voids while the other one nulls--feels interesting.  I just hadn't thought of MAYBE as a definitional-error-suppressor before.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/try-again/2025">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/try-again/2025</link>
          <pubDate>Fri, 14 Apr 2023 21:22:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2025</guid>
          <source url="https://forum.rebol.info/t/try-again/2025.rss">TRY... *again* :roll_eyes:</source>
        </item>
        <item>
          <title>The Handling of NULL and VOID in UPARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>By design, nulls are handled noisily--right at the moment of fetching the word!--in UPARSE (and PARSE3):</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [prefix, some "a", suffix]
** Error: (prefix is null, and we raise errors for that in parse)
</code></pre>
<p>If we didn't raise an error it seems there are only two other options:</p>
<ol>
<li>
<p>Make <strong><code>null</code></strong> always succeed, keeping the parse position where it is (synonym for <strong><code>[]</code></strong>)</p>
</li>
<li>
<p>Make <strong><code>null</code></strong> always be an unsuccessful combinator match, but not cause a failure (synonym for <strong><code>false</code></strong>)</p>
</li>
</ol>
<p>I think (1) feels like a pretty obvious bad idea, because null is supposed to represent a soft failure.  I've suggested that this is a better behavior for void, e.g. <strong><code>parse "ab" ["a" void "b"]</code></strong> would work.</p>
<p>I'm not too pleased with the idea of (2), and prefer the error as the default.</p>
<p><em>...that said...</em> it seems there should be some operators or combinators that let you get the other behaviors.</p>
<h2>
<a name="what-about-a-maybe-combinator-to-use-with-null-1" class="anchor" href="https://forum.rebol.info#what-about-a-maybe-combinator-to-use-with-null-1"></a>What About a "MAYBE" Combinator To Use With Null?</h2>
<p>In standard code, the policy of "void-in-null-out" has worked well, with MAYBE transforming soft-failure nulls to voids:</p>
<pre><code> ; non-PARSE handling of NULL via MAYBE

 &gt;&gt; append [a b c] null
 ** Error: cannot append ~null~ isotope to a block

 &gt;&gt; append [a b c] maybe null
 == [a b c]

 &gt;&gt; block: null

 &gt;&gt; append maybe block [d e]
 == ~null~  ; isotope
</code></pre>
<p>So if we imagine applying this to the parse example, it would presumably do this:</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [maybe prefix, some "a", maybe suffix]
== ")"
</code></pre>
<p>For the above parse to succeed, the combinator made by <strong>maybe prefix</strong> would have to succeed and not advance the input.</p>
<h2>
<a name="but-it-doesnt-combine-well-in-larger-rules-2" class="anchor" href="https://forum.rebol.info#but-it-doesnt-combine-well-in-larger-rules-2"></a>But It Doesn't Combine Well In Larger Rules</h2>
<p>What if what you intended was <em>"if there's a prefix, match some non-zero number of instances, but if prefix is null then don't worry about matching"</em>:</p>
<p>You might try doing that by COMPOSE'ing your rules.  But UPARSE actually lets us write that out literally using GET-GROUP! rule synthesis:</p>
<pre><code>&gt;&gt; parse "aaa)))" [:(if prefix '[some prefix]), some "a", :(if suffix '[some suffix])]
== ")"
</code></pre>
<p>But what if we tried to do that with MAYBE...could it work?</p>
<pre><code>&gt;&gt; parse "aaa)))" [some maybe prefix, some "a", some maybe suffix]
; infinite loop!
</code></pre>
<p>No dice.  We've said <strong>maybe prefix</strong> just succeeds and doesn't advance the input when prefix was null.  But if you combine that with <code>some</code> the null case will just match nothing in perpetuity, causing an infinite loop.</p>
<p>This may look familiar, because if you write <strong>some opt [...anything...]</strong> you'll always get an infinite loop.  But in that case it's just wrong thinking: you know that the repetitive nature of <code>some</code> looking for an eventual non-match meant you must have intended <strong>some [...anything...]</strong> (at least one) or <strong>opt some [...anything...]</strong> (zero or more).</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<blockquote>
<h3>NOTE THAT HISTORICAL PARSE HAS NO GOOD ANSWER FOR THIS</h3>
<p>Rebol2 treats NONE! as a no-op which just succeeds but doesn't advance the input.  So the following gives you an infinite loop:</p>
<pre><code>rebol2&gt;&gt; prefix: none suffix: ")"

rebol2&gt;&gt; parse "aaa)))" [some prefix some "a" some suffix]   
; infinite loop
</code></pre>
<p>The hackish "must make progress" rules in R3-Alpha actually make the above "work as intended", because the SOME will bail out after one non-advancing match.  I don't consider that a "good" answer--more a random effect.</p>
</blockquote>
<h2>
<a name="another-problem-maybe-is-a-very-similar-word-to-opt-3" class="anchor" href="https://forum.rebol.info#another-problem-maybe-is-a-very-similar-word-to-opt-3"></a>Another Problem: MAYBE is a very similar word to OPT</h2>
<p>Imagine looking at this code:</p>
<pre><code>&gt;&gt; prefix: "(", suffix: ")"

&gt;&gt; parse "aaa)" [maybe prefix, some "a", maybe suffix]
== ~null~  ; isotope
</code></pre>
<p><em>"But wait"</em>... I can imagine someone saying... <em>"doesn't that mean that if it's not there, you skip the rule"</em>?</p>
<blockquote>
<p>I've had some mental back-and-forth about the words <strong><code>try</code></strong>, <strong><code>opt</code></strong>, and <strong><code>maybe</code></strong>...with a general dislike of the word OPT.  The current idea is that TRY was intended to defuse harder definitional errors:</p>
<pre><code>&gt;&gt; take []
** Error: you can't take from an empty block (stopping further code)

&gt;&gt; try take []
== ~null~  ; isotope
</code></pre>
</blockquote>
<h2>
<a name="an-extra-barrier-to-creating-maybe-is-mechanical-4" class="anchor" href="https://forum.rebol.info#an-extra-barrier-to-creating-maybe-is-mechanical-4"></a>An extra barrier to creating MAYBE is mechanical</h2>
<p>... <em>because the error that NULL generates is the "null combinator" itself</em>.  It is <em>not</em> a definitional error, because those just represent things like "type didn't match".</p>
<p>The only way I can see a null-disabling MAYBE parse combinator working would be by quoting its argument, doing the rule fetch itself, and turning into a failing combinator if it fetched null.  This breaks the model somewhat.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="maybe-prefix-could-mean-optionally-null-variable-5" class="anchor" href="https://forum.rebol.info#maybe-prefix-could-mean-optionally-null-variable-5"></a>Maybe <strong>/prefix</strong> could Mean Optionally-Null variable?</h2>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [/prefix, some "a", /suffix]
== ")"
</code></pre>
<p>It's already the case that paths have to be quoted to match in blocks, but a leading slash could be used to deal with the rules.</p>
<p>It's a lot to think about on my first day of thinking about Rebol stuff for a while!  But there you go.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-handling-of-null-and-void-in-uparse/2023">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-handling-of-null-and-void-in-uparse/2023</link>
          <pubDate>Fri, 07 Apr 2023 00:14:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2023</guid>
          <source url="https://forum.rebol.info/t/the-handling-of-null-and-void-in-uparse/2023.rss">The Handling of NULL and VOID in UPARSE</source>
        </item>
        <item>
          <title>Correct Formulation of ME and MY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>The ME function is used with enfix to allow you to avoid repeating the name of a variable:</p>
<pre><code>&gt;&gt; variable: 10

&gt;&gt; variable: me + 1
== 11

&gt;&gt; variable
== 11
</code></pre>
<p>So that's the same as if you'd written <strong>variable: variable + 1</strong>.</p>
<p>There's an analogous operation for non-enfix functions called MY.</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; block: my next
== [b c]

&gt;&gt; block
== [b c]
</code></pre>
<p>So the same if you had written <strong>block: next block</strong>.</p>
<h2>Here Is The "Naive" Macro Implementation of ME</h2>
<pre><code>me: enfixed macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
][
    reduce [left, plain left, right]
]
</code></pre>
<p>So the macro is looking for a SET-WORD! or SET-TUPLE! on the left, and then something indicating the action to run on the right.  It replaces the whole sequence with what was on the left, then a plain WORD! or TUPLE! version of what was on the left, and then what's on the right.</p>
<p>MY is done similarly, just with <strong>reduce [left, right, plain left]</strong> to put the repeated term after the call.</p>
<p>This is naive for two reasons:</p>
<ul>
<li>
<p>It doesn't check that what the RIGHT parameter looks up to is an action</p>
</li>
<li>
<p>If the SET-TUPLE! in LEFT has a GROUP! in it, then it will be executed twice.</p>
</li>
</ul>
<h2>Here is A "Non-Naive" Implementation of ME</h2>
<pre><code>macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
    &lt;local&gt; value
][
    [left value]: resolve left  ; avoid double-evaluation
    :['set left meta value ensure action! get right]
]
</code></pre>
<p>The RESOLVE function is used to turn a TUPLE! or PATH! with groups in it into an inert representation:</p>
<pre><code> &gt;&gt; blk: [a b [c d]]

 &gt;&gt; resolve 'blk.(print "hi", 1 + 2).2
 hi
 == @[blk 3 2]
</code></pre>
<p>GET and SET accept these blocks as an alternative to words/tuples to be used to describe what to set or get.</p>
<p>It has to use a BLOCK! representation because not all things can be represented in paths that can be used with picking (note this implies you cannot pick with isotopes, otherwise not all blocks would be resolvable).</p>
<p>So long as RESOLVE is walking the path, you can ask it to give you back the value of what's there.</p>
<h2>But the non-naive version triggers a binding bug...</h2>
<p>It's also rather slow.  In trying to prioritize, it may be better to just document the right answer, as I've done here... :-/</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020</link>
          <pubDate>Fri, 03 Mar 2023 21:23:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2020</guid>
          <source url="https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020.rss">Correct Formulation of ME and MY</source>
        </item>
        <item>
          <title>Pikchr Drawing Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>This is an interesting dialect-looking thing that's a Unix utility someone showed me for diagrams.  It might interest <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>, or others.  It's called PIKCHR.</p>
<p>You can try it online at <a href="https://pikchr.org/home/pikchrshow">https://pikchr.org/home/pikchrshow</a> ... there are a few examples.</p>
<p>It's a textual set of instructions that lets you lay things out... but differently from something like PDF, it captures intents in a pretty interesting way for aligments and duplication.</p>
<p>Look how it lays out this "swim lanes" example graphic:</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/babd46454d69ba774a09050d20d26dc3e2e9e326.png" alt="image" data-base62-sha1="qDYklKuijn94kAkO07RmNG9E6YS" width="520" height="449"></p>
<pre><code>$laneh = 0.75
# Draw the lanes
down
box width 3.5in height $laneh fill 0xacc9e3
box same fill 0xc5d8ef
box same as first box
box same as 2nd box
line from 1st box.sw+(0.2,0) up until even with 1st box.n "Alan" above aligned
line from 2nd box.sw+(0.2,0) up until even with 2nd box.n "Betty" above aligned
line from 3rd box.sw+(0.2,0) up until even with 3rd box.n "Charlie" above aligned
line from 4th box.sw+(0.2,0) up until even with 4th box.n "Darlene" above aligned
# fill in content for the Alice lane
right
A1: circle rad 0.1in at end of first line + (0.2,-0.2) fill white thickness 1.5px "1"
arrow right 50%
circle same "2"
arrow right until even with first box.e - (0.65,0.0)
ellipse "future" fit fill white height 0.2 width 0.5 thickness 1.5px
A3: circle same at A1+(0.8,-0.3) "3" fill 0xc0c0c0
arrow from A1 to last circle chop "fork!" below aligned
# content for the Betty lane
B1: circle same as A1 at A1-(0,$laneh) "1"
arrow right 50%
circle same "2"
arrow right until even with first ellipse.w
ellipse same "future"
B3: circle same at A3-(0,$laneh) "3"
arrow right 50%
circle same as A3 "4"
arrow from B1 to 2nd last circle chop
# content for the Charlie lane
C1: circle same as A1 at B1-(0,$laneh) "1"
arrow 50%
circle same "2"
arrow right 0.8in "goes" "offline"
C5: circle same as A3 "5"
arrow right until even with first ellipse.w "back online" above "pushes 5" below "pulls 3 &amp; 4" below
ellipse same "future"
# content for the Darlene lane
D1: circle same as A1 at C1-(0,$laneh) "1"
arrow 50%
circle same "2"
arrow right until even with C5.w
circle same "5"
arrow 50%
circle same as A3 "6"
arrow right until even with first ellipse.w
ellipse same "future"
D3: circle same as B3 at B3-(0,2*$laneh) "3"
arrow 50%
circle same "4"
arrow from D1 to D3 chop</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pikchr-drawing-dialect/2018">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pikchr-drawing-dialect/2018</link>
          <pubDate>Tue, 28 Feb 2023 22:17:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2018</guid>
          <source url="https://forum.rebol.info/t/pikchr-drawing-dialect/2018.rss">Pikchr Drawing Dialect</source>
        </item>
        <item>
          <title>Compiling ren-c with zig?</title>
          <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Has anyone tried to compile ren-c with zig? ( <a href="https://www.ziglang.org">https://www.ziglang.org</a> ).</p>
<p>They claim to be able to compile c-code using zig cc , and have an impressive list of cross compilation targets, wasm among them.</p>
<p><a href="https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler">https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler</a></p>
<p><a href="https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case">https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case</a></p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/compiling-ren-c-with-zig/2017">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/compiling-ren-c-with-zig/2017</link>
          <pubDate>Wed, 22 Feb 2023 21:31:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2017</guid>
          <source url="https://forum.rebol.info/t/compiling-ren-c-with-zig/2017.rss">Compiling ren-c with zig?</source>
        </item>
        <item>
          <title>Kaitai Struct Declarative Language for Binary Formats</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>This is an interesting declarative language in YAML designed to generate classes for binary formats.  There are many formats defined:</p>
<p><a href="https://formats.kaitai.io/">https://formats.kaitai.io/</a></p>
<p>That's a lot of cases...but as one instructive example, you can look at how it describes a ZIP file--with little snippets of code in it for extracting the values:</p>
<p><a href="https://formats.kaitai.io/zip/" class="inline-onebox">ZIP archive file format spec for Kaitai Struct</a></p>
<p>The C++ code generated is like this:</p>
<p><a href="https://formats.kaitai.io/zip/cpp_stl_11.html" class="inline-onebox">ZIP archive file: C++11/STL parsing library</a></p>
<p>But it also can also be used to make code for C#, JavaScript, Python, Ruby, Nim, PHP, Lua, Perl... <em>(though we'd assume that if you escape code in, that part will only work be available for that language)</em></p>
<p>The regimentation of YAML provides the typical repetition in the "dialect".  This is the same as the Rebol complaint about JSON--not really leveraging "parts of speech", but repeating tags over and over like <code>id:</code> and <code>type:</code></p>
<pre><code>  - id: version
    type: u2
  - id: flags
    type: gp_flags
    size: 2
  - id: compression_method
    type: u2
    enum: compression
</code></pre>
<p>But it's still pretty hard to compete with, especially when you consider this is giving a compilable specification...so the performance is going to be much better.</p>
<p>I always thought BINARY! parse was something that Rebol would have a unique story for, and Ren-C's UPARSE makes that a stronger story (by allowing rules to synthesize arbitrary results via extraction)... but seeing this kind of stuff reminds me that there are diminishing returns.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/kaitai-struct-declarative-language-for-binary-formats/2016">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/kaitai-struct-declarative-language-for-binary-formats/2016</link>
          <pubDate>Tue, 21 Feb 2023 22:36:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2016</guid>
          <source url="https://forum.rebol.info/t/kaitai-struct-declarative-language-for-binary-formats/2016.rss">Kaitai Struct Declarative Language for Binary Formats</source>
        </item>
        <item>
          <title>Should SET-WORD!s Have &quot;Raised Error Interception&quot;?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>Division by zero is a simple example of something that produces a "definitional error".  <em>It's considered to be "emitted" by the division</em>, and if you try to "move on" without handling it, the raised error becomes a failure that <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871">you can only catch at some top level by SYS.UTIL.RESCUE</a>.</p>
<p>For instance:</p>
<pre><code>&gt;&gt; 1 / 0, 2 + 0
** Math Error: attempt to divide by zero
** Where: / console
** Near: [1 / 0 **, 2 + ***]
</code></pre>
<p>What happened was that <strong>1 / 0</strong> evaluated, but rather than forcing a "hard failure" (e.g. running FAIL) it instead <em>returned a raised error</em>.  There's an opportunity if that raised error were to be intercepted, but in this case it just moseyed along to the next expression... so the raised error was promoted to a failure.</p>
<p>However a ^META oriented function can trap that, and react to it, allowing you to continue.  EXCEPT is such a function:</p>
<pre><code>&gt;&gt; 1 / 0 except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p>One thing that pretty obviously shouldn't count as "moving on" would be parentheses.  Adding parentheses shouldn't change the situation, they just pass any raised errors through:</p>
<pre><code>&gt;&gt; (1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2

&gt;&gt; ((((1 / 0)))) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p><strong>But what about things like SET-WORD!s?</strong>  Right now, it does not raise an error and just skips the assignment, and lets the code continue:</p>
<pre><code>&gt;&gt; num: &lt;before&gt;

&gt;&gt; (num: 1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2

&gt;&gt; num
== &lt;before&gt;
</code></pre>
<p><strong>This is a useful pattern, but if we do it for SET-WORD!s then we have to ask whether it should be done for SET the function as well...</strong></p>
<pre><code>&gt;&gt; (set 'num 1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p>If we do this then the SET function has to take its argument of the value to assign as a ^META argument.  Because raised errors can't be stored in variables, and function parameters are communicated via variables.</p>
<p>This does make SET a more complicated function, and any functions like it might also become complicated.  It's a hard decision to condemn all SET-like functions to take their arguments as ^META so they can proxy any errors and not perform the assignment.</p>
<p>I'll probably have more to say about this, but for the moment both SET and SET-WORD! react to definitional failures by <em>not performing the assignment</em> and <em>propagating the raised error</em>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-s-have-raised-error-interception/2015">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-s-have-raised-error-interception/2015</link>
          <pubDate>Tue, 07 Feb 2023 02:52:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2015</guid>
          <source url="https://forum.rebol.info/t/should-set-word-s-have-raised-error-interception/2015.rss">Should SET-WORD!s Have &quot;Raised Error Interception&quot;?</source>
        </item>
        <item>
          <title>Difficult Decision: Not Renewing (unlaunched!) Domain Names</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Community</category>
          <description><![CDATA[
            <p>A couple of years ago--at <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>'s urging--I had reserved a <code>.com</code>, <code>.org</code>, and <code>.net</code> for launching Ren-C to the public.</p>
<p>But in the intervening years, I put nothing on these domains.  They've been vacant lots, doing little but transferring money from me to the "Namecheap" registrar.  <img src="https://forum.rebol.info/images/emoji/twitter/angry.png?v=9" title=":angry:" class="emoji" alt=":angry:"></p>
<p>Feb 3rd was this year's renewal date, and I disabled auto-renew, and didn't pay.</p>
<h2>If I "Owned" Them, Why Didn't I Use Them?</h2>
<p>I put "owned" in quotes because you don't own domain names, you just rent them.</p>
<p>There are good reasons for not wanting to impart value to these domains prematurely--e.g. not even transferring the forum there.  My worries were:</p>
<ol>
<li>
<p>You don't get a second chance to announce a project.</p>
<ul>
<li>If you need a case study, Red has certainly worn out their welcome on hackernews.</li>
</ul>
</li>
<li>
<p>Once you start using a domain, the content becomes an issue of identity.</p>
<ul>
<li>
<p>You have imparted a value to URLs which is easily stolen by spammers.</p>
</li>
<li>
<p>You become obligated to pay recurring charges to protect your material and identity.</p>
</li>
</ul>
</li>
</ol>
<h2>Why I'm Not Renewing Them, Despite Believing in Ren-C...</h2>
<p><strong>While Ren-C is in my eyes, successful in many areas... given the (long!) timescale we are looking at... I don't think it is necessary to pay for specialized domain names for the project.</strong></p>
<p>The DNS system itself may be obsolete--and AI may be writing all the code--before I get around to finishing this myself. <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:">  Though perhaps I have helped set the goalposts.</p>
<p>I'm basically saying that I'm okay coupling the Ren-C work to the domain names I already have established, or their subdomains, rather than making a separate entity that others would manage.  Those identities (like hostilefork or metaeducation) are a sunk cost, and I can just use those.</p>
<h2>I Put Up Money For A Couple Of Years, Is Not Doing So "Giving Up"?</h2>
<p>Not really.  This is just an epicycle of my firm belief that DNS is not to be trusted any further than you can throw it.  It says more about how I feel about the domain name ecosystem than it says about how I feel about Ren-C.</p>
<p>...and if I hadn't mentioned it, you wouldn't have noticed any difference at all.  Things would seem the same.</p>
<p><em>But in my mind with the huge new design space opening up with isotopes,</em> I will admit that I'm moving closer to the idea that the final product of Ren-C is just more like "demos and papers and code golf gaming".  Not "download the solution to all your problems here".</p>
<p>After all, there are worse things than being the <a href="https://en.wikipedia.org/wiki/Antikythera_mechanism">Antikythera mechanism</a>.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>So I'm not quitting, but I certainly am trying to do a lot more other things in my life these days.  I'll keep hacking on it as time permits, and hopefully we won't be taking too many steps backwards... and the WebAssembly stuff will remain the user-facing focus.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/difficult-decision-not-renewing-unlaunched-domain-names/2014">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/difficult-decision-not-renewing-unlaunched-domain-names/2014</link>
          <pubDate>Sat, 04 Feb 2023 17:56:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2014</guid>
          <source url="https://forum.rebol.info/t/difficult-decision-not-renewing-unlaunched-domain-names/2014.rss">Difficult Decision: Not Renewing (unlaunched!) Domain Names</source>
        </item>
        <item>
          <title>Future of the MATH Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>It is basically inevitable that people coming to Rebol will ask about its mathematical evaluation being left-to-right, instead of obeying the precedence order that they are used to.  Red just had a new user try to file it as a bug... 3 days ago:</p>
<p><a href="https://github.com/red/red/issues/5276">https://github.com/red/red/issues/5276</a></p>
<p><strong>What seemed to make sense to people like me and BrianH was that the core ship with a dialect called MATH.</strong>  The concept was that <strong>math [1 + 2 * 3]</strong> would give <strong>7</strong> and not <strong>9</strong>.  Having something in the box seemed better than having the first line of argument being <em>"you don't want the precedence you think you do"</em>.</p>
<p>But it turned out to be kind of hard to make pleasing.  One key difficulty which <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a> and I fretted over at some point was that since Rebol isn't "psychic" regarding arity, does not know a-priori how much code an expression will consume:</p>
<pre><code>math [1 + 2 * foo baz bar + 3]

; should it be...
[1 + (2 * (foo baz bar)) + 3]

; or perhaps...
[(1 + (2 * foo)) ((baz bar) + 3)]

; maybe...
[(1 + (2 * foo)) baz (bar + 3)]
</code></pre>
<p><strong>It started to appear that the user would have to put anything that wasn't a number or a math operator in groups.</strong>  There may be some heuristics which tolerate words that look up to numbers vs. functions, but it feels very slippery.</p>
<p>As I've said I hate to be dropping things, but MATH is something that Rebol programmers don't really want in the first place--and I don't think non-Rebol programmers would be satisfied by it.  If it's included in the core that suggests support for it, and there are just too many things in play.</p>
<p>Here is an implementation that was previously included, by Gabriele:</p>
<pre><code>; This MATH implementation is from Gabrielle Santilli circa 2001, found
; via http://www.rebol.org/ml-display-thread.r?m=rmlXJHS. It implements the
; much-requested (by new users) idea of * and / running before + and - in
; math expressions. Expanded to include functions.
;
math: func [
    {Process expression taking "usual" operator precedence into account.}

    expr [block!]
        {Block to evaluate}
    /only
        {Translate operators to their prefix calls, but don't execute}

    ; !!! This creation of static rules helps avoid creating those rules
    ; every time, but has the problem that the references to what should
    ; be locals are bound to statics as well (e.g. everything below which
    ; is assigned with BLANK! really should be relatively bound to the
    ; function, so that it will refer to the specific call.)  It's not
    ; technically obvious how to do that, not the least of the problem is
    ; that statics are currently a usermode feature...and injecting relative
    ; binding information into something that's not the function body itself
    ; isn't implemented.

    &lt;static&gt;

    slash (the /)

    expr-val (_)

    expr-op (_)

    expression  ([
        term (expr-val: term-val)
        opt some [
            ['+ (expr-op: 'add) | '- (expr-op: 'subtract)]
            term (expr-val: compose [(expr-op) (expr-val) (term-val)])
        ]
        &lt;end&gt;
    ])

    term-val (_)

    term-op (_)

    term ([
        pow (term-val: power-val)
        opt some [
            ['* (term-op: 'multiply) | slash (term-op: 'divide)]
            pow (term-val: compose [(term-op) (term-val) (power-val)])
        ]
    ])

    power-val (_)

    pow ([
        unary (power-val: unary-val)
        opt ['** unary (power-val: compose [power (power-val) (unary-val)])]
    ])

    unary-val (_)

    pre-uop (_)

    post-uop (_)

    unary ([
        (post-uop: pre-uop: [])
        opt ['- (pre-uop: 'negate)]
        primary
        opt ['! (post-uop: 'factorial)]
        (unary-val: compose [(post-uop) (pre-uop) (prim-val)])
    ])

    prim-val (_)

    primary ([
        set prim-val any-number!
        | set prim-val [word! | path!] (prim-val: reduce [prim-val])
            ; might be a funtion call, looking for arguments
            opt some [
                nested-expression (append prim-val take nested-expr-val)
            ]
        | ahead group! into nested-expression (prim-val: take nested-expr-val)
    ])

    p-recursion (_)

    nested-expr-val ([])

    save-vars (func [][
            p-recursion: reduce [
                :p-recursion :expr-val :expr-op :term-val :term-op :power-val :unary-val
                :pre-uop :post-uop :prim-val
            ]
        ])

    restore-vars (func [][
            set [
                p-recursion expr-val expr-op term-val term-op power-val unary-val
                pre-uop post-uop prim-val
            ] p-recursion
        ])

    nested-expression ([
            ;all of the static variables have to be saved
            (save-vars)
            expression
            (
                ; This rule can be recursively called as well,
                ; so result has to be passed via a stack
                insert nested-expr-val expr-val
                restore-vars
            )
            ; vars could be changed even it failed, so restore them and fail
            | (restore-vars) fail

    ])
][
    clear nested-expr-val
    let res: either parse3 expr expression [expr-val] [blank]

    either only [
        return res
    ][
        ret: reduce res
        all [
            1 = length of ret
            any-number? ret.1
        ] else [
            fail [
                unspaced ["Cannot be REDUCED to a number (" mold ret ")"]
                ":" mold res
            ]
        ]
        return ret.1
    ]
]</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/future-of-the-math-dialect/2013">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/future-of-the-math-dialect/2013</link>
          <pubDate>Tue, 31 Jan 2023 19:08:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2013</guid>
          <source url="https://forum.rebol.info/t/future-of-the-math-dialect/2013.rss">Future of the MATH Dialect</source>
        </item>
        <item>
          <title>Should Quasiform Parameters Accept as the Plain Form?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p><strong><a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">I'm very confident of the goodness of "isotopic actions"</a></strong>.</p>
<p>Not being able to put them in blocks gives us the <a href="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244/9">nice, mechanical invariant</a> of being able to manipulate blocks without inadvertently running functions in the process.  It opens the doors to other guardrails against isotopes being in variables when it might surprise you.</p>
<p>But what happens when you write something like SPECIALIZE, with a spec that looks something like:</p>
<pre><code>//
//  specialize: native [
//
//  {Create a new action through partial or full specialization of another}
//
//      return: [~action!~]  ; ~ notation since an isotopic action is returned
//      action "Function whose parameters will be set to fixed values"
//          [action!]
//      def "Definition for FRAME! fields for args and refinements"
//          [block!]
//  ]
//
</code></pre>
<p>Should SPECIALIZE tolerate being passed an isotopic action, maybe with a spec that looks like:</p>
<pre><code>return: [~action!~]
action "Function whose parameters will be set to fixed values"
    [action! ~action!~]
def "Definition for FRAME! fields for args and refinements"
    [block!]
</code></pre>
<p>This would lead to complexity inside most function, because now if it references the <strong>action</strong> variable it might run.  And this lack of automatic canonization to the inert form creates hassles for both usermode and native code alike.</p>
<p>Another thing is that the meaning of isotopic actions is potentially <em>very</em> different from that of a plain action.  For instance: <strong><code>find block :even?</code></strong> might know that since blocks cannot contain isotopes, it should interpret it as a function to call to test the items in the block for evenness.</p>
<p>So this led me to a bit of a thought...</p>
<h2>What if QUASI!-forms typechecked as the plain form?</h2>
<p>The idea is that there's an initial type check done.  If that check fails and it's a quasiform, it is tested again as its plain form.  If that passes, the plain form is received.</p>
<p>Producing a quasiform of an action from an isotope is easy, just use a meta operation.  So <strong><code>^append</code></strong> instead of <strong><code>:append</code></strong>.  All meta forms are inert, so code using the meta is less likely to do wild things.</p>
<p><em>To me, this feels like a safer exception than letting isotopes pass for plain forms.</em>  Due to their alien-ness, an isotopic form could intend something quite far from a mechanical brick in a block.  But what a quasiform has in common with a plain form is that both are inert.</p>
<p>Also, even the name "quasi" suggests a possibly loose relationship.  It carries the same payload as the plain form.  What if this were legal:</p>
<pre><code>&gt;&gt; add first [~1~] first [~2~]
== 3
</code></pre>
<p>I'm suggesting a general-enough mechanism that would work... so long as ADD didn't widen its net to taking actual ANY-VALUE! (which would indicate it had an actual meaning that applied to quasiforms).</p>
<p>This may not be the most brilliant thought to ever be thunk.  But in this more complex world there need to be succinct answers.  We don't want to have to write things like <strong><code>apply concretize :append [...]</code></strong>, and I feel like glossing over the fact that something is an isotope is a worse move than glossing over that something is a quasiform.</p>
<p>I even may like <strong><code>apply ^append [...]</code></strong> a bit more than <strong><code>apply :append [...]</code></strong> for looks, too.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012</link>
          <pubDate>Thu, 26 Jan 2023 18:42:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2012</guid>
          <source url="https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012.rss">Should Quasiform Parameters Accept as the Plain Form?</source>
        </item>
        <item>
          <title>Axing --breakpoint switch, C-DEBUG-BREAK-AT</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p><strong>I'm killing off features for whom their maintenance is not paying off.</strong></p>
<p>One is the "tick" based usermode <code>--breakpoint</code> feature, implemented on the command line as:</p>
<pre><code>        "--breakpoint" end (
            c-debug-break-at to-integer param-or-die "BREAKPOINT"
        )
</code></pre>
<p>The complex problem of taking a "tick" count to break on via a command line switch is that since command line processing is in usermode, you have a kind of observer-affects-the-experiment situation.  The code for adding in the breakpoint messes with the tick count you're trying to reproduce.</p>
<p>I had ideas to work around this.  So there's the /COMPENSATE feature of C-DEBUG-BREAK, which I don't even know if it works or if my idea is fundamentally flawed:</p>
<pre><code>; Taking a command-line `--breakpoint NNN` parameter is helpful if a
; problem is reproducible, and you have a tick count in hand from a
; panic(), REBSER.tick, Frame.tick, REBVAL.extra.tick, etc.  But there's
; an entanglement issue, as any otherwise-deterministic tick from a prior
; run would be thrown off by the **ticks added by the userspace parameter
; processing of the command-line for `--breakpoint`**!  :-/
;
; The /COMPENSATE option addresses this problem.  Pass it a reasonable
; upper bound for how many ticks you think could have been added to the
; parse, if `--breakpoint` was processed (even though it might not have
; been processed).  Regardless of whether the switch was present or not,
; the tick count rounds up to a reproducible value, using this method:
;
; https://math.stackexchange.com/q/2521219/
;
; At time of writing, 1000 ticks should be *way* more than enough for both
; the PARSE steps and the evaluation steps `--breakpoint` adds.  Yet some
; things could affect this, e.g. a complex userspace TRACE which was
; run during boot.
;
attempt [c-debug-break-at/compensate 1000]  ; fails in release build
</code></pre>
<p>Here was more of it:</p>
<pre><code>  #if !defined(NDEBUG) &amp;&amp; DEBUG_COUNT_TICKS
    if (REF(compensate)) {
        //
        // Imagine two runs of Rebol console initialization.  In the first,
        // the tick count is 304 when C-DEBUG-BREAK/COMPENSATE is called,
        // right after command line parsing.  Later on a panic() is hit and
        // reports tick count 1020 in the crash log.
        //
        // Wishing to pick apart the bug before it happens, the Rebol Core
        // Developer then re-runs the program with `--breakpoint=1020`, hoping
        // to break at that tick, to catch the downstream appearance of the
        // tick in the panic().  But since command-line processing is in
        // usermode, the addition of the parameter throws off the ticks!
        //
        // https://en.wikipedia.org/wiki/Observer_effect_(physics)
        //
        // Let's say that after the command line processing, it still runs
        // C-DEBUG-BREAK/COMPENSATE, this time at tick 403.  Imagine our goal
        // is to make the parameter to /COMPENSATE something that can be used
        // to conservatively guess the same value to set the tick to, and
        // that /COMPENSATE ARG(bound) that gives a maximum of how far off we
        // could possibly be from the "real" tick. (e.g. "argument processing
        // took no more than 200 additional ticks", which this is consistent
        // with...since 403-304 = 99).
        //
        // The reasoning for why the formula below works for this rounding is
        // given in this StackExchange question and answer:
        //
        // https://math.stackexchange.com/q/2521219/
        //
        Tick one = 1; // MSVC gives misguided warning for cast(Tick, 1)
        TG_tick =
            (one &lt;&lt; (ceil_log2(TG_tick) + 1))
            + VAL_INT64(ARG(tick))
            - 1;
        return nullptr;
    }
</code></pre>
<p>Also, I've never used the /RELATIVE tick feature, killing that too:</p>
<pre><code>  if (REF(relative))
      TG_break_at_tick = frame_-&gt;tick + 1 + VAL_INT64(ARG(tick));
</code></pre>
<p><strong>I'm going to be deleting a lot of things, I think, in the pursuit of simplification--now that isotopes are showing the way.</strong></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/axing-breakpoint-switch-c-debug-break-at/2009">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/axing-breakpoint-switch-c-debug-break-at/2009</link>
          <pubDate>Tue, 24 Jan 2023 21:57:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2009</guid>
          <source url="https://forum.rebol.info/t/axing-breakpoint-switch-c-debug-break-at/2009.rss">Axing --breakpoint switch, C-DEBUG-BREAK-AT</source>
        </item>
        <item>
          <title>Working With Truthy BLANK! (in SPLIT-PATH Tests)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The current re-imagining of the concept of truthy/falsey involves the idea that <em>anything you can put into a block is truthy</em>.  That includes BLANK!.</p>
<p>~null~ isotopes are falsey, and will REIFY to be <strong><code>~null~</code></strong> which can be somewhat clumsy-looking.</p>
<p>But consider some test cases for seeing how SPLIT-PATH works, looking a bit like this:</p>
<pre><code>split-path-tests:  [
    %foo                            [_ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%// _]
    %./                             [%./ _]
    &lt;...etc...&gt;
]
</code></pre>
<p>SPLIT-PATH is a multi-return routine, which gives back two values: the path and the filename.  But if one or the other is missing then that component will be null, which is useful for testing with IF (or using DEFAULT with).</p>
<p>But if we just blindly changed the tests to reify, it would become less legible:</p>
<pre><code>split-path-tests:  [
    %foo                            [~null~ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%// ~null~]
    %./                             [%./ ~null~]
    &lt;...etc...&gt;
]
</code></pre>
<p>However...with blanks being truthy, this means you that you can take a variable which may be null and turn it into a blank, like this:</p>
<pre><code>reduce [any [path _] any [file _]]
</code></pre>
<p>That's rather succinct!  Probably so succinct that it doesn't need its own native to express.</p>
<p>(I thought it was neat.)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007</link>
          <pubDate>Sat, 14 Jan 2023 15:21:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2007</guid>
          <source url="https://forum.rebol.info/t/working-with-truthy-blank-in-split-path-tests/2007.rss">Working With Truthy BLANK! (in SPLIT-PATH Tests)</source>
        </item>
        <item>
          <title>&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>It's no secret that I'm proud of the way the <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">design for generalized isotopes</a> is tearing through classic problems in Rebol.</p>
<p>At the same time, people's eyes can glaze over when you find yourself writing sentences like:</p>
<blockquote>
<p><em>"All quasiforms become isotopic forms when evaluated, and when going the other way through a meta operation on an isotope, you'll get a quasiform back."</em></p>
</blockquote>
<p>It all makes sense to me.  But I don't want to overlook better terms, if they exist.</p>
<h2>How Did "Isotopes" Come To Be Called That?</h2>
<p>The term isotope originated from the "decaying" behavior, where a special form of null would run a THEN branch.  But this special form would not be something you could store in a variable...it would become an ordinary null at that point.  So getting stored in a variable would cause "decay".</p>
<pre><code>&gt;&gt; null
; null

&gt;&gt; if true [null]
; null isotope

&gt;&gt; x: if true [null]
; null isotope

&gt;&gt; x
; null
</code></pre>
<p>The decay means variables captured from expressions would have a different behavior when substituted for the expressions.  That was deemed to be an acceptable cost.</p>
<pre><code>&gt;&gt; if true [print "then", null] else [print "else"]
then

&gt;&gt; temp: if true [print "then", null]
then

&gt;&gt; temp else [print "else"]
else
</code></pre>
<p>The parallel with decay of atomic isotopes seemed pretty clear, at least to me.  Many places would see it as a normal null, but a few special sites could use a "sensor" to detect the difference.  ELSE was an example of something that could detect.</p>
<p>As things moved forward, and when logic variables became ~true~ and ~false~ isotopes, it became clear these isotopic states would need to be able to stored in variables.  That meant there were "unstable isotopes" and "stable isotopes"... e.g. WORD! isotopes were stable, ERROR! isotopes were not.</p>
<p><em><strong>Having these stable isotopes actually strengthened the analogy.</strong></em>  Because some atomic isotopes are stable, while others are not.</p>
<h2>How Did "QUASI" Become Called That?</h2>
<p>Originally, things like <code>~foo~</code> were called "bad words", designed to cause errors when accessed through a variable by default.  They were like an old-school UNSET! where you could give it a custom label.  But eventually everything was generalized so that everything had an isotopic form.</p>
<p>The fact that these forms stopped conveying an error condition meant considering them "bad" wasn't sensible.  I kind of latched onto "quasi" in part because of the tilde's use in approximation, e.g. (3.0001 ~= 3).</p>
<p>(It also sounds a little like "queasy" and the squigglies look wavy and maybe a bit uncomfortable.  <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">)</p>
<h2>So... Speak Now Or Hold Your Peace?</h2>
<p>Bad naming can have an impact.  I think calling complex numbers "imaginary" is a good example of a bad name that probably caused a few problems.</p>
<p>But I think the names here are good.  It's just going to be a matter of figuring out how to teach people to not be afraid of them.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005</link>
          <pubDate>Sun, 08 Jan 2023 21:18:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2005</guid>
          <source url="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005.rss">&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</source>
        </item>
        <item>
          <title>Websocket Support in Oldes Rebol3</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Looking to see what Oldes has been up to, he added some kind of minimal websocket support to the HTTP scheme:</p>
<p><a href="https://github.com/Oldes/Rebol3/commit/bae6cffe97e662ec9a727a01cdcc1fdd61455ea6#diff-490ba807ac4a5ee57e7a587ca0936d36e4c0ff2798b0652fdf791e758ce079c2R718" class="inline-onebox">FEAT: Minimalistic WebSocket support in the `httpd` scheme · Oldes/Rebol3@bae6cff · GitHub</a></p>
<p>Websockets isn't something I'm looking into at this time, but I wanted to bookmark it here in case it comes up later.</p>
<p>He also updated zlib to a new version released in 2022... and <a href="https://github.com/Oldes/Rebol3/commit/15fcc00b84f6d0e386f2ba2f4fc7bdc32ebff75d">used Ren-C's %make-zlib.r to do it!</a>.  But he edited it so he'd be able to run it under his Rebol3.  It's not a huge priority to do that update, but seems like since his ported script still worked, it might not be too hard.  (And a good reminder that script exists, and should be part of a CI test...)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003</link>
          <pubDate>Fri, 06 Jan 2023 03:56:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2003</guid>
          <source url="https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003.rss">Websocket Support in Oldes Rebol3</source>
        </item>
        <item>
          <title>Picking ACTION!s from BLOCK!s In The Age of Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>In <strong><a href="https://forum.rebol.info/t/reds-design-issues-wiki/1282">Red's Design Questions wiki</a></strong>, they bring up the issue of why picking functions out of blocks runs them:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block
Evaluated.  ; d'oh
== false
</code></pre>
<p><a href="https://gitter.im/red/red?at=5c782ca0c1cab53d6f53dd6d">In the Gitter conversation</a>, Boris calls it a "shady area" that they can't get out of "under the current semantic model".  He suggests it is clear that <strong><code>block/1</code></strong> should not run an action, but possible that <strong>block/word</strong> would mean to.</p>
<p>They contemplate the idea that <strong>block/1</strong> would not run the action, but pick it:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block  ; hypothetical behavior
== false
</code></pre>
<p><strong>I will argue this doesn't really help you much, the problem just becomes one step removed.</strong>  Quite often people are picking things out of blocks to put them in variables, and you'll just get bit there instead:</p>
<pre><code>red&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block/1
== func [][print "Evaluated."]

red&gt;&gt; append otherblock temp
Evaluated.  ; d'oh
== [unset]  ; double d'oh
</code></pre>
<h2>
<a name="isotopes-bring-the-better-semantic-model-1" class="anchor" href="https://forum.rebol.info#isotopes-bring-the-better-semantic-model-1"></a>Isotopes Bring The Better Semantic Model!</h2>
<p>In Ren-C's concept (as I'm working on it), the only actions that will run from a word reference are those that are isotopic actions.  And FUNC or DOES creates an isotopic action.</p>
<p>So you would be stopped from making an illegal block up front:</p>
<pre><code>&gt;&gt; block: reduce [does [print "Evaluated."]]
** Script Error: Invalid use of ~#[action! []]~ isotope
</code></pre>
<p>You can put quasi-ACTION!s, plain ACTION!s, and quoted actions in blocks.  Just not isotopic ones.</p>
<p>Whichever you choose, the equality test will work... and picking out a value into a variable will give you an inert variable to work with, that can be used with things like append!</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; equal? block.1 first block
== ~true~  ; isotope  &lt;-- didn't run and print "Evaluated", yay!

&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block.1
== ~#[action! []]~

red&gt;&gt; append otherblock temp
== [~#[action! []]~]   ; &lt;-- didn't run and gave sensible block out
</code></pre>
<p>I used REIFY there and got a quasi-action.  BUT which would you rather put in the block: a quasi-action or a plain one?  This depends on what you plan to do with the block.  A plain action will execute when encountered by the evaluator, while a quasi-action will evaluate to an isotopic action--suitable for assigning via SET-WORD! when you meant to make that word dispatch the function when referenced.</p>
<p>My leaning is to say that either form can be used with APPLY, RUN, or the terminal path form:</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; run block.1
Evaluated.

&gt;&gt; block: reduce [concretize does [print "Evaluated."]] 
== [#[action! []]]

&gt;&gt; apply block.1 []
Evaluated.
</code></pre>
<p><em>(See post on <a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">difference between REIFY and CONCRETIZE</a>, and the search for a better term...)</em></p>
<p>If you want to pick an action out of a block and put it into a variable, where it will execute from that variable, there is the RUNS transformer.  It will turn a quasi or plain ACTION! into an action isotope:</p>
<pre><code> &gt;&gt; active-var: runs block.1
 == ~#[action! {active-var} []]~  ; isotope  &lt;-- note: also cached name, neat!

 &gt;&gt; active-var
 Evaluated.
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=12" title=":clap:" class="emoji only-emoji" alt=":clap:" loading="lazy" width="20" height="20"></p>
<p>You can use UNMETA more generically to get an isotope back from any quasi-form (not just actions), or ISOTOPIC to get an isotope from a plain form.</p>
<h2>
<a name="the-invariant-is-what-counts-here-2" class="anchor" href="https://forum.rebol.info#the-invariant-is-what-counts-here-2"></a>The Invariant Is What Counts, Here!</h2>
<p>The mountain that has been climbed is that we can now say that for any block, this is true:</p>
<pre><code>block2: collect [
    for-each item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<ul>
<li>
<p>I've just covered that there are no isotopic actions to implicitly execute; you'd get an error trying to put them in the block.</p>
</li>
<li>
<p>There are no blocks/groups/paths that will splice into the target, because splicing requires an explicit conversion to an isotope.</p>
</li>
<li>
<p>There are no "unsets" to trip on that you can find in a block, because the state conveying "unsetness" (none) is an isotope.</p>
</li>
</ul>
<p>Of course with objects, it's going to be a different story.  I think we'll still want some safeguards:</p>
<pre><code>for-each [key value] object [...]  ; will error when value is action

for-each [key :value] object [...]  ; will allow action isotopes as-is

for-each [key ^value] object [...]  ; will give a meta value
</code></pre>
<p>A key problem here is I'm wondering how much to cross purposes of GET-WORD! between action disarming and the other isotopic states.  But, it just takes time to work through.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002</link>
          <pubDate>Fri, 06 Jan 2023 03:16:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2002</guid>
          <source url="https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002.rss">Picking ACTION!s from BLOCK!s In The Age of Isotopes</source>
        </item>
        <item>
          <title>REIFY vs. META vs. SOMETHING</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Originally I suggested that REIFY of an isotope would give its plain form, and you would META it if you wanted a quasiform:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/1">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</a>
</div>
<blockquote>
<ul>
<li>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</li>
<li>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</li>
</ul>
</blockquote>
</aside>
<p><em>But that's not a full coverage answer.</em></p>
<ul>
<li>
<p>An operator that takes everything "one level up", where isotopes become quasiforms and everything else gets a quote level added.</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; meta true
== ~true~

&gt;&gt; meta 10
== '10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their quasiforms (and I think this probably is best called REIFY):</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; reify true
== ~true~

&gt;&gt; reify 10
== 10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their plain forms:</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; something true
== true

&gt;&gt; something 10
== 10
</code></pre>
</li>
</ul>
<p>Specifically for ACTION! isotopes being turned into plain actions, I used an interim term UNRUN, but that's pretty awful.</p>
<p>Making things into isotopes is done with ISOTOPIC:</p>
<pre><code>&gt;&gt; isotopic 10
== ~10~  ; isotope
</code></pre>
<p>It could be a refinement to REIFY, like REIFY/PLAIN.  But at that point it could be two steps that might be clearer: NOQUASI REIFY, where NOQUASI would be like NOQUOTE and not complain if the thing you passed it was not a quasiform.</p>
<p>Maybe... CONCRETIZE?  That sounds like it might do a bit more work than what REIFY does :-/</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concretize true
== true

&gt;&gt; concretize 10
== 10
</code></pre>
<p>It's not awful.  Main thing is just to have <em>a</em> name for it while the gears turn.  But as usual, throw out suggestions if you have them...</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001</link>
          <pubDate>Thu, 05 Jan 2023 21:26:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2001</guid>
          <source url="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001.rss">REIFY vs. META vs. SOMETHING</source>
        </item>
        <item>
          <title>Concept: Filters</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>Development</category>
          <description><![CDATA[
            <p>Filters are a means of incrementally transcoding data from source to brokered output (bytes/binary! or characters/text!). A goal is to provide a standard API for transcoding that can be implemented and used as efficiently as possible (e.g. extracting a portion of encoded data without extracting the whole; native transcoders for Deflate). A filter could conceivably be implemented as a distinct type that has object-like properties (as the PORT! type does) and could thus be acted upon by the appropriate Rebol actors (COPY/SKIP/NEXT/TAIL, etc.).</p>
<p><em>I've alluded to a similar idea in <a href="https://forum.rebol.info/t/semantics-of-port-s-vs-streams-vs-iterators/1689/4">an earlier post</a>, however this concept is more focussed on transcoding one series of numbers/characters to another. Filters are NOT scanners/tokenizers/lexers.</em></p>
<p>A filter source can be:</p>
<ul>
<li>BINARY! or TEXT! values</li>
<li>PORT! values that stream BINARY! or TEXT! (including files/network resources)</li>
<li>filter values (i.e. filters can be layered)</li>
</ul>
<p>Examples of filter types:</p>
<ul>
<li>Retrieves binary contained within a file/network resource</li>
<li>Decodes text encoded as UTF-8, UTF-16, ISO-8859-1, CP-1252, etc. (or even unspecified using something like Chardet)</li>
<li>Decodes binary compressed per Deflate, LZW, etc.</li>
<li>Decodes binary encoded as 'text' per Base64, Ascii85, Hexadecimal, etc.</li>
<li>Decrypts binary encrypted per e.g. Rebol 2 ENCLOAK/DECLOAK (but obviously more)</li>
<li>Decodes text encoded mostly literally but with escape sequences, e.g. JSON strings, Rebol strings, XML/HTML data sequences/attribute values</li>
</ul>
<p>Filters should have at least the following capabilities:</p>
<ul>
<li>Copy all encoded data</li>
<li>Copy part of the encoded data</li>
<li>Skip part of the encoded data (Deflate could potentially iterate faster if it wasn't emitting simultaneously)</li>
</ul>
<p>Filters should possibly have the following capabilities:</p>
<ul>
<li>BACK/HEAD/negative SKIP support</li>
<li>TAKE/REMOVE/CLEAR as a means of clearing buffers</li>
</ul>
<p>Functions that consume data should support filters as a pseudo-series type, e.g.</p>
<ul>
<li>Parse</li>
<li>BINARY/READ (from Oldes/Rebol3)</li>
<li>CONSUME (from <a href="https://forum.rebol.info/t/bincode/1863">rgchris/bincode</a>)</li>
</ul>
<p>Filter values are exhausted when:</p>
<ul>
<li>An end-of-content signal/delimiter has been found e.g. self-terminating formats such as Deflate; quote marks ending a JSON string</li>
<li>A filter cap has been reached e.g. the filter has a specified length</li>
<li>An unrecoverable error occurs (e.g. invalid UTF-8 sequences in strict mode; the 'g' character in a hexadecimal stream)</li>
<li>The source has been exhausted</li>
</ul>
<p>It should be possible to recover the current source at the corresponding index within a filter value though this may require additional state info, e.g. in Deflate or Base64 where a byte within an encoding has information pertaining to more than one decoded byte</p>
<p>Filter algorithms can be native (e.g. Deflate tied to Zlib, UTF-8) or in user-mode (thus extensible).</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/concept-filters/2000">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/concept-filters/2000</link>
          <pubDate>Thu, 05 Jan 2023 03:49:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2000</guid>
          <source url="https://forum.rebol.info/t/concept-filters/2000.rss">Concept: Filters</source>
        </item>
        <item>
          <title>Rebolbot future</title>
          <dc:creator><![CDATA[johnk]]></dc:creator>
          <category>Community</category>
          <description><![CDATA[
            <p>Hi guys<br>
I think it is time to turn off the old rebolbot server as I have not been using it for a while. <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> may still have a few things running on it, so this is a heads up that I plan to turn it off in the next month or so.<br>
All the best,<br>
John</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebolbot-future/1999">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebolbot-future/1999</link>
          <pubDate>Thu, 29 Dec 2022 07:31:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1999</guid>
          <source url="https://forum.rebol.info/t/rebolbot-future/1999.rss">Rebolbot future</source>
        </item>
        <item>
          <title>SPLIT Semantics</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><a href="https://gitter.im/red/red?at=63523097f00b697fec501c7a">On Red Gitter</a>, it was discussed "which of the following is 'correct'":</p>
<pre><code>Red&gt; split "" ","
== [""]

R3&gt; split "" ","
== []
</code></pre>
<p>Rebolek thinks R3 is right.  Boris says:</p>
<blockquote>
<p>I don't think there's a correct answer, just choices. I prefer the Red version because:<br>
it strictly follows the rule: `number-of-segments = 1 + number-of-delimiters", no exceptions, so it's easier to reason about</p>
<p>it should be able thus to preserve the type in case one wants to rejoin it later (that it doesn't is a bug, try split %"" ",")</p>
</blockquote>
<p>So there's a couple of ways to look at it.</p>
<p>But I have a philosophy about these things where I want edge cases to be "noisy", because usually they require special handling.  I might even say:</p>
<pre><code>&gt;&gt; split "" ","
== ~null~  ; isotope</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/split-semantics/1998">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/split-semantics/1998</link>
          <pubDate>Thu, 22 Dec 2022 04:04:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1998</guid>
          <source url="https://forum.rebol.info/t/split-semantics/1998.rss">SPLIT Semantics</source>
        </item>
        <item>
          <title>ChatGPT Speaking About Rebol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>So ChatGPT actually knows a bit about Rebol (at least Rebol2)</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" data-download-href="https://forum.rebol.info/uploads/default/7b940f01f3801b53d0a1d4d412074bda30517443" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" alt="image" data-base62-sha1="hDdWsU3sEBthVlysVvcHRLWmfWH" width="356" height="500" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/7b940f01f3801b53d0a1d4d412074bda30517443_2_10x10.png"></a></div><p></p>
<p>This does raise some questions about the future of software, in general.  It's possible that AI models will plateau and maybe they'll never get too much better than this...</p>
<p>...but I don't think so.  I imagine year-over-year, we're going to see them learning.  I don't know exactly when they'd be able to come up with ideas like what I've been doing for Ren-C.</p>
<p>But something I did think about is that if they can write code, then giving them a super-expressive medium in which to do it could be very powerful.  If they can come up with the dialect and then use it, then they might be able to write concise programs that wind up being quite legible...whereas other languages might make them trade off length for clarity.</p>
<p>If you ask ChatGPT an interesting Rebol question, feel free to put it in this thread.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997</link>
          <pubDate>Sat, 17 Dec 2022 15:53:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1997</guid>
          <source url="https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997.rss">ChatGPT Speaking About Rebol</source>
        </item>
        <item>
          <title>Should Isotopes Be Legal in MAP! (Keys, Values?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In the pre-isotopic era, there was a concept that MAP! would not allow you to store nulls.  Because null was the signal of not being in a map.  Assigning a key null was a way of removing items from that map.</p>
<pre><code>&gt;&gt; m: make map! [x 20]
== make map! [
    x 20
]

&gt;&gt; m.x
== 20

&gt;&gt; m.y
; null

&gt;&gt; m.x: null
; null

&gt;&gt; m
== make map! [
]
</code></pre>
<p>Additionally, NULL was not allowed as a key.</p>
<h2>How Should This Change In The Isotopic Era?</h2>
<p>I'll make the point that not allowing you to store isotopes as keys or values isn't a fundamental problem, because you can META a value to put it in, and then UNMETA it when taking it out.</p>
<p>You wind up with a fundamental issue that actions from a MAP! won't be run implicitly this way, and you can't put any falsey values in a map this way (because false is the ~false~ word isotope, and ~null~ isotopes are representations of not being in the map).</p>
<p>But that limitation can be a benefit.  I already think of it as a benefit that you cannot run an action by doing access of items out of a block.  e.g. <strong>block.1</strong> could never run a function now (since blocks can't store isotopic actions).  If that was true of <strong>map.key</strong> as well, that could be seen as a good thing... you'd have to APPLY or RUN a plain ACTION! (or QUASI-ACTION!).</p>
<pre><code>&gt;&gt; m: make map! []

&gt;&gt; m.1: :append
** Error: Cannot put ACTION! isotope in map

&gt;&gt; m.1: ^append
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; m.1
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; run m.1 [a b c] [d e]
== [a b c [d e]]

&gt;&gt; apply m.1 [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]

&gt;&gt; m.1/ [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]
</code></pre>
<p>As with the peace of mind using BLOCK!, that seems like a good thing to me.</p>
<p><em>(I'm not entirely sure if RUN should allow QUASI-ACTION!s, or if you should have to UNQUASI it into a plain ACTION!.  Forcing the canonization might make more sane, so that routines that want to exchange actions as currency would have one standard they spoke.)</em></p>
<p>I also think it's likely a good thing that false isotopes wouldn't be in the map, only quasi-false and the word false.  So if you're putting logic into a map, you'd wind up writing <strong><code>if map.key = 'true [...]</code></strong> or <strong><code>if map.key = 'false [...]</code></strong> and save the <strong>if map.key</strong> and <strong>if not map.key</strong> for testing things being in the map.</p>
<h2>This Would Widen The Gap With Objects</h2>
<p>There have been questions about what the difference is between maps and objects, and this would be another: objects must be able to have members that are isotopes: action isotopes that can run implicitly, logic and null and other word isotopes, and I'm presuming splices and other stable forms as well.</p>
<p>It would mean a map has more in common with a block.</p>
<p>This doesn't strike me as being that much of a problem.</p>
<p><strong>So I'm going to be going ahead with the premise that isotopes can't be stored in maps, as either keys or values.</strong>  We'll see how it goes, but I think this is the right answer.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995</link>
          <pubDate>Fri, 02 Dec 2022 09:28:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1995</guid>
          <source url="https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995.rss">Should Isotopes Be Legal in MAP! (Keys, Values?)</source>
        </item>
        <item>
          <title>Head-to-Head Battle of the Coding Fonts</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>So I don't think this did the best job of representing Inconsolata (the choice for the ReplPad), but it lets you pit monospace fonts against each other to find the one you like:</p>
<p><a href="https://www.codingfont.com/">https://www.codingfont.com/</a></p>
<p>I still think if the right weight of Inconsolata is chosen it's the best.</p>
<p><a href="https://fonts.google.com/specimen/Inconsolata?preview.text=0O1Iil&amp;preview.text_type=custom#styles" class="inline-onebox">Google Fonts: Inconsolata</a></p>
<p>For me, the competition would be Source Code Pro or Fira Code.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/head-to-head-battle-of-the-coding-fonts/1994">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/head-to-head-battle-of-the-coding-fonts/1994</link>
          <pubDate>Thu, 01 Dec 2022 14:43:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1994</guid>
          <source url="https://forum.rebol.info/t/head-to-head-battle-of-the-coding-fonts/1994.rss">Head-to-Head Battle of the Coding Fonts</source>
        </item>
        <item>
          <title>Python Speedup Proposals</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>The original "CPython" implementation is in some ways similar to Rebol/Red... though these days Ren-C is more aligned with the stackless Python implementation...which is also written in C, but distinct from CPython.</p>
<p><em>(But Ren-C's design overall is a lot less comparable to anything, due to the number of very "alien" ideas in it, but that I think are what gives it more notable properties.)</em></p>
<p>In any case, despite running an interpreter loop and doing kind-of-what-Rebol-does, they've committed themselves to doing some speedup proposals and apparently it's paying off:</p>
<p><a href="https://devblogs.microsoft.com/python/python-311-faster-cpython-team/" class="inline-onebox">A Team at Microsoft is Helping Make Python Faster - Python</a></p>
<p>Some of their proposals involve JIT-compiling things (which they know won't work on restrictive platforms like iOS).  But they apparently have done a lot of tweaks besides that which have turned out beneficial.  Because it's a C interpreter there might be something applicable to be learned by looking at their "Stage 1" and "Stage 2" changes.</p>
<blockquote>
<h3>Stage 1 -- Python 3.10</h3>
<p>The key improvement for 3.10 will be an adaptive, specializing interpreter. The interpreter will adapt to types and values during execution, exploiting type stability in the program, without needing runtime code generation.</p>
<h3>Stage 2 -- Python 3.11</h3>
<p>This stage will make many improvements to the runtime and key objects. Stage two will be characterized by lots of "tweaks", rather than any "headline" improvement. The planned improvements include:</p>
<ul>
<li>Improved performance for integers of less than one machine word.</li>
<li>Improved peformance for binary operators.</li>
<li>Faster calls and returns, through better handling of frames.</li>
<li>Better object memory layout and reduced memory management overhead.</li>
<li>Zero overhead exception handling.</li>
<li>Further enhancements to the interpreter</li>
<li>Other small enhancements.</li>
</ul>
<h3>Stage 3 -- Python 3.12 (requires runtime code generation)</h3>
<p>Simple "JIT" compiler for small regions. Compile small regions of specialized code, using a relatively simple, fast compiler.</p>
<h3>Stage 4 -- Python 3.13 (requires runtime code generation)</h3>
<p>Extend regions for compilation. Enhance compiler to generate superior machine code.</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/python-speedup-proposals/1992">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/python-speedup-proposals/1992</link>
          <pubDate>Sun, 27 Nov 2022 10:05:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1992</guid>
          <source url="https://forum.rebol.info/t/python-speedup-proposals/1992.rss">Python Speedup Proposals</source>
        </item>
  </channel>
</rss>

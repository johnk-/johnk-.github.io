<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest topics</title>
    <link>https://forum.rebol.info/latest</link>
    <description>Latest topics</description>
    
      <lastBuildDate>Sun, 22 Dec 2024 16:29:39 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/latest.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Get_Xxx_Flag() vs Has_Xxx_Flag() ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>Kind of a fiddly naming issue, but there are a lot of places where flag-testing helpers are defined, which usually have 4 variants like this:</p>
<pre><code>#define Set_Details_Flag(p,name) \
    Set_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)

#define Get_Details_Flag(p,name) \
    Get_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)

#define Clear_Details_Flag(p,name) \
    Clear_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)

#define Not_Details_Flag(p,name) \
    Not_Flavor_Flag(DETAILS, ensure(Details*, (p)), name)
</code></pre>
<p>The savings add up for having things like the NOT form, it unclutters things pretty well:</p>
<pre><code>Not_Details_Flag(details, CAN_BE_DISPATCHED_AS_INTRINSIC)
// vs
not Get_Details_Flag(details, CAN_BE_DISPATCHED_AS_INTRINSIC)
</code></pre>
<p>I hadn't really questioned these.  But lately I've been wondering... would HAS be better than GET?</p>
<pre><code>if (Has_Details_Flag(...)) ...

if (Get_Details_Flag(...)) ...
</code></pre>
<p>It's a subtle semantics thing.  You could argue that even if a flag is not set, the structure still <em>has</em> the flag.</p>
<p>But is "if Get(...)" like asking if the get operation itself succeeded?  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Of course, in the interpreter we have taken for granted that <strong><code>if get $var</code></strong> isn't asking if you successfully got the variable, but whether the variable's contents are null or not.  And <strong><code>has obj field</code></strong> is really asking about the presence or absence of the field.</p>
<p>When I first thought of it, I was thinking that HAS was better.  But after writing this I'm kind of thinking GET may be the more consistent choice after all.</p>
<p>To be painfully precise, we'd call it: <strong><code>Is_Details_Flag_Set(...)</code></strong>... but I certainly prefer <strong><code>Get_Details_Flag(...)</code></strong> to that.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/get-xxx-flag-vs-has-xxx-flag/2358">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/get-xxx-flag-vs-has-xxx-flag/2358</link>
          <pubDate>Sun, 22 Dec 2024 16:29:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2358</guid>
          <source url="https://forum.rebol.info/t/get-xxx-flag-vs-has-xxx-flag/2358.rss">Get_Xxx_Flag() vs Has_Xxx_Flag() ?</source>
        </item>
        <item>
          <title>What Should Returning a String From a Native Do?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>I've raved about <a href="https://forum.rebol.info/t/no-preprocessing-no-ffi-just-awesome-rebfunction/2224">how cool rebFunction() is</a>... though it may seem like mundane C interop, it's not.  <strong>It's quite novel.</strong></p>
<p>But to recap, a trivial example:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">const char* Add_1000_Spec = "[ \
    -{Adds 1000 to whatever you pass in}- \
    return: [integer!] \
    x [integer!] \
]";
Bounce Add_1000_Impl(Context* binding)
{
    int x = rebUnboxInteger("x");
    int bigger = x + 1000;
    return rebInteger(bigger);
}

Value* action = rebFunction(Add_1000_Spec, &amp;Add_1000_Impl);
</code></pre>
<p>So here you see us returning a synthesized Rebol Value, an INTEGER!.</p>
<p>You can return other things, such as <strong><code>rebDelegate("...");</code></strong> which defers execution to code which can do all kinds of things like throw or raise errors, or produce unstable antiforms.</p>
<h2><a name="p-7984-but-no-return-states-overlap-utf-8-strings-1" class="anchor" href="https://forum.rebol.info#p-7984-but-no-return-states-overlap-utf-8-strings-1"></a>But No Return States Overlap UTF-8 Strings</h2>
<p>This is by design.  All Cells and Stubs in the system are out-of-band from valid UTF-8 leading characters.</p>
<p>This means that the meaning for this is wide open:</p>
<pre><code>const char* Return_Utf8_Spec = "[ \
    -{return of a C const char literal pointer}- \
    return: [???] -{what do you think?}- \
]";
Bounce Return_Utf8_Impl(Context* binding)
{
    return "ðŸ˜¸ Some UTF-8 Here ðŸ˜¸";
}
</code></pre>
<h2><a name="p-7984-obvious-answer-return-text-2" class="anchor" href="https://forum.rebol.info#p-7984-obvious-answer-return-text-2"></a>"Obvious" Answer: Return TEXT!</h2>
<p>You might think that it's completely obvious what should happen in this case: that it returns TEXT! and that's the end of that.</p>
<p>Hence this would be a synonym for:</p>
<pre><code>return rebText("ðŸ˜¸ Some UTF-8 Here ðŸ˜¸");
</code></pre>
<p>Given that we could make the "instructions" legal to return as well, it could be equivalent to something even shorter:</p>
<pre><code>return rebT("ðŸ˜¸ Some UTF-8 Here ðŸ˜¸");
</code></pre>
<p>So this doesn't really rock anyone's world with a capability they didn't already have.</p>
<h2><a name="p-7984-or-it-could-run-code-3" class="anchor" href="https://forum.rebol.info#p-7984-or-it-could-run-code-3"></a>OR... It Could Run Code...</h2>
<p>I'll point out that plain C strings aren't generally seen in the API as being equivalent to text literals.  They're equivalent to code.</p>
<pre><code>rebElide("this isn't a string -{but this is}-");
</code></pre>
<p>So shifting into non-code interpretation requires some kind of marker.</p>
<p>By this logic, we might say that the specific relationship between <strong>return</strong> and a string runs code...but more than that, <em>delegated</em> code.</p>
<p>This is to say that because you are returning, you can do things safely that you couldn't do otherwise... because you've passed control back to the trampoline.  Hence something like a FAIL would not cross your own C stack levels.</p>
<pre><code>return "fail -{This would be safe!}-"
</code></pre>
<p>It's not as powerful as <strong><code>rebDelegate()</code></strong>, because you can't splice things in variadically.  And you might wonder how it could work at all...since it doesn't have a way to capture the shadowed binding variable.</p>
<p><strong>But interestingly, it doesn't need to capture the shadowed variable, because in processing the return it's actually the point of control of the Dispatcher that passed the variable in the first place!</strong></p>
<p>So indeed, you have access to the full context...including the local variables in the frame.</p>
<pre><code>const char* Return_Delegates_Spec = "[ \
    -{Demonstrate returning UTF-8 as delegation}- \
    return: [tag!] \
    x [integer!] \
]";
Bounce Return_Delegates_Impl(Context* binding)
{
    if (rebUnboxInteger("x") &gt; 1020)
         return rebValue("&lt;nice large number!&gt;");
    return "raise [-{X value is too small:}- x]";
}
</code></pre>
<h2><a name="p-7984-rebdelegate-still-is-a-lot-more-full-featured-4" class="anchor" href="https://forum.rebol.info#p-7984-rebdelegate-still-is-a-lot-more-full-featured-4"></a>rebDelegate() Still Is  A Lot More Full-Featured</h2>
<p>Not only can you splice, but you can use commas to separate runs of text:</p>
<pre><code>return rebDelegate(
    "you", "can",
    "do", "this"
    "and splice", values, "in the midst"
);
</code></pre>
<p>That doesn't wind up doing anything weird like giving you "cando".  The commas in the variadic are token stops.</p>
<p>C++ offers raw strings and you can do things like:</p>
<pre><code>return R"(fail [
    -{You can write a really long failure message here}-
    -{And the raw string will do the right thing}-
])"
</code></pre>
<p>I'm used to the commas, but maybe that's an improvement over:</p>
<pre><code>return rebDelegate("fail [",
    "-{You can write a really long failure message here}-",
    "-{And the raw string will do the right thing}-"
"]");
</code></pre>
<h2><a name="p-7984-overall-i-think-string-as-delegation-is-the-winning-choice-5" class="anchor" href="https://forum.rebol.info#p-7984-overall-i-think-string-as-delegation-is-the-winning-choice-5"></a>Overall, I Think String-As-Delegation Is The Winning Choice</h2>
<p>Making a TEXT! string is both counter to the default interpretation of C strings, and will have a well-known shorthand.</p>
<p>I don't think <strong><code>return rebD()</code></strong> for rebDelegate() has any particular clarity to it.</p>
<p>Where I see this being most useful is for short failure messages, which are pretty common to be returned...even in the middle of functions.</p>
<p>But it also lets you do things you couldn't otherwise, like <strong><code>return "quit 1"</code></strong> or <strong><code>return "halt"</code></strong>.</p>
<p>If you want to return nothing, you can just say <strong><code>return "~"</code></strong> instead of <strong><code>return rebNothing()</code></strong>... we can make that particular case fast where it doesn't call the evaluator (and maybe some other cases too...)</p>
<p>Really, it's just a greater force multiplier!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-should-returning-a-string-from-a-native-do/2357">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-should-returning-a-string-from-a-native-do/2357</link>
          <pubDate>Sun, 22 Dec 2024 07:39:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2357</guid>
          <source url="https://forum.rebol.info/t/what-should-returning-a-string-from-a-native-do/2357.rss">What Should Returning a String From a Native Do?</source>
        </item>
        <item>
          <title>Equivalent to [[nodiscard]] ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>C++ has an attribute on functions called <code>[[nodiscard]]</code> that instructs the compiler to make sure you do something with a result.</p>
<p><a href="https://en.cppreference.com/w/cpp/language/attributes/nodiscard" class="inline-onebox">C++ attribute: nodiscard (since C++17) - cppreference.com</a></p>
<p>I've long wondered about whether there's some kind of discard-sensitivity that should/could be thrown in, e.g. for noticing when a stray value in evaluation doesn't do anything:</p>
<pre><code>&gt;&gt; append [a b c] [d e] 2 print "Could we error?"
** Error: 2 was discarded
</code></pre>
<p>How much code would break if we didn't allow stray values like that in the evaluator?  I could actually test that question.</p>
<p>Anyway, the mechanics behind RAISE means there's already a place to implement this.  There's a spot where it is decided if a definitional error would be discarded, and if so it's escalated to an abrupt failure.  It's only okay if it falls out of the evaluation to get picked up by someone else, and stays as a hot potato.</p>
<p>But could we have other hot potatoes?  Results of functions that are marked NO-DISCARD?   Plain values?</p>
<p>I can't offhand think of any important techniques this would break.  But I'll have to try it and see.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/equivalent-to-nodiscard/2356">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/equivalent-to-nodiscard/2356</link>
          <pubDate>Sat, 21 Dec 2024 18:44:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2356</guid>
          <source url="https://forum.rebol.info/t/equivalent-to-nodiscard/2356.rss">Equivalent to [[nodiscard]] ?</source>
        </item>
        <item>
          <title>Multiple Return Values in JavaScript</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>rebRescue() in the C API returns an error, or null if no error... in which case your result is the value that's passed by pointer-to-pointer:</p>
<pre><code> Value* result;
 Value* error = rebRescue(&amp;result, "append 123 456");  // illegal, fails
 if (error) {  // non-0 pointer value means not ~null~ antiform
     /* handle error */
 }
 else {
     /* result is valid */
 }
</code></pre>
<p>But JavaScript doesn't have pointer-to-value semantics.  So you have to use multi-returns.</p>
<p>I didn't know how they did that, so I looked it up.  <a href="https://stackoverflow.com/questions/2917175/return-multiple-values-in-javascript/2917186#2917186">There are two ways</a>.  You can destructure an array:</p>
<pre><code>function getValues() {
    return [getFirstValue(), getSecondValue()]
}
const [a, b] = getValues()  ; any names you want here
</code></pre>
<p>Or you can destructure an object, where you have to use the names of the fields as the same names as your destructure variables:</p>
<pre><code>function getValues() {
    return {
        first: getFirstValue(),
        second: getSecondValue(),
    }
}

const {first, second} = getValues()
</code></pre>
<p>If you don't want to use the exact names, there's another syntax:</p>
<pre><code>const {a: first, b: second} = getValues()
</code></pre>
<p>I don't know if naming multi-returns is super important, and have had bigger ambitions for antiform objects.</p>
<p>The StackOverflow question has someone prescribing that it's very important to pick the named version over the non-named one.  I don't agree, and plan on using the array form for <code>rebRescue()</code></p>
<p><strong>The much bigger issue in my mind is forgetting to do the destructure, and getting back a value that's in-band as a plain array or object, when you really just forgot to destructure.</strong>  Isotopes do a very good thing here, not seen in other languages...decaying to the first item by default, and generalizing moving the out-of-band into band via meta/quasi/etc. forms in order to write peer destructuring operators when you need to.</p>
<p>This is a repeat of JavaScript's issue with Promise, where if you forget to do an AWAIT then you wind up with a Promise by value that you didn't expect.  But AWAIT is terrible for all kinds of other reasons, so we're not going down that road.</p>
<p><a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" class="inline-onebox">What Color is Your Function? â€“ journal.stuffwithstuff.com</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/multiple-return-values-in-javascript/2355">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/multiple-return-values-in-javascript/2355</link>
          <pubDate>Sat, 21 Dec 2024 18:32:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2355</guid>
          <source url="https://forum.rebol.info/t/multiple-return-values-in-javascript/2355.rss">Multiple Return Values in JavaScript</source>
        </item>
        <item>
          <title>Exceptions or longjmp() Across Client C/C++ Code</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>So there's a somewhat uncomfortable issue in using the API, of what to do if an abrupt failure happens.</p>
<pre><code>void my_c_function(int x) {
    char* memory = malloc(1020);
    ...
    rebElide("append 1020", rebI(x));  // can't append to integers, FAILs
}
</code></pre>
<p>Currently what happens in this situation depends on whether you're in the body of an API native which is being invoked by the trampoline or not.  If you're not, the program just terminates.  If you are, then there will be a longjmp or C++ exception (based on which you built with) thrown up the stack which gets caught at the trampoline layer of the API native invocation, and then propagated by that.</p>
<p>Either way you'll get a memory leak.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7981-every-api-could-return-failure-values-1" class="anchor" href="https://forum.rebol.info#p-7981-every-api-could-return-failure-values-1"></a>Every API Could Return Failure Values</h2>
<p>Then you would be forced to check it:</p>
<pre><code>Value* abrupt;
Value* result = rebValue(&amp;abrupt, "append 1020", rebI(x));
if (abrupt) {  // an ERROR! value, we'd presume
    free(memory);
    /* handle error */
}
</code></pre>
<p>Currently if you want to do something like this, there are tools like ENRESCUE, which will give you an ERROR! if there's a failure, or a ^META of whatever else:</p>
<pre><code>Value* meta = rebValue("sys.util/enrescue [append 1020", rebI(x), "]");
if (rebUnboxLogic("error?", meta")) {
    free(memory);
    /* handle error */
}
Value* result = rebValue(meta);  // evaluating meta will unmeta it
</code></pre>
<p>So yes, we could make that easier...and should:</p>
<pre><code>Value* value;
Value* error = rebRescue(&amp;value, "append 1020", rebI(x));
if (error) {
    free(memory);
    /* handle error */
}
/* use value, corrupt if error was non-null */
</code></pre>
<p>The API is built programmatically, so there's no real reason it couldn't have a Rescue variation for every entry point:</p>
<pre><code>int result;
Value* error = rebRescueUnboxInteger(&amp;result, ...);
</code></pre>
<p>I... guess we could do that.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20">  It's a bit unfortunate that you have to make separate entry points in C for all of these things.   JavaScript can have interface modifiers:</p>
<pre><code>const [error, result] = reb.Rescue.UnboxInteger(...);
</code></pre>
<h2><a name="p-7981-but-lets-say-you-dont-want-that-2" class="anchor" href="https://forum.rebol.info#p-7981-but-lets-say-you-dont-want-that-2"></a>But Let's Say You Don't Want That...</h2>
<p>What if you want plain old <code>rebElide()</code>, not <code>rebRescueElide()</code>, and you want something automatic to happen.</p>
<p>The API exports C functions that are declared with <strong><code>extern "C"</code></strong>.  This means they cannot throw C++ exceptions.  So if you want C++ exceptions so your code is unwound properly, that would have to be done in an inline wrapper of some kind, kind of like:</p>
<pre><code>inline void rebElide(...) {  // not extern "C"
    Value* error = rebRescueElide(...);  // extern "C", can't throw
    if (error)
        throw error;  // throw is legal in non-extern "C" (if C++)
}
</code></pre>
<p>But then, <code>rebFunction()</code> would have to do its own exception handling to intercept these throws so you didn't cross the interpreter stack.  It's doable.</p>
<p>The other option is to use <code>longjmp()</code>.</p>
<h2><a name="p-7981-what-do-other-languages-do-3" class="anchor" href="https://forum.rebol.info#p-7981-what-do-other-languages-do-3"></a>What Do Other Languages Do?</h2>
<p>Well, one case would be Ruby, which has <code>rb_rescue2()</code>, <code>rb_protect()</code>, <code>rb_ensure()</code>...</p>
<p><a href="http://silverhammermba.github.io/emberb/c/#rescue">http://silverhammermba.github.io/emberb/c/#rescue</a></p>
<p>These seem to be longjmp()-based, and nothing special.  Won't work with C++.</p>
<p>That's actually where I adopted the term RESCUE from (in the sense used here, and SYS.UTIL/RESCUE).</p>
<p>Long ago I thought to mirror the Ruby API, but I don't think we need to.  There doesn't need to be a special "Dangerous Function" type or routines to handle it.  Instead we just say that your dangerous function is simply a <strong><code>rebFunction()</code></strong> which has a C function as its implementation.  So we piggy-back on whatever exception handling protects that implementation.</p>
<p>Anyway, short term I've just made a new <strong><code>rebRescue()</code></strong> function implementing the better idea, and gotten rid of the very-very-old Ruby clone routines.  More work is needed, but I do want an answer for being able to properly run destructors in C++ code.</p>
<h2><a name="p-7981-added-convenience-rebmalloc-rebrealloc-rebfree-4" class="anchor" href="https://forum.rebol.info#p-7981-added-convenience-rebmalloc-rebrealloc-rebfree-4"></a>Added Convenience: rebMalloc(), rebRealloc(), rebFree()...</h2>
<p>For the sake of convenience, there is a memory allocator which lets you allocate memory that will be cleaned up automatically in case of a failure, and doesn't require destructors to do it.  It's just taken care of when a failed frame is taken off the stack.</p>
<p>These actually back the memory with a BINARY! series, and are cleaned up by the same mechanics that clean up unmanaged series that are in flight when an internal error occurs.</p>
<p>Just an added thing, but better to use C++ constructs if you have a C++ codebase and if the API is tweaked to properly support destructors, which it should be able to do without needing to compile the interpreter itself as C++!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/exceptions-or-longjmp-across-client-c-c-code/2354">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/exceptions-or-longjmp-across-client-c-c-code/2354</link>
          <pubDate>Sat, 21 Dec 2024 17:19:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2354</guid>
          <source url="https://forum.rebol.info/t/exceptions-or-longjmp-across-client-c-c-code/2354.rss">Exceptions or longjmp() Across Client C/C++ Code</source>
        </item>
        <item>
          <title>The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Overall, I have been tremendously happy with how the ideas of the <strong><a href="https://forum.rebol.info/t/big-alien-proposal-word-runs-functions/1905">Big Alien Proposal</a></strong> have worked out.</p>
<p>That started from the concept that when slashes appear, they either come <em>before</em> a function they run, or <em>after</em> a function they suppress execution for.</p>
<pre><code>foo.bar
; ^-- foo is an entity from which BAR is being selected.  BAR is not
; allowed to be an antiform frame, so this syntax cannot invoke a
; function call (though it can invoke an 'accessor', e.g. a "getter"
; which is 0-arity).

foo/bar
; ^-- foo is an entity from which BAR (an a FRAME! or antiform FRAME!)
; is being selected and then invoked.  This will generate an error if
; bar is not a frame or antiform frame.

foo.bar/
; ^-- bar is a field which is an antiform FRAME!, whose execution is
; being suppressed.  This expression will return an antiform frame, or
; an error if not an antiform frame.

foo
; ^-- conventional WORD! reference, will run an antiform frame as an
; action invocation or fetch other values as-is

/foo
; ^-- invocation reference, will run an antiform frame (or plain frame)
; as an action invocation and give errors on other types

foo/
; ^-- action suppression, will give you back an antiform frame as-is
; and error on other types.
</code></pre>
<p><em>(If you're curious about why <strong><code>/foo</code></strong> will run plain FRAME! as well as antiform, while <strong><code>foo/</code></strong> will not return an antiform frame for plain FRAME!, this is based on the idea that it's better to be conservative when fetching values so that you won't get surprised by getting a plain frame back from <strong><code>foo/</code>~</strong> which gives everything back as-is.)</em></p>
<hr>
<p>I've written elsewhere <a href="https://forum.rebol.info/t/trailing-slash-is-a-winner-for-defused-actions/2327">how pleased I am that the way you suppress a function's execution is by throwing up a "barrier"</a> with a separating slash that makes it clear arguments are not being gathered at the callsite.  That's really slick.</p>
<p>For this idea to work, something else had to be used for refinements.  That meant <a href="https://forum.rebol.info/t/introducingnew-chain-datatype/2226">invention of the CHAIN! datatype</a> has opened a lot of interesting doors, and I find it's quite learnable to see things like <strong><code>trim:auto:tail</code></strong> instead of <strong><code>trim/auto/tail</code></strong>.</p>
<p><em>I actually prefer it!</em>  What some might think of a disadvantage of being "less noticeable" turns into an advantage... <strong><code>trim:auto</code></strong> really could have been a function called <strong><code>trim-auto</code></strong> just as easily.  Why would you want a slash to make the fact that it has a refinement "pop"?  The slashes to make function calls or suppression pop are much better applied.</p>
<p><strong>So that's all good. <img src="https://forum.rebol.info/images/emoji/twitter/smile_cat.png?v=12" title=":smile_cat:" class="emoji" alt=":smile_cat:" loading="lazy" width="20" height="20"> No regrets!</strong></p>
<h2><a name="p-7975-but-leading-slash-for-functions-rule-hasnt-100-geld-1" class="anchor" href="https://forum.rebol.info#p-7975-but-leading-slash-for-functions-rule-hasnt-100-geld-1"></a>But... Leading-Slash For Functions Rule Hasn't 100% Gel'd</h2>
<p>Another part of the proposal was that in order to get tighter control on what was a function or not, you would be required to assign functions using a leading-slash kind of SET-WORD!.</p>
<pre><code>&gt;&gt; foo: func [a b] [return a + b]
** Error: FOO: can't be used to assign antiform FRAME!, use /FOO:

&gt;&gt; /foo: func [a b] [return a + b]
== ~#[frame! "foo" [a b]]]~  ; anti
</code></pre>
<p><strong>It hasn't fully settled with me after working with it for some time.</strong></p>
<p>As I mentioned above, colons for refinements was easy to adapt to...and now that I'm adapted, I prefer it.</p>
<p>But I'm still typing <strong><code>test: cascade [add/ even?/]</code></strong>.  I love the trailing slashes (and this will be even better when the whole cascade can be done with just <strong><code>even?/add/</code></strong>).  But I'm kind of cursing under my breath the thought of having typed <strong><code>test:</code></strong> and having to backspace over it so it says <strong><code>/test:</code></strong>.  And then I go "hrmph."</p>
<p>When I'm reading code, I probably appreciate it more than I find it to be "messy".  It gives you a better compass.  The eye can scan and comprehend much better... it's of particular value when you're not using an obvious function generator like FUNC, but something else.  This cues readers to go "oh, I guess that's a function generator".</p>
<p>Yet still... it's a burden in a way the other changes are not.  It's the only change that increases the character count.</p>
<h2><a name="p-7975-whats-at-stake-by-not-enforcing-this-2" class="anchor" href="https://forum.rebol.info#p-7975-whats-at-stake-by-not-enforcing-this-2"></a>What's At Stake By Not Enforcing This?</h2>
<p>Ren-C has a powerful story about how antiforms can't be put in blocks, which means you can write this kind of code and it "just works":</p>
<pre><code>block2: collect [
    for-each 'item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<p>When you compare it to Rebol2/R3-Alpha/Red, it's one of those vastly superior situations.  You aren't getting tricked into receiving an ITEM in the FOR-EACH that would generate an unset variable error, or conflate with the state that gets returned when an item can't be picked from a block, or accidentally run a function.  It's a solid solution.</p>
<p>But that's only for blocks.  What about other places, like objects?</p>
<p>If we don't put barriers on how action antiforms get assigned to variables, we get the problem all over again:</p>
<pre><code>for-each [key value] obj [
    if integer? value [  ; oops, what if VALUE is an action antiform!
        print "Found an integer"
    ]
]
</code></pre>
<p>There's no way in this case to say "variables can't hold antiforms".  Logic is an antiform.  Words holding antiform frames are actions.</p>
<p>Getting this under control with slashes is the kind of thing I've been trying to do for a long time, I've just never had the syntax.  Leading slashes felt like it could be the key:</p>
<pre><code>for-each [key value] obj [...]  ; value can't be frame antiform

for-each [key /value] obj [...]  ; value must be frame antiform

for-each [key ~/value] obj [...]  ; value may be frame antiform
</code></pre>
<p>But if these rules are applied everywhere, what you have to do gets more complex:</p>
<pre><code>set $x does [print "Is this an error?"]

set $/x does [print "Do you have to do this?"]

&gt;&gt; var: $x
== x  ; bound

set var does [print "If this errors, how to make VAR into bound /x?"]

set:active var does [print "Do you use refinements?"] (or just SET:ANY ?)
</code></pre>
<p>Nothing is free.  And the already more complicated world where <strong><code>x:</code></strong> is a CHAIN! instead of a fundamental different type of word has its own issues, that these all pile on top of.</p>
<h2><a name="p-7975-theres-likely-not-enough-value-in-optional-slash-3" class="anchor" href="https://forum.rebol.info#p-7975-theres-likely-not-enough-value-in-optional-slash-3"></a>There's Likely Not Enough Value In Optional Slash</h2>
<p>If <strong><code>/foo: func [...] [...]</code></strong> will enforce that the thing you're assigning is an antiform action, but <strong><code>foo: func [...] [...]</code></strong> still works... I have a feeling that the complexity it takes to offer the feature doesn't give a sufficient payoff to be worth it.</p>
<p>You have everyone paying the tax of dealing with complicated path structures and bookkeeping--vs. being able to just SET and GET words and tuples at will... and then you're not even giving any additional guarantees in the source.</p>
<p>This makes me feel like it really is an all-in or not-at-all situation.</p>
<h2><a name="p-7975-long-story-short-im-still-weighing-it-4" class="anchor" href="https://forum.rebol.info#p-7975-long-story-short-im-still-weighing-it-4"></a>Long Story Short: I'm Still Weighing It</h2>
<p>I'm not ready to make a verdict.</p>
<p>The techniques for working with these new CHAIN! and PATH! situations are still being learned.  Most of my hesitance isn't from the looks or typing an extra character, but from frustrations in that...and maybe that frustration will lessen as I work on it more.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-grand-leading-slash-safety-or-burden-question/2352">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-grand-leading-slash-safety-or-burden-question/2352</link>
          <pubDate>Thu, 19 Dec 2024 01:12:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2352</guid>
          <source url="https://forum.rebol.info/t/the-grand-leading-slash-safety-or-burden-question/2352.rss">The Grand Leading-Slash &quot;Safety, or Burden?&quot; Question</source>
        </item>
        <item>
          <title>C++ Magic for LVALUE Checking...or Use Functions?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>If you write traditional C like:</p>
<pre><code>BINDING(cellA) = BINDING(cellB);
</code></pre>
<p>Regardless of what the BINDING() macro expands to, there's no way to do any sort of validation in any build (debug or otherwise).  Whatever this becomes can only be a simple assignment.</p>
<p>But if you instead wrote:</p>
<pre><code>Tweak_Binding(cellA, Binding_Of(cellB));
</code></pre>
<p>Then even if the intent is just a simple assignment in a release build, you could define that in a checked build to something that runs arbitrary code :</p>
<pre><code>#if NO_RUNTIME_CHECKS
    #define Tweak_Binding(dest,src) \ 
        (dest)-&gt;extra.binding = (src)-&gt;extra.binding
#else
    #define Tweak_Binding(dest,src) \
        Tweak_Binding_With_Added_Checks((dest), (src))
#endif
</code></pre>
<p><strong>But if you're willing to confine your extra checks to C++ builds, you can leave the source looking like <code>BINDING(cellA) = BINDING(cellB)</code></strong></p>
<p>This is because C++ has operator overloading, and you can create a wrapper class which "does the right thing", e.g. notices whether a <code>BINDING(...)</code> is used as a left hand side operator or right side operator.</p>
<h2><a name="p-7972-just-because-i-can-does-that-mean-i-should-1" class="anchor" href="https://forum.rebol.info#p-7972-just-because-i-can-does-that-mean-i-should-1"></a>Just Because I Can, Does That Mean I Should?</h2>
<p>Most of my original rationale was that I didn't want the source to make it look like you were making a function call when you were not.</p>
<p>When you see something like <code>Tweak_Binding(...)</code> you don't know how many instructions that's going to be, or what side effects its going to have.  But when you see a plain assignment (that you know compiles in C to something quite simple), then that tells you not much is going on.</p>
<p>However...I specifically came up with the term <strong><code>"Tweak"</code></strong> as a convention for functions like this that do very little.  It's a pretty good name, and it's learnable to say "oh, if it says Tweak, that means it's as cheap as an assignment".</p>
<p>Here are some of the points to consider:</p>
<ol>
<li>
<p>Because things like BINDING() are doing weird magic allowing them to be on the left side of assignments, by convention I believe they must be in all caps.  This is kind of noisy.</p>
<ul>
<li>On the plus side, it can be brief, with the same term used for extracting and for tweaking.  Since datatypes use the leading-caps with no underscore convention, plain <strong><code>Binding()</code></strong> looks like a parameterized datatype, so it would have to be <strong><code>Binding_Of()</code></strong> for the extractor</li>
</ul>
</li>
<li>
<p>Using C++ magic to get the RUNTIME_CHECKS means the C build won't have assertion-parity with the C build.  Bugs that only happen in the C build (perhaps on platforms that only offer C) would thus be harder to find.</p>
</li>
<li>
<p>The C++ operator overloading is going to be over the heads of those reading the code who only know C.</p>
</li>
<li>
<p>In debug builds, the C++ compilers do not inline the operator overloading, constructors, etc. that are involved in making the weird objects that are behind the scenes making the trick work.  That means using the C++ debugger to step into an expression like <strong><code>BINDING(cellA) = BINDING(cellB)</code></strong> takes an annoying number of step-in and step-out operations.</p>
</li>
</ol>
<h2><a name="p-7972-heres-the-scary-implementation-2" class="anchor" href="https://forum.rebol.info#p-7972-heres-the-scary-implementation-2"></a>Here's The "Scary" Implementation</h2>
<p>It really isn't rocket science, but it is something.  And it's something that can't be compiled by plain C compilers, meaning you can't do DEBUG_CHECK_BINDING in C builds.</p>
<pre><code>#if (! DEBUG_CHECK_BINDING)
    #define BINDING(cell) \
        *x_cast(Context**, m_cast(Node**, &amp;(cell)-&gt;extra.node))
#else
    struct BindingHolder {
        Cell* &amp; ref;

        BindingHolder(const Cell* const&amp; ref)
            : ref (const_cast&lt;Cell* &amp;&gt;(ref))
        {
            assert(Is_Bindable_Heart(Cell_Heart(ref)));
        }

        void operator=(Stub* right) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = right;
            Assert_Cell_Binding_Valid(ref);
        }
        void operator=(BindingHolder const&amp; right) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = right.ref-&gt;extra.node;
            Assert_Cell_Binding_Valid(ref);
        }
        void operator=(nullptr_t) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = nullptr;
        }
        template&lt;typename T&gt;
        void operator=(Option(T) right) {
            Assert_Cell_Writable(ref);
            ref-&gt;extra.node = maybe right;
            Assert_Cell_Binding_Valid(ref);
        }

        Context* operator-&gt; () const
          { return x_cast(Context*, ref-&gt;extra.node); }

        operator Context* () const
          { return x_cast(Context*, ref-&gt;extra.node); }
    };

    #define BINDING(cell) \
        BindingHolder{cell}
#endif
</code></pre>
<h2><a name="p-7972-looking-at-them-side-by-side-3" class="anchor" href="https://forum.rebol.info#p-7972-looking-at-them-side-by-side-3"></a>Looking at them Side-By-Side</h2>
<pre><code>BINDING(cellA) = BINDING(cellB);

Tweak_Binding(cellA, Binding_Of(cellB));
</code></pre>
<p>I do feel a pretty strong bias for the briefer notation...</p>
<p>But I can see the argument for not doing the "weird" thing when there's no increase in functionality... in fact, only losing functionality in C builds.  <em>(Most C++-isms are there to add something that would be fundamentally not possible in C, vs. just syntax sugar like this.)</em></p>
<p>The invention of the "Tweak" term does change my calculation a little bit here.  Because if it's used only in these "single-assignment-equivalent" circumstances, you can comprehend it as a C assignment statement.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/c-magic-for-lvalue-checking-or-use-functions/2350">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/c-magic-for-lvalue-checking-or-use-functions/2350</link>
          <pubDate>Thu, 12 Dec 2024 13:07:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2350</guid>
          <source url="https://forum.rebol.info/t/c-magic-for-lvalue-checking-or-use-functions/2350.rss">C++ Magic for LVALUE Checking...or Use Functions?</source>
        </item>
        <item>
          <title>About the C/C++ Implementation category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>C/C++ Implementation</category>
          <description><![CDATA[
            <p>This category is for discussing issues in the source code for the interpreter itself.</p>
<p>e.g. what versions of the C or C++ language spec are supported, or how variables are named, or anything pertinent to that.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-c-c-implementation-category/2349">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-c-c-implementation-category/2349</link>
          <pubDate>Thu, 12 Dec 2024 12:22:15 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2349</guid>
          <source url="https://forum.rebol.info/t/about-the-c-c-implementation-category/2349.rss">About the C/C++ Implementation category</source>
        </item>
        <item>
          <title>HIJACK-protection: Preserve a Weird Feature? :face_with_diagonal_mouth:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>The HIJACK functionality was proposed by <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a>, many years ago:</p>
<pre><code>&gt;&gt; /foo: func [x] [print ["FOO" (x + 1)]
&gt;&gt; /foo-reference: foo/

&gt;&gt; foo 20
FOO 21

&gt;&gt; foo-reference 20
FOO 21

&gt;&gt; /bar: func [x] [print ["HIJACKED!" (x + 1000)]

&gt;&gt; hijack foo/ bar/

&gt;&gt; foo 20
HIJACKED! 1020

&gt;&gt; foo-reference 20
HIJACKED! 1020
</code></pre>
<p>And so, way back when... I worked up a mechanic for how to do this.  There's some nuance to how efficient it can be, based on whether the thing you're hijacking uses a parameter list that's in the same "derivation chain".</p>
<p>While it was originally a somewhat fringe feature, it became central to certain parts of the implementation--including the web ReplPad.</p>
<h2><a name="p-7968-what-if-you-want-to-use-the-old-implementation-1" class="anchor" href="https://forum.rebol.info#p-7968-what-if-you-want-to-use-the-old-implementation-1"></a>What If You Want To Use The Old Implementation?</h2>
<p>Note that all references to the old function will run the hijacker.  What if you wanted the old implementation?</p>
<p>The seemingly simplest answer would be to return the old implementation under a new identity by HIJACK:</p>
<pre><code>&gt;&gt; /foo: func [x] [print ["FOO" (x + 1)]
&gt;&gt; /bar: func [x] [print ["HIJACKED!" (x + 1000)]

&gt;&gt; /foo-old: hijack foo/ bar/

&gt;&gt; foo 20
HIJACKED! 1020

&gt;&gt; foo-old 20
FOO 21
</code></pre>
<h2><a name="p-7968-but-i-did-something-different-2" class="anchor" href="https://forum.rebol.info#p-7968-but-i-did-something-different-2"></a>But I Did Something Different...</h2>
<p>In that old era of ACTION! and FRAME! as distinct types, I decided to be clever.</p>
<p>I said that COPY of an ACTION! would create a new action identity that ran the same code... but that wouldn't be affected by a HIJACK of the old action.</p>
<pre><code>&gt;&gt; /foo: func [x] [print ["FOO" (x + 1)]
&gt;&gt; /bar: func [x] [print ["HIJACKED!" (x + 1000)]

&gt;&gt; /foo-copy: copy foo/ 

&gt;&gt; hijack foo/ bar/

&gt;&gt; foo 20
HIJACKED! 1020

&gt;&gt; foo-copy 20
FOO 21
</code></pre>
<p>So HIJACK didn't return anything.</p>
<p>On the one hand: this is strictly more powerful, it means any code anywhere can make a new identity and ensure it won't be affected by <em>subsequent</em> HIJACKs of the original function.</p>
<p>It also lets you avoid ordering problems:</p>
<pre><code> hijack foo/ (adapt copy foo/ [print "Doesn't need an extra step!"])
</code></pre>
<p>You'd have to do this in multiple steps otherwise, with some kind of dummy hijacking:</p>
<pre><code> /old-foo: hijack foo/ noop/
 hijack foo/ (adapt old-foo/ [print "Without COPY, you have to do this"])
</code></pre>
<p>So it seemed superior.</p>
<p>BUT this turned out to be more complicated to implement, and opens a bit of a can of worms about the meaning of COPY.</p>
<h2><a name="p-7968-what-should-could-copy-an-action-mean-3" class="anchor" href="https://forum.rebol.info#p-7968-what-should-could-copy-an-action-mean-3"></a>What Should (Could?) "COPY an ACTION" Mean?</h2>
<p>Let's just simplify matters a little and think about the actions which have an implementation "BLOCK!" behind them...what I've called the "Details Array".</p>
<p>You might imagine that making a copy that would not be subject to the same HIJACK-ings is as easy as making a copy of that array.  Maybe (?) that sounds a little expensive, but, you'd imagine this isn't done <em>too</em> often.</p>
<p>However, consider something like this:</p>
<pre><code>&gt;&gt; /g: generator [yield 1 yield 2 yield 3]

&gt;&gt; g
== 1

&gt;&gt; /g-copy: copy g/

&gt;&gt; g
== 2

&gt;&gt; g-copy
== ???  ; what do you think?
</code></pre>
<p>There's actually a huge problem here, in that the Details Array contains delicate state.  You can't just assume duplicating that state is going to lead to a situation that won't be confused or crashy.  It may contain unique pointers that one of the instances assumes it can free because it thinks it is unique.</p>
<p>Given this reality, the interaction between COPY of ACTION! and HIJACK was very crafty.  The HIJACK only did a <em>minor</em> disruption to the original Details array, basically rewriting a bit of it to say "you've been hijacked" but leaving the contents of the array state in place.  Copies were small stubs that could chain through to the original Details identity--and despite the fact that it had been hijacked, still run it.</p>
<p>But things got fairly twisted.  This meant HIJACK couldn't be simple, and function copies became strange beasts that had to be conscious of the possibility that they were representations of hijackings and be conditional and that.</p>
<h2><a name="p-7968-further-copy-of-action-is-now-copy-of-frame-4" class="anchor" href="https://forum.rebol.info#p-7968-further-copy-of-action-is-now-copy-of-frame-4"></a>Further... COPY of "action" is Now COPY of FRAME!</h2>
<p>The unification of FRAME! and action brought about a bit of a semantics problem.</p>
<p>COPY of an "action" now is just a mechanism of getting another FRAME! with the same parameters, that you can tweak.  It doesn't imply anything about "protect against hijacking".</p>
<p>Hence this notion of "make new action identity that can't be hijacked" would have to be some new operator, not COPY.</p>
<p>We're thus talking about something called <strong><code>make-unhijackable-reference</code></strong>.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7968-or-just-say-screw-it-hijack-returns-new-identity-5" class="anchor" href="https://forum.rebol.info#p-7968-or-just-say-screw-it-hijack-returns-new-identity-5"></a>Or... Just Say "Screw It", HIJACK Returns New Identity?</h2>
<p>This is almost certainly the best answer.</p>
<p>Redoing this doesn't necessarily rule out the idea of inventing MAKE-UNHIJACKABLE-REFERENCE some day.  But that would mean a hijacking would have to preserve the old implementation in a more "costly" way than it has historically, and those references would also be more costly.</p>
<p>Seeing it relatively clearly after having written this post, I think the added cost would be the right way to do it, if this feature were decided to actually matter to anyone.</p>
<p>So far the only uses of COPY of action to avoid hijackability have been done at the moment of hijacking, to re-use the implementation as part of the hijacking.  The concept of "shielding references from HIJACK" for any other reason is not something that I can think of applications for.</p>
<p>(If you are the one exporting a function, and you think you someone might hijack it and you don't want to be subject to those hijackings, you can export an ADAPT with an empty block...or something of that sort...and then your implementation is safe, because if someone hijacks that adaptation it won't affect what the adaptation called.)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/hijack-protection-preserve-a-weird-feature/2348">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/hijack-protection-preserve-a-weird-feature/2348</link>
          <pubDate>Wed, 11 Dec 2024 12:53:48 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2348</guid>
          <source url="https://forum.rebol.info/t/hijack-protection-preserve-a-weird-feature/2348.rss">HIJACK-protection: Preserve a Weird Feature? :face_with_diagonal_mouth:</source>
        </item>
        <item>
          <title>Default Values and MAKE FRAME! - 2024 Edition</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <blockquote>
<p><em><strong>NOTE:</strong> The below summarizes history with some adjustments made for simplification purposes.  See posts in <a href="https://forum.rebol.info/c/archive/61">Archive</a> regarding frames for all the exact detours.</em></p>
</blockquote>
<hr>
<p>Something like this has worked ever since the first FRAME!:</p>
<pre><code>f: make frame! append/
f.series: [a b c]
f.value: 10

&gt;&gt; eval f
== [a b c 10]
</code></pre>
<p>Notice that although APPEND has refinements, you don't have to explicitly go through and set them to NULL.  That was done for you.</p>
<p>That might make you think the result of <strong>(make frame! append/)</strong> looked like this:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [  ; you might think...
    series: ~null~
    value: ~null~
    part: ~null~
    dup: ~null~
    line: ~null~
]]
</code></pre>
<p>e.g. all fields defaulting to null, whether they are refinements or not.</p>
<h2><a name="p-7965-thats-not-what-it-did-here-is-why-1" class="anchor" href="https://forum.rebol.info#p-7965-thats-not-what-it-did-here-is-why-1"></a>That's Not What It Did... Here Is Why</h2>
<p>Even before the full-on unification of ACTION! and FRAME! into one datatype, there was a concept that you could make an action out of a frame.  This meant some state of the frame variables had to represent the idea that an argument was still to be gathered.</p>
<p>The goal was something like this:</p>
<pre><code>f: make frame! append/
f.value: 10
; don't assign f.series, leave it however it was

&gt;&gt; run f [a b c]
== [a b c 10]
</code></pre>
<p>If all the argument slots were eagerly set to <strong><code>~null~</code></strong> then you'd get something like:</p>
<pre><code>&gt;&gt; run f [a b c]
** Error: APPEND doesn't allow ~null~ for its VALUE argument
</code></pre>
<p>So instead, MAKE FRAME! would leave the slots all unset, to indicate they were unspecialized:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]]
</code></pre>
<p>If it got to the point of execution, optional parameters (e.g. refinements) would be turned from NOTHING into NULL implicitly.  But if you didn't set a slot for a required parameter, it would give a helpful error:</p>
<pre><code>f: make frame! append/
f.value: 10

&gt;&gt; eval f
** Error: APPEND's SERIES argument is unspecified
</code></pre>
<h2><a name="p-7965-but-what-if-you-want-to-specialize-to-nothing-2" class="anchor" href="https://forum.rebol.info#p-7965-but-what-if-you-want-to-specialize-to-nothing-2"></a>But What If You Want To Specialize To Nothing?</h2>
<p>It might seem that "nothing" is a rare thing to want to specialize to.  But it's a legitimate value, and represents a valid frame state.</p>
<p>e.g. let's say you wanted to write UNSET as a specialization:</p>
<pre><code>/unset: specialize set/ [value: ~]
</code></pre>
<p>This would wind up making UNSET a synonym for SET.  Because it would think you were saying <em>"specialize SET's value to be unspecialized"</em>...which is what it was by default.</p>
<p>In this sense, using NOTHING as the unspecialized value just pushed the problem around a little bit.  No matter what you pick to represent the unspecialized state, you're going to have a problem.  It just happens that functions which take ~null~ antiforms are relatively common compared to those that take ~ antiforms.</p>
<h2><a name="p-7965-leveraging-meta-on-a-stable-antiform-3" class="anchor" href="https://forum.rebol.info#p-7965-leveraging-meta-on-a-stable-antiform-3"></a>Leveraging ^META On a Stable Antiform</h2>
<p>If you start thinking about being sneaky, you might imagine adding extra hidden bits somewhere to say <em>"no, this is a magic kind of specialized NOTHING"</em>.  But sneaky hidden bits are a tangled web, adding cost in the routines to manipulate them.</p>
<p>So the idea was to use a not-so-hidden bit: any function that could legitimately take "nothing" as an argument had to take it as a ^META parameter.</p>
<pre><code>x: 1020

f: make frame! set/
f.var: $x
f.value: first [~]  ; ~ is meta-NOTHING, aka "quasi-BLANK!", aka "TRASH"

&gt;&gt; eval f
== ~  ; anti

&gt;&gt; x
** Error: X is unset (antiform BLANK!)
</code></pre>
<p>This works, but creates an additional burden: functions that truly want to receive a value that can represent any stable form must take their arguments as ^META... which usually you'd think you only need for unstable forms.</p>
<h2><a name="p-7965-theres-still-an-ambiguity-gather-or-error-4" class="anchor" href="https://forum.rebol.info#p-7965-theres-still-an-ambiguity-gather-or-error-4"></a>There's Still an Ambiguity: Gather, Or Error?</h2>
<p>The above was the status quo for a couple of years: MAKE FRAME! gave you back a frame whose slots were all unset.  Those unset slots represented arguments that were unspecialized.</p>
<p>But still you have a question: should an unspecialized argument be gathered from a callsite, or should it trigger an error?</p>
<p>That decision came from the operation.  If you used EVAL on a FRAME!, it would assume all the frame slots were finalized...and any nothing cells would raise errors.  If you used RUN (or converted the FRAME! into an action) then it assumed the unspecialized slots meant you wanted to gather arguments.</p>
<h2><a name="p-7965-evolution-antiform-parameter-for-unspecialized-slots-5" class="anchor" href="https://forum.rebol.info#p-7965-evolution-antiform-parameter-for-unspecialized-slots-5"></a>Evolution: Antiform PARAMETER! For Unspecialized Slots</h2>
<p>A big change came through with a user exposure of the PARAMETER! type.  With antiform parameters representing unspecialized slots, you had the signal of "this is unspecialized", but also the information required to gather the parameter: what types it checked, whether it was a refinement or not, whether it should be taken literally from a callsite, etc.</p>
<p>This heralded even more exposure of the mechanics of function composition to user mode.  Instead of just specializing a function argument to a value, you could do things like "tweak" the argument's accepted types.</p>
<p>For instance: what if you wanted a version of APPEND that only appended integers?</p>
<pre><code>&gt;&gt; ap-int: make frame! append/

&gt;&gt; ap-int.value: anti make parameter! [integer!]  ; or whatever syntax
== ~#[parameter! [integer!]]~  ; anti

&gt;&gt; /ap-int: anti ap-int
== ~#[frame! ...]~  ; anti

&gt;&gt; ap-int [a b c] 1020
== [a b c 1020]

&gt;&gt; ap-int [a b c] "illegal"
** Error: AP-INT requires [integer!] for its value argument
</code></pre>
<p>This meant that MAKE FRAME! gave back something that looked rather weird:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~#[parameter! [
        ~void~ any-series? port! map! object! module! bitset!]
    ]~
    value: ~#[parameter! [~void~ element? splice?]]~
    part: ~#[parameter! :[any-number? any-series? pair!]]~
    dup: ~#[parameter! :[any-number? pair!]]~
    line: ~#[parameter! :[]]~
]]
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji only-emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<p>Although this gives you a useful and actionable information about the parameters, that's fairly noisy for most purposes.  You haven't done any assignments to the frame, and yet it looks like it's "full".</p>
<p>Let's put a pin in that.</p>
<h2><a name="p-7965-are-meta-exceptions-still-needed-6" class="anchor" href="https://forum.rebol.info#p-7965-are-meta-exceptions-still-needed-6"></a>Are ^META Exceptions Still Needed?</h2>
<p>In this model, there is no way of expressing a specialization of a function to an antiform parameter unless that function defined the parameter as ^META.</p>
<p>That doesn't <em>necessarily</em> mean we'd have to be prescriptive.  I mentioned that EVAL expects all the arguments to be specified to their final values, while RUN accepts some will be unspecialized.  So EVAL <em>could</em> treat antiform parameters as the actual values to pass, while RUN would gather them from the callsite.</p>
<p>This would produce a strange conflation.  You couldn't tell by looking at a frame whether or not an antiform parameter was a legitimate argument, or an unspecialized parameter definition.</p>
<p>As an example, consider the HOLE? function, that tells you whether or not a value is an antiform parameter.  Let's assume it's operating in a world that it doesn't need to take the argument as ^META:</p>
<pre><code>&gt;&gt; f: make frame! hole/
== #[frame! [value: ~#[parameter! [any-value?]]~]
</code></pre>
<p>The interface says it takes ANY-VALUE? as the first parameter to HOLE?  Yet we don't have any mechanical way of telling that <strong><code>f2</code></strong> isn't a completed frame for calling HOLE?.  So if EVAL accepts this:</p>
<pre><code>&gt;&gt; eval f
== ~okay~  ; anti
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>It really seems the best plan is to keep erroring when you try to EVAL frames with antiform PARAMETER! in them, when those parameters are required:</p>
<pre><code>&gt;&gt; eval f2
** Error: HOLE?'s VALUE parameter is unspecified (antiform PARAMETER!)
</code></pre>
<p>It does require the ^META exception: functions which need to accept antiform arguments must take that parameter in a meta form.  A function like HOLE? would fit into this category, and so would SET (which has to take unstable antiforms anyway, e.g. to do SET of a BLOCK! to a PACK)</p>
<p>Under this design, any function that can accept antiform parameters at all, will also able to be specialized with antiform parameters.</p>
<h2><a name="p-7965-denoising-make-frame-different-frame-makers-7" class="anchor" href="https://forum.rebol.info#p-7965-denoising-make-frame-different-frame-makers-7"></a>Denoising MAKE FRAME!: Different Frame Makers?</h2>
<p>I pointed out that having antiform parameters in frame slots is a bit noisy.</p>
<p>So what if there were two ways of making frames: one that gives you the parameter antiforms (suitable for tweaking and writing your own specialization operations), and another that clears the fields out?</p>
<p>For instance, keeping the old behavior for MAKE FRAME!:</p>
<pre><code>&gt;&gt; make frame! append/
== #[frame! [
    series: ~
    value: ~
    part: ~
    dup: ~
    line: ~
]]
</code></pre>
<p>But if you wanted antiform parameters, you could just copy the non-antiform version of the FRAME!:</p>
<pre><code>&gt;&gt; copy unrun append/
== #[frame! [
    series: ~#[parameter! [
        ~void~ any-series? port! map! object! module! bitset!]
    ]~
    value: ~#[parameter! [~void~ element? splice?]]~
    part: ~#[parameter! :[any-number? any-series? pair!]]~
    dup: ~#[parameter! :[any-number? pair!]]~
    line: ~#[parameter! :[]]~
]]
</code></pre>
<p>In this design, you'd have <em>two</em> stable forms which you'd have to use ^META conventions to take as an argument.</p>
<p>Antiform ~ would still have to turn into ~null~ if EVAL found it in a refinement slot.  But I'm not sure PARAMETER! antiforms would need to do that too.  One could argue that you should never be EVAL'ing a frame with antiform parameters in it, so it could be a sort of safety mechanism (?).  I'm not sure if it's necessary to enable, so I'd probably just raise an error until I saw a compelling case.</p>
<h2><a name="p-7965-is-the-added-nuance-worth-it-8" class="anchor" href="https://forum.rebol.info#p-7965-is-the-added-nuance-worth-it-8"></a>Is The Added Nuance Worth It?</h2>
<p>Continuing to handle unset variables as placeholders is not strictly necessary, given that antiform parameters are the more fundamental "unspecialized" slot representation.</p>
<p>But it's definitely a lot better than something I tried that <em>sucked</em>: which was trying to make variables holding antiform PARAMETER! act like they were unset.  This made manipulating function interfaces programmatically <em>very</em> painful.</p>
<p>It would mean sacrificing another value to have to be passed ^META.  Though bear in mind, most of the damage is done from having one form: e.g. a function like SET is having to take its value ^META already in order to be able to set things to antiform PARAMETER!.  So it isn't like you'd be able to specialize SET with antiform <code>~</code> to get UNSET if this wasn't done... it would affect the NOTHING? function (and probably not a lot else).</p>
<p><strong>Having used MAKE FRAME! a fair bit, I am inclined to believe it's worth it.</strong>  It's a clear indicator of whether you've assigned fields or not, with some teeth by actually making the variables unset (erroring on use before assignment, and reacting to things like DEFAULT).</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347</link>
          <pubDate>Sat, 07 Dec 2024 20:48:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2347</guid>
          <source url="https://forum.rebol.info/t/default-values-and-make-frame-2024-edition/2347.rss">Default Values and MAKE FRAME! - 2024 Edition</source>
        </item>
        <item>
          <title>Should (1 + #A) Equal (#A + 1) ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>I ran across this peculiarity:</p>
<pre><code>rebol2&gt;&gt; 1 + #"A"
== 66

rebol2&gt;&gt; #"A" + 1
== #"B"
</code></pre>
<p>Red and R3-Alpha do this too.</p>
<p>Loosely speaking, there's an internal policy which is something along the lines of <em>"if the types don't match, convert the second operand into the type of the first, and then do the add"</em>.</p>
<p>Because of this, it's necessary to support the addition of characters to each other to get <strong>(<span class="hashtag-raw">#A</span> + 1)</strong> to work:</p>
<pre><code>red&gt;&gt; #"A" + #"B"
== #"^(83)"  ; only useful in implementation of old coercion rule
</code></pre>
<p>...which seems nonsensical to me.</p>
<h2><a name="p-7963-what-do-other-languages-do-1" class="anchor" href="https://forum.rebol.info#p-7963-what-do-other-languages-do-1"></a>What Do Other Languages Do?</h2>
<p>If "implicit type promotion" is supported, many languages, including C, C++, and Java, use a system where the "smaller" type is converted to the "larger" type (<a href="https://pages.mtu.edu/~shene/COURSES/cs201/NOTES/chap02/exp-2.html">e.g., int to float</a>).  Having an idea of what's bigger and what's smaller helps avoid the commutativity problem.</p>
<p>And in the specific case of adding characters to integers, Rebol is weird to give a different answer depending on order.</p>
<ul>
<li>
<p><strong>Python:</strong> In Python, adding an integer to a character (or vice versa) would raise a TypeError. Python doesn't implicitly convert between these types.</p>
</li>
<li>
<p><strong>JavaScript:</strong> JavaScript would convert the character to its ASCII value and perform integer addition in both cases, resulting in a number.</p>
</li>
<li>
<p><strong>Ruby:</strong> Similar to Python, Ruby would raise a TypeError when trying to add an integer to a character.</p>
</li>
<li>
<p><strong>Java:</strong> Java doesn't allow direct addition between char and int types without explicit casting.</p>
</li>
</ul>
<p>I think adding integers to characters and wanting a character back is the more common operation, so if it's legal, I'd advocate for:</p>
<pre><code>&gt;&gt; 1 + #A
== #B

&gt;&gt; #A + 1
== #B
</code></pre>
<p>But if we want to rule out addition of characters to characters (which I do) this commutative behavior doesn't fall out from a system of implicit conversion with an ordering on "bigger" types... since characters are smaller.</p>
<p>I don't see an obvious "rule" besides hardcoding it.</p>
<h2><a name="p-7963-what-about-commutativity-in-general-2" class="anchor" href="https://forum.rebol.info#p-7963-what-about-commutativity-in-general-2"></a>What About Commutativity In General?</h2>
<p>We can imagine decisions on what you would make <strong><code>+</code></strong> mean that would not be commutative.  For instance, if you were allowed to make it mean "join strings":</p>
<pre><code>&gt;&gt; "abc" + "def"
== "abcdef"

&gt;&gt; "def" + "abc"
== "defabc"
</code></pre>
<p>So you might try and argue that the rules for <strong>add</strong> are different than the rules for <strong>+</strong>, and it's only when + is acting as ADD that it enforces commutativity.  However... even in the domain of math, you have exceptions... e.g. matrix multiplication is not commutative.</p>
<p>The more general question of commutativity seems to be that there aren't any popular languages that do it automatically.  e.g. in C++ you have to overload <strong><code>operator+(T1,T2)</code></strong> and <strong><code>operator+(T2,T1)</code></strong> separately...one of them can call the other, but that never happens automatically.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-1-a-equal-a-1/2346">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-1-a-equal-a-1/2346</link>
          <pubDate>Fri, 06 Dec 2024 12:30:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2346</guid>
          <source url="https://forum.rebol.info/t/should-1-a-equal-a-1/2346.rss">Should (1 + #A) Equal (#A + 1) ?</source>
        </item>
        <item>
          <title>Design for Something Like FLIP To Reverse Arguments</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="1238">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238/6">Parameter Order in Rebol</a></div>
<blockquote>
<p>If someone wants to specify the second parameter first they can always write <code>flip cons</code> or <code>flip snoc</code>.</p>
</blockquote>
</aside>
<p>The design of a FLIP-like operation raises some questions.</p>
<p>If it were an operator that acted on functions, it wouldn't retrigger them.  You'd have to say:</p>
<pre><code>&gt;&gt; append 'd [a b c]
== [a b c d]

&gt;&gt; run flip append/ [a b c] 'd
== [a b c d]
</code></pre>
<p>Alternately, I guess you could use slash to run a GROUP!, but then you'd have a disabling slash and a running slash:</p>
<pre><code>&gt;&gt; /(flip append/) [a b c] 'd
== [a b c d]
</code></pre>
<p>If it were instead something along the lines of RUN, where applying the flipped function was implicit, you could write:</p>
<pre><code>&gt;&gt; flip append/ [a b c] 'd
== [a b c d]
</code></pre>
<p>I don't think <strong><code>flip/append</code></strong> being a synonym for <strong><code>/(flip append/)</code></strong> is a generically useful idea, compared to the likes of <strong><code>not/even?/</code></strong> for cascading.</p>
<p>But if the <a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">weird idea of dialected CHAIN!</a> ever came to pass, FLIP could go into a distinct mode based on receiving a function in the place other functions have refinements...</p>
<pre><code>&gt;&gt; append/
== ~#[frame! [value series]]~

&gt;&gt; flip append/
== ~#[frame! [series value]]~

&gt;&gt; flip:append [a b c] 'd
== [a b c d]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/design-for-something-like-flip-to-reverse-arguments/2345">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/design-for-something-like-flip-to-reverse-arguments/2345</link>
          <pubDate>Mon, 02 Dec 2024 14:41:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2345</guid>
          <source url="https://forum.rebol.info/t/design-for-something-like-flip-to-reverse-arguments/2345.rss">Design for Something Like FLIP To Reverse Arguments</source>
        </item>
        <item>
          <title>The %rebol.r Boot File From Rebol 1.0</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>While we don't have the C source code for Rebol 1.0, we do have the <code>%rebol.r</code> initialization file:</p>
<p><a href="https://gist.github.com/hostilefork/d6cfac90141688bd41b1b38a9a203b02" class="inline-onebox">Rebol 1.0.2 Initialization File (October 7, 1998) Â· GitHub</a></p>
<p>It would seem that if there were an ability to pack source code in with the executable, they would have done it...given that the Quick Start says <em>"do not modify <code>rebol.r</code>. If you accidentally do modify <code>rebol.r</code>, reinstall it."</em></p>
<p><em><strong>Hence this is probably the entire portion of Rebol 1.0 that's written in Rebol, e.g. the whole "Mezzanine".</strong></em></p>
<p>It says:</p>
<pre><code>;;; Note: Code in rebol.r runs in the system context.  The system
;;; context [has] all the built in bindings of the user context, but also
;;; has extra bindings to allow rebol to be bootstrapped.  Many of the 
;;; rebol functions available in user code are actually written in
;;; terms of simpler rebol natives, or in terms of special
;;; system natives.

;;; REBOL reserves the right to change the system natives at any time, 
;;; so you shouldn't depend on them for portable code.
</code></pre>
<h1><a name="p-7953-remarks-on-contents-in-no-particular-order-1" class="anchor" href="https://forum.rebol.info#p-7953-remarks-on-contents-in-no-particular-order-1"></a>Remarks On Contents, In No Particular Order</h1>
<h2><a name="p-7953-func-definition-2" class="anchor" href="https://forum.rebol.info#p-7953-func-definition-2"></a>FUNC Definition</h2>
<pre><code>func: make function! [args body] [make function! :args :body]
</code></pre>
<p>I found it a bit interesting that the <a href="https://forum.rebol.info/t/rebol-1-0-2-users-guide/2340/6#p-7944-func-shortcut-5">User Guide talked about how FUNC was defined</a>, as an illustrative example, of an important thing for users to know about.  (It turns out there's a <a href="https://www.rebol.com/docs/core23/rebolcore-9.html">brief mention in the Rebol2 User's Guide</a>, but the Rebol 1.0 Guide writes it up twice, probably on accident.)</p>
<p>It's worth pointing out that there's big questions even in this seemingly simple definition.  Such as, should a function copy its arguments or body?  What should this do?</p>
<pre><code> body: [print "Hello"]
 foo: func [] body
 append body [print "Goodbye"]
 bar: func [] body
</code></pre>
<p>Does <strong>foo</strong> print just "Hello", or does it print "Hello" and "Goodbye"?</p>
<p>I don't yet know what Rebol1 did, but Rebol2's MAKE FUNCTION! would <em>not</em> copy the body.  So FUNC would do a deep copy as the "higher level" operator, before passing it to MAKE FUNCTION!.</p>
<p>But during bootstrap, it used a definition of FUNC that <em>didn't</em> copy the body, for performance reasons...which it switched over to the copying implementation at the end of boot.  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<p>Some version of these crazy optimizations are on the table for future Ren-C.</p>
<h2><a name="p-7953-print-prin-probe-3" class="anchor" href="https://forum.rebol.info#p-7953-print-prin-probe-3"></a>PRINT, PRIN, PROBE</h2>
<pre><code>write-block-or-element:
    make function! [port element] [
             do
                if block? :element [:write-block] else [:form-to-port]
                :port
                :element]

write-block: func [port block] [    ; !!! needs work
    foreach element :block [form-to-port :port :element form-to-port :port " "]
]

prin: func [value] [
    if block? :value [write-block output-port reduce :value]
    else [form-to-port output-port :value]
    exit
]

print: func [value] [
    prin :value
    linefeed-port output-port
    exit
]

probe: func [value] [
     prin " PROBE --&gt; "
     send output-port :value
     linefeed-port output-port
     :value
 ]
</code></pre>
<p>Weird.  (and prints a space after every element, so you get a space at the end of the line vs. just delimited between, etc.)</p>
<p>At least one interesting aspect of this is to see the rigid "EXIT" at the end to make sure that PRIN and PRINT don't leak a result on accident.  Things like this feel like a vindication of Ren-C's <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">requirement to use a RETURN</a> in order to give back a result from FUNC (but not LAMBDA).</p>
<h2><a name="p-7953-is-as-to-logic-4" class="anchor" href="https://forum.rebol.info#p-7953-is-as-to-logic-4"></a>IS? as TO-LOGIC</h2>
<pre><code>is?: func [value] [not not :value]
</code></pre>
<p>This was called TRUE? in Rebol2, and I very much disliked the ambiguity of that vs. testing to see if a value was <code>= #[true]</code> the LOGIC! literal.</p>
<p>I wrote something up about <a href="http://blog.hostilefork.com/did-programming-opposite-of-not/">how DID could be the opposite of NOT</a> (which even goes together as DIDN'T for DID NOT).  But due to some various shades of meaning the current state is that it means THEN? and DIDN'T means ELSE? as prefix tests for the trigger conditions that would run THEN or ELSE.  It needs thought.</p>
<p>Anyway, interesting to see the choice of <code>IS?</code> here.</p>
<h2><a name="p-7953-a-recursive-folding-any-and-all-interrobang-5" class="anchor" href="https://forum.rebol.info#p-7953-a-recursive-folding-any-and-all-interrobang-5"></a>A Recursive Folding ANY and ALL <img src="https://forum.rebol.info/images/emoji/twitter/interrobang.png?v=12" title=":interrobang:" class="emoji" alt=":interrobang:" loading="lazy" width="20" height="20"></h2>
<pre><code>any: func [block] [
    eval-one block
        make function! [value rest] [
            if not value [any rest]
            else [value]
        ]
        make function! [value] [value]
]

all: func [block] [
    eval-one block
        make function! [value rest] [
            if is? value [all rest]
            else [false]
        ]
        make function! [value] [value]
]
</code></pre>
<p>So this is based on a function called EVAL-ONE, that takes a list and two functions.  It isn't defined in %rebol.r and isn't in the reference guide either.  But it's a right fold with early termination.</p>
<p>One can definitely imagine the Joe Marshall and Carl friction on this (<em>"why are you making all these usermode functions and calls, why not just use a loop?"</em>).</p>
<p>While there's a time and a place for this, I do think that if you are starting to push out into the usermode layers and finding this mentality is driving it...you're going to end up with something that isn't hitting the mark that Rebol was aiming at.</p>
<h2><a name="p-7953-why-is-pick-so-weird-6" class="anchor" href="https://forum.rebol.info#p-7953-why-is-pick-so-weird-6"></a>Why Is PICK So Weird?</h2>
<pre><code>pick: func [series index] [
  do make function! [offset] [
    if (:offset + index? :series) &lt;= 1
        [none]
    else [do make function! [disp] [
            if (length? :disp) = 0 
               [none]
            else
               [&amp;peek :disp 0]
            ] skip :series if :offset &lt; 0 [:offset] else [:offset - 1]
         ]
    ] if logic? :index [if :index [1] else [2]] else [:index]
]
</code></pre>
<p>My guess here is that the pattern:</p>
<pre><code>do make function! [arg] [...code with arg...] value-for-arg
</code></pre>
<p>...is probably some holdover from before USE existed.  Or maybe USE is just an abstraction built on functions, and so it's done this way for optimization.  I dunno.</p>
<h2><a name="p-7953-poor-mans-export-7" class="anchor" href="https://forum.rebol.info#p-7953-poor-mans-export-7"></a>Poor-Man's EXPORT</h2>
<pre><code>;;; These functions can be defined in terms of system natives that are
;;; not available in the user context.  Since we made the functions in 
;;; this context, the values of the words in the body are relative to
;;; this context.  But we place the functions in the user context so
;;; that the users can call them.  This allows the user to call the
;;; system natives through a defined API in a controlled manner.

user-functions: [
    dir? [file] [do func [info] [info/dir?] info? :file]
    size? [file] [do func [info] [info/size] info? :file]
    ...
]

foreach [name args body] user-functions [
    context-set user-context name func args body
]
</code></pre>
<p>So the comment says what's going on here, it's the attempt to push functions out into the user context when they're implemented in terms of functions that aren't available in the user context.  I'm not sure what's not available <em>(these implementations of DIR? and FILE? are based on INFO?, is that not exported to the user context?)</em></p>
<p>As far as I know, there's nothing like this in Rebol2 (there's no separate <code>user-context</code> from a <code>system-context</code>, is there?)  Interesting if that was something that disappeared in Rebol2 and came back in Rebol3.</p>
<h2><a name="p-7953-more-modularization-eval-reduce-takes-context-8" class="anchor" href="https://forum.rebol.info#p-7953-more-modularization-eval-reduce-takes-context-8"></a>More Modularization: EVAL-REDUCE Takes Context</h2>
<pre><code>if not none? REBOL/script [
    if exists? REBOL/script [
        do make function! [] [
                top-level-continuation: :return
                if not REBOL/silent [
                        linefeed
                        prin "Loading script "
                        print REBOL/script]
                eval-reduce [do REBOL/script] user-context
                ]
        ]
    ]
</code></pre>
<p>Rebol1 seems to have been working with modularization ideas, because even during startup, the script you pass on the command line is run via something called EVAL-REDUCE that takes a parameter of where to do the evaluation.</p>
<p>So definitely a shame that Rebol2 seems to have moved away from the idea that evaluations needed to be done in a context.</p>
<h2><a name="p-7953-catch-is-defined-in-terms-of-catch-func-9" class="anchor" href="https://forum.rebol.info#p-7953-catch-is-defined-in-terms-of-catch-func-9"></a>CATCH is defined in terms of CATCH-FUNC</h2>
<p>We know from the <code>user-functions</code> exporting that this:</p>
<pre><code>catch [word block] [catch-func func reduce [word] :block]
</code></pre>
<p>Is actually:</p>
<pre><code>catch: func [word block] [catch-func func reduce [word] :block]
</code></pre>
<p>Since there's no type checking, there's a <code>:BLOCK</code> GET-WORD! just to be sure it's not a function, I guess?  And then it's FUNC's job to do a check in its implementation.  But then, why not <code>:WORD</code> just to be sure WORD! isn't a function you're calling?  <em>(I like pointing this out, due to Ren-C's better answers to this issue...avoiding the "pox of documenting what you <strong>don't</strong> know")</em></p>
<p>So the idea of using functions as proxies for "virtual binding" is the <em>old way</em>.  What's going on here is that the block contains code that wants to be bound to whatever the throw construct is, and so that block is made the body of a function, that you call and pass the thing you want bound to that name as the argument.  (COLLECT+KEEP worked this way).  But it's undesirable, because it means you've lost the fluidity of having the currency of a structural BLOCK!...replaced with the black box of a function just because you wanted to bind something.</p>
<p>I'm pretty sure this CATCH mechanic (being called a "continuation") is stackful and can't do anything too bizarre, but I'd like an executable to try and ensure that.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344</link>
          <pubDate>Sun, 01 Dec 2024 12:40:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2344</guid>
          <source url="https://forum.rebol.info/t/the-rebol-r-boot-file-from-rebol-1-0/2344.rss">The %rebol.r Boot File From Rebol 1.0</source>
        </item>
        <item>
          <title>The Probably-False Economy of EVAL Consuming FRAME!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>The earliest design usages for FRAME! were for things like ENCLOSE.</p>
<p>ENCLOSE builds the frame for the function you're enclosing, then passes the frame to a function that can manipulate the frame, and invoke it with EVAL (or not invoke it at all, if it wishes).</p>
<p>Here's a sort of simple historical example:</p>
<pre><code>/foo: func [a b] [
   let result: a + b
   a: b: ~&lt;whatever&gt;~  ; functions can modify args/locals for any reason
   return result
]

/bar: enclose foo/ (lambda [f [frame!]] [
    let b: f.b
    f.a: f.a * 10
    (eval f) + b
])

&gt;&gt; bar 100 10
== 1020  ; ((a * 10) + b) + b
</code></pre>
<p>You'll notice above that I didn't write:</p>
<pre><code>/bar: enclose foo/ (lambda [f [frame!]] [
    f.a: f.a * 10
    (eval f) + f.b
])
</code></pre>
<p>This is because EVAL of a FRAME! would "consume" the frame, and trying to use <strong><code>f.b</code></strong> after the EVAL would raise an error.  In other words, memory was not allocated as it usually would be for a new frame to do the call...but the fields of the frame were the actual values being used.</p>
<p>I overwrote <strong><code>a</code></strong> and <strong><code>b</code></strong> to make the point that once that EVAL is called, you can't rely on any particular state of a frame's variables.  In the general case, they can be changed to anything.</p>
<h2><a name="p-7936-eval-copy-f-is-easy-and-so-is-saving-variables-right-1" class="anchor" href="https://forum.rebol.info#p-7936-eval-copy-f-is-easy-and-so-is-saving-variables-right-1"></a><code>(eval copy f)</code> is Easy, and So Is Saving Variables, Right?</h2>
<p>The premise I was going on was that it seemed like it would be wasteful...especially in scenarios like an ENCLOSE, to make another copy of the frame's data.</p>
<p>And I figured usually you wouldn't need to refer to anything from the frame's input state after you called it.</p>
<p>So you had two choices: either evaluate a copy of the frame, or save any variables you were interested in as locals.</p>
<h2><a name="p-7936-it-turns-out-to-be-incredibly-common-to-save-variables-2" class="anchor" href="https://forum.rebol.info#p-7936-it-turns-out-to-be-incredibly-common-to-save-variables-2"></a>It Turns Out To Be Incredibly Common To Save Variables</h2>
<p>I didn't know when originally trying to optimize the feature how often an ENCLOSE would need to talk about the input fields after an EVAL call.</p>
<p>But empirically I'd say you need the fields at least half the time.  You actually want it more often than that when you consider debugging--you often want to print some information about the input parameters after you've done the EVAL.</p>
<h2><a name="p-7936-let-b-fb-costs-much-more-than-mallocmemcpy-3" class="anchor" href="https://forum.rebol.info#p-7936-let-b-fb-costs-much-more-than-mallocmemcpy-3"></a><code>(let b: f.b)</code> Costs Much More Than <code>malloc()+memcpy()</code></h2>
<p>When you come down to it, relatively speaking: <em>Evaluator cycles are expensive</em>.  <em>Tuple lookup is expensive</em>.  <em>Assignment is expensive</em>.  <em>LET statements are expensive</em>.</p>
<p>That's because this is an interpreted language, and running code in the interpreter involves pushing and popping entities that represent interpreter stack levels.  There's all kinds of C data structures and layers of C function calls as the gears of the machinery turn...whether your operation be simple or complex.  That's just the name of the game... <strong>a + b</strong> in a generalized evaluator is going to be at least 100x more costly than adding two integers in C, which is basically just a single CPU instruction.</p>
<p>So if you have to do <em>any</em> mitigation of losing the frame data by adding interpreted code, not only are you having to junk up what you're writing...but you're also paying much more than you would have if the system had just gone ahead and made a copy.</p>
<h2><a name="p-7936-explaining-why-you-cant-is-lamer-than-it-just-works-4" class="anchor" href="https://forum.rebol.info#p-7936-explaining-why-you-cant-is-lamer-than-it-just-works-4"></a>Explaining Why You Can't Is Lamer Than <em>"It Just Works"</em></h2>
<p>People understand that if they have a FRAME! for APPEND and they EVAL it, that the series is going to be mutated.</p>
<p>But they're going to understand less that the series field of the frame is not available at all to them after the call.</p>
<p>It's kind of a no-brainer to say that if the two approaches were at all comparable in speed or overall performance, that the more useful behavior should be the default.</p>
<p><em>And I actually believe the more useful behavior is faster in the general case...by avoiding additional intepreter cycles to save frame fields in variables.</em></p>
<h2><a name="p-7936-free-f-could-use-free-as-an-intrinsic-if-you-want-5" class="anchor" href="https://forum.rebol.info#p-7936-free-f-could-use-free-as-an-intrinsic-if-you-want-5"></a><code>(free f)</code> Could Use FREE As An Intrinsic If You Want</h2>
<p><strong><a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">FREE could be trivially made Intrinsic</a>.</strong></p>
<p>If profiling suggested that something like an ENCLOSE on a function with a large frame was affecting your bottom line by not freeing the frame, you could just free it after the EVAL.  That would leave behind nothing but a tiny useless stub (to avoid latent references in other cells from crashing the GC), so you'd get the same end result as the historical EVAL.</p>
<p>I'm betting that having EVAL be able to be intrinsic when it takes one argument, and making FREE intrinsic would be faster than trying to do some weird refinement like <strong><code>eval:free</code></strong> to fold both into one operation...because refinement processing has its own cost, which I <em>think</em> would be greater.</p>
<p>But an optimized <strong><code>eval-free</code></strong> might be worth making, I don't know.  However its mechanic would simply be to natively fold the free in after the EVAL, instead of trying to make EVAL take over the frame and use its memory.</p>
<p>My guess is that using EVAL-FREE won't be a benefit most of the time if you add any evaluator cycles to save a variable because of it.</p>
<h1><a name="p-7936-hence-eval-will-no-longer-consume-frame-6" class="anchor" href="https://forum.rebol.info#p-7936-hence-eval-will-no-longer-consume-frame-6"></a>Hence, EVAL Will No Longer Consume FRAME!</h1>
<p>This makes the "action-is-frame" duality even more solid, because as frames are passed around in the system there won't be "consume frame vs. don't" flags involved.</p>
<p>You'll just either free the frame after you've applied it, or you won't.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-probably-false-economy-of-eval-consuming-frame/2339">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-probably-false-economy-of-eval-consuming-frame/2339</link>
          <pubDate>Sun, 01 Dec 2024 00:50:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2339</guid>
          <source url="https://forum.rebol.info/t/the-probably-false-economy-of-eval-consuming-frame/2339.rss">The Probably-False Economy of EVAL Consuming FRAME!</source>
        </item>
        <item>
          <title>Simplifying Refinement Promotion</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>There are two modes of partial specialization which Ren-C has supported.</p>
<p>One form would be like if APPEND takes something like :DUP and fixes it to a value:</p>
<pre><code>&gt;&gt; append2: specialize append/ [dup: 2]

&gt;&gt; append2 [a b c] &lt;d&gt;
== [a b c &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>Then there's a trickier kind of specialization, which is to ask for the parameter but not specify it... thus just increasing the arity:</p>
<pre><code>&gt;&gt; appenddup: append:dup/

&gt;&gt; appenddup [a b c] &lt;d&gt; 4
== [a b c &lt;d&gt; &lt;d&gt; &lt;d&gt; &lt;d&gt;]
</code></pre>
<p>The second form is pretty unusual in the language world.  There doesn't seem to be much prior art in "the conversion of optional parameters to required parameters" (at least I don't know any, and the AIs I asked don't know any).</p>
<p>Since it's pretty different from what what people think of as partial specialization, let's call it <strong>"refinement promotion"</strong>.</p>
<h2><a name="p-7935-refinement-promotion-is-tricky-1" class="anchor" href="https://forum.rebol.info#p-7935-refinement-promotion-is-tricky-1"></a>Refinement Promotion Is <em>Tricky</em></h2>
<p>Something that has been non-negotiable in the design is the straightforward array of parameters and locals that specify a function interface.</p>
<p>Refinements are defined in some order in that array.  But you are not required to use them in that order.</p>
<p>So consider a definition like:</p>
<pre><code> /foo: func [a [integer!] :b [integer!] :c [integer!]] [...]
</code></pre>
<p>Someone might do refinement promotion of this as <strong><code>foo:c:b/</code></strong> - this makes it seem to the caller a function originally written with spec:</p>
<pre><code> [a [integer!] c [integer!] b [integer!]]
</code></pre>
<p>The techniques so far have tried to mimic the way that refinements work.  So <strong><code>get $foo:c:b</code></strong> would produce a function that was accompanied by a <strong><code>[c b]</code></strong> array, that would get pushed when running the promoted function.  The elements in the array would not just have the words, but those words would have binding information to say what index those words were found at in the parameter array.</p>
<p>But since the underlying array is left the same, this means every time you want to know something like "what's the first unspecialized normal argument" you have to mimic the refinement gathering process.  It convoluted the process quite a lot, and really went against the idea of the implementation being "simple".</p>
<h2><a name="p-7935-q-is-this-really-required-to-support-a-yes-2" class="anchor" href="https://forum.rebol.info#p-7935-q-is-this-really-required-to-support-a-yes-2"></a>Q: Is This Really Required To Support?  (A: Yes)</h2>
<p>This may not seem like a super-common need.  But if you're implementing a dialect that wants to support calling functions with refinements, it's pretty important.</p>
<p>Let's say you're implementing something like <a href="https://forum.rebol.info/t/if-action-combinators-dont-impress-what-will/1608">the feature in UPARSE that lets you call functions</a>:</p>
<pre><code>&gt;&gt; data: copy ""

&gt;&gt; parse ["a" "b"] [some [/append:dup (data) text! (2)]]

&gt;&gt; data
== "aabb"
</code></pre>
<p>Basically, if <strong><code>(get $/append:dup)</code></strong> can come back with a function that you can query for its parameters and get answers just like it was any other function, then support for refinements comes basically for free.</p>
<h2><a name="p-7935-should-the-varlist-just-be-rewritten-3" class="anchor" href="https://forum.rebol.info#p-7935-should-the-varlist-just-be-rewritten-3"></a>Should The VarList Just Be Rewritten?</h2>
<p>If you look at what a modern SPECIALIZE followed by AUGMENT can do, they can hide parameters...and then add back parameters with the same name.  Which parameters are visible depend on the "phase" of the frame.</p>
<p>So why couldn't refinement promotion be done just by making a new function interface that removes the argument as a refinement, and adds it back as a regular argument... then has a dispatch phase that moves the argument data to its old position for the subsequent phases?</p>
<p>It's not particularly "cheap" to do that, space-wise.  You'd need a new VarList* and a new Phase*, and the Phase would have to remember the new and old positions to do the rewrite.  But it would make parameter enumeration blunt and simple, because you'd really just be enumerating the parameters in order.</p>
<p>There'd be some cases where the position of the refinement would allow it to just be naturally rewritten to be a regular argument, and that could be optimized for.</p>
<h2><a name="p-7935-what-about-when-you-have-lots-of-local-4" class="anchor" href="https://forum.rebol.info#p-7935-what-about-when-you-have-lots-of-local-4"></a>What About When You Have Lots of <code>&lt;local&gt;</code>?</h2>
<p>This is kind of the dark side of the simple FRAME! model, which is that if you use it to create a lot of local variables, then operations like SPECIALIZE and AUGMENT which do VarList manipulation have to make copies of everything for the new VarList...including a bunch of locals that aren't changing at all in each new form.</p>
<pre><code>/foo: func [x [text!] y [tag!] &lt;local&gt; a b c d e f g h i j k l m n o p] [
    ... 19 frame cells (includes RETURN) ...
]

/bar: augment foo/ [z [integer!]]  ; z is last item in new 20 item frame
</code></pre>
<p>Refinement promotion would become another one of these situations that would do seemingly unnecessary duplication.</p>
<p>It would be possible in cases like this to create smaller frames and then proxy the results into larger ones, essentially simulating what a user might do to manually call FOO from a new function BAR which had a frame with 3 elements.</p>
<pre><code>/bar: lambda [x [text!] y [tag!] z [integer!]] [
    foo x y  ; imagine doing this, but with faster internal mechanics
]
</code></pre>
<p>Some calculation could be done where the size of the frame justified it.  I have a feeling that the frame would have to be reasonably large before a technique like this would be beneficial.</p>
<h2><a name="p-7935-what-about-refinements-at-headhttpsforumrebolinfotrefinement-arguments-at-head-of-args-list-not-tail2331-5" class="anchor" href="https://forum.rebol.info#p-7935-what-about-refinements-at-headhttpsforumrebolinfotrefinement-arguments-at-head-of-args-list-not-tail2331-5"></a>What About <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">Refinements At Head</a>?</h2>
<p>Well, in that case, you would <em>have</em> to build a new VarList* that extracted the arguments, and then proxy them into position for the new interface.</p>
<p>At least one wouldn't be worried about the "bloated copies of locals" situation.</p>
<h2><a name="p-7935-souse-the-auxiliary-array-simulating-refinements-6" class="anchor" href="https://forum.rebol.info#p-7935-souse-the-auxiliary-array-simulating-refinements-6"></a>So...Use The Auxiliary Array Simulating Refinements?</h2>
<p>The code for simulating refinements when asking simple questions like <em>"what's the first unspecialized normal arg"</em> is unappealingly complex. <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=12" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<p>Making it further unappealing is that when you have this array of refinements "off to the side" but still allow people to fill in slots in frames to specialize out arguments, you end up needing to have "reconciliation"...because those frame slots that are referenced by this out-of-band array are no longer part of the refinement promotion.</p>
<pre><code>&gt;&gt; f: make frame! append:dup:part/  ; has auxiliary [dup part]

&gt;&gt; f.dup: 3  ; what cleans up [dup part] to just [part] ?
</code></pre>
<p>I've talked about not knowing about what "moment" to do these kinds of fixes, and I'm increasingly looking for ways to avoid there being any such moment.  If the physical experience of the frame was that DUP and PART were ordinary parameters and not refinements, then it "just works".</p>
<h2><a name="p-7935-the-dumb-mechanical-answer-is-likely-best-7" class="anchor" href="https://forum.rebol.info#p-7935-the-dumb-mechanical-answer-is-likely-best-7"></a>The "Dumb" Mechanical Answer Is Likely Best</h2>
<p>I sometimes forget just how much I take for granted in Ren-C, regarding the ability to compose functions together.</p>
<p>The "inefficient" idea of making a new parameter list and then proxying the arguments into position would be more efficient than having to create and evaluate an interpreted function that had to manually copy the parameters.</p>
<p>There's a huge tax created by having to compose an off-to-the-side parameter reordering list in with the frame variables, and that tax is paid by <em>any code</em> that wants to interpret the list.  It's just too big a tax to pay.</p>
<p>It pains me a bit to delete it, because it was hard to write and seemed clever at the time.  But techniques have advanced...and while the auxiliary list may have seemed somewhat optimal for storage, it's no longer the right choice.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/simplifying-refinement-promotion/2338">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/simplifying-refinement-promotion/2338</link>
          <pubDate>Sat, 30 Nov 2024 21:20:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2338</guid>
          <source url="https://forum.rebol.info/t/simplifying-refinement-promotion/2338.rss">Simplifying Refinement Promotion</source>
        </item>
        <item>
          <title>UPARSE Combinator Return Conventions: Reviewed</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>UPARSE was an early client of multiple return values, at a time when they worked by assigning variables local to your frame, which were then proxied to items in a SET-BLOCK!:</p>
<pre><code> /multi-returner: func [
     return: [integer!]
     secondary: [integer!]  ; SET-WORD! indicated another return
 ][
     secondary: 20
     return 10
 ]

 &gt;&gt; [ten twenty]: multi-returner
 == 10

 &gt;&gt; ten
 == 10

 &gt;&gt; twenty
 == 20
</code></pre>
<p>This basically made every multi-return function a kind of infix operation, that was able to take a SET-BLOCK! on its left hand side.  <a href="https://forum.rebol.info/t/multiple-return-values-via-infix/1257">(In fact, it was prototyped using infix.)</a></p>
<p>But this method had composability problems, and was defeated by abstraction of any sort, even the most minor forms:</p>
<pre><code> &gt;&gt; [ten twenty]: (multi-returner)
 ** Error: even this wouldn't work
</code></pre>
<p>So the method gave way to returning antiform BLOCK!s.  These represented parameter packs that would "decay" to their first item in most circumstances...but SET-BLOCK!s were one of the cases that could pick them apart (though you could design other operations as well).</p>
<pre><code> /multi-returner: func [
     return: [~[integer! integer!]~]
 ][
     return pack [10 20]
 ]
</code></pre>
<p>You can read all about it in <strong><a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">The History of Multi-Return in Ren-C</a></strong></p>
<h2><a name="p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1" class="anchor" href="https://forum.rebol.info#p-7932-so-local-proxies-diedbut-uparse-mimicked-them-1"></a>So Local Proxies Died...But UPARSE Mimicked Them</h2>
<p>Just because the mechanics got rid of local proxies doesn't mean you can't fake them.  All you have to do is hack up its RETURN function to make a PACK using a local variable.</p>
<p>Simplified example:</p>
<pre><code> /proxy-multi-func: adapt func/ [
      body: compose $() inside body '[
          /return: adapt return/ [
             atom: pack [(unmeta atom) secondary]
          ]
          (as group! unbind body)  ; I wish this pattern were simpler
      ]
 ]

 /multi-returner: proxy-multi-func [
     return: [integer!]
     &lt;local&gt; secondary  ; could be specially marked, if spec rewritten
 ][
     secondary: 20
     return 10
 ]
</code></pre>
<p>So when the multi-return-by-antiform-block change happened, this is what COMBINATOR did instead of transition to having every combinator do <strong><code>return pack [synthesized remainder]</code></strong></p>
<p>Instead it worked the same as before: you'd set <strong>remainder</strong> however you wished, do <strong>return synthesized</strong>.  Except now the specialization of RETURN would PACK things up.</p>
<h2><a name="p-7932-why-did-combinator-preserve-proxying-2" class="anchor" href="https://forum.rebol.info#p-7932-why-did-combinator-preserve-proxying-2"></a>Why Did COMBINATOR Preserve Proxying?</h2>
<p>Well... for starters, to show that it could be done.  You <em>should</em> be able to do it.  So having a living test case to hammer through any issues was good.</p>
<p>Also, because some combinators have two return values (synthesized and remainder), while others add a third (pending).  In truth the combinator always needs to return a pack of 3, it's just that some combinators automatically pipe the pending results from successful combinators to the output.  This means even if your combinator returned a pack of 2 in the piped case, that would have to be broken apart and turned into a pack of 3.  Having it in components helps.</p>
<p>But generally, I think it makes the code clearer as well.  Saying <strong><code>(return pack [x y])</code></strong> doesn't have any labeling, while <strong><code>(remainder: y, return x)</code></strong> is somewhat clearer, and you don't need to label the "primary" result because that's understood as what the combinator is synthesizing.</p>
<h2><a name="p-7932-synthesized-cant-be-proxied-unless-meta-3" class="anchor" href="https://forum.rebol.info#p-7932-synthesized-cant-be-proxied-unless-meta-3"></a>Synthesized Can't Be Proxied (unless ^META)</h2>
<p>It's worth pointing out that there's a sort of design constraint here, when you're going to break out multi-return results and have them represented by local variables which are proxied by an adjusted RETURN...</p>
<p>...and that constraint is that you can't put unstable antiforms in variables.  So if you have something you want to return like an antiform pack (as combinators can legitimately synthesize), it has to be the main return result.</p>
<p>So since they use this proxying, combinators kind of break the rule of thumb of "don't make unstable antiforms your primary return in a multi-return situation".  This is because if you do:</p>
<pre><code>return pack [pack [1 2] "a"]
</code></pre>
<p>Then you face some ambiguity in terms of what people might think <strong><code>([x y]: multi-return-func)</code></strong> should mean... or what <strong><code>(x: multi-return-func)</code></strong> should mean.</p>
<p>But really, this is still being worked out.</p>
<h2><a name="p-7932-anyway-just-wanted-to-sum-up-uparse-return-4" class="anchor" href="https://forum.rebol.info#p-7932-anyway-just-wanted-to-sum-up-uparse-return-4"></a>Anyway, Just Wanted To Sum Up UPARSE RETURN</h2>
<p>I was questioning it, and wanted to kind of work through why it is the way it is.  But I think it's right.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/uparse-combinator-return-conventions-reviewed/2337">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/uparse-combinator-return-conventions-reviewed/2337</link>
          <pubDate>Thu, 28 Nov 2024 00:35:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2337</guid>
          <source url="https://forum.rebol.info/t/uparse-combinator-return-conventions-reviewed/2337.rss">UPARSE Combinator Return Conventions: Reviewed</source>
        </item>
        <item>
          <title>Issues With Querying A Function&#39;s &quot;RETURN&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Each FUNCTION has a local variable named RETURN.  When it's running, the cell for that variable points at an "archetypal return function".  But that cell also holds a reference to that specific function instantiation's frame.  This way it knows how to return specifically from that invocation of that function.</p>
<p>This "definitional return" concept has worked quite well.  But there are some fiddly issues that arise from trying to make RETURN an ordinary local variable.</p>
<h2><a name="p-7931-it-was-hoped-return-would-not-be-special-1" class="anchor" href="https://forum.rebol.info#p-7931-it-was-hoped-return-would-not-be-special-1"></a>It Was Hoped RETURN Would Not Be Special</h2>
<p>The idea is that LAMBDA would be lower-level than FUNCTION, and permit you to have parameters or local variables named RETURN that had nothing to do with returning.</p>
<pre><code>/demo: lambda [return continue] [
    return + continue
]

&gt;&gt; demo 1 2
== 3
</code></pre>
<p>So an aspirational aspect of the design was that a user could create something that operated identically to the FUNCTION abstraction (just a bit slower, due to not being implemented natively).</p>
<p>It would use something like THROW and CATCH, to implement RETURN (or construct(s) in that family) itself, as LAMBDAs synthesized upon instantiation.</p>
<h2><a name="p-7931-return-as-local-hides-its-type-information-2" class="anchor" href="https://forum.rebol.info#p-7931-return-as-local-hides-its-type-information-2"></a>RETURN as Local Hides Its Type Information</h2>
<p>While it's not an argument to the function, RETURN still has associated type information.</p>
<p>Since RETURN is a local that will be filled with an action when the function runs, it isn't using its frame slot until that invocation happens.  That means it can store a PARAMETER! which says what return types are legal.  (It seems like a good use of an otherwise-unused slot otherwise you'd need a slot in the Phase to hold it.)</p>
<p>Functions like HELP want to know those types.  Yet locals and specialized arguments are traditionally considered implementation details, hidden from callers.  They're only visible  when frames are captured during the "phase" of being inside the function call:</p>
<pre><code>&gt;&gt; /foo: function [return: [integer!] x] [
     print mold words of binding of $x
]

&gt;&gt; words of foo/
== [x]

&gt;&gt; foo
== [return x]
</code></pre>
<p>Today's unsatisfying solution is that there's a flag on parameters that represent RETURN.  If you want the type information of that return, you can ask for it:</p>
<pre><code>&gt;&gt; return of foo/
== ~#[parameter! [integer!]]~  ; anti
</code></pre>
<p>But this flag is only applied by the FUNCTION native when its construction the parameter list.  So you wouldn't (for instance) get this behavior on a usermode re-implementation of FUNCTION based on LAMBDA.</p>
<h2><a name="p-7931-how-to-change-return-in-composition-3" class="anchor" href="https://forum.rebol.info#p-7931-how-to-change-return-in-composition-3"></a>How To Change RETURN In Composition?</h2>
<p>Let's say you're going to build a higher-level function with something like ENCLOSE:</p>
<pre><code>&gt;&gt; /bar: enclose foo/ func [return: [tag!] f [frame!]] [
       print "I'm an enclosure!"
       eval f
       return &lt;tag&gt;
   ] 
</code></pre>
<p>The interface of an enclosed function is the same parameter list as the original, and the same returns as the original.  The enclosure is implemented as a function that takes a frame, and it can be given a new return type.  But today that isn't reported as the return type if you asked for HELP of FOO.  It would look at the original parameter list, which in this case says its RETURN is <strong><code>[integer!]</code></strong>.</p>
<p><em>This suggests that the answer to the question <strong><code>return of</code></strong> has to be dispatcher-specific.</em></p>
<p>FUNCTION would say "it's the contents of the RETURN local in the archetype (not overwritten with return function, so still a PARAMETER!)".</p>
<p>ENCLOSE would say "it's the return type of the enclosure function that takes the frame" but then give back the original parameter list for everything else.  (This raises a question of how you would inherit the original function's return... it might be nice if you used a LAMBDA or something that reported no return constraint, that it would default to the constraints of the function you were enclosing.)</p>
<p>In any case, if it was answered by the dispatcher... then if LAMBDA says "I don't have a RETURN", you'd not have HELP information on your RETURN if you were trying to build your own FUNCTION on top of LAMBDA.</p>
<p><strong>The word RETURN may be a distraction, here.</strong>  Because if it's something like a GENERATOR, the products are coming from calls to YIELD.  Maybe <strong><code>(result of ...)</code></strong> or <strong><code>(synthesis of ...)</code></strong> would help stress that this question isn't tied up specifically with RETURN.</p>
<h2><a name="p-7931-lambda-semantics-may-want-result-specification-4" class="anchor" href="https://forum.rebol.info#p-7931-lambda-semantics-may-want-result-specification-4"></a>LAMBDA Semantics May Want Result Specification</h2>
<p>The idea of LAMBDA is that the evaluative product just drops out <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">(see various writings on why FUNCTION does not allow that)</a>.</p>
<p>But just because you want that semantic, doesn't mean you don't want the HELP to not give a return type.</p>
<p>However, LAMBDA doesn't have anywhere to store the type information the way FUNCTION does.  If it has a RETURN it may be using it for unrelated purposes.</p>
<p>Given what I've proposed for the dispatcher-specific RETURN, you could accomplish it with an ENCLOSE:</p>
<pre><code> enclose (lambda [...] [...]) func [return: [&lt;spec&gt;] f] [return eval f]
</code></pre>
<p>But it seems clearly better to have something specific to this purpose:</p>
<pre><code> returns [&lt;spec&gt;] lambda [...] [...]
</code></pre>
<p>Then the Returns_Dispatcher() would simply type check what you gave it.</p>
<p>Perhaps it could even accept a function as a first parameter, and then just say it returns whatever that function returns:</p>
<pre><code>returns add/ lambda [x] [x + 1]
</code></pre>
<p>Though that might be more confusing than writing it out:</p>
<pre><code>returns (return of add/) lambda [x] [x + 1]
</code></pre>
<p>Maybe a refinement should be used to bless that you're doing it on purpose:</p>
<pre><code>returns:same-as add/ lambda [x] [x + 1]
</code></pre>
<p>I guess the big question would be how to get the return's textual description in there.  Maybe it could assume if the format is TEXT! BLOCK! that's what you mean:</p>
<pre><code>/foo: returns [
   "The input plus one"
   [integer!]
] lambda [x] [
    x + 1
]
</code></pre>
<h2><a name="p-7931-well-theres-some-ideas-5" class="anchor" href="https://forum.rebol.info#p-7931-well-theres-some-ideas-5"></a>Well, There's Some Ideas</h2>
<p>I guess the idea here is that mechanics for answering "what do you return" come from the function's dispatcher, and maybe that becomes a chained question where if the dispatcher wraps something else, it has to ask the right parts of that thing.  There may be no user-exposed mechanic for building your own answer to the question beyond something like RETURNS, which is probably good enough.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/issues-with-querying-a-functions-return/2336">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/issues-with-querying-a-functions-return/2336</link>
          <pubDate>Thu, 28 Nov 2024 00:00:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2336</guid>
          <source url="https://forum.rebol.info/t/issues-with-querying-a-functions-return/2336.rss">Issues With Querying A Function&#39;s &quot;RETURN&quot;</source>
        </item>
        <item>
          <title>Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In R3-Alpha, there was the idea that FUNC was lower-level, <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/base-funcs.r#L28C1-L56C2">and "FUNCTION" was built on top of it</a>.</p>
<p>Its principal difference was automatically collecting SET-WORD!s as locals.  But it added two refinements: <strong>/WITH</strong> and <strong>/EXTERN</strong>.</p>
<p>/EXTERN was a way of saying what shouldn't get collected as a local variable due to being a SET-WORD!:</p>
<pre><code>global-var: 10

foo: function/extern [arg1 arg2] [
    local-var: "hi"
    global-var: 20  ; /EXTERN protected this from being collected local
    return arg1 + arg2
] [global-var]
</code></pre>
<p>/WITH was a way of making static variables:</p>
<pre><code>accumulate: function/with [x] [
   return state: state + x
] [state: 0]
</code></pre>
<h2><a name="p-7923-early-on-ren-c-moved-everything-into-the-spec-1" class="anchor" href="https://forum.rebol.info#p-7923-early-on-ren-c-moved-everything-into-the-spec-1"></a>Early On, Ren-C Moved Everything Into The Spec</h2>
<p>I didn't like seeing the refinement arguments at the end (of what could be a very long function definition).</p>
<p>It didn't occur to me to suggest that <a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">refinement arguments be moved to the head</a> (which they probably should).  But what did occur to me was that the function spec could incorporate these properties.</p>
<p>I actually thought <code>&lt;with&gt;</code> seemed better than extern, as a nicer word for "Use these existing variables".  And <code>&lt;static&gt;</code> seemed like a well-known term for static variables:</p>
<pre><code>foo: function [arg1 arg2 &lt;with&gt; global-var] [
    local-var: "hi"
    global-var: 20
    return arg1 + arg2
]

accumulate: function [x &lt;static&gt; state (0)] [
   return state: state + x
]
</code></pre>
<p>The subtlety of wanting to use an object instance was also added, as <code>&lt;in&gt;</code>:</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [x &lt;in&gt; obj] [
   return a + b + x
]
</code></pre>
<p>To my eyes, that all seemed like improvement.</p>
<p><strong>But it didn't come without cost: The spec had to be transformed into something the lower-level FUNC could understand.</strong></p>
<p>This meant there was a layer of parsing and production of a new spec that was a tax on every function creation.</p>
<h2><a name="p-7923-time-passes-set-word-gathering-is-panned-2" class="anchor" href="https://forum.rebol.info#p-7923-time-passes-set-word-gathering-is-panned-2"></a>Time Passes, SET-WORD! Gathering Is Panned</h2>
<p>It didn't take long for me to decide that <a href="https://forum.rebol.info/t/rethinking-auto-gathered-set-word-locals/1150">SET-WORD! locals-gathering was bad</a>... a gimmick that only made sense in very limited domains (perhaps code-golf)</p>
<p>This motivated having an answer for how to implement LET, as "virtual binding" became the new plan.</p>
<p>Once that transition went through, the effect of <strong><code>&lt;with&gt;</code></strong> was to become commentary.  Since all it did was remove SET-WORD!s from the collection list, and there was no collection any longer.</p>
<p>Though virtual binding did open up a new possibility, that if your block had a different binding than the spec, then the WITH might import visibility of terms to that block:</p>
<pre><code>global-variable: 10

block: /get-block-from-somewhere ...  ; doesn't know about GLOBAL-VARIABLE

/foo: function [x &lt;with&gt; global-variable] block
</code></pre>
<p>But this would be a binding operation, that is better generalized as:</p>
<pre><code>/foo: function [x] (bind @global-variable block)
</code></pre>
<h2><a name="p-7923-pushing-the-features-to-bind-make-the-most-sense-3" class="anchor" href="https://forum.rebol.info#p-7923-pushing-the-features-to-bind-make-the-most-sense-3"></a>Pushing The Features To BIND Make The Most Sense</h2>
<p>Not just <code>&lt;with&gt;</code>, but the <code>&lt;static&gt;</code> and <code>&lt;in&gt;</code> features seemed to be better as BIND operations as well.</p>
<p>The static syntax of not using SET-WORD!s was based on the idea that SET-WORD!s were reserved for local variables (and RETURN: syntax).  So it was a WORD! followed by a GROUP! to initialize.</p>
<p>I think it's better done with just <a href="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139">BIND to a FENCE!</a></p>
<pre><code>accumulate: function [
    x
] bind {state: 0} [
   return state: state + x
]
</code></pre>
<p><code>&lt;in&gt;</code> is similar.</p>
<pre><code>obj: make object! [a: 10 b: 20]

bar: function [
   x
] bind obj [
   return a + b + x
]
</code></pre>
<h2><a name="p-7923-uglier-maybe-more-general-yes-faster-definitely-4" class="anchor" href="https://forum.rebol.info#p-7923-uglier-maybe-more-general-yes-faster-definitely-4"></a>Uglier?  Maybe.  More General?  Yes.  Faster?  Definitely.</h2>
<p>Feature-wise, there's a slight loss of the commentary capacity of <code>&lt;with&gt;</code>.</p>
<pre><code>global-var: 10

foo: function [arg1 arg2 &lt;with&gt; global-var] [  ; no-op, but useful?
    global-var: 20
    return arg1 + arg2
]
</code></pre>
<p>But besides that, there's no loss of features to move everything to a BIND operation on the body.</p>
<p>Not having to PARSE the spec and generate a whole new one is a big performance win.</p>
<p>So I'm letting go of those features.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dropping-with-in-static/2335">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dropping-with-in-static/2335</link>
          <pubDate>Thu, 21 Nov 2024 22:06:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2335</guid>
          <source url="https://forum.rebol.info/t/dropping-with-in-static/2335.rss">Dropping `&lt;with&gt;`, `&lt;in&gt;`, `&lt;static&gt;`</source>
        </item>
        <item>
          <title>First Bootstrap In At Least 6 Months: Watershed Changes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Announcements</category>
          <description><![CDATA[
            <p>Evolving Ren-C is a messy and difficult balancing act.  Due to the experimental nature and bus-factor-of-one staffing, it's not always a good use of time to completely push through a change in all code...until it's seen to be a good change.</p>
<p>The adoption of dozens of experimental ideas had led to a situation where being able to bootstrap the codebase stalled... for possibly the longest period yet.  This is to say that while the old 2018-era executable is used to make all the <code>.h</code> and <code>.c</code> files to build the current sources, the executable it built would be unable to do so.</p>
<p>But a few days ago, I managed to accomplish bootstrap. And I've gotten several other codebases that had been atrophying (Whitespacers, Rebol-HTTPD, Query) up to date.</p>
<p>While there are a lot of shaky parts (in particular, the workings of the new form of methodization that relies on <a href="https://forum.rebol.info/t/word-as-member-selection/1843/3">leading-dot <strong>.member</strong> accesses</a>), I'd say overall things are very promising.</p>
<p>One of the toughest points was the institution of "strict mode"... where you cannot assign to a variable that has not been pre-declared in some way (either as a module-level declaration, a LET, a <code>&lt;local&gt;</code>, made with WRAP, etc.)  This is a big change, but a good one... for all the reasons "strict mode" is known to be good, but also because it eliminated <a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128">"attachment binding"</a></p>
<h2><a name="p-7921-not-easy-but-very-instructive-1" class="anchor" href="https://forum.rebol.info#p-7921-not-easy-but-very-instructive-1"></a>Not Easy, But Very Instructive</h2>
<p>In some ways, the story of Ren-C's evolution is told by Rebmake, and the process which produces all the <strong><code>.h</code></strong> and <strong><code>.c</code></strong> files that the build relies on.</p>
<p>It's certainly one of the top 3 biggest and snakiest Rebol codebases (I'd argue it's probably the <em>trickiest</em> codebase of its size, moreso than Red or Atronix Zoe).  And it contains the code of Carl, Shixin, Brett, BrianH, myself, and others... a mixture of styles, and patches, and hacks.  Some huge bends come from needing to run in an executable that's not much beyond a patched version of what ran in 2018.</p>
<p>I've also explained why <a href="https://forum.rebol.info/t/new-build-executables-new-build-strategy/1432">adopting Rebmake was very consequential, and complicating</a>.   It brought concerns to the build process to be a superset of CMake and GNU make, instead of being narrow and focused like other approaches (Giulio and Andreas tried their hands at much more succinct ideas, and Oldes <a href="https://forum.rebol.info/t/siskin-builder-rebol-based-build-tool-by-oldes/1672">is using something much lighter in daily work today</a>).</p>
<p>But this has informed the design, hardened it, and challenged it.</p>
<h2><a name="p-7921-a-new-weird-world-driven-by-reason-and-experience-2" class="anchor" href="https://forum.rebol.info#p-7921-a-new-weird-world-driven-by-reason-and-experience-2"></a>A New "Weird" World: Driven By Reason and Experience</h2>
<p>With changes like <strong><code>:refinement</code></strong> instead of <strong><code>/refinement</code></strong>, and the switch to where actions are assigned as <strong><code>/foo: func [...] [...]</code></strong>, plus member variables being indicated with <strong><code>.field</code></strong> -- things are starting to look quite different.</p>
<p><em>But I can say with confidence that from a usage perspective, it is very clearly better.</em></p>
<p>The slashes for functions is quite empowering.  Unlike the pox of <strong><code>:deactivating</code></strong> GET-WORD!s, slashes tell you <strong>what you know</strong> instead of <strong>what you DON'T know</strong>.</p>
<p>Refinements being done with colons does come out as what seems like a casualty of that, where you can have something like:</p>
<pre><code>data: copy:part series pos
</code></pre>
<p>It mingles refinements and assignments notationally, which some might find bad.  Though I think it's nothing like mingling field accesses and refinements with both being slashes.</p>
<p>And once you get used to it, I think it actually is nice to have the colons blend more quietly.  This allows the slashes to stand out, and it really is a better use of it popping.</p>
<p>The <strong><code>.field</code></strong> accesses are--I think--a pretty definite win.  I've made it so that the lone period (<strong><code>.</code></strong>) defaults to one of those sneaky functions that looks at the current environment, and gives you the object that the <strong><code>.field</code></strong> accesses are from.  So if you really want to bring all those fields into scope where you can use them undecorated, you'd be able to do something along the lines of:</p>
<pre><code>use &lt;*&gt; .
print ["Now I can access" field "without dots"]
</code></pre>
<p><em>(Though the notation for that is still in flux.)</em></p>
<p>But really, it's very hard to keep things straight and know what's an argument and what's a member... so I <em>like</em> the dots.  (They were added on purpose...and are harder to implement than just doing lookup in the object as a higher priority for regular words, so of course I must like them!)</p>
<h2><a name="p-7921-sowhats-not-working-well-3" class="anchor" href="https://forum.rebol.info#p-7921-sowhats-not-working-well-3"></a>So...What's NOT Working Well?</h2>
<p>One of the biggest problems I've run into is that the easy interplay between WORD! and SET-WORD! and GET-WORD! has been replaced by some really finicky sequence mechanics.</p>
<p>For instance, this no longer works:</p>
<pre><code> &gt;&gt; to word! first [a: 10]
 ** Error
</code></pre>
<p>TO's rule is reversibility.  And <strong><code>(to chain! 'a)</code></strong> shouldn't be biased to either <strong><code>a:</code></strong> or <strong><code>:a</code></strong></p>
<p>Maybe you could argue for saying that <strong><code>a:</code></strong> is more useful, and so TO for sequences should put words at the head.  But that's not really the case for <strong><code>a.</code></strong> or <strong><code>a/</code></strong>, is it?</p>
<p>Then you have composites like <strong><code>/a:</code></strong>, and the question of just how many routines have to deal with these composites... and what the rules are.  If you do a <strong>SET</strong> of plain <strong>a</strong> to an action, should that be an error unless you change it to set <strong>/a</strong> ?  Should SET support <strong>/a:</strong> or make you extract things down?</p>
<p>I've been building little parts to help attack this, such as a function RESOLVE for picking the variable out of a sequence:</p>
<pre><code>&gt;&gt; resolve first [/a:]
== a

&gt;&gt; resolve first [a.b/]
== a.b
</code></pre>
<p>And that's the kind of thing that helps pick up the slack from things like TO WORD!.</p>
<p>It's still new and awkward territory.  There's certainly going to be some amount of irreducible complexity that comes from working with these new parts, but I'm hopeful that I'll be able to reduce the pain as things develop.</p>
<h2><a name="p-7921-overall-things-are-reasonably-strong-4" class="anchor" href="https://forum.rebol.info#p-7921-overall-things-are-reasonably-strong-4"></a>Overall, Things Are Reasonably Strong</h2>
<p>I talk about how Ren-C's development methodology just keeps solidifying, to let it move on to building higher things.</p>
<p>Even with many pieces teetering on the edge, there's still a solidity underneath it all that means I almost never wind up chasing Heisenbugs.  When a part needs to be hardened, it can be hardened.</p>
<p>In any case, it's good to see it bootstrapping after a long time of not.  I'm hopeful that by the end of the year I'll feel comfortable enough to make new bootstrap executables and push out the web build, so expect a big "drop" sometime in December.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/first-bootstrap-in-at-least-6-months-watershed-changes/2334">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/first-bootstrap-in-at-least-6-months-watershed-changes/2334</link>
          <pubDate>Thu, 21 Nov 2024 05:08:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2334</guid>
          <source url="https://forum.rebol.info/t/first-bootstrap-in-at-least-6-months-watershed-changes/2334.rss">First Bootstrap In At Least 6 Months: Watershed Changes</source>
        </item>
        <item>
          <title>The Semantics of JOIN</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><strong>As <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a>'s critique of yesteryear pointed out, <a href="https://forum.rebol.info/t/rejoin-ugliness-and-the-usefulness-of-tests/248">REJOIN sucked</a>.</strong></p>
<p>If naming were consistent, you might think from this pattern:</p>
<pre><code>append a reduce b &lt;=&gt; repend a b
</code></pre>
<p>...that the following would have been true:</p>
<pre><code>join a reduce b &lt;=&gt; rejoin a b  ; one would have perhaps thought?
</code></pre>
<p>But no...REJOIN was single arity (and was a mess).</p>
<h2><a name="p-7907-so-rejoin-is-in-the-trash-heap-but-what-about-join-1" class="anchor" href="https://forum.rebol.info#p-7907-so-rejoin-is-in-the-trash-heap-but-what-about-join-1"></a>So REJOIN is in the trash heap, but what about JOIN?</h2>
<p>JOIN implicitly reduced, and was basically this:</p>
<pre><code>join a b &lt;=&gt; append copy a reduce b
</code></pre>
<p>But <strong>b</strong> didn't have to be a BLOCK!, so if it was not, it wasn't reduced and just left as-is.</p>
<pre><code>rebol2&gt;&gt; join "abc" [1 + 2 3 + 4]
== "abc37"  ; so the block was reduced

rebol2&gt;&gt; d: 10
rebol2&gt;&gt; join "abc" 'd
== "abcd"  ; not abc10, so the word was *not* reduced
</code></pre>
<p>Red did not carry forward this definition:</p>
<pre><code>&gt;&gt; join
*** Script Error: join has no value
</code></pre>
<h2><a name="p-7907-next-level-join-allow-join-datatype-2" class="anchor" href="https://forum.rebol.info#p-7907-next-level-join-allow-join-datatype-2"></a>Next-Level JOIN: Allow JOIN  DATATYPE</h2>
<p>At some point, it occurred to me that if you could use JOIN with a datatype, it could step in to fill in the desires of REJOIN more clearly:</p>
<pre><code>&gt;&gt; join binary! [1 + 2 #{DECAFBAD} 2 + 3]
== #{03DECAFBAD05}
</code></pre>
<p>There really had been expressions of this like:</p>
<pre><code>rebol2&gt;&gt; rejoin [#{} 1 + 2 #{DECAFBAD} 2 + 3]
== #{03DECAFBAD05}
</code></pre>
<p>But see Brett's critique, if the surface-level badness isn't enough to convince you!</p>
<p>I also wanted to support things that Rebol2 probably meant to, but did not.  This should give a WORD! back:</p>
<pre><code>rebol2&gt;&gt; join 'a 'b
== "ab"  ; should be word! `ab`
</code></pre>
<p>Plus, I thought it might be nice to have a non-reducing variant, done with <code>@[...]</code></p>
<pre><code>&gt;&gt; join word! @[a 1 + 2]
== a1+2
</code></pre>
<p>I've mentioned elsewhere that I think having <em>join-like</em> actions be done with JOIN is superior to being some form of MAKE, when there's nebulousness for what MAKE means.</p>
<h2><a name="p-7907-making-peace-with-uneasiness-about-list-ambiguity-3" class="anchor" href="https://forum.rebol.info#p-7907-making-peace-with-uneasiness-about-list-ambiguity-3"></a>Making Peace (?) With Uneasiness About List Ambiguity</h2>
<p>Ergonomically, it's nice for JOIN to be able to take either a BLOCK! or some other type.</p>
<p>One of the biggest uses of JOIN is with files:</p>
<pre><code>join directory %foo.txt
</code></pre>
<p>It would be annoying if you had to write:</p>
<pre><code>join directory [%foo.txt]
</code></pre>
<p>But then, you have the problem that if you're joining onto a BLOCK!, then a BLOCK! is a legitimate thing to join:</p>
<pre><code>&gt;&gt; join [a b] [1 + 2 10 + 20]
== [a b 3 30]  ; "traditional" behavior

&gt;&gt; join [a b] [1 + 2]
== [a b [1 + 2 10 + 20]]  ; ...but this could be valid
</code></pre>
<p>We could "fix" this by defining JOIN as a non-reducing construct, then have people use SPREAD and REDUCE:</p>
<pre><code>&gt;&gt; join [a b] spread reduce [1 + 2 10 + 20]
== [a b 3 30]

&gt;&gt; join [a b] [1 + 2 10 + 20]
== [a b [1 + 2 10 + 20]]

&gt;&gt; join [a b] reduce [1 + 2 10 + 20]
== [a b [3 30]]
</code></pre>
<p>But this doesn't exactly square with the JOIN of a DATATYPE! case, and the most common desires.</p>
<p>If anything, I'd rather make JOIN always take a <strong><code>[...]</code></strong> or <strong><code>@[...]</code></strong> in the second argument, and then create some other non-reducing construct that slaps two things together.</p>
<pre><code>&gt;&gt; block: [a b]

&gt;&gt; adjoin block [c d]
== [a b [c d]]

&gt;&gt; adjoin block spread [e f]
== [a b [c d] e f]

&gt;&gt; block
== [a b]  ; unmodified (difference from append)
</code></pre>
<p>But asking people to write <strong><code>(adjoin directory %foo.txt)</code></strong> is... ugly.</p>
<p>A compromise is to narrow it, so that you could only use it with single items when joining with non-lists...</p>
<pre><code>&gt;&gt; join "abc" "def"
== "abcdef"

&gt;&gt; join [a b c] "def"
** Error: JOIN with a list must use [...] or @[...]
</code></pre>
<p>This would help steer you away from writing code like <strong><code>join list value</code></strong> and think it works, to only find it falling down when value becomes a BLOCK!.</p>
<h2><a name="p-7907-is-reduce-just-join-block-4" class="anchor" href="https://forum.rebol.info#p-7907-is-reduce-just-join-block-4"></a>Is REDUCE just JOIN BLOCK! ?</h2>
<p>The implementation of JOIN that I'm working on seems like a more powerful REDUCE.</p>
<p>But questions start to arise about the binding... what should the binding be?</p>
<pre><code>&gt;&gt; join [add 1] ['multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>In that case, I'm going to assume the produced block would have the binding of the [add 1] block.  Since multiply is <strong><code>'multiply</code></strong> and not <strong><code>$multiply</code></strong> it would be unbound and hence an evaluation would be driven by that first argument's binding.</p>
<p>But what if you just said:</p>
<pre><code>&gt;&gt; join block! ['add 1 'multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>Before, the second block's binding was disregarded in the product.  But when there's no first block to get the binding from, does it assume the binding of the second block?  And how would you get an unbound block if you wanted it?</p>
<p>We could say that you get an unbound block, but if you want a bound block, you'd say:</p>
<pre><code>&gt;&gt; join $[] ['add 1 'multiply 2 3]
== [add 1 multiply 2 3]
</code></pre>
<p>Then we have similar questions for things like word!:</p>
<pre><code>&gt;&gt; join word! ["a" "b"]
== ab
</code></pre>
<p>I feel that pretty obviously should be unbound.  But words follow different rules:</p>
<pre><code>&gt;&gt; join $a ["b"]
== ab  ; can't necessarily be bound, just because a was...
</code></pre>
<p>That would suggest all words come back unbound from a joining process.</p>
<p>So no shortage of questions.  But in general, I think JOIN is on the right track, and splitting MAKE behaviors that are JOIN-like to it seems good.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-semantics-of-join/2333">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-semantics-of-join/2333</link>
          <pubDate>Sat, 16 Nov 2024 18:33:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2333</guid>
          <source url="https://forum.rebol.info/t/the-semantics-of-join/2333.rss">The Semantics of JOIN</source>
        </item>
        <item>
          <title>Refinement Arguments at Head of Args List, Not Tail</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In the corpus of code we have so far, it seems to me that when a refinement adds an argument to a function that it would be preferable if that argument would become the first parameter... not tacked onto the end.</p>
<p>Some cases might not be completely obvious one way or another:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append:dup [a b c] [d e] 2  ; old way
== [a b c [d e] [d e]] 

&gt;&gt; append:dup 2 [a b c] [d e]  ; new idea
== [a b c [d e] [d e]]
</code></pre>
<p>I think it's better if it's first, but it's not earth-shattering.</p>
<p>But in other cases it seems very much an improvement.  Consider the positioning of the argument to FAIL:BLAME...</p>
<pre><code>foo: func [arg thing] [
    if arg &lt; 0 [
        fail:blame [
           "Here is some long error message:" @thing
           "Whatever..."
        ] $arg
    ]
]

foo: func [arg thing] [
    if arg &lt; 0 [
        fail:blame $arg [
           "Here is some long error message:" @thing
           "Whatever..."
        ]
    ]
]
</code></pre>
<p>Or an argument to COMPOSE giving a pattern to use:</p>
<pre><code>compose:pattern [
    some bunch of {{code that}} &lt;spans&gt;
    #multiple lines
    [and could go on for pages]
] ${{}}  ; afterthought...

compose:pattern ${{}} [  ; forethought
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]
</code></pre>
<p>This goes along with some Haskell philosophy I cited in <a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238">Parameter Order in Rebol</a>:</p>
<blockquote>
<p><em>"It's common practice in Haskell to order function parameters so that parameters which "configure" an operation come first, and the "main thing being operated on" comes last. This is often counter intuitive coming from other languages, since it tends to mean you end up passing the "least important" information first. It's especially jarring coming from OO where the "main" argument is usually the object on which the method is being invoked, occurring so early in in the call that it's out of the parameter list entirely!"</em></p>
</blockquote>
<p>These refinements typically seem to be <em>configuring</em>, as if they are changing the function itself, and belong at the head.</p>
<p>e.g. above, the function you're conceptually applying is <strong><code>(compose:pattern ${{}})</code></strong></p>
<h2><a name="p-7889-history-didnt-do-it-this-way-with-some-reasons-1" class="anchor" href="https://forum.rebol.info#p-7889-history-didnt-do-it-this-way-with-some-reasons-1"></a>History Didn't Do It This Way, With Some Reasons</h2>
<p>Refinements are typically listed at the end of the function spec.</p>
<p>From an implementation standpoint, that's also where their "slots" are in the argument list.</p>
<p>This means that as you are walking the argument list and fulfilling arguments from the callsite, if refinements were used you would have to skip over the "normal" arguments in a first pass, and then come back and fill them later.</p>
<p>Historical Redbols only had to be worried about the order of usage of refinements... if you used them out of order from the declaration, a second pass would be needed.  But using them in order would not require it.</p>
<p>This isn't a problem for Ren-C...it's designed for generic parameter reordering (refinements or otherwise) and it has an efficient way to beeline back to slots it skipped on a second pass.</p>
<p>So really the only issue is the mismatch between the visual order in the spec (which may be exposed mechanically by fixed orders of enumeration of FRAME! keys and values), compared with the gathering behavior.  But the disconnect of that order has always been there, with <strong>foo/refine1/refine2</strong> vs. <strong>foo/refine2/refine1</strong> in Redbol... the callsite order may not match the frame order.</p>
<h2><a name="p-7889-is-it-worth-changing-2" class="anchor" href="https://forum.rebol.info#p-7889-is-it-worth-changing-2"></a>Is It Worth Changing?</h2>
<p>The competing (complementary) idea of <a href="https://forum.rebol.info/t/dialecting-function-calls-new-weird-powerful/2310">CHAIN! dialecting</a> offers something that's likely even more compelling:</p>
<pre><code>compose:pattern ${{}} [  ; better than today...
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]

compose:${{}} [  ; ...but this surpasses even that
    some bunch of {{code that}} &lt;spans&gt;
    #multiple {{lines}}
    [and could go on for pages]
]
</code></pre>
<p>Though it's kind of up in the air if and when that's going to get attacked, and how well it will work (it may run afoul of problems in binding, etc.)</p>
<p>My instincts tell me that it's worth changing.  In practice, refinements that take arguments are not super common... but when they do happen, being up front seems to make the most sense.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331</link>
          <pubDate>Tue, 12 Nov 2024 14:16:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2331</guid>
          <source url="https://forum.rebol.info/t/refinement-arguments-at-head-of-args-list-not-tail/2331.rss">Refinement Arguments at Head of Args List, Not Tail</source>
        </item>
        <item>
          <title>Antiform Safety: Covariance and Contravariance</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>Grafting antiforms onto a C codebase that had no such concept is fraught with disasters.</p>
<p>The semantics of unstable antiforms is particularly risky.  If you have a test like <strong><code>Is_Block(cell)</code></strong> that tells you whether a cell holds a BLOCK!, then what if that cell holds an antiform block?  Usermode code has the benefit of decay-by-default (unless you take a meta-parameter).  So if you ask <strong><code>BLOCK?</code></strong> on a parameter pack, it will decay to its first item and answer based on that.  The C implementation has no such "automatic" behavior.</p>
<p>Even "worse", what if <strong><code>cell</code></strong> contains an antiform error, and you quietly say "no it's not a block" and proceed on, ignoring situations when that should have raised an abrupt failure?</p>
<h2><a name="p-7886-creating-a-type-hierarchy-atom-value-element-1" class="anchor" href="https://forum.rebol.info#p-7886-creating-a-type-hierarchy-atom-value-element-1"></a>Creating A Type Hierarchy: Atom -&gt; Value -&gt; Element</h2>
<p>I've given names to the three broad categories of cells:</p>
<ul>
<li>
<p><strong>ELEMENT</strong> - anything that you can put in a List.  So this is "element" as in "array element".  Hence, no antiforms.  (It's not a perfect name in terms of correspondence to "chemical element" in terms of the abstract form that can come in isotopes, so think of it as array element)</p>
</li>
<li>
<p><strong>VALUE</strong> - anything that you can put in a Variable.  So it extends ELEMENT with stable antiforms.</p>
</li>
<li>
<p><strong>ATOM</strong> - anything, including unstable antiforms.</p>
</li>
</ul>
<p>Systemically, we want to stop antiforms from being put into the array elements of blocks, groups, paths, and tuples.  We also want to prevent unstable antiforms from being the values of variables.</p>
<p>To make it easier to do this, the C++ build offers the ability to make <code>Element</code> that can't hold any antiforms, <code>Value</code> that can hold stable antiforms, and <code>Atom</code> that can hold anything--including unstable isotopes.</p>
<ul>
<li>
<p><strong>Class Hierarchy:</strong> Atom as base, Value derived, Element derived (upside-down for compile-time error preferences--we want passing an Atom to a routine that expects only Element to fail)</p>
</li>
<li>
<p><strong>Primary Goal:</strong> Prevent passing Atoms/Values to Element-only routines, or Atoms to Value-only routines.</p>
</li>
<li>
<p><strong>Secondary Goal:</strong> Prevent things like passing Element cells to writing routines that may potentially produce antiforms in that cell.</p>
</li>
<li>
<p><strong>Tertiary Goal:</strong> Detect things like superfluous <code>Is_Antiform()</code> calls being made on Elements.</p>
</li>
</ul>
<p>The primary goal is achieved by choosing Element as a most-derived type instead of a base type.</p>
<p>The next two goals are somewhat maddeningly trickier... <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=12" title=":pouting_cat:" class="emoji" alt=":pouting_cat:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7886-sink-and-need-2" class="anchor" href="https://forum.rebol.info#p-7886-sink-and-need-2"></a><code>Sink(...)</code> and <code>Need(...)</code></h2>
<p>The idea behind a Sink() is to be able to mark on a function's interface when a function argument passed by pointer is intended as an output.</p>
<p>This has benefits of documentation, and can also be given some teeth by scrambling the memory that the pointer points at (so long as it isn't an "in-out" parameter).  But it also applied in CHECK_CELL_SUBCLASSES, by enforcing "covariance" for input parameters, and "contravariance" for output parameters.</p>
<p>If USE_CELL_SUBCLASSES is enabled, then the inheritance heirarchy has Atom at the base, with Element at the top.  Since what Elements can contain is more constrained than what Atoms can contain, this means you can pass Atom* to Element*, but not vice-versa.</p>
<p>However, when you have a Sink(Element) parameter instead of an Element*, the checking needs to be reversed.  You are -writing- an Element, so the receiving caller can pass an Atom* and it will be okay.  But if you were writing an Atom, then passing an Element* would not be okay, as after the initialization the Element could hold invalid states.</p>
<p>We use "SFINAE" to selectively enable the upside-down hierarchy, based on the <code>std::is_base_of&lt;&gt;</code> type trait.</p>
<h2><a name="p-7886-the-code-in-the-c-debug-build-3" class="anchor" href="https://forum.rebol.info#p-7886-the-code-in-the-c-debug-build-3"></a>The Code (in the C++ Debug Build)</h2>
<pre><code>template&lt;typename T, bool sink&gt;
struct NeedWrapper {
    T* p;
    mutable bool corruption_pending;  // can't corrupt on construct

  //=//// TYPE ALIASES ////////////////////////////////////////////////=//

    using MT = typename std::remove_const&lt;T&gt;::type;

    template&lt;typename U&gt;  // contravariance
    using IsReverseInheritable = typename std::enable_if&lt;
        std::is_same&lt;U,T&gt;::value or std::is_base_of&lt;U,T&gt;::value
    &gt;::type;

  //=//// CONSTRUCTORS ////////////////////////////////////////////////=//

    NeedWrapper() = default;  // or MSVC warns making Option(Sink(Value))

    NeedWrapper(nullptr_t) {
        p = nullptr;
        corruption_pending = false;
    }

    NeedWrapper (const NeedWrapper&lt;T,sink&gt;&amp; other) {
        p = other.p;
        corruption_pending = p and (other.corruption_pending or sink);
        other.corruption_pending = false;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper(U* u) {
        p = u_cast(T*, u);
        corruption_pending = p and sink;
    }

    template&lt;typename U, bool B, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper(const NeedWrapper&lt;U, B&gt;&amp; other) {
        p = u_cast(T*, other.p);
        corruption_pending = p and (other.corruption_pending or sink);
        other.corruption_pending = false;
    }

  //=//// ASSIGNMENT //////////////////////////////////////////////////=//

    NeedWrapper&amp; operator=(nullptr_t) {
        p = nullptr;
        corruption_pending = false;
        return *this;
    }

    NeedWrapper&amp; operator=(const NeedWrapper&lt;T,sink&gt; other) {
        if (this != &amp;other) {  // self-assignment possible
            p = other.p;
            corruption_pending = p and (other.corruption_pending or sink);
            other.corruption_pending = false;
        }
        return *this;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper&amp; operator=(const NeedWrapper&amp; other) {
        if (this != &amp;other) {  // self-assignment possible
            p = other.p;
            corruption_pending = p and (other.corruption_pending or sink);
            other.corruption_pending = false;
        }
        return *this;
    }

    template&lt;typename U, IsReverseInheritable&lt;U&gt;* = nullptr&gt;
    NeedWrapper&amp; operator=(U* other) {
        p = u_cast(T*, other);
        corruption_pending = p and sink;
        return *this;
    }

  //=//// OPERATORS ///////////////////////////////////////////////////=//

    operator bool () const { return p != nullptr; }

    operator T* () const {
        if (corruption_pending) {
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
            corruption_pending = false;
        }
        return p;
    }

    T* operator-&gt;() const {
        if (corruption_pending) {
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
            corruption_pending = false;
        }
        return p;
    }

  //=//// DESTRUCTOR //////////////////////////////////////////////////=//

    ~NeedWrapper() {
        if (corruption_pending)
            Corrupt_If_Debug(*const_cast&lt;MT*&gt;(p));
    }
};
</code></pre>
<p>So then the <code>Sink(...)</code> and non-corrupting version <code>Need(...)</code> for in/out parameters with contravariance checking are:</p>
<pre><code>#define Sink(T) \
    NeedWrapper&lt;T, true&gt;

#define Need(TP) \
    NeedWrapper&lt;typename std::remove_pointer&lt;TP&gt;::type, false&gt;
</code></pre>
<h2><a name="p-7886-notes-on-corrupting-4" class="anchor" href="https://forum.rebol.info#p-7886-notes-on-corrupting-4"></a>Notes on Corrupting</h2>
<p>The original implementation was simpler, by just doing the corruption at the moment of construction.</p>
<p>But this faced a problem:</p>
<pre><code>    bool some_function(Sink(char*) out, char* in) { ... }

    if (some_function(&amp;ptr, ptr)) { ...}
</code></pre>
<p>If you corrupt the data at the address the sink points to, you can actually be corrupting the value of a stack variable being passed as another argument before it's calculated as an argument.  So deferring the corruption after construction is necessary.  It's a bit tricky in terms of the handoffs and such.</p>
<p><em>(While this could be factored, function calls aren't inlined in the debug build, so given the simplicity of the code, it's repeated.)</em></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/antiform-safety-covariance-and-contravariance/2330">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/antiform-safety-covariance-and-contravariance/2330</link>
          <pubDate>Mon, 11 Nov 2024 09:49:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2330</guid>
          <source url="https://forum.rebol.info/t/antiform-safety-covariance-and-contravariance/2330.rss">Antiform Safety: Covariance and Contravariance</source>
        </item>
        <item>
          <title>Full-Band Return Values from Generators/Yielders</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>Definitional Errors came into PARSE as an answer for how to make it possible to return any value... simply make a failed parse a definitional error.  Not only does it mean that NULL can be a legitimate synthesized product that you don't conflate with failure, but it also means that parse failures can give back more information in the error about what went wrong <em>(farthest parse point reached, etc.)</em>...</p>
<p>Looking at another problem where a sentinel NULL had been used... there's <a href="https://forum.rebol.info/t/yielder-and-generator-and-thinking-about-coroutines/1311">Generators and Yielders</a>:</p>
<pre><code>&gt;&gt; g: generator [print "A" yield 1, print "B" yield 2, print "C"]

&gt;&gt; g
A
== 1

&gt;&gt; g
B
== 2

&gt;&gt; g
C
== ~null~  ; anti

&gt;&gt; g
== ~null~  ; anti

&gt;&gt; g
== ~null~  ; anti
</code></pre>
<p>But Generators and Yielders predate antiforms in general... they came at a time where there were just two forms of NULL: "heavy" and "light".  So the thought was that if you wanted to actually yield null, it would be the heavy form.</p>
<pre><code>&gt;&gt; g: generator ["Start", yield null, print "Done"]

&gt;&gt; g
Start
== ~[~null~]~  ; anti

&gt;&gt; g
Done
== ~null~  ; anti
</code></pre>
<p>But this isn't nearly as good as using a specific raised error.  If NULL is truly out of band, then you could use <strong><code>try g</code></strong> to get null when there are no more values.</p>
<p>If you try to YIELD or RETURN a raised error, then it would become an abrupt failure.  So you'd be assured that the only time you'd ever get a definitional error back from a generator or yielder would be if it had been exhausted.</p>
<h2><a name="p-7884-pack-returns-for-things-like-key-and-value-in-objects-1" class="anchor" href="https://forum.rebol.info#p-7884-pack-returns-for-things-like-key-and-value-in-objects-1"></a>PACK returns for things like KEY and VALUE in objects?</h2>
<p>As the enumeration routines are retooled to be based on generator functions, it struck me as very cool if generators returned packs, which could be decayed:</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20 c: 30]

&gt;&gt; g: each obj

&gt;&gt; g
; first in pack of 2 items
== a

&gt;&gt; meta g
== ~['b '20]~

&gt;&gt; [key {val}]: g
== 30

&gt;&gt; key
== c

&gt;&gt; g
** Error: Generator/Yielder exhausted

&gt;&gt; try g
== ~null~  ; anti
</code></pre>
<p>That's really cool, and seems like it would go along with decaying:</p>
<pre><code>for 'key each obj [...]

for [key val] each obj [...]
</code></pre>
<p>This looks pretty nice, however blocks used in FOR-EACH scenarios like this haven't meant "unpack", it has meant keep getting items and assign them to each.</p>
<p>It seems like it would be unfortunate if you had to write the object unpacking as:</p>
<pre><code>for [~[key val]~] each obj [...]
</code></pre>
<p>But that does seem sort of like what you'd have to do in order to make it generalized.  It doesn't look <em>that</em> bad, and it does have a theory behind it...</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20 c: 30]

&gt;&gt; for [~[key val]~ :otherkey] each obj [  ; leading colon for optionality
       print ["key:" key]
       print ["val:" val]
       if otherkey [
           print ["otherkey:" otherkey]
       ]
   ]

key: a
val: 10
otherkey: b
key: c
val: 30
</code></pre>
<p>This assumes that plain blocks might be taken for some other intent in the FOR.  If it were not:</p>
<pre><code>for [[key val] :otherkey] each obj [...]
</code></pre>
<p>But I had been thinking that plain BLOCK! would likely be good for type checking (<span class="mention">@hiiamboris</span> has some experiments in this vein):</p>
<pre><code>for [x [integer!] y [tag!]] each [1 &lt;a&gt; 2 &lt;b&gt;] [....]
</code></pre>
<h2><a name="p-7884-big-design-space-but-full-band-returns-opens-it-up-2" class="anchor" href="https://forum.rebol.info#p-7884-big-design-space-but-full-band-returns-opens-it-up-2"></a>Big Design Space, but Full-Band Returns Opens It Up</h2>
<p>I'd let the Generator and Yielder experiments atrophy while working on other things.  But I stopped today to try and get the basics working again, and it's interesting to see how isotopes bring a lot to the table...as they seem to have done with nearly everything.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329</link>
          <pubDate>Sun, 10 Nov 2024 19:25:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2329</guid>
          <source url="https://forum.rebol.info/t/full-band-return-values-from-generators-yielders/2329.rss">Full-Band Return Values from Generators/Yielders</source>
        </item>
        <item>
          <title>Trailing Slash Is A Winner For Defused Actions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I <em>really</em> like this trailing slash thing, meaning "get me the action as is and don't run it AND guarantee it's an action".</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] word?/ &lt;ice&gt;
== [&lt;ice&gt; 1 &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>That's to me just about perfect:</p>
<ul>
<li>
<p>You're passing the parameter of what to replace as being an antiform action, so it will be called on the elements.</p>
</li>
<li>
<p>It does NOT take a parameter (notice the slash dividing it from what comes after it?  that's a strong semiotic hint that <code>&lt;ice&gt;</code> is not a parameter to <code>word?</code>)</p>
</li>
<li>
<p>...and it's an antiform, so you know it doesn't occur literally in the block.</p>
</li>
</ul>
<p>Before this form existed, I was using MATCHES which made an antiform action for a datatype:</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] matches word! &lt;ice&gt;
== [&lt;ice&gt; 1 &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>That's slower, wordier, and more opaque about the mechanics.</p>
<p>It's useful if you have a datatype in your hand and need to convert it to a function, or if you have a more complex type construction:</p>
<pre><code>&gt;&gt; replace [a 1 a &lt;baby&gt;] matches [word! integer!] &lt;ice&gt;
== [&lt;ice&gt; &lt;ice&gt; &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>Maybe it should be called MATCHER, since it's actually a function generator.  MATCHES looks a little too much like MATCH, so it seems like it might take <code>&lt;ice&gt;</code> as an argument.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>If you make such a call often, you wouldn't want to regenerate the function each time:</p>
<pre><code>&gt;&gt; word-or-int?: matcher [word! integer!]

&gt;&gt; replace [a 1 a &lt;baby&gt;] word-or-int?/ &lt;ice&gt;
== [&lt;ice&gt; &lt;ice&gt; &lt;ice&gt; &lt;baby&gt;]
</code></pre>
<p>MATCHES would seems like it's providing an answer in the moment, whereas MATCHER works better for when you're not using immediately.  So it's probably the better choice.</p>
<p>Anyway, I'll also say that the <a href="https://forum.rebol.info/t/make-replace-all-default-semantics-of-replace/2269">REPLACE "ALL" semantic being the default</a> is a big improvement.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/trailing-slash-is-a-winner-for-defused-actions/2327">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/trailing-slash-is-a-winner-for-defused-actions/2327</link>
          <pubDate>Fri, 08 Nov 2024 19:05:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2327</guid>
          <source url="https://forum.rebol.info/t/trailing-slash-is-a-winner-for-defused-actions/2327.rss">Trailing Slash Is A Winner For Defused Actions</source>
        </item>
        <item>
          <title>TAG!s Angle Brackets: *They Aren&#39;t There!*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Implementation-wise, the delimiters of tag have been quite the thorn.</p>
<p>Are they there or not?</p>
<p>In Rebol2, Red, R3-Alpha...</p>
<pre><code>&gt;&gt; find &lt;abcd&gt; "c"
== &lt;cd&gt;

&gt;&gt; find &lt;abcd&gt; "&gt;"
== none
</code></pre>
<p>Not there!</p>
<p>Or are they?  Reverse the arguments, and in Rebol2 and Red, they seem to magically appear:</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "&lt;c&gt;d"
</code></pre>
<p>But... this was not the case in R3-Alpha...</p>
<pre><code>r3-alpha&gt;&gt; find "abcd" &lt;c&gt;
== "cd"

r3-alpha&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"
</code></pre>
<p>I know things have gone back and forth with people believing deeply in their little hearts that they are happier when routines act like the delimiters are there...</p>
<p>But for the baseline behavior: <em>I have come to believe R3-Alpha is right.</em>  They're string delimiters, and incidental to the default purpose, just as quotes are.</p>
<p>If you start looking at TAG! as it truly is--just another string class with different delimiters--it simplifies the mental model and the implementation model.  You can truly just use it like another string, and it suddenly becomes consistent.</p>
<p>Of course, it's still nice to be able to match the molded form of a tag.</p>
<p>But... why stop at tags? <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> Why not have a syntax to match the molded form of anything?</p>
<p>In strings, where you can't match list elements literally anyway:</p>
<pre><code>&gt;&gt; parse "&lt;a&gt; 100 (b c)" ['&lt;a&gt; space '100 space '(b c)]
== (b c)
</code></pre>
<p>(The synthesized product may be more interesting, too.  As a reminder, Ren-C has taken words that might be better as variable names like END and uses plain tag as  instead, or  to synthesize the parse input, etc.)</p>
<pre><code>&gt;&gt; parse "&lt;end&gt; asdf" ['&lt;end&gt; to &lt;end&gt; &lt;input&gt;]
== "&lt;end&gt; asdf"
</code></pre>
<p>I don't know whether that is best done as just a PARSE feature, or if quoted things need to be searched for literally by FIND.</p>
<pre><code>&gt;&gt; find "ab&lt;c&gt;d" &lt;c&gt;
== "c&gt;d"

&gt;&gt; quote &lt;c&gt;
== '&lt;c&gt;

&gt;&gt; find "ab&lt;c&gt;d" quote &lt;c&gt;
== "&lt;c&gt;d"

&gt;&gt; find "ab&lt;c&gt;d" mold &lt;c&gt;  ; one fewer character
== "&lt;c&gt;d"
</code></pre>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326</link>
          <pubDate>Fri, 08 Nov 2024 18:12:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2326</guid>
          <source url="https://forum.rebol.info/t/tag-s-angle-brackets-they-arent-there/2326.rss">TAG!s Angle Brackets: *They Aren&#39;t There!*</source>
        </item>
        <item>
          <title>Embracing A &quot;Useless&quot; Definition of TO</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Many years ago, I thought about <strong><a href="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649">trying to untangle of the TO and MAKE matrix</a></strong>.  These operations are notoriously unpredictable in historical Redbol.</p>
<p>I tried putting some stakes in the ground about what I believed <em>had</em> to be true.  It was difficult because I could not think of too many.</p>
<p>One thing I said was that TO should always create a "new" value (if the value was not immediate).  And I felt like this should be true:</p>
<pre><code>to (type of value) value
; ...same as...
copy value
</code></pre>
<p>Grasping for any stake in the ground I could find, I was pretty sure that TO of a string representation of an integer to an integer should give you the integer:</p>
<pre><code>&gt;&gt; to integer! "1020"
== 1020  ; we know this, at least? (one hopes...)
</code></pre>
<p>And the reverse, one would think, as well:</p>
<pre><code>&gt;&gt; to text! 1020
== "1020"  ; what else *could* it be?  codepoint 1020? -&gt; "Ï¼"
</code></pre>
<p>But beyond that it was hard to think of the pattern.</p>
<h2><a name="p-7876-coming-back-to-an-old-idea-reversibility-1" class="anchor" href="https://forum.rebol.info#p-7876-coming-back-to-an-old-idea-reversibility-1"></a>Coming Back To An Old Idea: Reversibility</h2>
<p>When I first encountered Rebol and was made aware of these problems, I suggested TO should be reversible:</p>
<pre><code>value1 = to (type of value1) to type2 value1
</code></pre>
<p>However, this gave what <em>appeared</em> to be very "unexciting" options for behavior:</p>
<pre><code>&gt;&gt; to block! 1
== [1]

&gt;&gt; to integer! [1]
== 1

&gt;&gt; to integer! [...anything else in a block that's not integer...]
** Error.  Always.
</code></pre>
<p>That particular idea was was so long ago that I don't have direct quotes on hand of people saying "nah, that sucks, TO could barely do anything."  But I'm pretty sure it was panned by basically everyone I suggested it to.  I guess I agreed, because I dropped it.</p>
<p><strong>Coming back to it now, and seeing it in a new light, I see this as much more useful than I used to.</strong>  Especially when compared to the historical mess that makes TO nigh-unusable.</p>
<p>And in fact, it fits in with several Rebol2/Red behaviors that I'd thought were kind of pointless before:</p>
<pre><code>&gt;&gt; to integer! &lt;1&gt;
== 1

&gt;&gt; to tag! 1
== &lt;1&gt;
</code></pre>
<p>The use I didn't see at the time was the frequent need when dialecting to push values out of band, into some other type, without losing their meaning.  If you have a dialect in which integers already mean something, but you want a way of pushing some integer-oriented instruction in there...you can use these kinds of operations.</p>
<p>Definitional errors in Ren-C make this convenient, since checking if something fits the pattern is quick, you just throw in a TRY and the antiform error that's the return result of the TO will be suppressed, giving you a "falsey" null:</p>
<pre><code>&gt;&gt; thing: &lt;a b&gt;

&gt;&gt; to integer! thing
** Error: Cannot TO convert &lt;a b&gt; to integer

&gt;&gt; try to integer! thing
== ~null~  ; anti
</code></pre>
<p>The more I look at it the more useful it appears.  And it helps give clarity to the MAKE vs. TO division.  If you have something that isn't shaped like this, then <em>maybe</em> MAKE is the right place to put it.  For example:</p>
<pre><code>&gt;&gt; to percent! 1
== 1%

&gt;&gt; to integer! 1%
== 1

&gt;&gt; make percent! 1
== 100%
</code></pre>
<p><em>(Note: I think ENCODE + DECODE is a better place for binary conversions, e.g. ENCODE 'IEEE-754 is better than MAKE BINARY! of a decimal because that could mean many things, and ENCODE can have more parameterization for single vs. double precision, etc.  I don't know<br>
if TO BINARY! should work at all, but if it does, I'd probably agree with the Rebol2 choice to give the binary representation of the UTF-8 string... e.g. (to binary! 1020) as #{31303230} ... and use more explicit future-proof routines to encode with specified byte size and endianness.)</em></p>
<h2><a name="p-7876-reversibility-rules-out-rounding-2" class="anchor" href="https://forum.rebol.info#p-7876-reversibility-rules-out-rounding-2"></a>Reversibility Rules Out Rounding</h2>
<p>In order to get losslessness in the representation, you can't throw out information.</p>
<p>So this works:</p>
<pre><code>&gt;&gt; to integer! 1.0
== 1

&gt;&gt; to decimal! 1
== 1.0
</code></pre>
<p>But this does not:</p>
<pre><code> &gt;&gt; to integer! 1.5
 ** Error: Can't TO INTEGER! a DECIMAL! w/digits after decimal point
</code></pre>
<p>I don't think that's a problem, because that seems like a job for ROUND.  Unfortunately, R3-Alpha and Red do something dumb:</p>
<pre><code>rebol2&gt;&gt; round 1.5
== 2

red&gt;&gt; round 1.5
== 2.0

r3-alpha&gt;&gt; round 1.5
== 2.0
</code></pre>
<p>It seems this was part of a shift to try and preserve the input type, to facilitate things like rounding MONEY!:</p>
<pre><code>r3-alpha&gt;&gt; round $1.50
== $2
</code></pre>
<p>So I guess the way the thinking went was that if you want to keep MONEY! as MONEY! when you round it, all types should act that way.</p>
<p>I think the relationship between INTEGER! and DECIMAL!, which lack decoration, suggests something more intimate where the type can be lost.  If you don't want to lose it, ROUND:TO 1.0</p>
<pre><code>&gt;&gt; round 1.5
== 2

&gt;&gt; round:to 1.5 1
== 2

&gt;&gt; round:to 1.5 1.0
== 2.0
</code></pre>
<h2><a name="p-7876-blank-pretty-much-has-to-mean-empty-3" class="anchor" href="https://forum.rebol.info#p-7876-blank-pretty-much-has-to-mean-empty-3"></a>BLANK! Pretty Much Has To Mean Empty</h2>
<p>If we're talking about equivalencies, we now know this:</p>
<pre><code>&gt;&gt; for-each 'x _ [print "Doesn't run"]
== ~void~  ; anti

&gt;&gt; empty? _
== ~okay~  ; anti
</code></pre>
<p>And so really, it seems that the TO conversion of BLANK! has only one set of answers to fit into the family of reversibility:</p>
<pre><code>&gt;&gt; to block! _
== []

&gt;&gt; to text! _
== ""

&gt;&gt; to blank! &lt;&gt;
== _

&gt;&gt; to blank! #{}
== _
</code></pre>
<p>And if you try to TO BLANK! anything that's not conceptually empty, you'd get an error.</p>
<pre><code>&gt;&gt; to blank! &lt;a&gt;
** Error: ...
</code></pre>
<p>I don't know if there's a motivating case for saying <strong>to integer! _</strong> should pick something like 0 as an answer, though Rebol2 did something of that sort:</p>
<pre><code>rebol2&gt;&gt; to integer! none
== 0
</code></pre>
<p>Neither Red nor R3-Alpha carried that forward, <a href="https://github.com/metaeducation/rebol-issues/issues/1018">though it was discussed</a></p>
<h2><a name="p-7876-can-be-checked-in-the-implementation-4" class="anchor" href="https://forum.rebol.info#p-7876-can-be-checked-in-the-implementation-4"></a>Can Be Checked In The Implementation</h2>
<p>I've started hacking this through, and it's gone relatively well.  TO dispatches <em><strong>to the type it's converting from</strong></em>, with the type being converted to as the argument.</p>
<p>And it's nice in the sense that the TO native driving the process can also check the reversibility constraint in the debug build, to give it some teeth.</p>
<p><em>(I've rigged up some interesting frame mechanics to enable doing this reversal efficiently, that have sped up other parts of the system (like CASCADE) with "downlevel shifting", that can bypass a trampoline bounce...)</em></p>
<p>Anyway, things are a mess right now with a couple hundred broken tests to painfully sift through.  But I think the reversibility rule is good... biggest questions are whether that relaxes in terms of spacing...</p>
<pre><code>&gt;&gt; to block! "  1    2  "
== [1 2]  ; legal?
</code></pre>
<p>This would suggest you would have to compare with the trimmed/canonized version of your input.</p>
<p>Also, issues of string representations.</p>
<pre><code>&gt;&gt; b: to block! "--{1}--"
== ["1"]  ; legal?
</code></pre>
<p>So there are some pain points, but chipping away at them.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325</link>
          <pubDate>Fri, 08 Nov 2024 17:57:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2325</guid>
          <source url="https://forum.rebol.info/t/embracing-a-useless-definition-of-to/2325.rss">Embracing A &quot;Useless&quot; Definition of TO</source>
        </item>
        <item>
          <title>Old Idea Revisited: DATATYPE as... Antiform?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>I've been suffering through an attempt to bring sanity to bear upon the MAKE and TO matrix.</p>
<p>While doing so, I noticed that there are a lot of MAKE instructions that do "joining".</p>
<p>In R3-Alpha and Red:</p>
<pre><code>&gt;&gt; make binary! [1 2 #{DECAFBAD} 3 4]   
== #{0102DECAFBAD0304}
</code></pre>
<p>Historical MAKE is so arbitrary in how it interprets its arguments that it made me feel that it would be better if JOIN allowed a datatype as its first argument...</p>
<p>JOIN typically makes a new series out of what you give it:</p>
<pre><code>&gt;&gt; bin: #{AABB}

&gt;&gt; join bin #{CCDD}
== #{AABBCCDD}  ; made new series, didn't impact BIN

&gt;&gt; bin
== #{AABB}
</code></pre>
<p>But if you could pass a datatype as the first argument, you could relieve MAKE of the behavior...and make it clearer in the source what's actually happening:</p>
<pre><code>&gt;&gt; join binary! [1 2 #{DECAFBAD} 3 4]
== #{0102DECAFBAD0304}
</code></pre>
<p>Since that seemed nice, I started to map it out, and ran into a bit of a problem:</p>
<p><strong>If "datatypes" are an ANY-WORD! or ANY-LIST! or anything like that, how do you know you're not trying to JOIN with it?</strong></p>
<p>A WORD! should be able to join:</p>
<pre><code>&gt;&gt; join 'var 10
== var10
</code></pre>
<p>A BLOCK! should be able to join...</p>
<pre><code>&gt;&gt; join [a b] 10
== [a b 10]
</code></pre>
<p>Okay, but when you say <strong>join binary!</strong> what is BINARY!?  Well right now, it's:</p>
<pre><code>&gt;&gt; binary!
== &amp;[binary]
</code></pre>
<p>Well that looks like it's in-band for the kinds of things JOIN operates on:</p>
<pre><code>&gt;&gt; join &amp;[binary] 10
== &amp;[binary 10]
</code></pre>
<h2><a name="p-7875-an-antiform-would-push-datatype-out-of-band-1" class="anchor" href="https://forum.rebol.info#p-7875-an-antiform-would-push-datatype-out-of-band-1"></a>An Antiform Would Push DATATYPE? Out-Of-Band...</h2>
<p>It's possible that we could come up with a new non-antiform for types.  But the lexical space is extremely saturated.</p>
<p>If we were just reaching for something on the basis of looks, antiform FENCE! is nice:</p>
<pre><code>&gt;&gt; binary!
== ~{binary}~  ; anti
</code></pre>
<h2><a name="p-7875-this-has-come-up-before-2" class="anchor" href="https://forum.rebol.info#p-7875-this-has-come-up-before-2"></a>This Has Come Up Before...</h2>
<p>Historical Rebol let you use datatypes in FIND:</p>
<pre><code>rebol2&gt;&gt; find [a b c 10 20] integer! 
== [10 20]
</code></pre>
<p>But then this conflates with when you actually literally have the INTEGER! datatype in the block.</p>
<pre><code>&gt;&gt; find compose [a (integer!) b c 10 20] integer!
== [integer! b c 10 20]
</code></pre>
<p>So in the early days of antiforms, I proposed antiform datatypes as a solution... but at that time I was thinking that there'd be non-antiform DATATYPE!, and it's just that when it was an antiform it would be a "MATCHER".</p>
<p>The proposal I'm thinking of now is different, in saying that DATATYPE? only exists as a (stable) antiform state.</p>
<p>There are tradeoffs, in that datatypes can't be put in blocks directly.  But the mechanics of working with quasiforms and antiforms via things like REIFY and DEGRADE are much smoother now.  And really, putting datatypes in blocks doesn't happen that often (I've had to put splices in blocks but really never datatypes).</p>
<p>Being completely out of band with things you can find in a block has advantages.  JOIN isn't unique in reaping benefits from being able to say that datatypes aren't things.</p>
<p>And it unifies datatypes with typecheckers being antiforms, because typecheckers are frame antiforms, e.g. actions:</p>
<pre><code>&gt;&gt; find [1 3 5 8 10] even?/
; first in pack of length 2
== [8 10]
</code></pre>
<p>So I don't think it's a crazy idea.</p>
<p>I'm hesitant to surrender FENCE! antiforms to the purpose so soon after their invention.  But there isn't anything undecorated left.</p>
<p>Not that "no decorated antiforms" is some unbreakable rule, it was a guideline.</p>
<p>Using &amp; would put it in the family of TYPE-XXX! and be cheaper than FENCE! if you made new instances:</p>
<pre><code>&gt;&gt; binary!
== ~&amp;binary~  ; anti
</code></pre>
<p>A random bad idea would be to make them keywords, and just have DATATYPE? be smart enough to filter out ~null~ or ~void~ or ~okay~ or whatever else (the symbol could carry a flag)</p>
<pre><code>&gt;&gt; binary!
== ~binary~  ; anti

&gt;&gt; null
== ~null~  ; anti

&gt;&gt; datatype? binary!
== ~okay~  ; anti

&gt;&gt; datatype? null
== ~null~  ; anti
</code></pre>
<p>I can pretty clearly say that's bad.</p>
<h2><a name="p-7875-or-pick-some-non-antiform-notation-3" class="anchor" href="https://forum.rebol.info#p-7875-or-pick-some-non-antiform-notation-3"></a>Or, Pick Some Non-Antiform Notation</h2>
<p>Status quo might look like:</p>
<pre><code>&gt;&gt; binary!
== #[binary]
</code></pre>
<p>Despite it looking sort of like a block, it wouldn't be.  But we're squandering some of our notational space no matter what.  The <strong><code>~&amp;type~</code></strong> is the discount route.</p>
<h2><a name="p-7875-either-way-datatype-cant-be-any-word-or-any-list-4" class="anchor" href="https://forum.rebol.info#p-7875-either-way-datatype-cant-be-any-word-or-any-list-4"></a>Either Way, DATATYPE? Can't be ANY-WORD! or ANY-LIST!</h2>
<p>It needs to be out of band one way or another.  I'll have to think about it.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324</link>
          <pubDate>Fri, 08 Nov 2024 17:05:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2324</guid>
          <source url="https://forum.rebol.info/t/old-idea-revisited-datatype-as-antiform/2324.rss">Old Idea Revisited: DATATYPE as... Antiform?</source>
        </item>
        <item>
          <title>ENHEX and DEHEX testing, another &quot;Micro-Dialect&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>Here's a little excerpt of testing <strong><a href="https://en.wikipedia.org/wiki/Percent-encoding">Percent Encoding</a></strong> <em>(which Rebol gives the poor names ENHEX and DEHEX to, and should probably be changed)</em>.</p>
<p>It started out just as a table of encoded and decoded forms, e.g.</p>
<pre><code>for-each [encoded decoded] [
    "a%20b" "a b"
    "a%25b" "a%b"
    "a%ce%b2c" "aÎ²c"
    ...
][
   ; test that it decodes
]
</code></pre>
<p>But the encoding produces uppercase hex digits (per <a href="https://datatracker.ietf.org/doc/html/rfc3986">RFC 3896</a>), while the decoding tolerates lowercase ones.  So you don't get the same thing back.</p>
<p>That led me to the "whimsical" choice to denote reversible <strong><code>&lt;-&gt;</code></strong> and non-reversible <strong><code>-&gt;</code></strong> transforms:</p>
<pre><code>"a%25b" &lt;-&gt; "a%b"
"a%ce%b2c" -&gt; "aÎ²c" -&gt; "a%CE%B2c"
</code></pre>
<p>This is strange in that <strong><code>-&gt;</code></strong> is a WORD!, while <strong><code>&lt;-&gt;</code></strong> is a TAG! (and I believe this is the correct design choice when all is said and done).</p>
<p>But in a dialect, having something <em>look like what you want</em> can be enough, as it's just being looked for literally.</p>
<p>I threw in an additional wrinkle by letting BLOCK! with an INTEGER! in it serve as a comment.  It looks visually better than having to throw in a semicolon.</p>
<p>It's satisfying when such things can be done in a matter of a few minutes:</p>
<pre><code>; 1. Accept lowercase, but canonize to uppercase, per RFC 3896 2.1
;
; 2. A case can be made for considering the encoding of characters that
;    don't need it to be an error by default.
;
parse compose [
    "a%20b" &lt;-&gt; "a b"
    "a%25b" &lt;-&gt; "a%b"
    "a%ce%b2c" -&gt; "aÎ²c" -&gt; "a%CE%B2c"  [1]
    "%2b%2b" -&gt; "++" -&gt; "++"  [2]
    "a%2Bb" -&gt; "a+b" -&gt; "a+b"  [2]
    "a%62c" -&gt; "abc" -&gt; "abc"  [2]
    "a%CE%B2c" &lt;-&gt; "aÎ²c"
    (as text! #{2F666F726D3F763D254335253939}) -&gt; "/form?v=Å™"
][ some [
    let encoded: text!
    let arrow: ['&lt;-&gt; | '-&gt;]
    let decoded: text!
    let re-encoded: [when (arrow = '-&gt;) ['-&gt; text!] | (encoded)]
    optional block!  ; headnote comment
    (
        let de: dehex encoded
        if de != decoded [
            fail ["Decode of" @encoded "gave" @de "expected" @decoded]
        ]
        let en: enhex decoded
        if en != re-encoded [
            fail ["Encode of" @decoded "gave" @en "expected" @re-encoded]
        ]
    )
]]
</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/enhex-and-dehex-testing-another-micro-dialect/2323">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/enhex-and-dehex-testing-another-micro-dialect/2323</link>
          <pubDate>Fri, 08 Nov 2024 16:10:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2323</guid>
          <source url="https://forum.rebol.info/t/enhex-and-dehex-testing-another-micro-dialect/2323.rss">ENHEX and DEHEX testing, another &quot;Micro-Dialect&quot;</source>
        </item>
        <item>
          <title>Much Ado About A Tiny Email Test &quot;Micro-Dialect&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Testing</category>
          <description><![CDATA[
            <p>So there was a "micro dialect" for email address scanning.  A simple idea that you could intermix valid and invalid email addresses...to put groups of related emails together even though some in the group would fail and others would succeed.</p>
<p>It was something along these lines:</p>
<pre><code>for-each [mode text] [
    + {email@example.com}
    + {firstname.lastname@example.com}
    - {email@example@example.com}
    + {email@subdomain.example.com}
    + {firstname+lastname@example.com}
    - {email@example.com}
    + {email@123.123.123.123}
    - {email@[123.123.123.123]}
    ...
 ][
    assert [mode: select [+ valid - invalid] mode]
    if (mode = 'valid) != test-scan-email (...) [
        fail ["Expected" @text "to be" an mode "email"]
    ]
 ]
</code></pre>
<p>But for this post, I threw in a couple of "hey that's neat" aspects, like:</p>
<pre><code>&gt;&gt; an "valid"
== "a valid"

&gt;&gt; an "invalid"
== "an invalid"
</code></pre>
<h2><a name="p-7845-enter-dashed-strings-1" class="anchor" href="https://forum.rebol.info#p-7845-enter-dashed-strings-1"></a>Enter Dashed Strings</h2>
<p>I don't know that the <strong><code>+</code></strong> and <strong><code>-</code></strong> markers were ever the greatest, but they certainly lost their appeal with dashed strings.</p>
<pre><code>    + -{email@example.com}-
    + -{firstname.lastname@example.com}-
    - -{email@example@example.com}-
    + -{email@subdomain.example.com}-
</code></pre>
<p>At first I figured I'd just pick an alternative.  There's Y and N...</p>
<pre><code>    Y -{email@example.com}-
    Y -{firstname.lastname@example.com}-
    N -{email@example@example.com}-
    Y -{email@subdomain.example.com}-
</code></pre>
<p>Those are pretty big letterforms that blur together some.  Tilde for trash to differentiate carries the connotation of "something wrong"...</p>
<pre><code>    Y -{email@example.com}-
    Y -{firstname.lastname@example.com}-
    ~ -{email@example@example.com}-
    Y -{email@subdomain.example.com}-
</code></pre>
<p>...but it blurs here too much with the dash.</p>
<p><strong>Really we can ask: why are we decorating the valid things, and not just the invalid things?</strong></p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
    # -{email@example@example.com}-
      -{email@subdomain.example.com}-
</code></pre>
<p>You could use <strong><code>N</code></strong> or <strong><code>*</code></strong> or <strong><code>#</code></strong> or any other nasty here, and it sort of stands out.  Not as well as <strong><code>&lt;bad&gt;</code></strong> would.</p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
&lt;bad&gt; -{email@example@example.com}-
      -{email@subdomain.example.com}-
</code></pre>
<p><strong>But if you're going to break the regularity of the structure, you can't use (today's) FOR-EACH.</strong></p>
<p>If you want to regularize it a bit, you could use something like BLOCK! to mark the bad ones:</p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
     [-{email@example@example.com}-]
      -{email@subdomain.example.com}-
</code></pre>
<p>If that didn't stand out enough, you could use a double-block:</p>
<pre><code>      -{email@example.com}-
      -{firstname.lastname@example.com}-
    [[-{email@example@example.com}-]]
      -{email@subdomain.example.com}-
</code></pre>
<p>It's worth remembering such things are options in some cases, but I don't think that works very well here.</p>
<h2><a name="p-7845-bad-seems-good-but-could-it-be-easier-2" class="anchor" href="https://forum.rebol.info#p-7845-bad-seems-good-but-could-it-be-easier-2"></a><code>&lt;bad&gt;</code> Seems Good, But Could It Be Easier?</h2>
<p>It would be nice if there were some way to type the FOR-EACH variables, and denote their optionality.</p>
<p><span class="mention">@hiiamboris</span> has done some things in this vein, see his <a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/foreach-design.md">type filter on FOR-EACH proposal</a>.  I feel like the concept of skipping and checking should be separate intents.  I can want to type check something but not want to skip it.</p>
<p>A leading colon could imply optionality, as it does with refinements now:</p>
<pre><code>for-each [:bad [tag!] text [text!]] [
        -{email@example.com}-
        -{firstname.lastname@example.com}-
  &lt;bad&gt; -{email@example@example.com}-
        -{email@subdomain.example.com}-
        ...
][
    ...
]
</code></pre>
<p>You can even use <code>&lt;bad&gt;</code> itself for the type check by quoting it, and enforce/document that more stringently.  Also, for the sake of "how does that look in the generator model" I'll write it out that way:</p>
<pre><code>for [:bad ['&lt;bad&gt;] text [text!]] each [
        -{email@example.com}-
        -{firstname.lastname@example.com}-
  &lt;bad&gt; -{email@example@example.com}-
        -{email@subdomain.example.com}-
        ...
][
    ...
]
</code></pre>
<p>Of course you can split this out to a table vs. having the tests inline like that.</p>
<p>Interpreting blocks as type checks seems pretty useful, but that takes away from some other applications which might be used for destructuring.</p>
<p>Anyway, this is just some thinking inspired by a very small example.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/much-ado-about-a-tiny-email-test-micro-dialect/2315">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/much-ado-about-a-tiny-email-test-micro-dialect/2315</link>
          <pubDate>Fri, 11 Oct 2024 21:29:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2315</guid>
          <source url="https://forum.rebol.info/t/much-ado-about-a-tiny-email-test-micro-dialect/2315.rss">Much Ado About A Tiny Email Test &quot;Micro-Dialect&quot;</source>
        </item>
        <item>
          <title>Dimension Conversions in Arturo</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Here is a table of dimensions used by <a href="https://forum.rebol.info/t/arturo-rebol-inspired-language/1370">Arturo</a>, expressed as a table in the Nim language:</p>
<p><a href="https://github.com/arturo-lang/arturo/blob/master/src/vm/values/custom/quantities/definitions.nim" class="inline-onebox">arturo/src/vm/values/custom/quantities/definitions.nim at master Â· arturo-lang/arturo Â· GitHub</a></p>
<p>It's a pretty impressive compendium.  And there's also some "heavily macro-driven" Nim code that implements conversion operations:</p>
<p></p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0.jpeg" data-download-href="https://forum.rebol.info/uploads/default/970992fb6919f5b8f0bb350bcbff2390f350cab0" title="Screenshot_2024-10-11_at_07.40.49"><img src="https://forum.rebol.info/uploads/default/optimized/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0_2_371x375.jpeg" alt="Screenshot_2024-10-11_at_07.40.49" data-base62-sha1="ly8BQYMZcqhc44hu8VlGzNKezNS" width="371" height="375" srcset="https://forum.rebol.info/uploads/default/optimized/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0_2_371x375.jpeg, https://forum.rebol.info/uploads/default/optimized/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0_2_556x562.jpeg 1.5x, https://forum.rebol.info/uploads/default/original/1X/970992fb6919f5b8f0bb350bcbff2390f350cab0.jpeg 2x" data-dominant-color="312113"></a></div><p></p>
<p><a class="mention" href="https://forum.rebol.info/u/drkameleon">@drkameleon</a> cites <a href="https://frinklang.org/">Frink</a> as the main inspiration for this, though assembling the table and conversion code was original work on the order of months.</p>
<h2><a name="p-7841-why-not-use-arturo-for-the-table-1" class="anchor" href="https://forum.rebol.info#p-7841-why-not-use-arturo-for-the-table-1"></a>Why Not Use Arturo For The Table...?</h2>
<p>The table is Nim code...and as such, beholden to having a lot of repetition and commas.</p>
<p>So of course my first question was <em>"why not express it as Arturo, and then spit out the Nim table as part of the build process"</em>?</p>
<p>Instead of:</p>
<pre><code>#-----------------------------------------------------------------------
# Length units (base: m)
#-----------------------------------------------------------------------
#       name  symbol  prefix?    definition      aliases
#-----------------------------------------------------------------------
defUnit "in",  "in", false,  "127:5000 m",      "inch", "inches"
defUnit "ang",  "Ã…", false,  "1:10000000000 m", "angstrom", "angstroms"
defUnit "px",  "px", true,   "1:96 in",         "pixel", "pixels"
</code></pre>
<p>It could be reduced down to something more like this:</p>
<pre><code>    === LENGTH (base: m) ===

     in [127:5000 m] inch inches
    ang [1:10000000000 m] angstrom angstroms ("Ã…")
   */px [1:96 in] pixel pixels
</code></pre>
<p>The meaning of "prefix?" is actually "prefixable?" that a type can have a prefix. e.g. pixels is prefixable because you can say <strong><code>Mpx</code></strong> for "megapixels".  So I think some prefixing decoration on the type is a nice way to convey this.  I just threw in <strong><code>*/px</code></strong> as an example--though I gather that in Arturo that would be <strong><code>*\px</code></strong></p>
<p>Though when I first saw some isolated instance of the colon notation I didn't realize it was a ratio.  Ren-C could do this as a CHAIN! or as a PATH!.  I think my first instinct would have been path:</p>
<pre><code>     in [127/5000 m] inch inches
    ang [1/10000000000 m] angstrom angstroms ("Ã…")
   *.px [1/96 in] pixel pixels
</code></pre>
<p>But it actually looks a bit better with the colons I think.</p>
<p>Some notation would be nice for the pluralization.  It's one of the places where the <a href="https://forum.rebol.info/t/no-interstitial-delimiter-sequence-proposal-fused/1503">FUSED! proposal</a> might come in handy:</p>
<pre><code>     in [127:5000 m] inch{es}
    ang [1:10000000000 m] angstrom{s} ("Ã…")
   */px [1:96 in] pixel{s}
</code></pre>
<p>You can use tuples or paths, but it's not quite as neat...although the paths aren't terrible:</p>
<pre><code>     in [127:5000 m] inch.es
    ang [1:10000000000 m] angstrom.s ("Ã…")
   */px [1:96 in] pixel.s

     in [127:5000 m] inch/es
    ang [1:10000000000 m] angstrom/s ("Ã…")
   */px [1:96 in] pixel/s
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dimension-conversions-in-arturo/2314">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dimension-conversions-in-arturo/2314</link>
          <pubDate>Fri, 11 Oct 2024 07:09:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2314</guid>
          <source url="https://forum.rebol.info/t/dimension-conversions-in-arturo/2314.rss">Dimension Conversions in Arturo</source>
        </item>
  </channel>
</rss>

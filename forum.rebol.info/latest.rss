<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest topics</title>
    <link>https://forum.rebol.info/latest</link>
    <description>Latest topics</description>
    
      <lastBuildDate>Fri, 08 Dec 2023 02:49:41 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/latest.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Making CALL Raise a (definitional) Error For Bad Exit Codes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Before definitional errors existed, I noticed that <a href="https://forum.rebol.info/t/the-need-to-rethink-error/1371/2">@gchiu had some uses of CALL</a> that weren't checking the return code.</p>
<pre><code>call [
    gs -sDEVICE=pngmono -o (join root "-%02d.png") -r600 (pdfname)
]

call [
    gs -sDEVICE=eps2write -sPAPERSIZE=a4
        -o (join root "-%02d.eps") (pdfname)
]
</code></pre>
<p>I wanted the default to raise an error if the <strong>gs</strong> (GhostScript) process did not return a 0 exit code.  But I wanted that error to be a result of CALL... so it would be distinct from other errors (like a typo in the code in the groups inside, <code>pfdname</code> instead of <code>pdfname</code> or whatever).</p>
<p><code>CALL</code> was already a wrapper on top of an internal <code>CALL*</code> function, so I thought "why not expand upon that?"</p>
<h2>
<a name="a-cool-enclose-of-an-augment-of-a-specialize-1" class="anchor" href="https://forum.rebol.info#a-cool-enclose-of-an-augment-of-a-specialize-1"></a>A Cool ENCLOSE of an AUGMENT of a SPECIALIZE!</h2>
<pre><code>call: enclose (
    augment (specialize :call* [wait: #]) [
        /relax "If exit code is non-zero, return the integer vs. raising error"
    ]
) func [f [frame!]] [
    let relax: f.relax
    let result: do f
    if relax or (result = 0) [
        return result
    ]
    return raise make error! compose [
        message: ["Process returned non-zero exit code:" exit-code]
        exit-code: (result)
    ]
]
</code></pre>
<p>I think that's pretty neat.</p>
<p>It twists the CALL* function so that it always waits (vs. spawn a separate process and return a process ID to wait on).</p>
<p>Then it offers a /RELAX setting for getting the exit code back, if you don't want the definitional error behavior.</p>
<p>But then, by default it will RAISE an error.   You can get that error via EXCEPT or you can do TRY CALL if you just want to ignore any errors.</p>
<h2>
<a name="issue-exposed-whos-actually-to-blame-2" class="anchor" href="https://forum.rebol.info#issue-exposed-whos-actually-to-blame-2"></a>Issue Exposed: Who's Actually To Blame?</h2>
<p>While making this I noticed that there were actually several points of failure:</p>
<ul>
<li>
<p>The guts of CALL might not be able to find the file you're asking to execute</p>
</li>
<li>
<p>The executable may run, but return a non-zero exit code</p>
</li>
<li>
<p>If you're running through CALL/SHELL and delegating to it to call a process, then the shell may have its own exit status distinct from the process you tried to call</p>
</li>
</ul>
<p>It seems there's not really any great way to untangle the return results of a shell from that of a process it executes.  <a href="https://en.wikipedia.org/wiki/Exit_status">Here's some of the informal conventions of UNIX shells</a>:</p>
<blockquote>
<p><em>"When a command is terminated by a signal whose number is N, a shell sets the variable $? to a value greater than 128. Most shells use 128+N, while ksh93 uses 256+N."</em></p>
<p><em>"If a command is not found, the shell should return a status of 127. If a command is found but is not executable, the return status should be 126."</em></p>
</blockquote>
<p>So I'm a little shaky on what exactly a TRY CALL should be ignoring.  It's one thing to ignore a program's exit status, and another to ignore whether the program was on disk at all.</p>
<p>TAKE of a BLOCK only has a definitional failure when the block is empty, so you know what TRY TAKE means.  But it may be that you should more or less never say TRY CALL, and always specifically handle the errors that arise from it.  I think this may be a common theme of definitional errors coming out of complicated functions which have more than a single way to fail.</p>
<p>But... in any case, it's progress.  Because we're not conflating typos or other incidental errors to those that are coming from CALL.  And I like the default that it has an error on non-zero exit statuses.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068</link>
          <pubDate>Fri, 08 Dec 2023 02:49:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2068</guid>
          <source url="https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068.rss">Making CALL Raise a (definitional) Error For Bad Exit Codes</source>
        </item>
        <item>
          <title>Accepting the availability of stdint.h and stdbool.h</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>One of Carl's comments in R3-Alpha complained about the lack of a standardization of integer sizes in C:</p>
<blockquote>
<p><em>"One of the biggest flaws in the C language was not to indicate bitranges of integers. So, we do that here.  You cannot 'abstractly remove' the range of a number.  It is a critical part of its definition."</em></p>
</blockquote>
<p>So he did some empirical platform detection to define things like REBI32 for a signed 32-bit integer, REBU64 for an unsigned 64-bit integer, etc.</p>
<p>But once C99 arrived, the file &lt;stdint.h&gt; offered several basic types, and basically covered the needs with types that had names like <strong>int32_t</strong> and <strong>uint64_t</strong>:</p>
<p><a href="http://en.cppreference.com/w/c/types/integer" class="inline-onebox">Fixed width integer types (since C99) - cppreference.com</a></p>
<p>So Ren-C was changed to use the C99 names and include <code>&lt;stdint.h&gt;</code>.  For pre-C99 compilers, it used a portable shim called "pstdint", which it maintained its own copy of in the repository:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/e6e3e7fe0fcff165557f9ffc3de3e6713a50f99a/src/include/pstdint.h">src/include/pstdint.h</a></strong></p>
<p>By similar reasoning, booleans were shimmed with another found-file:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/blob/e6e3e7fe0fcff165557f9ffc3de3e6713a50f99a/src/include/pstdbool.h">src/include/pstdbool.h</a></strong></p>
<h2>
<a name="ren-c-has-embraced-c99-so-why-keep-these-shims-1" class="anchor" href="https://forum.rebol.info#ren-c-has-embraced-c99-so-why-keep-these-shims-1"></a>Ren-C Has Embraced C99, So Why Keep These Shims?</h2>
<p>C99 is now a prerequisite for building the system.</p>
<p>It may be that some pre-C99 standards compiler <em>could</em> still build Ren-C with these shims, though it would need variadic macro support.  The odds of a compiler having that support yet lacking things like <strong>bool</strong> and <strong>int32_t</strong> are fairly slim.</p>
<p>In any case, these esoteric compilation environments could be "shimmed" by hacking in versions of stdint.h and stdbool.h to their include directories.  I feel like that's the responsibility of the build environment at this point... and that the Ren-C codebase need not be carrying the baggage.</p>
<p>So I'm pulling the files out.  If anyone is on an esoteric platform and trying to build but finds these definitions being missing is the only problem, then they should dig up pstdint and pstdbool.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/accepting-the-availability-of-stdint-h-and-stdbool-h/2067">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/accepting-the-availability-of-stdint-h-and-stdbool-h/2067</link>
          <pubDate>Thu, 07 Dec 2023 18:40:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2067</guid>
          <source url="https://forum.rebol.info/t/accepting-the-availability-of-stdint-h-and-stdbool-h/2067.rss">Accepting the availability of stdint.h and stdbool.h</source>
        </item>
        <item>
          <title>Definitional Break and Continue... the Time is Now</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I was writing what I thought to be a clever bit of code, <a href="https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065">discussed here</a></p>
<pre><code>for-each file ... [
    parse file [thru any [".reb" ".r"] &lt;end&gt; | (continue)]
    ...
]
</code></pre>
<p>I thought it was pleasing to have the CONTINUE in the rules themselves.</p>
<p>Pleasing, except... a bit displeasing considering <strong>it didn't work.</strong></p>
<p>BREAK and CONTINUE would break or continue the first loop they found above them in the stack.  Since PARSE is currently written in usermode code, it uses loops in its implementation (to loop over the rules).  <em>so you wind up continuing some arbitrary loop inside the combinators, having random effects</em>!</p>
<p>Happily Ren-C has pioneered answers to this kind of problem with definitional returns.  But loops just have to get with the program and make CONTINUE and BREAK definitional in their bodies.</p>
<p>So I did it!  And most things appeared to work (like the motivating example).</p>
<h2>
<a name="still-complexity-for-loops-implemented-without-loops-1" class="anchor" href="https://forum.rebol.info#still-complexity-for-loops-implemented-without-loops-1"></a>Still Complexity For Loops Implemented Without "Loops"</h2>
<p>In bootstrap, there was some code implementing FOR-EACH-PLATFORM.  Hand-waving a bit, it initially looked like this:</p>
<pre><code> for-each-platform: func ['var [word! tuple!] body [block!]] [
     parse platforms-table [
         while [not &lt;end&gt;] [
              ...  ; rules that build up an OBJECT! 
              (set var obj, do body)
         ]
     ]
 ]
</code></pre>
<p>But that didn't make CONTINUE work:</p>
<pre><code> for-each-platform p [
     if p.name = 'HaikuOS [continue]
     ...
 ]
</code></pre>
<p>So I'd hacked up something at one point in history which looked like this monstrosity:</p>
<pre><code>    completed*: false
    running*: false
    while [true] [  ; must be in loop for BREAK or CONTINUE
        if running* [  ; must have had a CONTINUE
            completed*: true
            break
        ]
        running*: true
        do body
        completed*: true
        break
    ]
    if not completed* [return null] 
</code></pre>
<p>That depended on non-definitional CONTINUE happening inside BODY finding the enclosing WHILE.</p>
<p>But now, that CONTINUE isn't definitionally bound anywhere.  So that CONTINUE is just a reference to a default CONTINUE function in LIB, which will error telling you there are no loops providing continue available.</p>
<p>For the modern world, this <em>works</em>:</p>
<pre><code> repeat 1 body else [return null]
</code></pre>
<p>Reserving the pure NULL return value for BREAK means you can get that communication of when BREAK was encountered out of the return result.  And in this case, CONTINUE is just supposed to bypass the remainder of code in BODY and go on parsing.  So it works.</p>
<p>But it's suboptimal as the binding of the body to BREAK and CONTINUE happens on each run instead of once.  Doing that more efficiently would need some new techniques and case studies.</p>
<p>Overall though, it's progress...in the sense that there's an answer that works slowly, vs. not working at all!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066</link>
          <pubDate>Thu, 07 Dec 2023 16:29:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2066</guid>
          <source url="https://forum.rebol.info/t/definitional-break-and-continue-the-time-is-now/2066.rss">Definitional Break and Continue... the Time is Now</source>
        </item>
        <item>
          <title>Deceptive Incomplete Parsing: A Common Problem</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Some code I'd written checked for file extensions, wanting only %.r and %.reb files to be processed.  It looked like this:</p>
<pre><code> for-each file ... [
     parse file [thru ".reb" | thru ".r"] else [continue]
     ...
 ]
</code></pre>
<p>That doesn't work anymore, because PARSE raises an error instead of returning null.  The ELSE needs to be an EXCEPT, or you have to use IF NOT OK?, or some other solution.</p>
<p>My first thought on fixing it was why not just put the CONTINUE inside the parse...</p>
<pre><code> for-each file ... [
     parse file [thru ".reb" | thru ".r" | (continue)]
     ...
 ]
</code></pre>
<p>That's a neat Rebolism that shows the kind of malleability other languages just don't have.</p>
<p>But it has a problem.  Can you spot it?</p>
<h2>
<a name="old-redbol-conventions-wouldnt-catch-the-mistake-1" class="anchor" href="https://forum.rebol.info#old-redbol-conventions-wouldnt-catch-the-mistake-1"></a>Old Redbol Conventions Wouldn't Catch The Mistake</h2>
<p>Imagine if the file is named <strong>%foo.reb.zip</strong> or <strong>%foo.rar</strong>.  One of the THRUs succeeds, so it won't run the continue alternate.  But it won't reach the end of the filename.</p>
<p>Historical Redbol would have had the PARSE return false, but would have just blindly continued running, passing those unintended filenames!!!</p>
<p>Now we're a step ahead, because PARSE will error if it doesn't reach the end!  <img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=12" title=":clap:" class="emoji" alt=":clap:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="but-how-to-stop-the-error-2" class="anchor" href="https://forum.rebol.info#but-how-to-stop-the-error-2"></a>But How To Stop the Error?</h2>
<p>We don't want an error if it doesn't terminate in %.r or %.reb, we want to continue the loop.</p>
<p>This will work:</p>
<pre><code> parse file [thru ".reb" &lt;end&gt; | thru ".r" &lt;end&gt; | (continue)]
</code></pre>
<p>And it's not catastrophically bad.  But it feels weird.</p>
<p>You can remove the <code>&lt;end&gt;</code> duplication:</p>
<pre><code> parse file [thru [".reb" | ".r"] &lt;end&gt; | (continue)]
</code></pre>
<p>You can also do that with ANY:</p>
<pre><code> parse file [thru any [".reb" ".r"] &lt;end&gt; | (continue)]
</code></pre>
<p>You can of course go for the conventional forms:</p>
<pre><code>parse file [thru ".reb" | thru ".r"] except [continue]

if not ok? parse file [thru ".reb" | thru ".r"] [continue]
</code></pre>
<p>But I feel like there's something missing when you write something like this without making the <code>&lt;end&gt;</code> explicit...because it leads to someone getting the bright idea (as I did) to reformulate it without taking the <code>&lt;end&gt;</code> into account.</p>
<h2>
<a name="in-any-case-this-being-overlooked-is-now-caught-3" class="anchor" href="https://forum.rebol.info#in-any-case-this-being-overlooked-is-now-caught-3"></a>In Any Case, This Being Overlooked Is Now Caught!</h2>
<p>It's food for thought on what style you want. But no matter what style you like, I think it shows a clear win for raising the error when the parse doesn't reach the end.</p>
<p>That %foo.rar or %foo.reb.zip -- when they occur -- will not be accepted quietly in the reformulation!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065</link>
          <pubDate>Tue, 28 Nov 2023 03:33:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2065</guid>
          <source url="https://forum.rebol.info/t/deceptive-incomplete-parsing-a-common-problem/2065.rss">Deceptive Incomplete Parsing: A Common Problem</source>
        </item>
        <item>
          <title>Dialect Meaning of Non-Words in Function Parameter Spec Blocks</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Historical Redbol only had WORD!s in the BLOCK! that came after a parameter:</p>
<pre><code>foo: func [
    arg [block! word! number!]  ;  all words in block
] ...
</code></pre>
<p>But when Ren-C introduced the paradigm-breaking NULL that could not be put in arrays, that meant there was no <code>null!</code> datatype.  To fill the gap, the tag <code>&lt;opt&gt;</code> was chosen to indicate the parameter as optional--hence possibly null:</p>
<pre><code>foo: func [
    arg [&lt;opt&gt; block! word! number!]  ;  now it's WORD!s and TAG!s
] ...
</code></pre>
<p>I liked using a TAG! for how it stood out (though in retrospect I'd have probably chosen <code>&lt;null&gt;</code>, but everything was named differently then).  Other quirky ideas were floated, like being able to put a leading slash on the typeset block:</p>
<pre><code>foo: func [
    arg /[block! word! number!]  ; like a refinement, but on the types
] ...
</code></pre>
<p>That didn't gain traction, and probably shouldn't have.</p>
<p>Then when early efforts faced another value state that couldn't be put in a block and didn't have a type, <strong><code>&lt;void&gt;</code></strong> came onto the scene...because as with there being no NULL!, there was no VOID! datatype.</p>
<h2>
<a name="tag-modifiers-which-werent-type-checkers-showed-up-1" class="anchor" href="https://forum.rebol.info#tag-modifiers-which-werent-type-checkers-showed-up-1"></a>Tag Modifiers Which Weren't Type Checkers Showed Up</h2>
<p>The ability to take a parameter but get an immutable view of it was added as <strong><code>&lt;const&gt;</code></strong>.</p>
<p>Parameters that would accept being at the end of input and evaluate to null in that case were <strong><code>&lt;end&gt;</code></strong></p>
<p><strong><code>&lt;variadic&gt;</code></strong> and <strong><code>&lt;skippable&gt;</code></strong> came into existence.</p>
<p>These "parameter-control tags" seemed to me to be a distinct category from typecheckers like <strong><code>&lt;opt&gt;</code></strong> and <strong><code>&lt;void&gt;</code></strong>.   Having them all use TAG! felt like <em>too many tags.</em></p>
<p>So I mused about splitting the roles, something like:</p>
<pre><code>[&lt;const&gt; #null type!]
-or-
[#const &lt;null&gt; type!]
</code></pre>
<p>But I didn't like the look of it enough to move on it.  So things like <strong><code>[&lt;const&gt; &lt;opt&gt; type!]</code></strong> stuck around while I wondered about it.</p>
<h2>
<a name="today-you-can-specify-any-type-check-by-function-2" class="anchor" href="https://forum.rebol.info#today-you-can-specify-any-type-check-by-function-2"></a>Today, You Can Specify Any Type Check By Function</h2>
<p>There's still no NULL! or VOID!.  But with the way things work now, you can use functions as "type predicates" to recognize things that aren't datatypes in their own right:</p>
<pre><code>foo: func [
    arg [null? block! word! number!]
] ...
</code></pre>
<p>What's good:</p>
<ul>
<li>It leaves TAG! for the properties like <strong><code>&lt;const&gt;</code></strong> that don't have to do with type recognition... but rather controlling the parameter in a more special way.</li>
</ul>
<p>What's bad:</p>
<ul>
<li>It loses that kind of special look that tags gave to arguments that could take null.  It blurs together, especially with things like SPLICE? and LOGIC? and CHAR? for other non-fundamental datatypes (characters are just single-character issues now, and ~true~ and ~false~ isotopes of WORD! implement logic)</li>
</ul>
<h2>
<a name="a-modern-option-null-for-taking-null-3" class="anchor" href="https://forum.rebol.info#a-modern-option-null-for-taking-null-3"></a>A Modern Option: ~NULL~ for Taking Null</h2>
<p>I made an experiment so if you used a QUASI-WORD!, then it would match an isotope of that form.</p>
<p>It's a kind of pleasingly distinct look:</p>
<pre><code>foo: func [
    arg [~null~ block! word! number!]
] ...
</code></pre>
<p>And it mixes better with the tags:</p>
<pre><code>foo: func [
    arg [~null~ &lt;const&gt; block! word! number!]
] ...
</code></pre>
<p>It also works for "nones" (isotopic voids) and doesn't look too bad there, e.g. for RETURN:</p>
<pre><code>foo: func [
    return: [~]  ; as opposed to `return: [none?]`
 ] ...
</code></pre>
<p>That doesn't work for voids, and the current idea is that there's no VOID! because TYPE OF VOID gives back NULL.  This is consistent with void-in-null out in general, although it might confuse people who expect to do:</p>
<pre><code>switch type of value [
    null [print "This means value was void, not null"]
    ...
]
</code></pre>
<p>So the idea there was that perhaps TYPE OF NULL is an error, and this guides you to another solution like <strong>switch/type</strong> where you can use <strong>&amp;[null?]</strong> or <strong>&amp;[void?]</strong> as type predicates and get what you actually want.</p>
<p><em>(I still don't think defining <strong>null!: &amp;[null?]</strong> is a good idea, because it looks like a fundamental datatype, and you cannot <strong>make null! ...</strong> etc.  Maybe <strong>null?!: &amp;[null?]</strong> or something like that would be a bit less noisy at usage sites, enough to be worth it?)</em></p>
<h2>
<a name="allowing-null-and-null-as-choices-seems-good-4" class="anchor" href="https://forum.rebol.info#allowing-null-and-null-as-choices-seems-good-4"></a>Allowing NULL? and ~NULL~ As Choices Seems Good</h2>
<p>I think we can live with <strong>void?</strong> in function specs for functions that deliberately take voids.  It's also more legitimate--voids are more neutral than nulls in the current formulation--e.g. <strong>append [a b c] void</strong> is [a b c].</p>
<p>I like the option of <strong>~null~</strong> instead of <strong>null?</strong> to call out the more rare-and-alarming idea of accepting null parameters.</p>
<h2>
<a name="what-about-return-nihil-and-return-none-5" class="anchor" href="https://forum.rebol.info#what-about-return-nihil-and-return-none-5"></a>What about <code>return: &lt;nihil&gt;</code> and <code>return: &lt;none&gt;</code>
</h2>
<p>These two special uses of tag! with no block have been used to say you don't need a RETURN statement at all... the function just gives back none or nihil respectively when the body completes.</p>
<p>How necessary is it?  Well, you either write things like:</p>
<pre><code>comment: func [
    return: [nihil?]
    discarded [any-value!]
][
    return nihil
]
</code></pre>
<p>Or you have the contraction:</p>
<pre><code>comment: func [
    return: &lt;nihil&gt;
    discarded [any-value!]
][
]
</code></pre>
<p>This style of "don't even worry about writing a RETURN" has the widest applicability to NONE and NIHIL.  We don't strictly need it, but I've gotten used to it.</p>
<p>I mention <strong>return: [~]</strong> as a possible alternative for saying none is a return type using the quasiform-means-isotope idea.  And since none falls out of function bodies by default with no return, it's not strictly necessary to have <strong><code>return: &lt;none&gt;</code></strong> as any kind of special operation.</p>
<p>Again, how does that look?</p>
<pre><code>foo: func [
    return: [~]
 ] ...
</code></pre>
<p>If you're going to break the pattern and not say <strong><code>return: [none?]</code></strong>  then I may call that a break-even alternative to <strong><code>return: &lt;none&gt;</code></strong>.  A little more symbol-y, but doesn't break the rhythm of type specs being blocks.</p>
<p>This leaves the nihil case.  We could say <strong>return: [~[]~]</strong> and have that mean "I return an empty pack" but in that case you'd still need an explicit return:</p>
<pre><code>comment: func [
    return: [~[]~]
    discarded [any-value!]
][
    return nihil
]
</code></pre>
<p>But I think I like <strong><code>return: [nihil?]</code></strong> better than that.  Compared to <strong><code>return: [~]</code></strong> the <strong><code>[~[]~]</code></strong> is a bridge too far.</p>
<p>Anyway, the reason this is a struggle is that <strong><code>return: &lt;none&gt;</code></strong> has just become so pervasive that it's hard to see that changed to <strong><code>return: [none?]</code></strong>.  But standardizing on blocks and moving away from the tags for this application may be the best idea.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/dialect-meaning-of-non-words-in-function-parameter-spec-blocks/2064">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dialect-meaning-of-non-words-in-function-parameter-spec-blocks/2064</link>
          <pubDate>Sat, 25 Nov 2023 08:25:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2064</guid>
          <source url="https://forum.rebol.info/t/dialect-meaning-of-non-words-in-function-parameter-spec-blocks/2064.rss">Dialect Meaning of Non-Words in Function Parameter Spec Blocks</source>
        </item>
        <item>
          <title>Why can&#39;t you PROTECT individual cells in an array?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p>You can PROTECT a variable:</p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; protect 'x

&gt;&gt; x: 20
** Access Error: variable x locked by PROTECT (see UNPROTECT)
</code></pre>
<p>And you can PROTECT an array pointed to by a variable:</p>
<pre><code>&gt;&gt; array: [&lt;a&gt; b #c]

&gt;&gt; protect array

&gt;&gt; append array ["d"]
** Access Error: series read-only due to PROTECT (see UNPROTECT)

&gt;&gt; array: [&lt;q&gt; r #s]  ; variable holding array not protected

&gt;&gt; array
== [&lt;q&gt; r #s]
</code></pre>
<p>...but you can't PROTECT a cell resident inside an array:</p>
<pre><code>&gt;&gt; array: [&lt;a&gt; b #c]

&gt;&gt; protect 'array.2  ; this doesn't work

&gt;&gt; array.2: "z"
; you'd expect an error here if it did work

&gt;&gt; array.3: 1020
; you'd expect no error here if it did work
</code></pre>
<p>R3-Alpha didn't have the feature, and Ren-C hasn't added it.  Why?</p>
<h2>
<a name="making-this-work-would-add-significant-complexity-1" class="anchor" href="https://forum.rebol.info#making-this-work-would-add-significant-complexity-1"></a>Making This Work Would Add Significant Complexity</h2>
<p>Your first thought (well, mine) would be that this is about efficiency.  e.g. if you were going to write something like <strong>clear block</strong>, the existence of PROTECT'd cells inside that block would mean you'd have to visit all the cells before knowing if it was okay to clear it.  Other code that already has to visit the cells in order to copy them would still pay a little more too... like <strong>take/part</strong>.</p>
<p><em>But that's not where the real problem is.</em>  Paying a little more for mutating operations is only slightly relevant.  The real problem has to do with a pointer to a cell not being able to answer the question of its own mutability--since it can't speak for the container's protection status.</p>
<p>In more detail:</p>
<p>Ren-C's clever management of immutability uses the C <code>const</code> designator.  What the const means on a <em>series</em> is that the series may be mutable, but hasn't had a runtime check yet to flip it over to being readable.  And what the const means on <em>cells</em> is that the cell was <em>extracted</em> from a series that may be mutable, but hadn't had the runtime check applied.</p>
<p>This way, casual code that just messes around reading cells and series can be written easily, using const pointers and not paying for runtime checks.  And you can be certain of not skipping the runtime checks in the places where you want to get mutable access.  (R3-Alpha was full of bugs from "just forgetting".)</p>
<p>The problem with getting a granularity of cell-level mutability is that right now, there's just one runtime check that gives you a mutable cell pointer...done at the array level:</p>
<pre><code>Cell* tail;
Cell* cell = VAL_ARRAY_AT_ENSURE_MUTABLE(&amp;tail, block);
</code></pre>
<p>There are multiple checks done, here.  The BLOCK! cell passed in may or may not carry a CONST cell bit--which is to say, that particular reference to the BLOCK! might be const (even if the underlying array hasn't been PROTECT'd).  And then, there's the protection status of the array...which can also become protected during enumerations of the array, or if it is executing currently in the evaluator.</p>
<p>If this code doesn't trigger a failure from discovering a form of mutability, then the non-const <code>Cell*</code> is given back.</p>
<p>But then...the code will increment that cell pointer to find other cells in the array.  And incrementing a mutable pointer gives you another mutable pointer.</p>
<p>It may seem we <em>could</em> make <code>Cell(*)</code> in the C++ debug build a smart pointer class that gives you back a <code>Cell(const*)</code> when incremented.  And then say that there's a way to promote a const cell reference to a mutable cell reference with a runtime check.</p>
<p>But this would be deceptive.  We already know that if you have a const reference to a cell that lives in the middle of an array, that a runtime check of the containing array for that cell hasn't been done yet.</p>
<p>In other words: once you have your hands on a cell pointer, it's too late to ask about <em>that</em> cell's mutability.  The knowledge is up to the container.</p>
<p>Trying to solve this would be a mess.  e.g. making a kind of Cell(const*) that was the size of two pointers, but held a reference to the array the cell was resident in...in case you wanted to do the runtime check asking for a promotion to a Cell(*).</p>
<p>I've been moving in the other direction...paring away complexities in the source where possible.  Something like that doesn't belong in the codebase--especially to implement a feature that I can only vaguely imagine uses for.</p>
<h2>
<a name="so-dont-expect-cell-level-protectever-2" class="anchor" href="https://forum.rebol.info#so-dont-expect-cell-level-protectever-2"></a>So Don't Expect Cell-Level PROTECT...Ever</h2>
<p>Every now and again I've looked at the flag and thought "why does this apply only to variable cells?"  So I wanted to hammer out the reasoning, and confirm that it wasn't just about performance.</p>
<p>From my point of view, it's about creating a situation of a flag that needs to be checked, and which the code has no (reasonable) systemic way to enforce that checking.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-cant-you-protect-individual-cells-in-an-array/2062">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-cant-you-protect-individual-cells-in-an-array/2062</link>
          <pubDate>Tue, 21 Nov 2023 22:52:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2062</guid>
          <source url="https://forum.rebol.info/t/why-cant-you-protect-individual-cells-in-an-array/2062.rss">Why can&#39;t you PROTECT individual cells in an array?</source>
        </item>
        <item>
          <title>Executable Size circa 2023...and tweaking INLINE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>A modern Ren-C non-debug executable on Linux--with https and the libuv filesystem and networking code (which supports asynchronous file I/O etc.) is about 1.7 MB when it is built at an O2 level of optimization (optimize for speed).</p>
<p>When built at Os optimization it's about 1.2 MB, sacrificing 40% of the speed to get the compression.  (In the modern era, most people would say that the extra size isn't a big deal to get that much of a speed improvement.)</p>
<p>By comparison, an R3-Alpha Linux executable is about 0.56 MB at O2.  And a Red CLI-only binary on Linux is about 1.0 MB.</p>
<h2>
<a name="why-has-size-gone-up-1" class="anchor" href="https://forum.rebol.info#why-has-size-gone-up-1"></a>Why Has Size Gone Up?</h2>
<p>I've looked under the hood at the differences with R3-Alpha to see what accounts for the disparity with modern Ren-C.  libuv accounts for a couple 100k, and is worth it--it would be especially so if taking advantage of things like the async file I/O.</p>
<p>But the rest just generally comes down to the fact that it's about twice as much code.  If you enjoy using ADAPT or ENCLOSE or SPECIALIZE, well, there's code that implements it.  And it's a deeper, safer, far more advanced codebase that just does more.</p>
<h2>
<a name="i-actually-pared-out-about-600k-by-tweaking-inlining-2" class="anchor" href="https://forum.rebol.info#i-actually-pared-out-about-600k-by-tweaking-inlining-2"></a>I Actually Pared Out About 600K By Tweaking Inlining</h2>
<p>When I started looking at size, the O2 binary was like 2.4 MB.  That was more than I expected, so I decided to look under the hood into why.</p>
<p>I used Google's tool <a href="https://github.com/google/bloaty">Bloaty McBloatface</a> to get some insight, and to my surprise...some rather small functions had a disproportionate amount of code attributed to them.</p>
<p>It turned out that this was due to putting functions in header files and inlining them with <code>static inline</code>.  When I moved 5 of these functions into the .c files instead of the .h files, that saved 400k in one blow... and the executable only got 0.4% slower (four tenths of a percent) as a result.</p>
<p>Then I managed to make it so the C++ build was about 140K lighter by changing the <code>static inline</code> on the remaining functions to a macro of INLINE that's either <code>inline</code> in the C++ build, or <code>static inline</code> in the C build.</p>
<p>I guess the takeaway here is that even if you notice that something is getting bigger due to good reasons of having more code, it always pays to look under the hood a bit when you can.  A few hours of work can get some low-hanging fruit.</p>
<p>(Another takeaway is that being able to build a C codebase as C++--if you want to--continuously pays dividends...)</p>
<p>Here's some notes on the INLINE macro:</p>
<pre><code class="lang-auto">
//=//// INLINE MACRO FOR LEVERAGING C++ OPTIMIZATIONS /////////////////////=//
//
// "inline" has a long history in C/C++ of being different on different
// compilers, and took a long time to get into the standard.  Once it was in
// the standard it essentially didn't mean anything in particular about
// inlining--just "this function is legal to appear in a header file and be
// included in multiple source files without generating conflicts."  The
// compiler makes no particular promises about actually inlining the code.
//
// R3-Alpha had few inline functions, but mostly used macros--in unsafe ways
// (repeating arguments, risking double evaluations, lacking typechecking.)
// Ren-C reworked the code to use inline functions fairly liberally, even
// putting fairly large functions in header files to give the compiler the
// opportunity to not need to push or pop registers to make a call.
//
// However, GCC in C99 mode requires you to say `static inline` or else you'll
// get errors at link time.  This means that every translation unit has its
// own copy of the code.  A study of the pathology of putting larger functions
// in headers as inline with `static inline` on them found that about five
// functions were getting inlined often enough to add 400K to the executable.
// Moving them out of .h files and into .c files dropped that size, and was
// only about *0.4%* slower (!) making it an obvious win to un-inline them.
//
// This led to experimentation with C++ builds just using `inline`, which
// saved a not-insignificant 8% of space in an -O2 build, as well as being ever
// so slightly faster.  Even if link-time-optimization was used, it still
// saved 3% on space.
//
// The long story short here is that plain `inline` is better if you can use
// it, but you can't use it in gcc in C99 mode (and probably not other places
// like TinyC compiler or variants). So this clunky INLINE macro actually
// isn't some pre-standards anachronism...it has concrete benefits.
//
#if CPLUSPLUS_11
    #define INLINE inline
#else
    #define INLINE static inline
#endif
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/executable-size-circa-2023-and-tweaking-inline/2061">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/executable-size-circa-2023-and-tweaking-inline/2061</link>
          <pubDate>Tue, 21 Nov 2023 05:02:05 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2061</guid>
          <source url="https://forum.rebol.info/t/executable-size-circa-2023-and-tweaking-inline/2061.rss">Executable Size circa 2023...and tweaking INLINE</source>
        </item>
        <item>
          <title>Lisps, Kernel, Clojure: limits of &quot;Code is Data and Data is Code&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I had little-to-no Lisp experience when I encountered Rebol.  I just knew the general concept of "code is data, and data is code", and assumed they were similar.</p>
<p>But as it turns out, <em>executing arbitrary structures of code constructed at runtime is taboo in most Lisps.</em>  This comes under the umbrella of "EVAL", and <a href="https://stackoverflow.com/questions/2571401/why-exactly-is-eval-evil">warned against for all the reasons that people say it's bad in any language</a>...such as why you wouldn't want to run an arbitrary string of JavaScript code.  About the only exception they seem to consider is the Read-Eval-Print-Loop: <strong><code>(loop (print (eval (read))))</code></strong>.</p>
<p>There are warnings about the inefficiency of EVAL not being compiled...or the security concerns of running fully arbitrary code that is cobbled together from possibly unsanitized sources (which Rebol deliberately ignores).</p>
<p>If you're willing to ignore that, you still face the Big Mechanical Problem:</p>
<blockquote>
<p><em>"[EVAL] evaluates under the global environment, losing your local context."</em></p>
</blockquote>
<h2>
<a name="but-if-so-how-do-branches-work-in-lisps-1" class="anchor" href="https://forum.rebol.info#but-if-so-how-do-branches-work-in-lisps-1"></a>But If So... How Do Branches Work in Lisps?</h2>
<p>If you have a branching function like EITHER, and it has two legs of the branch with the intent to only run one of them... doesn't that require selectively running an "EVAL"?  The EITHER receives a condition and then two "blocks" (lists) specifying arbitrary code.  If you lose all your local variables known at the callsite of the EITHER, how can it work?</p>
<p>The answer depends on which Lisp variation you are using.  If you are using a classical Lisp (or Clojure), it simply has a list of exceptions... or "special forms".  These constructs are treated weirdly by the compiler and it's just swept under the rug.  For example:</p>
<p><strong><a href="https://clojure.org/reference/special_forms">Special Forms in Clojure</a></strong></p>
<p>Another possibility would be if there was some kind of environment capture at the callsite, and the EITHER received this environment as a parameter.  Then it could pass that environment to EVAL...so the eval would happen as if it were at the callsite.</p>
<p>Were that written in a Rebol-like syntax, it would be quoting all its arguments and look like:</p>
<pre><code> either: func [
     'condition [group!]  ; conditions would have to be grouped
     'true_branch [block!]
     'false_branch [block!]
     &lt;environment&gt; env  ; implicit capture of environment at callsite
 ][
     if do/environment condition env [  ; let's say IF is a native
         return do/environment true_branch env
     ]
     return do/environment false_branch env
 ]
</code></pre>
<p>Now that you're familiar with the idea, here is that written in how the <a href="https://web.cs.wpi.edu/~jshutt/kernel.html">"Kernel" Lisp Variant</a> does it:</p>
<pre><code>($define! $either
   ($vau (condition true_branch false_branch) env
       ($if (&gt;=? (eval condition env) 0)
           (eval true_branch env)
           (eval false_branch env))))
</code></pre>
<p>Notably, <strong>Kernel is considered a very experimental black-sheep of the Lisp world</strong>, due to how much slower this generalized method of thinking is.  Special forms understood by the compiler are the norm.</p>
<p>However, being able to pass environments to EVAL is <a href="https://www.gnu.org/software/texinfo/gsoc-2017-js-example/kawa/Eval-and-Environments.html">seemingly endorsed in modern Scheme</a>.  But that's not a feature of Clojure.</p>
<h2>
<a name="macros-cover-some-monkeying-with-code-structure-cases-2" class="anchor" href="https://forum.rebol.info#macros-cover-some-monkeying-with-code-structure-cases-2"></a>Macros Cover Some Monkeying-With-Code-Structure Cases</h2>
<p>Lisp Macros can be used for source-to-source transformations, manipulating structure in the free-wheeling way we might think of doing in Rebol.  But that transformation happens only once.</p>
<p>This Reddit question <a href="https://www.reddit.com/r/lisp/comments/13rmllb/difference_between_function_with_quoted_arguments/">asks about the difference between macros and receiving arguments unevaluated</a>:</p>
<blockquote>
<p><em>"If we put a backtick in front of the body of a function and we pass arguments quoted when calling it, wouldn't the function work the same as a macro (except that macros are evaluated in an earlier stage)? What would be the difference in practice? And how does this approach compare to fexpr?"</em></p>
</blockquote>
<p>The answers outline the difference... macros just run once, and they don't call EVAL on the code they get... they just return new code which will be evaluated later.  If you wrote something like an EITHER as a macro, you would have to transform it into IFs, and be dependent on the special forms to do the actual "weird" mechanic.</p>
<h2>
<a name="isnt-this-kind-of-weak-for-the-data-is-code-mantra-3" class="anchor" href="https://forum.rebol.info#isnt-this-kind-of-weak-for-the-data-is-code-mantra-3"></a>Isn't This Kind of Weak for the "Data is Code" Mantra?</h2>
<p>It does seem disappointing.  :-/</p>
<p>But Lisps haven't taken over the world, and maybe this is part of why.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/lisps-kernel-clojure-limits-of-code-is-data-and-data-is-code/2060">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/lisps-kernel-clojure-limits-of-code-is-data-and-data-is-code/2060</link>
          <pubDate>Sat, 11 Nov 2023 21:52:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2060</guid>
          <source url="https://forum.rebol.info/t/lisps-kernel-clojure-limits-of-code-is-data-and-data-is-code/2060.rss">Lisps, Kernel, Clojure: limits of &quot;Code is Data and Data is Code&quot;</source>
        </item>
        <item>
          <title>ReplPad Visual PARSE Debugger</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p>Hey!  I've gotten UPARSE hooked up to a debugger:</p>
<p><a href="https://www.youtube.com/watch?v=doS7NgajRxI">Ren-C PARSE Hook Demo: Debugging</a></p>

<p>The ability to step in at every level shows just how granular the hook is.  It's not a terrible lot of code:</p>
<p><a href="https://github.com/hostilefork/replpad-js/blob/eb8a62054d345f798b3b87364943df3534a7b92e/eparse.reb#L334">https://github.com/hostilefork/replpad-js/blob/eb8a62054d345f798b3b87364943df3534a7b92e/eparse.reb#L334</a></p>
<p>It's barely tested, but it is public on the ReplPad if anyone wants to throw something at it.</p>
<h2>
<a name="what-concerns-did-writing-this-raise-1" class="anchor" href="https://forum.rebol.info#what-concerns-did-writing-this-raise-1"></a>What Concerns Did Writing This Raise?</h2>
<p>Having the debugger in the ReplPad gives an immediate user annoyance: <em>Why can't I type in the console while the debugger is running?</em>  (That's a huge can of worms and requires several posts of its own to talk about.)</p>
<p>The design of UPARSE is that you can provide your own set of combinators to use.  You can give it a new WORD! combinator that does something besides fetch what the word looks up to and "act like it would if it were written there".  While this simple tracing facility can handle generic interpretations, the generality could subvert the usefulness of higher level tools.</p>
<p>Beyond that problem of "words may not look things up at all", there's also the problem of "discovery".  Everything is "discovered" as you go along--there's not a list supplied up front.  That may not be a fit for some tools, so they could end up asking you to pass in the names of all the rules of interest even though they don't need to be "instrumented".</p>
<p>I thought of adding a BREAKPOINT combinator, so you could break in mid-parse.  But I was only building up a list modeling the stack for frames while you were interacting with the buttons.  Having the stack always available at an arbitrary moment would mean that the stack model would have to be updated on every call to the hook.  Effectively this duplicates information held in the "real stack"--the subset of function calls that represent combinators.  So it's tempting to find a way to label stack frames and enumerate them generically, vs. expecting all debuggers like this to maintain their own.</p>
<p>There's a lot to think about, here.  But as Rebol in the browser goes, this really is the only game in town, and it's holding up pretty well whenever I exercise it!</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/replpad-visual-parse-debugger/2063">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/replpad-visual-parse-debugger/2063</link>
          <pubDate>Thu, 26 Oct 2023 02:19:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2063</guid>
          <source url="https://forum.rebol.info/t/replpad-visual-parse-debugger/2063.rss">ReplPad Visual PARSE Debugger</source>
        </item>
        <item>
          <title>MOLD/ONLY vs. MOLD SPREAD</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historically, the way you would ask to mold an array without its delimiters was with MOLD/ONLY:</p>
<pre><code>rebol2&gt;&gt; mold [a b c]
== "[a b c]"

rebol2&gt;&gt; mold/only [a b c]
== "a b c" 
</code></pre>
<p>In Ren-C this raises some existential questions, like how should quoted arrays be handled?</p>
<pre><code>mold/only first [''(a b c) d e]  ; ???
</code></pre>
<p>But I think there's a better answer: <em>use SPREAD and splice isotopes</em>.  If you want to mold the contents of an array, then turning it into a splice seems the natural answer.  And since you can't have splices of quoted things...there's a nice unambiguous answer.</p>
<pre><code>&gt;&gt; mold [a b c]
== "[a b c]"

&gt;&gt; mold spread [a b c]
== "a b c"
</code></pre>
<p>It does raise the question of what to do if you have something that might be an array or might not.  How do you tell it to mold as is if it's not an array, or without the delimiters if it is?  That's what MOLD/ONLY did, after all:</p>
<pre><code>rebol2&gt;&gt; mold/only [b l o c k]
== "b l o c k"

rebol2&gt;&gt; mold/only &lt;tag&gt;
== "&lt;tag&gt;"
</code></pre>
<p><em>"SPREAD won't SPREAD tags..."</em> you say.  And no, it won't.  But I think this is a rare case... and the neat thing about putting the bit on the value (as opposed to a refinement) is you can make functions like SPREAD-OR-AS-IS.  Or SPREAD-IF-PATH-OR-GROUP.  You can really tweak this however you want.</p>
<pre><code>&gt;&gt; mold spread-or-as-is &lt;tag&gt;
== "&lt;tag&gt;"

&gt;&gt; mold spread-or-as-is "[b l o c k]"
== "b l o c k"

&gt;&gt; spread-if-path-or-group 'p/a/t/h
== ~(p a t h)~  ; isotope

&gt;&gt; mold spread-if-path-or-group 'p/a/t/h
== "p a t h"
</code></pre>
<p>How about THAT?  All of this hinges on the idea that MOLD doesn't generally know how to mold isotopes, as they have no representation.  It just chooses to interpret the request to mold a splice isotope as "contents matter, no delimiters".</p>
<p>More control, more clarity, and the death of another /ONLY.  What more could you ask for?</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/mold-only-vs-mold-spread/2059">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/mold-only-vs-mold-spread/2059</link>
          <pubDate>Sun, 22 Oct 2023 23:59:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2059</guid>
          <source url="https://forum.rebol.info/t/mold-only-vs-mold-spread/2059.rss">MOLD/ONLY vs. MOLD SPREAD</source>
        </item>
        <item>
          <title>UNION, INTERSECT, DIFFERENCE...and Splices</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>There is a pattern that comes up a lot in Query which looks like this:</p>
<pre><code>if not find qe.clause-list 'update [append qe.clause-list 'update]
</code></pre>
<p>You could use an operation like UNION here, but since UNION only works on arrays you'd have to put UPDATE in a block:</p>
<pre><code>qe.clause-list: union qe.clause-list [update]
</code></pre>
<p>If the word to update with was in a variable (e.g. <strong>word: 'update</strong>), you couldn't do that block literally...so you'd need some blockifying function to do it:</p>
<pre><code>qe.clause-list: union qe.clause-list compose [(word)]

qe.clause-list: union qe.clause-list reduce [word]

qe.clause-list: union qe.clause-list :[word]

qe.clause-list: union qe.clause-list enblock word
</code></pre>
<h2>
<a name="semantics-of-operating-on-arrays-1" class="anchor" href="https://forum.rebol.info#semantics-of-operating-on-arrays-1"></a>Semantics of Operating on Arrays</h2>
<p>Historical Rebol would only accept BLOCK!s as the second argument to these operations.  I didn't see any reason not to generalize it, so I allowed GROUP!s as well:</p>
<pre><code>&gt;&gt; intersect [a b c d] '(b c e)
== [b c]

&gt;&gt; intersect '(a b c d) [b c e]
== (b c)
</code></pre>
<p>But there's a little bit of a question there about the result type.  Both arrays are taken account in terms of the elements, but only the first determines the type.  That's a little bit odd.</p>
<p>Furthermore, what if you wanted to intersect an array as an item?  The following wouldn't give you what you intended:</p>
<pre><code>item: [b]
collection: [[a] [b] [c] [d]]

collection: intersect collection item
</code></pre>
<p>You'd have to put the block into another block.  This is another one of those /ONLY style problems...</p>
<h2>
<a name="with-spread-we-can-do-this-better-2" class="anchor" href="https://forum.rebol.info#with-spread-we-can-do-this-better-2"></a>With SPREAD, we can do this better!</h2>
<p>We can make it so that UNION and friends assume you mean just one item by default, and you need to SPREAD the second argument to get it considered itemwise:</p>
<pre><code>&gt;&gt; union [a b c d] 'e
== [a b c d e]

&gt;&gt; union [[a] [b] [c] [d]] [e]
== [[a] [b] [c] [d] [e]]

&gt;&gt; union [[a] [b] [c] [d]] spread [e]
== [[a] [b] [c] [d] e]
</code></pre>
<p>So this means the operation from Query could be a little more succinct:</p>
<pre><code>if not find qe.clause-list 'update [append qe.clause-list 'update]
=&gt;
qe.clause-list: union qe.clause-list 'update
</code></pre>
<p>But more importantly, the as-is nature would avoid needing to jump through hoops for single-item operands:</p>
<pre><code> word: update
qe.clause-list: union qe.clause-list word
</code></pre>
<p>There are some questions about whether there is a guarantee of where the update would be added if it wasn't there... does it matter if it's added at the beginning or the end?</p>
<p>This is not a new question for these operations... the blocks are being treated as sets, so theoretically multiple answers could be valid:</p>
<pre><code>&gt;&gt; intersect [a b c d] spread [c b e]
== [b c]

 &gt;&gt; intersect [a b c d] spread [c b e]
== [c b]  ; what promises this wouldn't be the answer?
</code></pre>
<p>I think it's likely beneficial to make some kind of promise here.</p>
<h2>
<a name="should-unionetc-mutate-by-default-3" class="anchor" href="https://forum.rebol.info#should-unionetc-mutate-by-default-3"></a>Should UNION/etc. mutate by default?</h2>
<p>I point out that you'd have to write:</p>
<pre><code>qe.clause-list: union qe.clause-list 'update
</code></pre>
<p>In the Rebol model, "modify by default" is how things like APPEND or REVERSE work.  That would suggest you could write:</p>
<pre><code>union qe.clause-list 'update
</code></pre>
<p>And if you didn't want to modify qe.clause-list directly, you could copy it:</p>
<pre><code>result: union copy qe.clause-list 'update
</code></pre>
<p>If the interface to these functions was changed to work with splices and treat everything else as-is by default, it seems like a good time to make this change for consistency.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/union-intersect-difference-and-splices/2058">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/union-intersect-difference-and-splices/2058</link>
          <pubDate>Sun, 22 Oct 2023 06:06:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2058</guid>
          <source url="https://forum.rebol.info/t/union-intersect-difference-and-splices/2058.rss">UNION, INTERSECT, DIFFERENCE...and Splices</source>
        </item>
        <item>
          <title>How Much Determinism Should Be Pursued?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>While writing tests for the QUERY dialect against some sample files in a directory, it ran into an issue of the order those files were given back.  <em>Operating system APIs generally do not return the list of files in a determined order, and the ordering across filesystems also varies.</em></p>
<p>This means that even with the same files, you could have the lists come back differently.  One OS could say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Disk50.txt 26-Jul-2021]
2 [%tests/file-tests/11barz99.txt 26-Jul-2021]
3 [%tests/file-tests/Apple3.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
...
</code></pre>
<p>While another would say:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/Apple3.txt 26-Jul-2021]
2 [%tests/file-tests/Banana1.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Disk50.txt 26-Jul-2021]
5 [%tests/file-tests/11barz99.txt 26-Jul-2021]
...
</code></pre>
<p>This made getting reproducible outputs to verify was hard.</p>
<h2>
<a name="i-made-query-use-sortcase-on-the-read-dir-result-1" class="anchor" href="https://forum.rebol.info#i-made-query-use-sortcase-on-the-read-dir-result-1"></a>I Made QUERY use SORT/CASE on the READ DIR Result</h2>
<p>Getting determinism in the output meant using a function that guarantees an ordering for filenames:</p>
<pre><code>Domain-SQL&gt;&gt; select 'name 'date from %tests/file-tests/
    where 'size &gt; 100 and 'date = 26-Jul-2021

1 [%tests/file-tests/11barz99.txt 26-Jul-2021]
2 [%tests/file-tests/Apple3.txt 26-Jul-2021]
3 [%tests/file-tests/BANANA22.txt 26-Jul-2021]
4 [%tests/file-tests/Banana1.txt 26-Jul-2021]
5 [%tests/file-tests/Disk50.txt 26-Jul-2021]
...
</code></pre>
<p>Having to pay for the sort adds a little bit of overhead, but it's not that significant.</p>
<h2>
<a name="should-read-dir-be-sorted-by-default-2" class="anchor" href="https://forum.rebol.info#should-read-dir-be-sorted-by-default-2"></a>Should READ DIR be Sorted By Default?</h2>
<p>WASI in WebAssembly is looking to chase down sources of non-determinism and see what it can do to stop it.  They mention directory listing order as one potential for problems:</p>
<p><a href="https://github.com/WebAssembly/WASI/issues/190" class="inline-onebox">Roadmap to determinism in WASI · Issue #190 · WebAssembly/WASI · GitHub</a></p>
<p>They seem to believe that on the same OS the directory ordering would be deterministic for the same files, but I don't know of any guarantee of that.</p>
<h2>
<a name="all-this-points-to-bigger-issues-about-reproducibility-3" class="anchor" href="https://forum.rebol.info#all-this-points-to-bigger-issues-about-reproducibility-3"></a>All This Points to Bigger Issues About Reproducibility</h2>
<p>We can pick many examples... like whether a MAP! will always enumerate in the same order on different platforms, or with the same contents.  Using a deterministically sorted implementation of map would seem to have a number of advantages.</p>
<p>Especially since there's a growing push in software for giving deterministic outputs by default.  If you want some reasoning, see this article:</p>
<p><a href="https://buttondown.email/nelhage/archive/determinism-in-software-engineering/" class="inline-onebox">Determinism in software engineering • Buttondown</a></p>
<p>The more testing one does, the more important it seems.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057</link>
          <pubDate>Thu, 19 Oct 2023 19:34:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2057</guid>
          <source url="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057.rss">How Much Determinism Should Be Pursued?</source>
        </item>
        <item>
          <title>COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>While working on <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a>'s query, I noticed code that was making paths (now tuples) out of components via TO TUPLE! COMPOSE of a BLOCK!.  Like this:</p>
<pre><code>to tuple! compose [obj clauses (kwd.1)]
</code></pre>
<p>But did you know that COMPOSE can act directly on TUPLE! and PATH!  You could instead just write:</p>
<pre><code>compose 'obj.clauses.(kwd.1)
</code></pre>
<p>It supports splices as well:</p>
<pre><code>&gt;&gt; compose '(10 + 20)/a/b/(spread [c d e])/(reverse [g f])
== 30/a/b/c/d/e/[f g]
</code></pre>
<p>And if you remember that TUPLE! can be nested underneath PATH! (not vice versa) then you can COMPOSE/DEEP and handle mixed tuples and paths:</p>
<pre><code>&gt;&gt; compose/deep '(10 + 20)/a/b.(spread [c d e])
== 30/a/b.c.d.e
</code></pre>
<p>Voids can vanish...so there can be fewer dots in an output tuple than in the input:</p>
<pre><code>&gt;&gt; compose 'a.(if false [b]).c
== a.c
</code></pre>
<p>Empty splices will vanish as well:</p>
<pre><code>&gt;&gt; compose 'a.(spread []).c
== a.c
</code></pre>
<p>You can't compose in NULLs as an important safety measure...central to the design!</p>
<pre><code>&gt;&gt; compose 'a.(select [x 10 y 20] 'b).c
** Script Error: non-NULL value required (see MAYBE, TRY, REIFY)
** Near: [a ** (select [x 10 y 20] 'b) c]
</code></pre>
<p>But don't forget about MAYBE as the way to convert nulls to void when that's what you meant!</p>
<pre><code>&gt;&gt; compose 'a.(maybe select [x 10 y 20] 'b).c
== a.c
</code></pre>
<h2>
<a name="you-can-also-compose-a-group-1" class="anchor" href="https://forum.rebol.info#you-can-also-compose-a-group-1"></a>You can also COMPOSE a GROUP!</h2>
<p>In R3-Alpha, only BLOCK! would compose.  Everything else was passed-through as-is, including GROUP!s (PAREN!s in their terminology)</p>
<pre><code>r3-alpha&gt;&gt; compose quote (1 + (2 + 3))
== (1 + (2 + 3))
</code></pre>
<p>Red just doesn't allow it:</p>
<pre><code>red&gt;&gt; compose quote (1 + (2 + 3))
*** Script Error: compose does not allow paren! for its value argument
</code></pre>
<p>So you'd wind up having to make BLOCK!s and then convert them:</p>
<pre><code>red&gt;&gt; as paren! compose [1 + (2 + 3)]
== (1 + 5)
</code></pre>
<p>But in Ren-C, group composing works... it just leaves the top group as-is.  And you also have quoted groups to make it easier!</p>
<pre><code>&gt;&gt; compose '(1 + (2 + 3))
== (1 + 5)
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056</link>
          <pubDate>Thu, 19 Oct 2023 06:39:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2056</guid>
          <source url="https://forum.rebol.info/t/compose-of-tuple-and-path-and-toplevel-group/2056.rss">COMPOSE of TUPLE! and PATH! (and toplevel GROUP!)</source>
        </item>
        <item>
          <title>Building C++ GUI Code that Calls Ren-C Wasm and Runs in Browser</title>
          <dc:creator><![CDATA[OneArb]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>There is a quite active <a href="https://github.com/ocornut/imgui" rel="noopener nofollow ugc">Dear ImGui immediate mode GUI library</a> running on Emscript: <a href="https://github.com/jnmaloney/WebGui" rel="noopener nofollow ugc">WebGui</a>.</p>
<p>Dear ImGui provides just about any widget one might wish for.</p>
<p><a href="https://jnmaloney.github.io/WebGui/imgui.html" rel="noopener nofollow ugc">Wasm WebGui demo</a> runs at 60 FPS.</p>
<p>My roadmap is to embed Ren-C and bind the ImGui functions I need. I already have a skeleton parser that converts text into ImGUI function calls.</p>
<p>The code allows creating / modifying windows along with a few widgets at runtime.</p>
<p><a href="https://github.com/ocornut/imgui/discussions/3890" rel="noopener nofollow ugc">Dear ImGUI uses a minimal C++ set</a> and remains class and standard container free.</p>
<p>The only piece I'd be missing is the RPL interpreter if I am comprehending Ren-C feature set.</p>
<p>I'd also like to be able to grant filesystem access for the Wasm web instance using WASI API.  Here's an example where WASI is already implements accessing an OS directory from a Web instance:</p>
<p><a href="https://www.perplexity.ai/search/C-example-of-4jA7fNiiQSWtKthpleu2pQ?s=c" rel="noopener nofollow ugc">https://www.perplexity.ai/search/C-example-of-4jA7fNiiQSWtKthpleu2pQ?s=c</a></p>
<p>The use case can be distributing a chat GUI application launched through a browser running from the Internet using <a href="https://gist.github.com/nus/564e9e57e4c107faa1a45b8332c265b9" rel="noopener nofollow ugc">emscripten WebSocket support</a> or even full TCP UDP connections.</p>
            <p><small>10 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/building-c-gui-code-that-calls-ren-c-wasm-and-runs-in-browser/2053">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/building-c-gui-code-that-calls-ren-c-wasm-and-runs-in-browser/2053</link>
          <pubDate>Wed, 18 Oct 2023 01:41:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2053</guid>
          <source url="https://forum.rebol.info/t/building-c-gui-code-that-calls-ren-c-wasm-and-runs-in-browser/2053.rss">Building C++ GUI Code that Calls Ren-C Wasm and Runs in Browser</source>
        </item>
        <item>
          <title>WASI Encap: Embedding Read-Only Filesystems in .wasm Blobs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>WebAssembly</category>
          <description><![CDATA[
            <p>I found this project which looks promising:</p>
<p><a href="https://github.com/kateinoigakukun/wasi-vfs" class="inline-onebox">GitHub - kateinoigakukun/wasi-vfs: A virtual filesystem layer for WASI.</a></p>
<p>It includes a tool which can pack a directory into a .wasm file, and then you can read that directory from within the Wasm code itself.</p>
<p>Right now it's not a priority to look into, given that I added BASIC-READ and BASIC-WRITE to the WASI build.  If someone can prove the limit to using WASI effectively is that they have to distribute their project as a .zip and grant the runtime directory access (instead of as a single .wasm file) that seems like the time to attack it.</p>
<p>So... far future.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/wasi-encap-embedding-read-only-filesystems-in-wasm-blobs/2052">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wasi-encap-embedding-read-only-filesystems-in-wasm-blobs/2052</link>
          <pubDate>Tue, 17 Oct 2023 13:39:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2052</guid>
          <source url="https://forum.rebol.info/t/wasi-encap-embedding-read-only-filesystems-in-wasm-blobs/2052.rss">WASI Encap: Embedding Read-Only Filesystems in .wasm Blobs?</source>
        </item>
        <item>
          <title>Intrinsics: Functions without Frames</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>Redbol's historical type system really had only one design point: <em>be fast</em>.  There were 64 fundamental datatypes, and parameters of a function could either accept each datatype or not.  So a simple bitset of 64 bits was stored alongside each parameter, and checked when the function was called.  That was it.</p>
<p>Ren-C's richer design explodes the number of "types" in the system.  Isotopes like <strong><code>~null~</code></strong> are variations on WORD!, but you don't want every function that takes a WORD! to take nulls...and you don't want to have the type checking be so broad as to take <strong><code>[isotope!]</code></strong> just because you want to be able to take nulls (because that would include splices, packs, etc.)</p>
<p>It's not just this reason that Redbol's type checking was too simple, but it forced my hand in coming up with some sort of answer.  <em>I couldn't think of any better idea than Lisp, which does type checking via functions ("predicates").</em>  So I rigged it up where if you want to say a function can take an integer or null, you can write <strong><code>[null? integer!]</code></strong>  You can freely mix LOGIC-returning functions with fundamental types, and we're no longer stuck with the 64 fundamental type limit.</p>
<h2>
<a name="isnt-it-slow-to-call-a-list-of-functions-for-typechecking-1" class="anchor" href="https://forum.rebol.info#isnt-it-slow-to-call-a-list-of-functions-for-typechecking-1"></a>Isn't It Slow To Call A List of Functions For Typechecking?</h2>
<p>It can be.  And in particular, it can be if you have to go through calling those functions twice.</p>
<p>Why twice?  Because of "coercion".  For example, if you pass a pack to a function that expects packs, you'll get the meta-pack:</p>
<pre><code>&gt;&gt; foo: func [^x [pack?]] [probe x]

&gt;&gt; foo pack [1 "hi"]
~['1 '"hi"]~
</code></pre>
<p>But if your function didn't want packs, but wanted the type the pack decays to, it has to work for that as well:</p>
<pre><code>&gt;&gt; bar: func [^x [integer?]] [probe x]

&gt;&gt; bar pack [1 "hi"]
'1 
</code></pre>
<p><em>Did the function want the meta form or the meta-decayed form?</em>  There's no way of knowing for sure in advance.  The method chosen is to offer the meta form first, and if that doesn't match then the decayed form is offered.</p>
<p>It didn't know before walking through the block of functions to typecheck that a pack wouldn't have been accepted.  So it had to go through offering the pack, and then offering the integer.</p>
<h2>
<a name="but-i-noticed-something-about-these-functions-2" class="anchor" href="https://forum.rebol.info#but-i-noticed-something-about-these-functions-2"></a>But I Noticed Something About These Functions...</h2>
<p>Typically these functions are very simple:</p>
<ul>
<li>
<p>They take one argument.</p>
</li>
<li>
<p>They can't fail.</p>
</li>
<li>
<p>They don't require recursive invocations of the evaluator.</p>
</li>
</ul>
<p>This led me to wonder how hard it would be to define a class of actions whose implementations were a simple C function with an input value and output value.  If you weren't in a scenario where you needed a full FRAME!, you could reach into the ACTION!'s definition and grab the simple C function out of it.  All these functions would use the same dispatcher--that would be a simple matter of proxying the first argument of a built frame to pass it to this C function.</p>
<p>I decided to call these <strong>"intrinsics"</strong>, which is named after a <a href="https://en.wikipedia.org/wiki/Intrinsic_function">trick compilers use</a> when they see certain function calls that they implement those functions via direct code inlining.  It's not a perfect analogy, but it's similar in spirit.</p>
<h2>
<a name="it-wasnt-all-that-hard-to-implement-relatively-speaking-roll_eyes-3" class="anchor" href="https://forum.rebol.info#it-wasnt-all-that-hard-to-implement-relatively-speaking-roll_eyes-3"></a>It Wasn't All That Hard To Implement (relatively speaking <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"> )</h2>
<p>All of the native function implementations were assumed to have the same type signature, taking a frame as an argument.  I took away that assumption and added an /INTRINSIC refinement to the NATIVE function generator.  If it was an intrinsic, then the C function in the native table would take a single value argument and an output slot to write to.</p>
<p>So it's still one C function per native.  But if it's an intrinsic, then the function is not a dispatcher... the Intrinsic_Dispatcher() is used, and the C function is poked into the properties of the function.</p>
<p>Callsites that want to optimize for intrinsics just look to see if an action has the Intrinsic_Dispatcher(), and if so they have to take responsibility for procuring an argument and type checking it.  But if they do, they can just call the C function directly with no frame overhead.</p>
<p><strong>This helps make the switchover to functions in type spec blocks much more palatable.</strong>  It's never going to be as fast as the bitset checking, but it's fast enough to allow things to make progress.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/intrinsics-functions-without-frames/2050</link>
          <pubDate>Sun, 15 Oct 2023 17:25:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2050</guid>
          <source url="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050.rss">Intrinsics: Functions without Frames</source>
        </item>
        <item>
          <title>VSCode Files</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>There are some not-checked-in files that are used for building and editing in VSCode.  Every now and again, when I wipe out a ren-c clone, this information is lost.</p>
<p>Posting it here is as good as anywhere:</p>
<p><strong>.vscode/c_cpp_properties.json</strong></p>
<pre><code class="lang-auto">{
    "configurations": [
        {
            "name": "Win32",
            "includePath": [
                "C:/Projects/ren-c/build/prep/**",
                "C:/Projects/ren-c/**"
            ],
            "defines": [
                "_DEBUG",
                "UNICODE",
                "_UNICODE",
                "CPLUSPLUS_11=1",
                "ENDIAN_LITTLE"
            ],
            "windowsSdkVersion": "10.0.18362.0",
            "compilerPath": "C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.32.31326/bin/Hostx86/x86/cl.exe",
            "compilerArgs": [],
            "cStandard": "c11",
            "cppStandard": "c++17",
            "intelliSenseMode": "msvc-x64"
        }
    ],
    "version": 4
}
</code></pre>
<p><strong>.vscode/launch.json</strong></p>
<pre><code class="lang-auto">{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
        {
            "name": "(Windows) Launch",
            "type": "cppvsdbg",
            //"type": "cppdbg",
            "request": "launch",
            //"request": "attach",
            //"processId": "${command:pickProcess}"
            "program": "C:/Projects/ren-c/build/r3.exe",
            //"program": "/home/hostilefork/ren-c-linux/r3",
            "args": [],
            "stopAtEntry": false,
            "cwd": "C:/Projects/rebol-whitespacers/",
            //"cwd": "/home/hostilefork/Projects/ren-c/tests/",
            "environment": [],
            "console": "newExternalWindow"
            //"externalConsole": true
        }
    ]
}
</code></pre>
<p><strong>.vscode/settings.json</strong></p>
<pre><code class="lang-auto">{
    "files.associations": {
        "*.c": "cpp",
        "*.r": "plaintext"
    }
}
</code></pre>
<p><strong>.vscode/tasks.json</strong></p>
<pre><code class="lang-auto">{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "Build With JOM",
            "type": "shell",
            // nmake is slow but coherent errors, make is fast with jom
            "command": "make clean &amp;&amp; make prep &amp;&amp; make folders &amp;&amp; make",
            "options": {
                "cwd": "/Projects/ren-c/build/",
                "shell": {
                    "executable": "cmd.exe",
                    "args": [
                      "/C",
                      "\"C:/PROGRA~1/Microsoft Visual Studio/2022/Community/Common7/Tools/VsDevCmd.bat\"",
                      "&amp;&amp;"
                    ]
                }
            },
            "problemMatcher": {
                "base": "$msCompile"
            },

            "group": {
                "kind": "build",
                "isDefault": true
            },

            "presentation": {
                "clear": true // &lt;-- this line
            }
       }
    ]
}
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/vscode-files/2048">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/vscode-files/2048</link>
          <pubDate>Sun, 17 Sep 2023 09:56:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2048</guid>
          <source url="https://forum.rebol.info/t/vscode-files/2048.rss">VSCode Files</source>
        </item>
        <item>
          <title>MAYBE IF conditionals went back to returning NULL on Failure?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>A while ago, I made void more friendly... to say that void variables could be fetched without using GET-WORD! access or other fanfare:</p>
<pre><code>&gt;&gt; x: void

&gt;&gt; append [a b c] x
== [a b c]
</code></pre>
<p>My rationale was something along the lines of <em>"well, if you make a void variable, then you get what you were asking for"</em>.</p>
<p>A little bit unsettling is how easy you can make voids if something like your branches in a CASE or SWITCH are not exhaustive.  For instance:</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
]
</code></pre>
<p>You've now got LIB as VOID.  It's a little uncomfortable for me to think about how such casual creation of voids makes a thing that will go around opting out of things, but those opt-outs produce NULL via the void-in-null-out protocol, so you should find out about it eventually.  My other argument was that if you didn't want this, then you should just throw in a FAIL at the ending:</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
    fail  ; not so hard to do this if you don't want VOIDs
]
</code></pre>
<h2>
<a name="butwhat-if-you-want-a-null-1" class="anchor" href="https://forum.rebol.info#butwhat-if-you-want-a-null-1"></a>But...What if you <em>WANT</em> a NULL?</h2>
<p>As it happens, due to the <a href="https://forum.rebol.info/t/the-fallout-from-the-switch-fallout-feature/312">SWITCH and CASE "Fallout" Feature</a>, this also works with things like NULL:</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
    null
]
</code></pre>
<p>Basically if you give an evaluative clause with no branch, the clause drops out if it is reached.</p>
<p>It is <em>weird</em>, but it's foreignness doesn't necessarily make it <em>bad</em>.  Though were it a CASE statement, some people might gravitate toward an always-TRUE branch as not violating the structure:</p>
<pre><code>lib: case [
    config.platform = 'Windows [%windows.lib]
    config.platform = 'Linux [%linux.a]
    true [null]
]
</code></pre>
<p>But SWITCH has no equivalent, so its either the fallout feature or an ELSE (which won't please <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> and I think I prefer fallout)</p>
<pre><code>lib: switch config.platform [
    'Windows [%windows.lib]
    'Linux [%linux.a]
] else [null]
</code></pre>
<h2>
<a name="or-is-this-a-job-for-a-void-to-null-operator-2" class="anchor" href="https://forum.rebol.info#or-is-this-a-job-for-a-void-to-null-operator-2"></a>Or Is This A Job For A VOID-TO-NULL Operator?</h2>
<p>I thought maybe TRY could nullify-voids, but this creates conflation of disabling raised errors returned by branches.  e.g. what if the Windows branch tried to READ a nonexistent file?</p>
<pre><code>lib: try switch config.platform [
    'Windows [read %windowslibname.txt]  ; imagine raises error
    'Linux [%linux.a]
]
</code></pre>
<p>Not being able to open the file would conflate with not taking a branch--no good.  This shows the use of TRY to convert voids to nulls is clearly a poor idea, and that needs to be a special purpose function.</p>
<p>So TRY is off the table at this point; it's an ignore-raised-error-and-continue.</p>
<p>MAYBE makes more sense as NULL-TO-VOID and serves well in that purpose.</p>
<p>DEVOID is a cryptic name that was actually proposed to turn VOIDs to NIHILs for vaporization in situations that didn't naturally vaporize voids:</p>
<pre><code>&gt;&gt; 1 + 2 void

&gt;&gt; 1 + 2 devoid void
== 3
</code></pre>
<p>So I will call this something like NULLIFY-IF-VOID until a better idea comes along.  Clearly not great for everyday use.</p>
<h2>
<a name="or-is-this-cold-feet-on-void-from-failed-conditionals-3" class="anchor" href="https://forum.rebol.info#or-is-this-cold-feet-on-void-from-failed-conditionals-3"></a>Or... Is This Cold Feet on Void From Failed Conditionals?</h2>
<p>Production of voids from failed conditionals was motivated almost entirely by wanting IFs to vanish quietly when they don't take their branch.  At first it was just COMPOSE:</p>
<pre><code> &gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
 == [&lt;a&gt; &lt;b&gt;]
</code></pre>
<p>But this spread to things like REDUCE, ANY, ALL, etc.</p>
<pre><code>&gt;&gt; reduce [1 + 2 if false [30] 100 + 200]
== [3 300]

&gt;&gt; all [&lt;a&gt; if false [&lt;b&gt;] if true [&lt;c&gt;]]
== &lt;c&gt;
</code></pre>
<p>In terms of composability and convenience, it's hard for me to think this isn't the right answer.  It feels like they get mutilated if you have to throw in a NULL-TO-VOID (what I've called "MAYBE")</p>
<pre><code>&gt;&gt; compose [&lt;a&gt; (maybe if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;b&gt;]

&gt;&gt; reduce [1 + 2 maybe if false [30] 100 + 200]
== [3 300]

&gt;&gt; all [&lt;a&gt; maybe if false [&lt;b&gt;] maybe if true [&lt;c&gt;]]
== &lt;c&gt;
</code></pre>
<p>But perhaps it's only a good answer for IF, because it has one branch and you're very aware that it takes its branch or it doesn't?  Maybe twistier constructs like SWITCH and CASE should be more conservative and evaluate to NULL when a branch isn't taken...?  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_raised_eyebrow.png?v=12" title=":face_with_raised_eyebrow:" class="emoji" alt=":face_with_raised_eyebrow:" loading="lazy" width="20" height="20"></p>
<p>I don't like it for a couple of reasons, but a big one is that it feels like it throws a wrench into equivalencies.  e.g. I'd like:</p>
<pre><code> unmeta* any [
     meta* if condition1 [branch1]
     meta* if condition2 [branch2]
 ]
</code></pre>
<p>...to be the same as:</p>
<pre><code>case [
   condition1 [branch1]
   condition2 [branch2]
]
</code></pre>
<p>Having transformations which relate constructs together means people can build on reliable parts.  The response of ANY when all expressions void out is to give a VOID, and that's by design.</p>
<p>So, hmm.</p>
<h2>
<a name="or-are-void-variables-the-problem-4" class="anchor" href="https://forum.rebol.info#or-are-void-variables-the-problem-4"></a>...Or Are Void Variables The Problem?</h2>
<p>There could be some kind of rule, that variables are not allowed to hold voids...and if you assign void to a variable it becomes null.</p>
<pre><code> &gt;&gt; void? x: if false [&lt;a&gt;]
 == ~true~  ; isotope

 &gt;&gt; x
 == ~null~  ; isotope
</code></pre>
<p>Proposals along these lines have been entertained before.  I don't think I like it, and I feel like void variables should be legal.</p>
<h2>
<a name="i-think-im-committed-to-untaken-branches-as-void-5" class="anchor" href="https://forum.rebol.info#i-think-im-committed-to-untaken-branches-as-void-5"></a>I Think I'm Committed To Untaken Branches As VOID...</h2>
<p>But as with most things here, I think the fun is letting people play language designer and making their own choices.</p>
<p>If pure VOID means no branch taken, you can pipe the constructs:</p>
<pre><code>case: chain [:case, :void-to-null]
</code></pre>
<p>And that's it.  You could choose to do this for CASE and SWITCH so they'd need a MAYBE to vanish quietly, and leave IF alone.</p>
<p>But it's important to look at all the angles...!</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/maybe-if-conditionals-went-back-to-returning-null-on-failure/2047">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/maybe-if-conditionals-went-back-to-returning-null-on-failure/2047</link>
          <pubDate>Mon, 14 Aug 2023 17:08:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2047</guid>
          <source url="https://forum.rebol.info/t/maybe-if-conditionals-went-back-to-returning-null-on-failure/2047.rss">MAYBE IF conditionals went back to returning NULL on Failure?</source>
        </item>
        <item>
          <title>Console Treatment of VOID vs. NONE (isotopic void)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>Rebol2 and Red both have a console property that when the console sees an UNSET!, it prints nothing:</p>
<pre><code>&gt;&gt; block: reduce [&lt;a&gt; #[unset!] &lt;b&gt;]
== [&lt;a&gt; unset &lt;b&gt;]  ; bad rendering, conflates #[unset!] with the word `unset`

&gt;&gt; first block
== &lt;a&gt;

&gt;&gt; second block

&gt;&gt; third block
== &lt;b&gt;
</code></pre>
<p>This doesn't provide the best grounding in the console, especially considering that in their world an UNSET! is a reified value that can be found in a block.</p>
<p>However, returning an UNSET! is how functions like PRINT avoid outputting anything with <strong><code>==</code></strong> in the console:</p>
<pre><code>rebol2&gt;&gt; print "Notice no == result"
Notice no == result

rebol2&gt;&gt; type? print "Test"
Test
== unset!
</code></pre>
<h2>
<a name="but-what-result-should-ren-c-suppress-1" class="anchor" href="https://forum.rebol.info#but-what-result-should-ren-c-suppress-1"></a>But What Result Should Ren-C Suppress?</h2>
<p>Ren-C has the concept of VOID which has an isotopic form known as "NONE", that is used as the unfriendly contents of an unset variable.</p>
<p>For educational purposes, I feel it makes the most sense to have voids not print anything, and nones print out the standard isotopic form:</p>
<pre><code>&gt;&gt; void

&gt;&gt; quote void
== '

&gt;&gt; quasi void
== ~

&gt;&gt; ~
== ~  ; isotope
</code></pre>
<p>Looking at this it might seem to make a lot of sense to have functions like PRINT and HELP return VOID.</p>
<p>But as I explain in <a href="https://forum.rebol.info/t/why-doesnt-print-return-void-or-vaporize-via-nihil/1466">"Why doesn't PRINT return VOID or NIHIL"</a>, there is a bit of a pitfall.  Voids are friendly in terms of opting out of things:</p>
<pre><code>&gt;&gt; append [a b c] print "If PRINT returned void..."
If PRINT returned void...
== [a b c]
</code></pre>
<p><em>This seems too friendly to me.</em>  There's another possibility of returning NIHIL, which would be void if no other expressions were in play...and would prohibit use as an argument.  But it would let previous results fall out:</p>
<pre><code>&gt;&gt; print "If PRINT returned nihil"
If PRINT returned nihil

&gt;&gt; append [a b c] "If PRINT returned nihil"
If PRINT returned nihil
** Error: APPEND is missing its VALUE argument

&gt;&gt; 1 + 2 print "If PRINT returned nihil"
If PRINT returned nihil
== 3
</code></pre>
<p>So returning NONE mechanically feels like it makes the most sense...it has the right amount of ornery-ness:</p>
<pre><code>&gt;&gt; print "Mechanically this works best"
Mechanically this works best
== ~  ; isotope
</code></pre>
<p>But it's ugly to have that <strong>== ~  ; isotope</strong> after every HELP or PRINT or other function.</p>
<p>Previously I had it so that voids printed out a comment, and nones printed nothing:</p>
<pre><code>&gt;&gt; ~

&gt;&gt; void
; void
</code></pre>
<p>But this is making the console pretty at the cost of obfuscation.  I'll point out that the web console can make the <strong>== ~  ; isotope</strong> some kind of light gray so it's less noticeable.</p>
<h2>
<a name="people-always-bend-to-get-what-they-want-2" class="anchor" href="https://forum.rebol.info#people-always-bend-to-get-what-they-want-2"></a>People Always Bend To Get What They Want...</h2>
<p>I might not like the idea of returning a "friendly" void to get invisibility, and try forcing everyone to use NONE for console commands.  But if they see VOID/NIHIL as the better way to get what they want, they'll choose that in their own commands to cut down on the clutter.</p>
<p>It seems there's at least a rationale here for why isotopic void would output nothing, while void would give a comment.  If you consider the fact that isotopic void is "less than" a void, then giving it the special nothing-printed status makes some amount of sense.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/console-treatment-of-void-vs-none-isotopic-void/2045">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/console-treatment-of-void-vs-none-isotopic-void/2045</link>
          <pubDate>Thu, 03 Aug 2023 22:48:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2045</guid>
          <source url="https://forum.rebol.info/t/console-treatment-of-void-vs-none-isotopic-void/2045.rss">Console Treatment of VOID vs. NONE (isotopic void)</source>
        </item>
        <item>
          <title>Is The Script Compression Feature Necessary?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>R3-Alpha introduced the option that when you SAVE a script, you can ask that it be compressed.</p>
<p>It doesn't compress the header...just the body of the script.  There were two options for how this body could be compressed after the header: either as a Base64 BINARY literal ("script compression"), or directly as gzip'd bits ("raw compression").</p>
<p>As an example:</p>
<pre><code>&gt;&gt; data: save/compress blank [1 &lt;two&gt; "three"] 'script
== #{
    5245424F4C205B0A202020204F7074696F6E733A205B636F6D70726573735D0A
    5D0A3634237B483473494141414141414141436A4E5573436B707A3764545543
    724A4B45704E56654943414E425746325951414141417D
}

&gt;&gt; print as text! data
REBOL [
     Options: [compress]
]
64#{H4sIAAAAAAAACjNUsCkpz7dTUCrJKEpNVeICANBWF2YQAAAA}

&gt;&gt; [body header]: load data
== [1 &lt;two&gt; "three"
]

&gt;&gt; body
== [1 &lt;two&gt; "three"
]

&gt;&gt; header
== make object! [
    Title: "Untitled"
    File: ~null~
    Name: ~null~
    Type: 'script
    Version: ~null~
    Date: ~null~
    Author: ~null~
    Options: [compress]
    Description: ~null~
]
</code></pre>
<h2>
<a name="rebol2-didnt-have-it-red-doesnt-have-it-1" class="anchor" href="https://forum.rebol.info#rebol2-didnt-have-it-red-doesnt-have-it-1"></a>Rebol2 Didn't Have It, Red Doesn't Have It...</h2>
<p>Arguments that it helps with transmitting over networks don't hold up much these days, because the HTTP protocol itself does compression.</p>
<p>Plus, keeping scripts in compressed form is an annoying form of opaqueness on a language that's supposed to be about simplicity.</p>
<p>I've kept it around just because there were tests for it, and it exercised compression code (including showcasing a really bad design method of trying to decompress garbage to see if it was the raw compressed form, causing a crazy memory allocation).  But I'm not sure what the compelling use case for this feature is.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/is-the-script-compression-feature-necessary/2044">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/is-the-script-compression-feature-necessary/2044</link>
          <pubDate>Thu, 27 Jul 2023 23:20:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2044</guid>
          <source url="https://forum.rebol.info/t/is-the-script-compression-feature-necessary/2044.rss">Is The Script Compression Feature Necessary?</source>
        </item>
        <item>
          <title>Skinning REPLACE with Red&#39;s String PARSE Hack</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Red made an unusual choice with their implementation of REPLACE when you use a pattern that's a block with a string.  Instead of trying to stringify the block, <a href="https://github.com/red/red/blob/40096dd12ca9c3b9b47e9eaa995d425b9faf620b/tests/source/units/replace-test.red#L72">they assume it's a PARSE rule</a>:</p>
<pre><code>red&gt;&gt; replace/case/all "aAbbabAAAa" ["Ab" | "Aa"] "-"
== "a-babAA-"
</code></pre>
<p>It seems like a bad idea to make the choice to do this based on the input type.  What if you actually want to do this when the input is a BLOCK!?  I'd prefer something like <strong>parse-replace</strong> <em>(or if we ever allow the same word to be a function and a module, maybe <strong>parse.replace</strong>)</em>.</p>
<p>But honestly, I think that the answer is just to keep pushing on UPARSE itself to be slick enough that you wouldn't feel the need to reach for a shorthand like this.  It's pretty easy to write as is:</p>
<pre><code>&gt;&gt; parse/case "aAbbabAAAa" [
       try some thru [change ["Ab" | "Aa"] ("-")]
       accept &lt;input&gt;
   ]
== "a-babAA-"
</code></pre>
<p>That's probably reaching the limits of how short UPARSE can do an equivalent.  Yet it's more powerful if you want to deviate or customize it, so I would reach for this more often than a limited REPLACE.</p>
<h2>
<a name="still-ren-c-does-backflips-and-lets-you-have-it-your-way-1" class="anchor" href="https://forum.rebol.info#still-ren-c-does-backflips-and-lets-you-have-it-your-way-1"></a>Still, Ren-C Does Backflips And Lets You Have It Your Way</h2>
<p>So you should be able to adapt REPLACE to have Red's behavior if you want it.</p>
<p>Super easy.  Barely an inconvenience!</p>
<pre><code>replace: enclose :lib.replace func [
     f [frame!]
     &lt;local&gt; head tail rule
][
    if not all [
        match [text! binary!] f.target
        block? f.pattern
    ][
        return do f  ; use normal REPLACE semantics
    ]

    rule: if activation? :f.replacement '[  ; function generates replacement
        head: &lt;here&gt;
        change [f.pattern, tail: &lt;here&gt;] (
            apply/relax :f.replacement [const head, const tail]
        )
    ] else '[  ; replacement can be used as-is
        change f.pattern (f.replacement)
    ]

    apply :parse [/case f.case, f.target [
        while [thru rule] (
            if not f.all [return f.target]
        )
        to &lt;end&gt;
    ]]
    return f.target
]
</code></pre>
<h2>
<a name="it-worked-the-first-time-i-ran-it-2" class="anchor" href="https://forum.rebol.info#it-worked-the-first-time-i-ran-it-2"></a>It worked the first time I ran it!</h2>
<p>There's so much interesting stuff going on here that it's hard to list it all. I can quickly hit some high points.</p>
<ul>
<li>
<p>You don't have to repeat the interface of REPLACE.  This is an ENCLOSE, so it just passes the frame built for LIB.REPLACE to the wrapper and lets it choose whether to run that frame as-is (or modified), or do its entirely own thing.</p>
</li>
<li>
<p>It uses the <a href="https://forum.rebol.info/t/the-cool-new-repurposing-of-while-in-parse/1875">kickass new arity-2 WHILE combinator</a> to great effect...simply iterating over the replacement rule.</p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834">Modern kickass APPLY</a> for PARSE lets you put arguments in any order, and does refinements by name... here we put /CASE first because it's clearer... then passing the series and the rule.</p>
</li>
<li>
<p>It doesn't just run isotopic actions if they are passed, but it also optionally passes them the head and tail of where in the input is matched.  If the function is arity-1, it just receives the head.  If it's arity-0, it doesn't receive either.  (This is due to APPLY's /RELAX that tolerates too many arguments.)</p>
</li>
</ul>
<p>I wrote a little demo of the fancier function invocation:</p>
<pre><code>&gt;&gt; data: "(real)1020(powerful)0304(magic)"

&gt;&gt; collect [
       replace/all data [between "(" ")"] func [head tail] [
            let item: copy/part head tail
            keep item
            if item = "(powerful)" [item: copy "(ren-c)"]
            return uppercase item
        ]
    ]
== ["(real)" "(powerful)" "(magic)"]

&gt;&gt; data
== "(REAL)1020(REN-C)0304(MAGIC)"
</code></pre>
<p>Not only that, but the references to the head and tail of the match are CONST...which prevents the replacement function from messing up the in-progress iteration of the series where the replace is happening.  It only achieves modification by means of what result it synthesizes.</p>
<p>How about that?</p>
<p>cc: <a class="mention" href="https://forum.rebol.info/u/brett">@Brett</a>, <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>, <a class="mention" href="https://forum.rebol.info/u/johnk">@johnk</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043</link>
          <pubDate>Thu, 27 Jul 2023 06:23:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2043</guid>
          <source url="https://forum.rebol.info/t/skinning-replace-with-reds-string-parse-hack/2043.rss">Skinning REPLACE with Red&#39;s String PARSE Hack</source>
        </item>
        <item>
          <title>Discouraging Semantics for COMMA! in Dialects</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Today I consider <a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387">COMMA! to be an indispensible addition to the language</a>.</p>
<p>But something that feels like a Rebol philosophy point is that we should strongly discourage the idea of commas having semantic meaning in dialects.  The status quo should be that they just provide visual separation.</p>
<p>In this mindset, the only impact adding a comma should have on code would be an error if they're not put in an "interstitial" position.  If you want a grouping to have semantic meaning, then a BLOCK! or GROUP! should be used... or perhaps a vertical bar |.</p>
<p>I think giving this guidance helps preserve Rebol's natural language stream aesthetic, where the kinds of problems mandatory commas introduce can be avoided.  Whether you are doing things at source level or in code generation, having N entries needing (N - 1) commas can be an annoyance.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/discouraging-semantics-for-comma-in-dialects/2042">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/discouraging-semantics-for-comma-in-dialects/2042</link>
          <pubDate>Wed, 26 Jul 2023 16:30:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2042</guid>
          <source url="https://forum.rebol.info/t/discouraging-semantics-for-comma-in-dialects/2042.rss">Discouraging Semantics for COMMA! in Dialects</source>
        </item>
        <item>
          <title>Should ANY and ALL Vaporize VOID (or require ELIDE-IF-VOID ?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've written up how <a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">the evolution of invisibility gave rise to VOID vs. NIHIL</a>.</p>
<p>The default evaluator (and UPARSE) accept that void is "nothing" and can't be put in blocks.  But they don't vaporize VOID on a whim: it will still be the result of expressions whose last result is a void.</p>
<pre><code>&gt;&gt; 1 + 2 if false [&lt;a&gt;]
; void
</code></pre>
<p>On the other hand, the empty parameter pack of NIHIL truly vaporizes unless you pipe it around with ^META:</p>
<pre><code>&gt;&gt; 1 + 2 nihil
== 3
</code></pre>
<p>This means it's up to constructs to decide if they want to erase voids or not.  DELIMIT does, so you will see that reflected in things like UNSPACED:</p>
<pre><code>&gt;&gt; unspaced ["A" if false ["B"] "C"]
== "AC"
</code></pre>
<p>COMPOSE vaporizes void slots (and errors on null ones).  <a href="https://forum.rebol.info/t/vaporizing-failed-conditionals-in-reduce/1665">REDUCE is currently vaporizing VOID</a> because it seems like the default people want.</p>
<h2>
<a name="should-any-and-all-vaporize-voids-1" class="anchor" href="https://forum.rebol.info#should-any-and-all-vaporize-voids-1"></a>Should ANY and ALL Vaporize Voids?</h2>
<p>To me, this is a bit of a tough decision.</p>
<p>VOID is neither truthy nor falsey, and IF will reject it:</p>
<pre><code>&gt;&gt; if (if false [true]) [&lt;unreachable&gt;]
** Error: IF doesn't accept VOID as its condition argument
</code></pre>
<p>When there was no VOID/NIHIL distinction, then ANY and ALL were backed into a corner.  If they decided to error on void, you couldn't use an ELIDE or ASSERT in the middle of them.  If they didn't error on VOID then the risk was that you could write something like <strong><code>all [1 = 1, 2 = 2, value]</code></strong> and if VALUE was just incidentally void you'd get the 2 = 2 result as ~true~.</p>
<p>Today, things like ELIDE and ASSERT return NIHIL and can be safely vaporized by ANY and ALL, while retaining the choice to error on voids as not being true or false.  If you really want to erase voids, we can have something that converts voids to nihil called ELIDE-IF-VOID</p>
<pre><code>&gt;&gt; value: void

&gt;&gt; all [1 = 1, 2 = 2, value]
** Error: VALUE is VOID which is neither truthy nor falsey

&gt;&gt; all [1 = 1, 2 = 2, elide-if-void value]
== ~true~  ; isotope
</code></pre>
<h2>
<a name="things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2" class="anchor" href="https://forum.rebol.info#things-like-for-bothhttpsforumrebolinfotdemonstrating-for-both-loop-composability-for-the-win1833-would-get-more-awkward-2"></a>Things Like <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">FOR-BOTH</a> Would Get More Awkward...</h2>
<p>I was fairly proud of this formulation:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        meta* for-each (var) blk1 body
        meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>(I wound up deciding that META would meta-raise everything--including pure null and void--so the asterisks were probably best included there for the alternative formulation.)</p>
<p>But if ALL and ANY errored on void, and you had to erase it, this would become:</p>
<pre><code>for-both: func ['var blk1 blk2 body] [
    return unmeta* all [
        elide-if-void meta* for-each (var) blk1 body
        elide-if-void meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>If I put on my formalism hat, I can see how this is <em>safer</em>.  But I've made similar arguments about why I don't want this:</p>
<pre><code>&gt;&gt; compose [a (if false ['b]) c]
** Error: COMPOSE cannot erase VOID (use ELIDE-IF-VOID if intentional)

&gt;&gt; compose [a (elide-if-void if false ['b]) c]
== [a c]
</code></pre>
<p>It is admittedly a bit different in ANY and ALL's case, because they're mixing in a test for truthiness.  But erasing voids by default has other advantages in writing wild control constructs.</p>
<p>I'm really torn on this, as it's right on the edge.  <strong>But when all things are mostly equal, safety isn't as compelling as enabling creativity in my current view of the language.</strong>  I think I'm going to wait until I see a really bad consequence of vaporizing the voids here... it hasn't broken any real code yet, and it has proven its convenience.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-any-and-all-vaporize-void-or-require-elide-if-void/2040">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-any-and-all-vaporize-void-or-require-elide-if-void/2040</link>
          <pubDate>Thu, 29 Jun 2023 02:09:57 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2040</guid>
          <source url="https://forum.rebol.info/t/should-any-and-all-vaporize-void-or-require-elide-if-void/2040.rss">Should ANY and ALL Vaporize VOID (or require ELIDE-IF-VOID ?)</source>
        </item>
        <item>
          <title>Invisibility Reviewed Through Modern Eyes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>The first idea of making constructs that would "vanish completely" leveraged a special kind of enfix function, that would receive the entire evaluated value of the left hand side:</p>
<pre><code> elide: enfix func [
     left [&lt;evaluate-all&gt; any-value!]
     right
 ][
     print ["ELIDE got left as" mold left]
     return left
 ]

 &gt;&gt; 1 + 2 + 3 comment [magic!]
 hi
 ELIDE got left as 6
 == 6  ; wow!
</code></pre>
<p>This was a workaround for the (seeming?) fundamental fact that you can't have such a thing as "invisible variables" or "invisible values".  <em>Certain functions just faked invisibility by repeating the previous value in the evaluator chain.</em></p>
<p>The possibilities seemed endless.  For instance, imagine something like this:</p>
<pre><code>case [
   conditionA [...code...]
   elide print "conditionA didn't succeed but running this"
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>To do that in Rebol2 or Red would be incredibly awkward.  e.g. using a condition that runs code but evaluates to false, and then a throwaway block for the never-executed branch:</p>
<pre><code>case [
   conditionA [...code...]
   (
       print "conditionA didn't succeed but running this"
       false
   ) [&lt;unreachable&gt;]
   conditionB [...code...]
   conditionC [...code...]
]
</code></pre>
<p>Similar awkwardness would arise in things like ANY and ALL, where you'd have to switch from using true and false based on which you were using...</p>
<pre><code>any [conditionA (print "vanish" false) conditionB]
all [conditionA (print "vanish" true) conditionB]
</code></pre>
<p>Beyond being awkward, it simply can't work if what you want to vanish is the last expression.  But ELIDE handled all these cases:</p>
<pre><code>any [conditionA elide print "vanish" conditionB]
all [conditionA elide print "vanish" conditionB]
any [conditionA conditionB elide print "vanish"]
all [conditionA conditionB elide print "vanish"]
</code></pre>
<h2>
<a name="it-was-a-neat-trickbut-problems-emerged-1" class="anchor" href="https://forum.rebol.info#it-was-a-neat-trickbut-problems-emerged-1"></a>It Was A Neat Trick...But Problems Emerged</h2>
<p>The trick of invisibility requiring a function to receive its left hand side meant a GROUP! or COMMA! would break these constructs, as there was no access to a previous value:</p>
<pre><code> &gt;&gt; 1 + 2 + 3 (elide print "hi")
 hi
 ELIDE got left as null
 == ~null~  ; not 6, d'oh!

 &gt;&gt; 1 + 2 + 3, elide print "hi"
 hi
 ELIDE got left as null
 == ~null~
</code></pre>
<p>Plus being enfix forced the invisible functions to execute in the same step as whatever came before them, causing unsuspected results:</p>
<pre><code>&gt;&gt; case [
        1 = 1 [print "branch"]
        elide print "reached here first :-("
        1 = 2 [fail "Unreachable"]
    ]
ELIDE got left as [print "branch"]
reached here first :-(
branch
</code></pre>
<p>There we see that when the evaluator visited the <strong>[print "branch"]</strong> block in the CASE it had to greedily run the ELIDE, which evaluates its argument and then yielded the code block as its result.  CASE ran that code after the elide...out of order from what was desired.</p>
<p>Issues seemed to keep compounding.  These invisible functions couldn't be reliably used with MAKE FRAME!, and people trying to simulate the evaluator's logic found it hard to detect and wrap them.  That led to major issues with UPARSE trying to implement combinators that acted like ELIDE.</p>
<p>So the enfix mechanism wasn't going to cut it.  But it was too late: having been able to try out and develop all kinds of invisible constructs convinced me of their value.  I had to try another way...</p>
<h2>
<a name="formalizing-a-void-state-and-corresponding-meta-state-2" class="anchor" href="https://forum.rebol.info#formalizing-a-void-state-and-corresponding-meta-state-2"></a>Formalizing a VOID State And Corresponding Meta State</h2>
<p>The seeming impossibility of having a "void value" was addressed with the idea of folding special treatment in the evaluator of voids, but offering a meta domain in which they could be handled safely.</p>
<pre><code>&gt;&gt; var: void
; void

&gt;&gt; 1 + 2 var
== 3

&gt;&gt; var: meta void
== '

&gt;&gt; 1 + 2 var
== '

&gt;&gt; 1 + 2 unmeta var
== 3
</code></pre>
<p>The concept of being able to pipe around and process "slippery" values in this meta domain (including unset states and other isotopes) wound up being very successful.</p>
<p>Evaluators like DO and UPARSE would specially preserve the last evaluative value in order to give the illusion of invisibility when voids were seen on the next step.  Other constructs got to make a choice as to whether they wanted to embrace voids as part of the mechanic, or think of them as errors:</p>
<pre><code>&gt;&gt; comment "comments returned void"  ; Note: console doesn't show void results

&gt;&gt; if comment "hi" [print "not tolerated in conditions"]
** Error: IF doesn't accept void as its condition argument

&gt;&gt; all [comment "begin" 1 + 2 10 + 20 comment "end"]
== 30

&gt;&gt; any [comment "begin" 1 + 2 10 + 20 comment "end"]
== 3
</code></pre>
<p>e.g. for the above to work, ALL has to hang on to the last evaluated result as it goes...in case the next evaluated result is a comment.  This allows the 30 to fall out.</p>
<h2>
<a name="a-flexible-approach-but-here-be-dragons-3" class="anchor" href="https://forum.rebol.info#a-flexible-approach-but-here-be-dragons-3"></a>A Flexible Approach... But... Here Be Dragons</h2>
<p>Something that concerned me early on was that what had started as a narrow ability of just a few functions (like COMMENT and ELIDE) was becoming a case where generalized execution could possibly return voids, leading to unexpected results.</p>
<pre><code>&gt;&gt; code: [comment "some arbitary code block"]

; ... then much later ...

&gt;&gt; result: (mode: &lt;reading&gt; do code)
== &lt;reading&gt;

&gt;&gt; result
== &lt;reading&gt;  ; oops
</code></pre>
<p>Increasing dependence on void as a "vanishing" alternative to the noisier null also raised the demand for void variables, with them becoming slippery to generate:</p>
<pre><code>&gt;&gt; parse [x] [rule: ['x (void) | 'y ([some "y"])]
== x

&gt;&gt; rule
== x  ; wanted void
</code></pre>
<p>VOID was becoming a victim of its own popularity.  When it was rare coming from only a few constructs like ELIDE and COMMENT it was rare to see problems.  Yet when every IF/CASE/SWITCH statement that didn't run a branch started returning voids, things got hairier.</p>
<p>There were also snags when making void isn't a parameter...but a product of something like the body on a MAP-EACH. At first it looks fine:</p>
<pre><code>map-each item [1 &lt;one&gt; 2 &lt;two&gt; 3 &lt;three&gt;] [
    maybe match tag! item  ; leaving it as NULL would be an error
]
== [&lt;one&gt; &lt;two&gt; &lt;three&gt;]
</code></pre>
<p>But what if you had something else in the loop body?</p>
<pre><code>map-each item [1 &lt;one&gt; 2 &lt;two&gt; 3 &lt;three&gt;] [
    append log spaced ["Logging:" item]
    maybe match tag! item  ; remember, void vanishes
]
== ["Logging: 1" "Logging: &lt;one&gt;" "Logging..." ...]
</code></pre>
<h2>
<a name="once-again-isotopes-to-the-rescue-4" class="anchor" href="https://forum.rebol.info#once-again-isotopes-to-the-rescue-4"></a>Once Again: Isotopes To The Rescue</h2>
<p>As part of <a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">solving the problem of multi-returns</a>, parameter pack isotopes were introduced.  These would "decay" to their first item, unless something handled the isotope specially.</p>
<pre><code>&gt;&gt; pack [1 + 2 10 + 20]
== ~['3 '30]~  ; isotope

&gt;&gt; a: pack [1 + 2 10 + 20]
== 3

 &gt;&gt; [a b]: pack [1 + 2 10 + 20]  ; SET-BLOCK! handles PACK! isotopes specially
 == 3

 &gt;&gt; a
 == 3

 &gt;&gt; b
 == 30
</code></pre>
<p>Unpacking the packs raised a question: <em><strong>What if the PACK! is Empty</strong></em>?  As far as variable assignment goes, it seems it can't do anything.  So erroring made the most sense:</p>
<pre><code>&gt;&gt; pack []
== ~[]~  ; isotope

&gt;&gt; a: pack []
** Error: No values available in empty parameter pack
</code></pre>
<p>Then there was a breakthrough of the next thought: <em><strong>Empty isotopic packs could be used as the vanishing intent!!</strong></em></p>
<pre><code>&gt;&gt; 1 + 2, pack []
== 3
</code></pre>
<p>This would mean VOID could be less "slippery" in the evaluator, being treated normally most of the time and falling out of expressions vs. vaporizing:</p>
<pre><code>&gt;&gt; 1 + 2, if false [&lt;a&gt;]  ; overall result is void (no console output)

&gt;&gt; 1 + 2, if true [&lt;a&gt;]
== &lt;a&gt;
</code></pre>
<h2>
<a name="empty-isotopic-packs-were-then-given-a-name-nihil-5" class="anchor" href="https://forum.rebol.info#empty-isotopic-packs-were-then-given-a-name-nihil-5"></a>Empty isotopic packs were then given a name: <strong>"NIHIL"</strong>
</h2>
<p>The terminology has varied over time.  I accomplished the distinction another way before isotopic packs, and at that time I called the distinction "impure invisibility" (non-vaporizing) vs. "pure invisibility" (vaporizing).</p>
<p>But I think the "impure" vs. "pure" terms just caused confusion.  This is where things stand today, and it seems comfortable:</p>
<pre><code>&gt;&gt; 1 + 2 void

&gt;&gt; 1 + 2 nihil
== 3

&gt;&gt; 1 + 2 null
== ~null~   ; isotope
</code></pre>
<h2>
<a name="i-think-this-is-a-comfortable-balance-6" class="anchor" href="https://forum.rebol.info#i-think-this-is-a-comfortable-balance-6"></a>I Think This Is A Comfortable Balance</h2>
<p>No matter what way you slice it, an expression that can truly vaporize is something that can make you uneasy.  Look at this CASE statement and imagine if FOO or BAR could vanish:</p>
<pre><code> case [
     foo [print "hi"]
     bar [print "bye"]
 ]
</code></pre>
<p>Sure... we can lament that if FOO comes back as NIHIL, it will wreck the geometry of the CASE completely.  After dropping the FOO it will treat [print "hi"] as a condition and use BAR as a code branch.</p>
<p><em>But if FOO is a function that takes a BLOCK! as a parameter, it will also wreck the geometry of the CASE completely!</em>  This is just the cost of doing business in the Rebol paradigm.</p>
<p>This modern model with NIHIL being an unstable isotope brings us back to where you can only get vanishing function calls--not vanishing variables.  FOO can be a variable holding VOID, but there's no risk of that wrecking the CASE statement...because CASE is not one of the constructs that willfully erases VOID.  Neither does the foundational evaluator (and nor does UPARSE)</p>
<p>So long as usage of NIHIL is judicious, I think this is about as terra firma as the rest of Rebol is.  And UPARSE stands as a great example of a system that has been able to build on meta-representation in order to be able to pipe around vanishing states using "special gloves" and build upon it to make new invisible behaviors...</p>
<pre><code>&gt;&gt; parse "aaabbb" [collect some keep "a", elide some "b"]
== ["a" "a" "a"]
</code></pre>
<p>It's rather satisfying.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034</link>
          <pubDate>Fri, 23 Jun 2023 17:06:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2034</guid>
          <source url="https://forum.rebol.info/t/invisibility-reviewed-through-modern-eyes/2034.rss">Invisibility Reviewed Through Modern Eyes</source>
        </item>
        <item>
          <title>Unstable Isotope Conundrums</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>An unstable isotope is one that cannot be stored in a variable.  The clearest example of one of these is a PACK!.</p>
<p>Quick refresher: because functions receive their arguments in variables, you clearly cannot pass an unstable isotope to a function.  You instead use ^META parameters and get the quasiform.</p>
<pre><code>&gt;&gt; pack [3 4]
; first in pack of length 2
== 3

&gt;&gt; meta pack [3 4]
== ~['3 '4]~

&gt;&gt; [a b]: pack [3 4]
== 3

&gt;&gt; a
== 3

&gt;&gt; b
== 4
</code></pre>
<p><strong>But what about non-variable situations... like expressions that are being tested for being truthy or falsey?</strong></p>
<p>Right now, tests for truthiness throw the unstable state away.  For instance, ALL:</p>
<pre><code>&gt;&gt; all [1 2 pack [3 4]]
== 3
</code></pre>
<p>The PACK! formed by the PACK function is decayed to just 3 by the ALL, and then the 3 was tested as truthy.  If you wanted to get past this, you would have to meta-and-then-unmeta the pack:</p>
<pre><code>&gt;&gt; unmeta all [1 2 meta pack [3 4]]
; first in pack of length 2
== 3
</code></pre>
<p>But note that here, it's testing the meta-pack ~['3 '4]~ for truthiness, not the 3.  So if false were in the meta pack, it would still wind up truthy.</p>
<pre><code>&gt;&gt; all [1 2 meta pack [false false]]
== ~[~false~ ~false~]~
</code></pre>
<p>Whereas a regular pack would be decayed before the test:</p>
<pre><code>&gt;&gt; all [1 2 pack [false false]]
== ~null~  ; isotope
</code></pre>
<p>You might ask <em>"Why not just say all PACK!s are truthy, so you don't have to META and UNMETA them?"</em></p>
<p>Well just think about it: when you use a multi-returning function you may only be interested in the primary result...and even only be slightly aware that more results are available.  For instance: not everyone knows that today's FIND returns an additional output if you want it (it's the end of a match).</p>
<p><strong>Saying that packs must decay to test them for truthiness doesn't seem too baffling, but what about loop constructs that don't test for truthiness?</strong></p>
<p>Is this harmless?</p>
<pre><code>&gt;&gt; flag: true

&gt;&gt; meta while [flag] [flag: false, pack [3 4]]
== ~['3 '4]~
</code></pre>
<p>It seems all right, although this becomes a property that <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">has to be preserved by compositions like FOR-BOTH</a>. (As it so happens, the composition does work.)</p>
<p>But what about UNTIL?  In until the loop condition and the body are the same, and in order to exit the loop the body must be truthy...so you can't get a pack out:</p>
<pre><code>&gt;&gt; until [pack [3 4]]
== 3
</code></pre>
<p>And also... what about situations like CONTINUE/WITH or STOP/WITH.  If the /WITH parameter is a plain refinement and not a ^META one, then the information will be lost:</p>
<pre><code>&gt;&gt; cycle [stop/with pack [3 4]]
== 3
</code></pre>
<p>If CONTINUE and STOP were to follow in the footsteps of RETURN, they would need an added refinement like RETURN/FORWARD which distinguishes the case where you do want the meta parameter from where you don't (which is the current solution, vs. something like marking ^RETURN: as always being meta on the function definition).</p>
<h2>
<a name="maybe-test-decayd-value-preserve-pack-1" class="anchor" href="https://forum.rebol.info#maybe-test-decayd-value-preserve-pack-1"></a>Maybe Test DECAY'd Value, Preserve PACK! ?</h2>
<p>Constructs like ALL or UNTIL might decay only for the purposes of the truthiness test, but preserve the original PACK! for the actual return.</p>
<p>For instance could you do this?</p>
<pre><code>&gt;&gt; [a /b]: all [
       1 = 1
       2 = 2
       pack [3 4]
   ]
== 3

&gt;&gt; a
== 3

&gt;&gt; b
== 4
</code></pre>
<p>I've pointed out that PACKs with falsey items have to break the chain:</p>
<pre><code>&gt;&gt; [a /b]: all [
       1 = 1
       2 = 2
       pack [false 4]
   ]
== ~null~  ; isotope

&gt;&gt; a
== ~null~  ; isotope

&gt;&gt; b
== ~null~  ; isotope
</code></pre>
<p>If you didn't intend that you'd have to META the pack inside the ALL...and UNMETA outside as discussed (in this case with UNMETA* which passes through null as-is vs. erroring if the leading conditions resulted in a null outcome)</p>
<pre><code>&gt;&gt; [a /b]: unmeta* all [
       1 = 1
       2 = 2
       meta pack [false 4]
   ]
== ~false~  ; isotope

&gt;&gt; a
== ~false~  ; isotope

&gt;&gt; b
== 4
</code></pre>
<p>Taking this preservation to extremes would complicate a lot of places in the code.  For instance: IF tolerates function branches, and will pass on the condition to the branch:</p>
<pre><code>&gt;&gt; var: [a b c]

&gt;&gt; if var (func [x] [print ["var was" mold x]])
var was [a b c]
</code></pre>
<p>But what if you want to do this with a pack, and have the option of receiving it in that function?</p>
<pre><code> &gt;&gt; if pack [1 2] (func [x] [print ["var was" mold x]])
 var was 1

 &gt;&gt; if pack [1 2] (func [^x] [print ["meta var was" mold x]])
 meta var was ~[1 2]~

 &gt;&gt; if pack [false 2] (func [^x] [print ["meta var was" mold x]])
 ; void
</code></pre>
<p>Interesting though that may look, it changes IF to where it has to take its condition as a ^META parameter, otherwise it decays and can't be passed on.</p>
<p>I can't tell if this is a high-enough leverage piece of functionality to be worth complicating IF or not.</p>
<h2>
<a name="for-now-tempting-to-say-loop-protocol-cant-return-pack-2" class="anchor" href="https://forum.rebol.info#for-now-tempting-to-say-loop-protocol-cant-return-pack-2"></a>For Now, Tempting To Say "Loop Protocol" Can't Return PACK!</h2>
<p>It's not necessarily <em>hard</em> to make /WITH a ^META-refinement on CONTINUE and STOP... at least in terms of allowing PACK!.  <strong>continue/with raise error</strong> would cause some uncomfortable results.</p>
<p>Again, note there are ways to work around not processing unstable pack! isotopes by the /WITH itself, by META-ing on the inside and UNMETA-ing on the outside:</p>
<pre><code> &gt;&gt; cycle [stop/with meta pack [3 4]]
 == ~[3 4]~

 &gt;&gt; [a b]: unmeta cycle [stop/with meta pack [3 4]]
 == 3

 &gt;&gt; a
 == 3

 &gt;&gt; b
 == 4
</code></pre>
<p>Every time I see this, I do kind of wish up and down arrows were on our keyboards:</p>
<pre><code>  [a b]: ↓ cycle [stop/with ↑ pack [3 4]]
</code></pre>
<p>Caret-Meta only gets you half of this:</p>
<pre><code> [a b]: unmeta cycle [stop/with ^ pack [3 4]]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/unstable-isotope-conundrums/2033">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/unstable-isotope-conundrums/2033</link>
          <pubDate>Thu, 22 Jun 2023 17:09:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2033</guid>
          <source url="https://forum.rebol.info/t/unstable-isotope-conundrums/2033.rss">Unstable Isotope Conundrums</source>
        </item>
        <item>
          <title>Is there anything like parse in other languages?</title>
          <dc:creator><![CDATA[johnk]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I have been away for a while and I am missing parse. I was wondering if you know of any similar parsers in other languages like Python or R?</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/is-there-anything-like-parse-in-other-languages/2032">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/is-there-anything-like-parse-in-other-languages/2032</link>
          <pubDate>Thu, 25 May 2023 09:17:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2032</guid>
          <source url="https://forum.rebol.info/t/is-there-anything-like-parse-in-other-languages/2032.rss">Is there anything like parse in other languages?</source>
        </item>
        <item>
          <title>&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</title>
          <dc:creator><![CDATA[vnzio]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p><a href="https://factorcode.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://factorcode.org/</a></p>
<aside class="onebox wikipedia" data-onebox-src="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1">
  <header class="source">

      <a href="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">en.wikipedia.org</a>
  </header>

  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:200/124;"><img src="//upload.wikimedia.org/wikipedia/en/thumb/f/ff/NewFactorLogo.png/200px-NewFactorLogo.png" class="thumbnail" width="200" height="124"></div>

<h3><a href="https://en.wikipedia.org/wiki/Factor_%28programming_language%29?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">Factor (programming language)</a></h3>

<p>Factor is a stack-oriented programming language created by Slava Pestov. Factor is dynamically typed and has automatic memory management, as well as powerful metaprogramming features. The language has a single implementation featuring a self-hosted optimizing compiler and an interactive development environment. The Factor distribution includes a large standard library.
 Slava Pestov created Factor in 2003 as a scripting language for a video game. The initial implementation, now referred to as JFa...</p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Google Tech Talk 2008</p><p><a href="https://www.youtube.com/watch?v=f_0QlhYlS8g">Factor: an extensible interactive language</a></p>

<p>Silicon Valley Forth Interest Group<br>
2022<br>
"Factor in 2022"</p><p><a href="https://www.youtube.com/watch?v=OLh61q4c4XE">2022-03-26 --- Factor in 2022 --- John Benediktsson &amp; Doug Coleman</a></p>

            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029</link>
          <pubDate>Mon, 17 Apr 2023 23:10:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2029</guid>
          <source url="https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029.rss">&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</source>
        </item>
        <item>
          <title>Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</title>
          <dc:creator><![CDATA[vnzio]]></dc:creator>
          <category>Offtopic</category>
          <description><![CDATA[
            <p>Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</p>
<p>???</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028</link>
          <pubDate>Mon, 17 Apr 2023 22:47:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2028</guid>
          <source url="https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028.rss">Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</source>
        </item>
        <item>
          <title>Should ANY-VALUE! Include Isotopes?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So if you don't put any type restrictions on a parameter, it will allow isotopes:</p>
<pre><code> &gt;&gt; foo: func [x] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p>And right now, that is a synonym for ANY-VALUE!.</p>
<pre><code> &gt;&gt; foo: func [x [any-value!]] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p><strong>But what if you want to exclude isotopes?</strong>  We could have a name for the typeset excluding isotopes (perhaps ANY-CELL!).  Or we could say that ANY-VALUE! doesn't include isotopes by default, and so you have to write <strong>[any-value! isotope!]</strong> if you want them... or just include the specific ones you intend (like <strong>[null! any-value!]</strong>.</p>
<p>Right now I'm going the route of saying ANY-CELL! is the narrower set of values that do not include isotopes.  Is there a better term for saying something can be put into an array vs. not?</p>
<p><em>"10 is an integer! which is legal to use as a cell, while ~null~ isotopes are not legal as cells, but can be variable values"</em></p>
<p>It seems shorter and cleaner than ANY-REIFIED!  or something like that.  I don't know any better options.</p>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-any-value-include-isotopes/2026">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-any-value-include-isotopes/2026</link>
          <pubDate>Fri, 14 Apr 2023 21:37:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2026</guid>
          <source url="https://forum.rebol.info/t/should-any-value-include-isotopes/2026.rss">Should ANY-VALUE! Include Isotopes?</source>
        </item>
        <item>
          <title>TRY... *again* :roll_eyes:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I have proposed a concept for TRY as trapping definitional errors and turning them into nulls, like this:</p>
<pre><code>&gt;&gt; take []
** Error: you can't take from an empty block (stopping further code)

&gt;&gt; try take []
== ~null~  ; isotope
</code></pre>
<p>And I'll just give a reminder that as this is trapping <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">definitional errors</a>.  So failures from deeper inside code would not be caught... only errors that are returned by contract from the function being called.</p>
<pre><code>&gt;&gt; try compose [(1 / 0)]
** Error: division by zero (e.g. COMPOSE itself didn't raise the error)
</code></pre>
<p><em>I'll remind everyone that it's a very slippery slope to trap "deep errors", and this is why the deep error trapping concept is <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871/3">hidden away as <code>sys.util.rescue</code></a>)</em></p>
<h2>Why Return NULL From TRY (vs. void) ?</h2>
<p>The decision to return null is to make the result falsey so it can be acted on:</p>
<pre><code>while [item: try take block] [
    ...
]

all [
    try take block  ; if this fails we don't want to keep going
    ...
]
</code></pre>
<p>In the vernacular I use, I call NULL "soft failure".  So TRY "converts a definitional failure into soft failure", passing through all other results as-is.</p>
<h2>Comparison with similar word MAYBE</h2>
<p>The MAYBE operation was defined as something that converts nulls to voids, and passes through everything else.  If you didn't know that, it's easy to see not intuiting what the difference between <strong>try take block</strong> and <strong>maybe take block</strong> would be.</p>
<p>You can get some odd-looking combinations with this, e.g.</p>
<pre><code> &gt;&gt; block1: [a b c]
 &gt;&gt; block2: []

 &gt;&gt; append block1 maybe try take block2
 == [a b c]
</code></pre>
<p>Which makes one wonder if MAYBE could be used to trap definitional errors as well as nulls and turn them into voids, so you could just write <strong>append block1 maybe take block2</strong>.</p>
<p>So it raises the question: are there null-returning operations that also return definitional errors, where one would want to suppress the null but not the error?  There's not enough experience for me to say yet.</p>
<h2>Usage in PARSE as opposed to OPT?</h2>
<p>I've wondered if TRY and MAYBE could have parallel meanings in PARSE, where you use TRY to continue but get NULL and MAYBE to skip things:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" maybe some "b"]
== "a"

&gt;&gt; parse "aaa" [some "a" var: try some "b"]
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; var
== ~null~  ; isotope
</code></pre>
<p>Seeing the two operations as being very similar--only one voids while the other one nulls--feels interesting.  I just hadn't thought of MAYBE as a definitional-error-suppressor before.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/try-again/2025">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/try-again/2025</link>
          <pubDate>Fri, 14 Apr 2023 21:22:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2025</guid>
          <source url="https://forum.rebol.info/t/try-again/2025.rss">TRY... *again* :roll_eyes:</source>
        </item>
  </channel>
</rss>

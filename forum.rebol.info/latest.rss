<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest topics</title>
    <link>https://forum.rebol.info/latest</link>
    <description>Latest topics</description>
    
      <lastBuildDate>Sun, 28 Aug 2022 16:39:55 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/latest.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Better Answers than TRY and OPT For BLANK! &lt;=&gt; NULL</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Ever since the creation of null and blank, it's been desirable to go between them.</p>
<p>The word I first chose for NULL =&gt; BLANK! was TRY.  It would pass through anything else:</p>
<pre><code>&gt;&gt; try null
== _

&gt;&gt; try _
== _

&gt;&gt; try 1020
== 1020
</code></pre>
<p>The reverse operation of converting BLANK! =&gt; NULL was called OPT; again passing through everything else:</p>
<pre><code>&gt;&gt; opt _
; null

&gt;&gt; opt null
; null

&gt;&gt; opt 1020
== 1020
</code></pre>
<p>It may seem mysterious to ascribe such a trivial operation to a high-value word like TRY.  But it made sense at the time, because nulls were rather unfriendly:</p>
<pre><code>&gt;&gt; if not x: find "abc" "d" [print "Assignment goes okay..."]
Assignment goes okay...
; null

&gt;&gt; if not x [print "But word fetching has problems"]
** Error: X is NULL    
</code></pre>
<p>TRY provided a way to disarm the result:</p>
<pre><code>&gt;&gt; x: try find "abc" "d"
== _

&gt;&gt; if not x [print "Didn't find it"]
Didn't find it
</code></pre>
<p>But as it turned out: NULL was trying to do too many things, being fused with the notion of "unset variables".  It was a good start on having non-valued states... we just needed more!</p>
<p>Once VOID arrived it was no longer necessary to error on null variable accesses, and this particular usage of TRY was not necessary.</p>
<h2>But...It Was Actually On The Right Track...</h2>
<p>FIND is a bad demonstration.  But TAKE on empty block is actually a good one from that erroring-on-nulls era:</p>
<pre><code>&gt;&gt; x: take []
; null

&gt;&gt; if x [print "-some- error around here seems right..."]
** Error: X is NULL

&gt;&gt; x: try take []
== _

&gt;&gt; if x [print "-some- signal for saying it's okay seems right..."]
-some- signal for saying it's okay seems right...
</code></pre>
<p>But we see it's suboptimal, as now X is valued... and conflates with if we had written <strong><code>take [_]</code></strong>.  It also seems the need for the TRY in this case should have been independent of whether you stored the result in a variable or not.</p>
<p>Definitional errors come in and clean this mess up... so that TRY can defuse the take and give you the NULL state you want:</p>
<pre><code>&gt;&gt; x: take []
** Error: TAKE of EMPTY block, use TRY if you meant to do that

&gt;&gt; x: try take []
; null
</code></pre>
<h2>But Now How Do We Interconvert BLANK! and NULL?</h2>
<p>You're still going to come across situations where you pick a blank out of a block, where it's representing a null intent.  And it's illegal to compose or append nulls to blocks / etc, so how do you convert them?</p>
<p>Meet REIFY and DECAY.</p>
<pre><code>&gt;&gt; reify null
== _

&gt;&gt; decay _
; null
</code></pre>
<p>We actually have new members of this family: the conversion of isotopes to quasiforms.</p>
<pre><code>&gt;&gt; true
== ~true~  ;  isotope

&gt;&gt; append [a b c] true
** Error: Cannot append ~true~ isotope to block, use REIFY for quasiform

&gt;&gt; append [a b c] reify true
== [a b c ~true~]

&gt;&gt; append [a b c] as word! true
== [a b c true]
</code></pre>
<p>I think the words are a nice coupling...and even the same number of letters!</p>
<h2>What Will OPT Do Now?</h2>
<p>I'm not sure.  I'm actually pulling back a bit on the idea of saying that what happens in PARSE is a TRY... because in essence there's always a built-in "TRY" during parse.  Rules are raising definitional errors, but that's just swept under the rug by the parse process itself.  So OPT kind is kind of a different shade of meaning there.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946</link>
          <pubDate>Sun, 28 Aug 2022 16:39:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1946</guid>
          <source url="https://forum.rebol.info/t/better-answers-than-try-and-opt-for-blank-null/1946.rss">Better Answers than TRY and OPT For BLANK! &lt;=&gt; NULL</source>
        </item>
        <item>
          <title>Minor (but nice!) %prot-http.r parsing improvements</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>Here's is R3-Alpha's <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/mezz/prot-http.r">PARSE-WRITE-DIALECT</a> from %prot-http.r</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set block word! (spec/method: block) | (spec/method: 'post)]
        opt [set block [file! | url!] (spec/path: block)]
        [set block block! (spec/headers: block) | (spec/headers: [])]
        [set block [any-string! | binary!] (spec/content: block) | (spec/content: none)]
    ]
]
</code></pre>
<p>You couldn't set paths in R3-Alpha parse, which is weird.  So things had to be captured into a temporary variable (it reused the input block for some reason).</p>
<p>Let's imagine that setting paths were legal:</p>
<pre><code>parse-write-dialect: func [port block /local spec] [
    spec: port/spec
    parse block [
        [set spec/method word! | (spec/method: 'post)]
        opt [set spec/path [file! | url!]]
        [set spec/headers block! | (spec/headers: [])]
        [set spec/content [any-string! | binary!] | (spec/content: none)]
    ]
]
</code></pre>
<p>Let's do a quick transformation of this to PARSE3 in Ren-C:</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse3 block [  ; PARSE3 is R3-Alpha-compatible parse
        [set spec.method word! | (spec.method: 'post)]
        opt [set spec.path [file! | url!]]
        [set spec.headers block! | (spec.headers: [])]
        [set spec.content [any-string! | binary!] | (spec.content: _)]
    ]
]
</code></pre>
<ul>
<li>
<p>The TUPLE!s help us see we're not making function calls, which is nice</p>
</li>
<li>
<p>We have BLANK! which gives a nicer semiotic "we're nulling out this variable" look.</p>
</li>
<li>
<p>/LOCAL is a legitimate normal refinement, and <code>&lt;local&gt;</code> variables are truly local--you can't slip them in from the caller.  Because they are invisible, you can build function compositions that don't have to worry about colliding with their names.</p>
<ul>
<li>It also frees up /LOCAL to just be a typical refinement, like TIME/LOCAL</li>
</ul>
</li>
</ul>
<p>Now let's throw in some UPARSE, with the SET-WORD!s for assignment...</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [  ; PARSE is now UPARSE
        [spec.method: word! | (spec.method: 'post)]
        opt [spec.path: [file! | url!]]
        [spec.headers: block! | (spec.headers: [])]
        [spec.content: [any-string! | binary!] | (spec.content: _)]
    ]
]
</code></pre>
<p>It looks a little tighter...but then we also have the ability to factor the assignments out...</p>
<pre><code>parse-write-dialect: func [port block &lt;local&gt; spec] [
    spec: port.spec
    parse block [
        spec.method: [word! | ('post)]
        spec.path: opt [file! | url!]
        spec.headers: [block! | ([])]
        spec.content: [any-string! | binary! | (_)]
    ]
]
</code></pre>
<p>As it happens, that last line could just be <strong>opt [any-string! binary!]</strong>, because it would assign the result to NULL.</p>
<h2>But... That Raises a Question...</h2>
<p>What if the PARSE behavior for BLANK! was the same as in the evaluator, and it just produced NULL out of thin air but didn't match it?  Hence <code>_</code> would be a synonym for <code>(_)</code>.</p>
<p>Then these would be equivalent:</p>
<pre><code>spec.content: [any-string! | binary! | _]

spec.content: opt [any-string! | binary!]
</code></pre>
<p>You'd also be able to easily zero variables without entering a GROUP!.</p>
<pre><code>&gt;&gt; data: &lt;before&gt;

&gt;&gt; parse [x x x] [data: _ [some "y" (data: "Found some Y!")]]
; null

&gt;&gt; data
; null
</code></pre>
<p>I think the literal INTEGER! behavior has turned out to be a winner, where <code>3</code> is the same as <code>(3)</code>.  So maybe that would be good for blank too, given its new useful null-making behavior?  Dunno.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945</link>
          <pubDate>Sat, 27 Aug 2022 17:38:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1945</guid>
          <source url="https://forum.rebol.info/t/minor-but-nice-prot-http-r-parsing-improvements/1945.rss">Minor (but nice!) %prot-http.r parsing improvements</source>
        </item>
        <item>
          <title>Thinking About Isotopes Logically: ~true~ and ~false~</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Here's an idea: what if <strong>~true~</strong> and <strong>~false~</strong> are examples of weird isotopic exceptions.</p>
<p>Let's say you could assign them to variables...and fetch them from variables...without erroring:</p>
<pre><code>&gt;&gt; true: ~true~
== ~true~  ; isotope

&gt;&gt; false: ~false~
== ~false~  ; isotope

&gt;&gt; obj: make object! [y: true, n: false]
== make object! [
     y: ~true~
     n: ~false~
]
</code></pre>
<p><em>(not being quoted in the assignment indicates they become their isotopic forms.)</em></p>
<p>This is typically not legal...accessing a WORD! isotope from a variable like true would be an error.  But these would be special (like how I'm suggesting isotopic ACTION! would be special in running the action from a word reference...)</p>
<p>Things that tested for truthiness would treat them as expected, considering the ~false~ isotope to be a falsey thing:</p>
<pre><code>&gt;&gt; any [true false]
== ~true~  ; isotope

&gt;&gt; all [true false]
; null
</code></pre>
<p><em>Being isotopes comes with a constraint</em>...you couldn't put them into blocks.  You'd have to ^META them (which would lose their special status, turning them into QUASI-WORD!s...that were truthy.</p>
<pre><code>&gt;&gt; ^ false
== ~false~

&gt;&gt; if ^ false [print "Meta false is truthy"]
Meta false is truthy
</code></pre>
<p>The functions TRUE? and FALSE? could then work on isotopic, non-isotopic, or word forms of TRUE and FALSE...but error if passed other values.</p>
<ul>
<li>
<p><strong>This should work for casual cases of just having variables that hold a true or false state...and gives a good appearance for knowing what you're looking at.</strong></p>
</li>
<li>
<p><strong>It builds on standard mechanisms, and hence if you need to promote the isotopic state into something that can be represented in a block you can do so... with the caveat that once you do, it will no longer reflect its logical property when used with IF and such.</strong></p>
<ul>
<li><strong>That's true for NULL being ^META promoted and put in blocks as well.</strong></li>
</ul>
</li>
</ul>
<p><strong>And crucially: Since you know isotopes can't be in blocks--and if we say BLANK! is truthy as well--then you'd be guaranteed to visit all the items in a block with code like this:</strong></p>
<pre><code>while [item: try take block] [
    print mold item
]
</code></pre>
<p>This is easily the best idea so far for dealing with the problem.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944</link>
          <pubDate>Thu, 25 Aug 2022 23:34:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1944</guid>
          <source url="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944.rss">Thinking About Isotopes Logically: ~true~ and ~false~</source>
        </item>
        <item>
          <title>Weird Little Function: STEAL a Variable&#39;s Prior Value</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>I don't know if it has the best name (suggestions?), but it's kind of interesting...</p>
<pre><code>&gt;&gt; x: 304
== 304

&gt;&gt; steal x: 1000 + 20
== 304

&gt;&gt; x
== 1020
</code></pre>
<p>I wrote it as a variadic function for some reason (as a test, maybe?) but you could write it in Redbol.  You could even use their lame ALSO.</p>
<pre><code>steal: func [
    {Red version}
    'var [set-word! set-path!]
    value [any-type!]
][
    also get var set var value
]
</code></pre>
<p>The Ren-C version of that reads a lot better:</p>
<pre><code>steal: lambda [
    {Ren-C version}
    'var [set-word! set-path!]
    value [any-value!]
][
    get var
    elide set var value
]
</code></pre>
<p>It naturally has the benefit of letting you break things across lines.  I feel like it's better to point out "this is the thing being erased".  And of course the mechanic is far more general.</p>
<p>I definitely like ANY-VALUE! better than ANY-TYPE!.</p>
<p>Anyway, I'm sure I've seen places I could have used it if I thought of it.  I'll keep my eyes open.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943</link>
          <pubDate>Thu, 25 Aug 2022 16:27:06 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1943</guid>
          <source url="https://forum.rebol.info/t/weird-little-function-steal-a-variables-prior-value/1943.rss">Weird Little Function: STEAL a Variable&#39;s Prior Value</source>
        </item>
        <item>
          <title>BLANK! 2022: Revisiting The Datatype</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Long, long ago there was a datatype called NONE.  In historical Redbol, it had the bad habit of looking like a WORD!:</p>
<pre><code>rebol2&gt;&gt; 'none
== none

rebol2&gt;&gt; none
== none  ; same in R3-Alpha and Red
</code></pre>
<p>But it wasn't a word:</p>
<pre><code>rebol2&gt;&gt; type? 'none
== word!

rebol2&gt;&gt; type? none
== none!
</code></pre>
<p>It was a distinct type, which also happened to be falsey (while WORD!s are truthy):</p>
<pre><code>rebol2&gt;&gt; if 'none [print "Truthy word!"]
Truthy word!

rebol2&gt;&gt; if none [print "Falsey none!"]
== none
</code></pre>
<p>And as we can see, NONE!s served purposes of signaling "soft failures": branches that didn't run, or FINDs that didn't find, or SELECTs that didn't select... etc.</p>
<pre><code>rebol2&gt;&gt; find "abcd" "z"
== none

rebol2&gt;&gt; select [a 10 b 20] 'c
== none
</code></pre>
<h2>Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!</h2>
<ul>
<li>
<p><strong>NULL</strong> - a non-ANY-VALUE! state that couldn't be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use NULL.</p>
<pre><code>&gt;&gt; find "abcd" "z"
; null

&gt;&gt; select [a 10 b 20] 'c
; null

&gt;&gt; append [a b c] null
** Error: APPEND doesn't allow NULL
</code></pre>
</li>
<li>
<p><strong>VOID</strong> - the "isotopic" form of NULL, which represents the result of things that are effectively "no ops".  Unlike nulls, they will vanish in-between expressions, and when functions like APPEND get them as an argument they are treated as no-ops:</p>
<pre><code>&gt;&gt; if null [print "Doesn't print as NULL is falsey"]
; void

&gt;&gt; 1 + 2 if null [print "Voids disappear..."]
== 3

&gt;&gt; append [a b c] void
== [a b c]
</code></pre>
<p>Void is also the state of unset variables.</p>
<pre><code>&gt;&gt; unset 'foo
; void

&gt;&gt; get/any 'foo
; void
</code></pre>
</li>
<li>
<p><strong>BLANK!</strong> was represented by a lone underscore ( <strong><code>_</code></strong> ) and could be put into blocks:</p>
<pre><code>&gt;&gt; append [a b c] _
== [a b c _]
</code></pre>
<p>It retained the choice to be falsey:</p>
<pre><code>&gt;&gt; if _ [print "Won't print because blanks are falsey"]
</code></pre>
</li>
</ul>
<h2>Question One: Could BLANK! Just Be A WORD! ?</h2>
<p>You might wonder if you could just say:</p>
<pre><code>&gt;&gt; _: '_
== _
</code></pre>
<p>This would give you BLANK! as a WORD! that had the behavior of reducing to itself.</p>
<pre><code>&gt;&gt; reduce [_ 1 + 2 _]
== [_ 3 _]
</code></pre>
<p>That could be just a default, and you could redefine it to anything you wanted.  Generally speaking, people do like being able to define words as operators... and _ has historically been a WORD! (Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word).</p>
<p>But outside of being hardcoded as falsey, what makes BLANK! fairly "built in" is that in the path mechanics, it fills in the empty slots:</p>
<pre><code>&gt;&gt; to path! [_ a]
== /a

&gt;&gt; as block! 'a//b//c
== [a _ b _ c]
</code></pre>
<p>Alternately, we could get a "reified nothing" with a quoted null:</p>
<pre><code>&gt;&gt; to path! [' a]
== /a

&gt;&gt; as block! 'a//b//c
== [a ' b ' c]
</code></pre>
<p>But there's other places the blank is used, such as to opt-out of multi-returns.</p>
<pre><code>&gt;&gt; [_ pos]: transcode "abc def"
; void

&gt;&gt; pos
== " def"
</code></pre>
<p>So freeing it up to be an arbitrary variable feels kind of wrong, as if it were taken for dialects like multi-return you'd be unable to set it as a variable.</p>
<p>This may be an argument for using something like a TAG! instead, so you're not worrying about overlapping with user variables:</p>
<pre><code>[&lt;_&gt; pos]: transcode "abc def"
</code></pre>
<p>Similar arguments have led me to contemplate the dangers of using things like <strong><code>[a b ...]:</code></strong> in case someone has assigned a meaning to the ellipsis.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">  That might be a good reason to keep <strong><code>...</code></strong>  as a TUPLE! instead of a WORD! exception, because no one could assign it.</p>
<p><strong>I'm pretty sure we should keep _ reserved as a BLANK! datatype, not a WORD!.</strong>  People can still give it arbitrary meanings in dialects, they just can't assign values to it as a variable... and they can't do that with <strong><code>#</code></strong> either or <strong><code>&lt;a&gt;</code></strong> so I can live with it.  Taking it away from the word pool does more good than harm.</p>
<h2>Question Two: Does BLANK! Still Need To Be Falsey?</h2>
<p><em>My feeling is that having blank be falsey doesn't have all that much benefit.</em>  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:</p>
<pre><code>&gt;&gt; append [a b c] all [1 &lt; 2, 3 &lt; 4, _]
== [a b c _]  ; would seem nice, but gives error today since ALL is NULL
</code></pre>
<p>Thinking of BLANK! as being "null-like" in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:</p>
<pre><code>&gt;&gt; item: _

&gt;&gt; item: default [1 + 2]
== ???
</code></pre>
<p>In practice, I prefer the truly non-valued NULL (and its isotopic state of VOID) being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as "not being assigned"... as you'll get errors when you try to use it places (e.g. in APPEND).  Trying to use it to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)</p>
<p>Also, the asymmetry between BLANK! and NULL were part of a scheme to try and solve what Redbols called "NONE! propagation":</p>
<pre><code>&gt;&gt; second null
** Error: SECOND doesn't take NULL

&gt;&gt; try null
== _

&gt;&gt; second try null
== null
</code></pre>
<p><strong>We still want this general concept, but <a href="https://forum.rebol.info/t/definitional-errors-as-blank-in-null-out-alternative/1880/7">the new idea is that it's VOID which opts out</a> cleanly from these operations, and MAYBE is the operator that produces them.</strong></p>
<p>This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I've said "blanks are to blocks what space is to strings".  And space is truthy:</p>
<pre><code>&gt;&gt; if second "a b" [print "Space is truthy"]
Space is truthy

&gt;&gt; if second [a _ b] [print "So why shouldn't blank be truthy?"]
???
</code></pre>
<p><strong>So I Suggest The Removal of BLANK! From Being Falsey</strong>.  This creates some incompatibility in Redbol (which has been using NONE! as a blank substitute).  But it's something that can be worked around.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942</link>
          <pubDate>Thu, 25 Aug 2022 13:50:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1942</guid>
          <source url="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
        </item>
        <item>
          <title>Incomplete TRANSCODEs: Actually an Optimization Problem</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p><strong>Ren-C has a very slick multi-return interface for TRANSCODE.</strong>  The mere request of a "remainder" of data left indicates you're not trying to do a full scan.</p>
<p>Without the request, you get the whole thing:</p>
<pre><code>&gt;&gt; transcode "abc def"
== [abc def]

; ...or...

&gt;&gt; value: transcode "abc def"
== [abc def]

; ...or...

&gt;&gt; [value]: transcode "abc def"
== [abc def]
</code></pre>
<p>With the next position request, just one item and a remainder:</p>
<pre><code>&gt;&gt; [value pos]: transcode "abc def"
== abc

&gt;&gt; pos
== " def"

; ...or...

&gt;&gt; transcode/next "abc def" 'pos
== abc

&gt;&gt; pos
== " def"
</code></pre>
<p>You also know that you're at the end of the input when it returns null, with all the benefits of easy reactions to NULL with IF and ELSE and friends:</p>
<pre><code>&gt;&gt; [value pos]: transcode ""
; null
</code></pre>
<p>Writing foolproof loops to process items are a breeze:</p>
<pre><code>while [true]
    [item utf8]: transcode utf8 else [break]
    print mold item
 ]

; or for the THEN/ELSE haters out there (you know who you are :-P)

while [true]
    if null? [item utf8]: transcode utf8 [
        break
    ]
    print mold item
 ]
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=9" title=":+1:" class="emoji only-emoji" alt=":+1:"></p>
<h2>This Runs Circles Around Red and R3-Alpha</h2>
<p>For starters: neither support strings as input--because the scanner is built for reading UTF-8 files...and both R3-Alpha and Red unpack strings into fixed-width encodings.  So if you have string input, you have to pay for a copy encoded as UTF-8 via TO BINARY!.  (<a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">Ren-C's UTF-8 Everywhere</a> wins again!)</p>
<p>R3-Alpha unconditionally returns a block with the last element as a remainder, whether you ask for one item via /NEXT or not:</p>
<pre><code>r3-alpha&gt;&gt; transcode to binary! "abc def"
== [abc def #{}]

r3-alpha&gt;&gt; transcode/next to binary! "abc def"
== [abc #{20646566}]

r3-alpha&gt;&gt; transcode/next to binary! ""
== [#{}]
</code></pre>
<p>So if you were transcoding an entire input, you have to TAKE/LAST an always-empty binary off of the result.</p>
<p>But you are using /NEXT you have to PICK out the element from the start of the array and the remainder from the end.  But you need to notice the exception of no-value-produced where the block is length 1 instead of 2.</p>
<p>That's awkward, but as usual... <em>Red somehow manages to make an incompatible interface that is as much worse as it is better:</em></p>
<p>The better part is that if you don't ask for /NEXT you just get the block back, like in Ren-C:</p>
<pre><code>red&gt;&gt; transcode to binary! "abc def"
== [abc def]
</code></pre>
<p>But the /NEXT interface is outright broken:</p>
<pre><code>red&gt;&gt; transcode/next to binary! "abc def"
== [abc #{20646566}]

red&gt;&gt; transcode/next to binary! ""
== [[] #{}]
</code></pre>
<p>It might look better because you don't have to guess about which position to find the remainder in--it's always in the second slot.  But it has a fatal flaw: you can't distinguish the result state of scanning <code>"[]"</code> and any string with nothing but comments and whitespace.</p>
<p>Consider this very basic loop to scan one item at a time and print it:</p>
<pre><code>red&gt;&gt; utf8: to binary! "abc def"

red&gt;&gt; while [not tail? utf8] [
     set [item utf8] transcode/next utf8
     print mold item
]
abc
def
</code></pre>
<p>You get two items.  But what if you had something that was--say--a comment:</p>
<pre><code>red&gt;&gt; utf8: to binary! "; I'm just a comment"

red&gt;&gt; while [not tail? utf8] [
     set [item utf8] transcode/next utf8
     print mold item
]
[]
</code></pre>
<p>You get one spurious item.  (They chose BLOCK! for the item, but it wouldn't matter what it was--a NONE! would be just as bad, you're just losing the distinction between empty strings and <code>"#[none]"</code> then.)</p>
<p>If I were prescribing a solution for Red I'd say:</p>
<ul>
<li>
<p>Make /NEXT take a variable to write the next position into</p>
</li>
<li>
<p>Error on <code>#{}</code> input, so anyone doing a TRANSCODE/NEXT knows they are responsible for testing for TAIL? before they call (if they're not sure their input is non-empty)</p>
<ul>
<li>This way an empty remainder returned in the /NEXT variable will uniquely signal the reached-end state</li>
</ul>
</li>
<li>
<p>Make the synthesized product at the tail something ugly but assignable (so not an unset!)</p>
<ul>
<li>an ERROR! saying "end of input" is at least informative in case it winds up getting treated as an actual value somewhere</li>
</ul>
</li>
</ul>
<p>That would at least give them patterns like:</p>
<pre><code>if not tail? utf8 [  ; needed if you're not sure it's non-empty
    while [true] [
        item: transcode/next utf8 'utf8
        if tail? utf8 [break]
        print mold item
    ]
]
</code></pre>
<p><em>(Having NULL is clearly better as a non-valued state (with isotope states fleshing out the picture)...and my <a href="https://forum.rebol.info/t/why-or-why-not-have-unset-in-rebol-like-languages/113/2">bafflement at Nenad's blindness</a> when confronted with what should be clear as day is as relevant as it was 6-plus-years ago.  And of course we see they'd actually need SET/ANY to do this right if you were allowing #[unset!]...but Ren-C's design has no need of that.)</em></p>
<h2>Ren-C Also <em>Thrashes</em> R3-Alpha and Red In Error Handling</h2>
<p>Ren-C TRANSCODE has these potential behaviors:</p>
<ul>
<li>
<p>RETURN a BLOCK! (if plain TRANSCODE)</p>
</li>
<li>
<p>RETURN an ANY-VALUE! or NULL (if TRANSCODE/NEXT)</p>
</li>
<li>
<p>It can do a "hard FAIL"</p>
<ul>
<li>
<p>This would happen if you asked something fundamentally incoherent...like asking to TRANSCODE a with input that was non-UTF-8...like a GOB!, or something like that</p>
</li>
<li>
<p>Such errors are only interceptible by a special SYS.UTIL.ENTRAP method--they are not supposed to be easy to gloss over and unlikely to have meaningful mitigation.  So only special sandboxing situations (like writing consoles that print out the error) are supposed to trap them.</p>
</li>
</ul>
</li>
<li>
<p>It can RETURN an <em>isotopic ERROR!</em> ("raised error") if something went wrong in the transcoding process itself</p>
<ul>
<li>
<p>This would be something like a syntax error, like  if you asked <strong>transcode "a bc 1&amp;x def"</strong></p>
</li>
<li>
<p>These will be promoted to a hard FAIL if the immediate caller doesn't do something to specially process them.</p>
</li>
<li>
<p>You can casually ignore or intercept these, because you can be confident that it was a formal return result of the thing you just called--not some deeper problem like a random typo or other issue.</p>
</li>
</ul>
</li>
</ul>
<p>I won't rehash the entire <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">"why definitional errors are foundational"</a> post, but TRANSCODE was one of the first functions that had to be retrofitted to use them.</p>
<pre><code>&gt;&gt; transcode "a bc 1&amp;x def" except e -&gt; [print ["Error:" e.id]]
Error: scan-invalid
</code></pre>
<p><strong>The definitionality is extremely important!</strong>  I spent a long time today because in the bootstrap shim I had a variation of transcode...parallel to this in R3-Alpha:</p>
<pre><code>r3-alpha&gt;&gt; transcode: func [input] [
               prnit "My Transcode Wrapper"  ; oops, typo
               return transcode input
           ]

r3-alpha&gt;&gt; if not attempt [transcode to binary! "abc def"] [print "Bad input"]
Bad input
</code></pre>
<p><em><strong>But the input isn't bad!!!</strong></em>  This leads to a nightmare of trying to figure out what was going wrong.  I had just one of those nightmares today in the bootstrap executable when tinkering with the shim implementation of TRANSCODE.  A bug in the shim was leading to silently skipping work that should have been done, because the caller wanted to be tolerant of bad transcode input.</p>
<p>There's simply no practical way of working on code of any complexity without something like definitional failures, and experience has proven this day after day.</p>
<h2>Getting Incomplete Results Via R3-Alpha's /ERROR</h2>
<p>R3-Alpha offered this feature:</p>
<pre><code>/error -- Do not cause errors - return error object as value in place
</code></pre>
<p>The intended use is that you might want the partial input of what had been successfully scanned so far.  If the code went and raised an error, you could trap that error.  But you wouldn't have any of the scanned items.</p>
<p>It would put it any ERROR! as the next-to-last item in the block, with the remainder after that:</p>
<pre><code>&gt;&gt; transcode/error to binary! "a bc 1&amp;x def"
== [abc make error! [
    code: 200
    type: 'Syntax
    id: 'invalid
    arg1: "pair"
    arg2: "1&amp;x"
    arg3: none
    near: "(line 1) a bc 1&amp;x def"
    where: [transcode]
] #{20646566}]

&gt;&gt; to string! #{20646566}
== " def"  ; wait...why isn't 1&amp;x part of the "remainder"
</code></pre>
<p>It's clumsy to write the calling code (or to read it...testing to see if the next-to-last-item is an ERROR! and reacting to that.</p>
<p><em>(Also: What if there was some way to represent ERROR! values literally in source?  This would conflate with such a block that was valid...but just incidentally had an ERROR! and then a BINARY! in the last positions.)</em></p>
<p>But the thing that had me most confused about it was the remainder.  Notice above you don't get  <code>1&amp;x</code> as the start of the stuff it couldn't understand.</p>
<p>Was it trying to implement some kind of recoverable scan?  What would that even mean?  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:"></p>
<p><strong>Ultimately I think this was just a leaking of an implementation detail as opposed to any reasonable attempt at recoverable scanner.</strong>  It only didn't tell you where the exact tail of the successfully scanned material was because it did not know.</p>
<p>The scanning position is based on token consumptions, and so if you started something like a block scan and it saw a <strong>[</strong> then it forgets where it was before that.  Then if something inside the block goes bad, it will just give you a remainder position somewhere inside that--<em>completely forgetting about how many nesting levels it was in</em>.</p>
<p>So what you were getting was a crappier implementation of scanning one by one, and remembering where you were before the last bad scan:</p>
<pre><code>pos: input
error: null
block: collect [
   while [true] [
       keep [# pos]: transcode pos else [
           break
       ] except e -&gt; [
           error: e
           break
       ]
   ]
]
</code></pre>
<p>That gives you a proper version, setting error if something happened and giving you the block intact.</p>
<h2>So Finally... We See It's An Optimization Problem</h2>
<p>Question is if there's some way of folding this into TRANSCODE, so it's doing the looping and collecting efficiently for you.</p>
<p>But this interface wants to get back a "remainder".  And I kind of hate to sacrifice the property that TRANSCODE's asking for a remainder means scan one element.  :-/</p>
<p>I guess we <em>could</em> say that there's a logical process you follow:</p>
<ul>
<li>
<p>The output parameter is called REST (instead of NEXT)</p>
</li>
<li>
<p>An additional output parameter is added for ERROR</p>
</li>
<li>
<p>If you ask for the REST and <em>don't</em> ask for an ERROR, that suggests you want to encode a single item</p>
<ul>
<li>
<p>You could have just intercepted the error if you wanted it</p>
</li>
<li>
<p>Nothing is lost because there wouldn't be any partial results to miss (if you're only doing one item, there will always be zero items completed before it)</p>
</li>
</ul>
</li>
<li>
<p>If you ask for the REST and <em>do</em> ask for an error, then it assumes you must not want the one-item-only semantics after all.</p>
</li>
</ul>
<p>It's a little bit awkward because it conflates partial output with fully successful output</p>
<pre><code>&gt;&gt; [block rest error]: transcode "a bc"
== [a bc]

&gt;&gt; error
; null

&gt;&gt; [block rest error]: transcode "a bc 1&amp;x def"
== [a bc]  ; no indication something failed

&gt;&gt; error? error  ; you'd have to remember to check this
== #[true]
</code></pre>
<p>That's not a deal breaker, and Ren-C makes it easy to work with, using <a href="https://forum.rebol.info/t/circling-multi-returns-choose-which-is-expression-result/1587">circling an output in multi-return</a> to make it the primary return result:</p>
<pre><code>&gt;&gt; [block rest @error]: transcode "a bc"
; null

&gt;&gt; [block rest @error]: transcode "a bc 1&amp;x def"
== make error! [...]
</code></pre>
<p><strong>What's much more jarring to me is the flipping back and forth of whether you're asking for a full transcode or not.</strong></p>
<pre><code>&gt;&gt; x: transcode "abc def"
== [abc def]

&gt;&gt; [x y]: transcode "abc def"
== abc

&gt;&gt; [x y z]: transcode "abc def"
== [abc def]
</code></pre>
<p>Ick.  Should I be willing to bend on the transcode "requested parameter" behavior in this case, by adding a /ONE refinement?</p>
<pre><code>&gt;&gt; [block rest]: transcode "abc def"
== [abc def]

&gt;&gt; rest
== #{}  ; kind of useless, but honest

&gt;&gt; [block rest]: transcode/one "abc def"
== abc

&gt;&gt; rest
== " def"
</code></pre>
<p>That would make me feel grief, as it loses one of the first showcases of return value sensitivity.  <em>And it irks me to think that the beauty is ultimately being given up for the sake of what amounts to an optimization.</em></p>
<h2>Answer For Now: Kill Off /ERROR</h2>
<ul>
<li>
<p>The answer /ERROR has been giving back in error cases for the remainder is sketchy, and I don't want to figure out how to fix it.</p>
</li>
<li>
<p>You can get the behavior reliably just by intercepting errors going one transcode item at a time.</p>
</li>
<li>
<p>This is a good opportunity to write tests of item-by-item scanning with error handling</p>
</li>
<li>
<p>Red added a bunch of refinements on transcode [/next /one /prescan /scan /part /into /trace], and they didn't pick up /error themselves</p>
</li>
</ul>
<p>Speaking of adding lots of refinements: I also want to get away in general from investments in weird C scanner code and hooks (<em>especially</em> if it's just an optimization).</p>
<p>What we should be investing in is more fluid mixture of PARSE of strings/binary with the scanner.  e.g. we should have ways of knowing what line number you're at during the parse for any combinator, and just generally pushing on that.  Adding TRANSCODE parameters up the wazoo isn't a winning strategy.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/incomplete-transcodes-actually-an-optimization-problem/1940">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/incomplete-transcodes-actually-an-optimization-problem/1940</link>
          <pubDate>Mon, 22 Aug 2022 15:09:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1940</guid>
          <source url="https://forum.rebol.info/t/incomplete-transcodes-actually-an-optimization-problem/1940.rss">Incomplete TRANSCODEs: Actually an Optimization Problem</source>
        </item>
        <item>
          <title>Optimizing TRANSCODE Usage in String/Binary PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>As written, the DATATYPE! combinator in UPARSE may do wasteful value loading when operating on string input.</p>
<p>Consider this case.</p>
<pre><code>&gt;&gt; parse "[some big block ...] 10" [collect some [keep integer! | block!]]
== [10]
</code></pre>
<p><em>Pretty impressive that it works.</em>  (Red will only do this on BINARY! input, but Ren-C's UTF-8 everywhere allows it to do it on strings too!)</p>
<p>But at the combinator level, it's wasteful.  What happens is:</p>
<ul>
<li>
<p>Hitting the INTEGER! combinator, causing it to scan the next element, loading <strong><code>[some big block ...]</code></strong> as a series into memory.</p>
<ul>
<li>It then checks the type, notices it's not an integer, and the INTEGER! combinator gives back a rejection...so the BLOCK! combinator goes to the next alternate.</li>
</ul>
</li>
<li>
<p>It hits the BLOCK! combinator and scans the block again.</p>
<ul>
<li>
<p>This time it matches, so the parser returns success and the synthesized block</p>
</li>
<li>
<p><em>But the block isn't actually desired</em>, so it is thrown away</p>
</li>
</ul>
</li>
<li>
<p>The next iteration scans the INTEGER! and keeps it.</p>
</li>
</ul>
<h2>Why Does It Work This Way?</h2>
<p>It's based on TRANSCODE, and does basically exactly what I said:</p>
<pre><code>[item remainder]: transcode input except e -&gt; [return raise e]

if datatype != type of item [
    return raise ["Could not TRANSCODE" datatype "from input"]
]
return item
</code></pre>
<p>If we could pass in a datatype to TRANSCODE when using the /NEXT option (e.g. requesting a remainder, as we are above) then it could short-circuit and we wouldn't need that test.</p>
<h2>Red Has Looked At This Kind of Problem</h2>
<p>There are a bunch of new arguments to Red's TRANSCODE function:</p>
<pre><code>USAGE:
     TRANSCODE src

DESCRIPTION: 
     Translates UTF-8 binary source to values.
     Returns one or several values in a block. 

ARGUMENTS:
     src          [binary! string!]
     {UTF-8 input buffer; string argument will be UTF-8 encoded.}

REFINEMENTS:
     /next        =&gt; Translate next complete value (blocks as single value).
     /one         =&gt; Translate next complete value, returns the value only.
     /prescan     =&gt; Prescans only, do not load values. Returns guessed type.
     /scan        =&gt; Scans only, do not load values. Returns recognized type.
     /part        =&gt; Translates only part of the input buffer.
         length       [integer! binary!] "Length in bytes or tail position."
     /into        =&gt; Optionally provides an output block.
        dst          [block!] 
     /trace       =&gt; 
        callback     [function! [
                        event [word!]
                        input [binary! string!]
                        type [word! datatype!]
                        line [integer!]
                        token
                        return: [logic!]
                      ]] 

RETURNS:
    [block!]
</code></pre>
<p>I'm not sure exactly how useful the /PRESCAN option is (what good is a "guess" of the type?)  But the /SCAN option would offer some bit of efficiency.</p>
<p>It would mean instead of one call to TRANSCODE followed by a datatype test, there'd be two calls</p>
<ul>
<li>
<p>The first as TRANSCODE/SCAN to get the datatype (but not synthesize a value from it)</p>
</li>
<li>
<p>A second call to scan again and get the value</p>
</li>
</ul>
<p>We assume the idle mode of scanning without producing anything can be fast.</p>
<p>I would suggest the scan feature be <strong>transcode/types</strong> so it worked more generally, not just with /NEXT.</p>
<pre><code>&gt;&gt; transcode/types [1 a [b]]
== [#[datatype! integer!] #[datatype! word!] #[datatype! block!]]
</code></pre>
<p><sub><em>(When I figure out the story of datatypes, there are going to be a lot of forum posts fixing up the above ugly notation.)</em></sub></p>
<h2>But What About The Synthesis Of Unused Values?</h2>
<p>This is a bit of a pickle.  <em>We don't know if you're going to use the product or not.</em></p>
<p>UPARSE's design has values bubbling out the top, and no line of communication to be aware of whether what it produces will be used:</p>
<pre><code>&gt;&gt; uparse "[a] (b)" [block! group!] 
== (b)
</code></pre>
<p>You might think that when the block! rule is going to be run, UPARSE could notice it wasn't at the end and send some kind of signal to the BLOCK! combinator that it doesn't have to synthesize an output.  But there's no a-priori psychic power saying that GROUP! hasn't been configured to evaluate to void.  Until the combinator gets looked up and run, it's potentially the same situation as this:</p>
<pre><code>&gt;&gt; uparse "[a] (b)" [block! void] 
== [a]
</code></pre>
<h2>It Seems We Have Two Choices</h2>
<ol>
<li>
<p>We can assume that a plain DATATYPE! intends to synthesize a value, and use a different combinator to say you only want to match the type:</p>
<pre><code>&gt;&gt; uparse "[a b c]" [scan block!]
== #[datatype! block!]  ; cheap (but useful) return value, no series synthesis

&gt;&gt; uparse "[a b c]" [block!]
== [a b c]
</code></pre>
</li>
<li>
<p>We can reverse it and say that by default it does the cheap thing, and you have to explicitly ask to get the expensive thing:</p>
<pre><code>&gt;&gt; uparse "[a b c]" [block!]
== #[datatype! block!]

&gt;&gt; uparse "[a b c]" [scan block!]
== [a b c]
</code></pre>
</li>
</ol>
<p>Looked at in isolation, it might seem like (2) would be the obvious winner.</p>
<p>The thorn is that this would be a pretty notable divergence from how array parsing works, which I would basically call non-negotiable:</p>
<pre><code>&gt;&gt; uparse [[a b c]] [x: block!]

&gt;&gt; x
== [a b c]
</code></pre>
<p>So is there actually an option 3?</p>
<ol start="3">
<li>
<p>Make lone datatype! an error, and have two distinct operations for transcoding:</p>
<pre><code>&gt;&gt; uparse "[a b c]" [block!]
** Error: On string input, use either TRANSCODE BLOCK! or SCAN BLOCK!

&gt;&gt; uparse "[a b c]" [transcode block!]
== [a b c]

&gt;&gt; uparse "[a b c]" [scan block!]
== [a b c]
</code></pre>
</li>
</ol>
<p>Urg.  That kind of sucks.</p>
<p><strong>I think the answer is to accept option (1) being suboptimal performance, allowing those who are performance-minded to tune it.</strong>  There's no overt harm by scanning things you throw away, it's just wasteful.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/optimizing-transcode-usage-in-string-binary-parse/1939">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/optimizing-transcode-usage-in-string-binary-parse/1939</link>
          <pubDate>Sun, 21 Aug 2022 19:10:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1939</guid>
          <source url="https://forum.rebol.info/t/optimizing-transcode-usage-in-string-binary-parse/1939.rss">Optimizing TRANSCODE Usage in String/Binary PARSE</source>
        </item>
        <item>
          <title>Matching Characters in BINARY! PARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>In Rebol2, you can't match a character (or string) against a binary!:</p>
<pre><code>rebol2&gt;&gt; to binary! " "
== #{20}

rebol2&gt;&gt; parse #{20} [" "]
== false

rebol2&gt;&gt; parse #{20} [#" "]
== false
</code></pre>
<p>In Red and R3-Alpha, you can do both...</p>
<pre><code>red&gt;&gt; parse #{20} [" "]
== true

red&gt;&gt; parse #{20} [#" "]
== true
</code></pre>
<p>But their unicode model means they really don't know what they're doing in any general sense, and I'm sure whatever's under the hood is incoherent:</p>
<pre><code>red&gt;&gt; to binary! "Æ"
== #{C386}

red&gt;&gt; parse #{C386} ["Æ"]
== false
</code></pre>
<p>Ren-C is much more coherent!</p>
<pre><code>&gt;&gt; did parse #{C386} ["Æ"]
== #[true]
</code></pre>
<h2>So the PARSE Succeeds, but... what should it return?</h2>
<p>Right now a parse on a string returns the <em>rule</em> when it matches.</p>
<pre><code>&gt;&gt; rule: "cd"

&gt;&gt; result: parse "abcd" ["ab" rule]
== "cd"

&gt;&gt; append result "ef"
== "cdef"

&gt;&gt; rule
"cdef"
</code></pre>
<p><strong>This is clearly correct, because you don't want it to make a copy if it doesn't know if you're going to use the copy.</strong>  Basic rule matching should not produce a new series.</p>
<p>The same logic applies to BINARY!...but should it give you the string as a string, or aliased to its binary form?</p>
<pre><code>&gt;&gt; parse #{C386} ["Æ"]
== "Æ"  ; option 1

&gt;&gt; parse #{C386} ["Æ"]
== #{C386}  ; option 2
</code></pre>
<p>I think the answer is that you should match it as whatever form it was in the rule.</p>
<p>But then...how about something like BLANK!, which acts equivalently to space if the input is a string... or BLANK! if it's an array?</p>
<pre><code>&gt;&gt; parse [_] [_]
== _

&gt;&gt; parse " " [_]
== ???

&gt;&gt; parse #{20} [_]
== ???
</code></pre>
<p>If we're going with the idea of rule as being primacy, then the language of the match should be the same as the language of the rule... e.g. the above all return blank.</p>
<p>But this is something of a gray area, IMO.  I feel like blank is acting as a stand-in for space and should probably be looked at as if you said space.</p>
<pre><code>&gt;&gt; parse " " [_]
== #" "

&gt;&gt; parse #{20} [_]
== #" "  ; instead of 32
</code></pre>
<p>So this is what I'm going with, unless someone has a really good argument for something else.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/matching-characters-in-binary-parse/1935">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/matching-characters-in-binary-parse/1935</link>
          <pubDate>Sun, 21 Aug 2022 05:43:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1935</guid>
          <source url="https://forum.rebol.info/t/matching-characters-in-binary-parse/1935.rss">Matching Characters in BINARY! PARSE</source>
        </item>
        <item>
          <title>Calling Ren Functions From Redbol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>When you <strong><code>import @redbol</code></strong> the environment for your module is skinned with the Redbol definitions.  But it can run concurrently with non-Redbol modules in the same session.  This is very cool.</p>
<p>I've nudged it a little further into cool by having the definition of LIB in Redbol be the initial state of the Redbol definitions, and then REN is the Ren-C's version of LIB.</p>
<pre><code>&gt;&gt; import @redbol

&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append/only [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; ren/append [a b c] ren/spread [d e]
== [a b c d e]

&gt;&gt; append: does [print "Overwritten"]
== #[action! {append} []]

&gt;&gt; append
Overwritten

&gt;&gt; lib/append [a b c] [d e]
== [a b c d e]
</code></pre>
<p><em>Pretty slick.</em></p>
<h2>But IMPORT is Ultimately Not The Right Mechanism</h2>
<p>Because it's done using import, Redbol does not "clear out" the space of all the Ren-Cisms.</p>
<p>In fact, I didn't actually have to say <strong>ren/spread</strong> because the spread definition is still available:</p>
<pre><code>&gt;&gt; ren/append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>It's non-viable to ask Redbol to remove every Ren-C definition.  Instead, there needs to be a way to get a Redbol-using module to start from a fully clean slate where it explicitly exports everything it wants to make available.  This doesn't have to be that much work, it can just be a list of words in a block, with possible renamings:</p>
<pre><code>redbol-inherit [even?, odd?, value?: unset? ...]
</code></pre>
<h2>These Challenges Are Great For Vetting</h2>
<p>I don't throw softballs.  This is all truly attempting to live up to the hype of a language that you can bend and redefine at will, without constantly tripping over your own changes--and being able to build on top of existing functionality without being forced to rewrite it too.</p>
<p>Although things move slowly... the arrow of progress is in the right direction.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934</link>
          <pubDate>Sat, 20 Aug 2022 21:05:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1934</guid>
          <source url="https://forum.rebol.info/t/calling-ren-functions-from-redbol/1934.rss">Calling Ren Functions From Redbol</source>
        </item>
        <item>
          <title>About the Functions category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>Discussions of Functions and Generators, e.g. how things like RETURN work... or the mechanics of generators and composers like ADAPT, SPECIALIZE, ENCLOSE, HIJACK, etc.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-functions-category/1931">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-functions-category/1931</link>
          <pubDate>Sat, 20 Aug 2022 07:39:08 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1931</guid>
          <source url="https://forum.rebol.info/t/about-the-functions-category/1931.rss">About the Functions category</source>
        </item>
        <item>
          <title>Should RETURN be Assignable on Function Interfaces?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>When implementing multi-returns I had an idea, to think of <strong><code>[x]: negate 10</code></strong> in terms of slipping X into the RETURN: slot of NEGATE as an input.</p>
<p>On the surface that seems like it might even be useful more generally:</p>
<pre><code> &gt;&gt; f: make frame! :negate

 &gt;&gt; negate.return: 'x  ; X gets hidden, and RETURN is redefined during the call

 &gt;&gt; negate.value: 10

 &gt;&gt; do f  ; the hidden X is written back automatically
 == -10

 &gt;&gt; x
 == -10
</code></pre>
<h2>But Not Every Action is a FUNC/FUNCTION</h2>
<p>Not all functions are guaranteed to have something in their frame called RETURN (e.g. a LAMBDA does not).  And a non-FUNC ACTION! could have something in its frame called RETURN that wasn't used for anything pertaining to the return process.</p>
<p>This ruled it out from being a mechanic relied on by the multi-return machinery.  Because we want the following to work:</p>
<pre><code>&gt;&gt; test: lambda [x] [x + 20]

&gt;&gt; [y]: test 1000
== 1020

&gt;&gt; y
== 1020
</code></pre>
<h2>Nevertheless, People Can Implement It If They Want</h2>
<p>It's certainly something you could <em>choose</em> to do if you were writing your own function generator.</p>
<p>In fact, it's trivial to write a wrapper for it!  Just add a /RETURN to the public interface, and write back to it if it's supplied:</p>
<pre><code>returnproxy: lambda [action [action!]] [
    enclose (augment :action [/return [word!]]) f -&gt; [
        (maybe f.return): do f
    ]
]
</code></pre>
<p>That means you can pass it as a refinement:</p>
<pre><code>&gt;&gt; test: lambda [x] [x + 1000]

&gt;&gt; wrapper: returnproxy :test

&gt;&gt; wrapper/return 20 'y
== 1020

&gt;&gt; y
== 1020
</code></pre>
<p>Or you can use it with a frame:</p>
<pre><code>&gt;&gt; f: make frame! :wrapper
&gt;&gt; f.x: 20
&gt;&gt; f.return: 'out

&gt;&gt; do f
== 1020

&gt;&gt; out
== 1020
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/nut_and_bolt.png?v=9" title=":nut_and_bolt:" class="emoji only-emoji" alt=":nut_and_bolt:"></p>
<p><em>(Seeing superpowers like this work so clearly and obviously is what keeps me invested in this.)</em></p>
<h2>So Anyone CAN Do It, But Should FUNC/FUNCTION Do It?</h2>
<p>I lean toward not doing it with things implemented the way they are right now, because it would add overhead to every function with a RETURN:, due to needing to have a place to store the variable if you gave it one.</p>
<p>But it might be nice to give people an optimized version of the proxying wrapper above.  You could then convert any function to support it.</p>
<h2>But today RETURN is on the public interface of FUNC <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">
</h2>
<pre><code>&gt;&gt; f: make frame! func [x] [return x + 1000]
== make frame! [
    return: ~
    x: ~
]
</code></pre>
<p><em>"Errr.  Why's it there?"</em>, you might ask.</p>
<p>The reason is that the return typeset information currently lives on that field.  So if you're going to ask about it, you get it from there.</p>
<p><strong>This is one of many good arguments for why this information should <em>not</em> live there.</strong></p>
<p>There's a long running body of evidence suggesting that the way return types are managed today is probably wrong.</p>
<ul>
<li>
<p><strong>LAMBDA Can't Currently Document Its Result Types</strong>.  There are a lot of actions out there that don't have a RETURN function, but nevertheless have something to say about what types they can produce.</p>
</li>
<li>
<p><strong>ENCLOSE Can't Change The Type Signature</strong>.  If you wrap a function, you're subject to its type checking rules.</p>
</li>
<li>
<p><strong>NATIVE Doesn't Want To Pay For A RETURN Slot</strong>.  The typechecking is only done in the debug build, so why should every native frame require a RETURN function?</p>
</li>
</ul>
<p>I think I've got some ideas coming together--mostly centering on factoring out typechecking to be another one of the little pieces you can build functions out of (like AUGMENT).  So when doing a composition you would just bolt on a typechecker if you wanted one.  Internal efficiencies could fold that in so it actually didn't generate a separate phase and action identity.  Pursing some inspiration on that as we speak...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929</link>
          <pubDate>Sat, 20 Aug 2022 05:32:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1929</guid>
          <source url="https://forum.rebol.info/t/should-return-be-assignable-on-function-interfaces/1929.rss">Should RETURN be Assignable on Function Interfaces?</source>
        </item>
        <item>
          <title>Waforth: WebAssembly Forth</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>There may be some relevant or interesting things to learn by looking at this:</p>
<aside class="onebox allowlistedgeneric">
  <header class="source">
      <img src="https://el-tramo.be/favicon-32x32.png?v=1560365977" class="site-icon" width="32" height="32">
      <a href="https://el-tramo.be/blog/waforth/" target="_blank" rel="noopener" title="12:00AM - 24 May 2018">el-tramo.be – 24 May 18</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:690/271;"><img src="https://el-tramo.be/blog/waforth/header@2x.png" class="thumbnail" width="690" height="271"></div>

<h3><a href="https://el-tramo.be/blog/waforth/" target="_blank" rel="noopener">A Dynamic Forth Compiler for WebAssembly</a></h3>

<p>In yet another ‘probably-useless-but-interesting’ hobby project, I wrote a Forth compiler and interpreter targeting WebAssembly. It’s written entirely in WebAssembly, and comes with a compiler that dynamically emits WebAssembly code on the fly. The...</p>


  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>I've wanted to do some kind of dynamic Wasm generation--even very simple--so we can have something like the experience of the TCC natives, but on the web.  So seeing what they have to go through is probably informative.</p>
<p>Here are the design notes:</p>
<p><a href="https://github.com/remko/waforth/blob/master/doc/Design.md">https://github.com/remko/waforth/blob/master/doc/Design.md</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/waforth-webassembly-forth/1927">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/waforth-webassembly-forth/1927</link>
          <pubDate>Fri, 19 Aug 2022 15:22:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1927</guid>
          <source url="https://forum.rebol.info/t/waforth-webassembly-forth/1927.rss">Waforth: WebAssembly Forth</source>
        </item>
        <item>
          <title>TRY PARSE + PARSE EXCEPT : *FAIL* On Mismatch</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>There's a snazzy new potential for giving more informative messages / logs from failed parses... which means we now have a more interesting option than we might have had before.</p>
<p>Imagine something like:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" some "b"]
** Error: SOME requires at least one match
** Where: [some "a" \\ some "b" \\]
; Note: this failure can be intercepted by TRY, EXCEPT, ATTEMPT
</code></pre>
<p>It can't be perfect unless it maintains some kind of large error tree that accumulates the list of all the reasons it decided to fail, so you might have to be in a debugging mode to ask it to give you a bigger diagnostic.  But we can build it now with the participation of the combinators themselves.</p>
<p><strong>But not only this, we could open up the full spectrum of return values.</strong>  Right now if your parse returns NULL, it has to be contorted into a null isotope to avoid accidentally cuing an ELSE.  Similar contortions for void, blank, and logic false.</p>
<pre><code>result: parse block rules except e -&gt; [print "Got an error", return]

; If you got here, you know result is good
; Even if it was a purposefully returned NULL, etc.
</code></pre>
<p>There'd be some way to rig this up without using enfix.  I might make things more lax about letting you assign error isotopes, because the isotope will bubble through and cause a problem anyway.  So you could write something like:</p>
<pre><code> if fail? result: parse block rules [
     print "You have a failure, use ^result to get it"
 ]
</code></pre>
<p>If you were willing to collapse failure down to a NULL or somesuch, or didn't even care about the result, you could just TRY it.</p>
<pre><code> try parse block rules
</code></pre>
<h2>Too Good Not To Be The Default</h2>
<p>Of course you'll be able to reskin it however you like for the R3C's or R3Chius out there.  But I think this looks like a perfect convergence to put in the box.</p>
<p>Errors aren't going to be that interesting on day one, but it's good to point the ship in the right direction.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924</link>
          <pubDate>Fri, 19 Aug 2022 06:23:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1924</guid>
          <source url="https://forum.rebol.info/t/try-parse-parse-except-fail-on-mismatch/1924.rss">TRY PARSE + PARSE EXCEPT : *FAIL* On Mismatch</source>
        </item>
        <item>
          <title>JUST For Sale - Low Mileage, Original Owner, Like New</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>As the /ONLY debacle was chipped away at... slowly... the role of quoting came to the forefront.  Quotes were used to <em>suppress</em> splicing (in contrast with today's isotopic blocks through SPREAD, which <em>request</em> the splicing).</p>
<p>So the anti-spread behavior looked something like:</p>
<pre><code>&gt;&gt; append [a b c] first [[d e]]
== [a b c d e]

&gt;&gt; append [a b c] first ['[d e]]
== [a b c [d e]]
</code></pre>
<p>I'm picking out of an outer block there just to avoid confusion, because notice what happens when there's no container:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] '[d e]
== [a b c d e]
</code></pre>
<p>By design, the evaluator strips off quotes, leading to potential confusion when it comes to what people might think they could do with such a system.</p>
<p>You might think that this is all fine and you could just call the function QUOTE instead of putting a quote mark on the value.  Hence the quoted block is an evaluation <em>product</em> not an evaluation <em>input</em>...and so it makes it to the append:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c d e]

&gt;&gt; append [a b c] quote [d e]
== [a b c [d e]]
</code></pre>
<p>But there were protections that were added to try and discern if you were adding non-inert values without quoting them.</p>
<pre><code>&gt;&gt; append [a b c] "this was presumed okay since it was inert"
== [a b c "this was presumed okay since it was inert"]

&gt;&gt; append [a b c] 'd
** Error: d is a WORD! and evaluative...your callsite might accidentally lose an
    apostrophe if you didn't know what you were doing.  Quote it to be safe.
</code></pre>
<p><em>(Note: I always disliked how these errors were working, I just hadn't gotten to the isotope design yet.  They did afford some protection.)</em></p>
<p>This would lead you to a couple of bad options to work with the case when you had something evalutative at source level:</p>
<pre><code>&gt;&gt; append [a b c] quote 'd
== [a b c d]

&gt;&gt; append [a b c] ''d
== [a b c d]
</code></pre>
<p>In an attempt to make the "just add a thing at source level" case a slight bit easier, I made JUST.</p>
<pre><code>&gt;&gt; just d
== 'd

&gt;&gt; append [a b c] just d
== [a b c d]
</code></pre>
<h3>Let's Take A Moment To Be Thankful For Isotopes...</h3>
<p>All of this is behind us now.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/pray.png?v=9" title=":pray:" class="emoji only-emoji" alt=":pray:"></p>
<p>But of course, the mechanics are actually nearly identical.  Just subtract 1 from all the quoting levels, and allow -1 for BLOCK!s.  <em>(Then build upon years of diligence in bulletproofing the system from leaking -1 quotelevels where they shouldn't be.)</em></p>
<h2>But JUST is Free Again.  Now What?</h2>
<p>There was a time when JUST was what I now call THE.</p>
<pre><code>&gt;&gt; just x
== x

&gt;&gt; just ''[foo]
== ''[foo]
</code></pre>
<p>I thought it was a good word for it at the time.  But THE won me over:</p>
<pre><code>&gt;&gt; the x
== x

&gt;&gt; the ''[foo]
== ''[foo]
</code></pre>
<h3>Maybe Something That Limits to One Expression Only?</h3>
<pre><code>&gt;&gt; just add 1 2
== 3

&gt;&gt; just add 1 2 10
** FAIL: JUST code had residual material: 10
</code></pre>
<p>I've been wanting a syntax for this at the API level, when you think you're running one expression:</p>
<pre><code>REBVAL* sum = rebJust("add", value1, value2, "10");
</code></pre>
<p>In that world, it's not any more typing (actually less typing than rebValue)...but gives you an extra bit of safety.</p>
<p>With regular (non-API) code, I can see it being very useful in generated code scenarios.</p>
<h3>Perhaps A THE-like Operator With A Shade of Meaning In PARSE?</h3>
<p>PARSE needs to keep raw material sometimes, and I've pointed out some of the hazards in the past of making you do this with GROUP!s when nested compositions are involved.</p>
<p>So might these be different?  As an example:</p>
<pre><code>parse ... [x: the ''foo] =&gt; parse ... [x: (the ''foo)]

parse ... [x: just ''foo] =&gt; parse ... [x: '''foo]
</code></pre>
<p>So above, THE is synthesizing ''foo out of whole cloth with no need to match it in the input.  The other would require a ''foo in the input to be considered a match.</p>
<p>For WORD!s, the above sense of JUST isn't as necessary, as there's a decent visual trick:</p>
<pre><code>parse ... [x: just ''foo] =&gt; parse ... [x: '|''foo|]
</code></pre>
<p>But other datatypes would not have this out, and you'd always be reading the thing you see in the rule as having one more quote level than what you're matching.</p>
<p>There's the option of putting it in an @ group:</p>
<pre><code>parse ... [x: just ''foo] =&gt; parse ... [x: @(the ''foo)]
</code></pre>
<p>But this has the problems I mention about nested composition that can be a major hassle when writing rule genreators and you have to weasel something like <strong><code>''foo</code></strong> inside a group inside a composed block.</p>
<p>This definition might jibe with keeping the regular evaluator meaning of JUST as it is (literal but add a quoting level).</p>
<h3>Other Ideas?</h3>
<p>Hopefully no one wants to fight to swap JUST with THE, because I really like THE as it is.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923</link>
          <pubDate>Fri, 19 Aug 2022 03:09:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1923</guid>
          <source url="https://forum.rebol.info/t/just-for-sale-low-mileage-original-owner-like-new/1923.rss">JUST For Sale - Low Mileage, Original Owner, Like New</source>
        </item>
        <item>
          <title>The FAIL That Wins Big: Combinator Definitional Errors</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <h2>Announcing Another Major Step Forward...</h2>
<p>As the wheels of thought began to churn around TRY, it came to seem clear that it had a higher purpose in defusing definitional errors.</p>
<p>This led to a thought about how if UPARSE were to allow calling arbitrary decoders (like DEBIN) that would deliver informative errors when the input wasn't a fit...that those errors would need to be interpreted as "soft" parse match failures...moving on to the next alternate.</p>
<p>That called back to another musing about why we don't use the readable word TRY instead of OPT in PARSE when we want to say a component of a parse is optional.</p>
<p>But so long as the combinator-skinned-decoders are communicating in errors, <strong>why not make combinators always indicate failure with definitional errors?</strong></p>
<ul>
<li>
<p>This would free up NULL as a synthesized product to just be an ordinary result, which had been a sticking point trying to wrangle the dual needs of isotopic nulls in a fully generic dialect.</p>
</li>
<li>
<p>The parsers would be able to generate diverse and informative errors, that in debug modes could be tagged with where they came from.  Parsers could distinguish between tunneling an error generated by another parser and emitting their own...providing more information for tracing tools.</p>
</li>
</ul>
<p><strong>It only took a couple of days to do...</strong> most of which was just sorting out a lot of edge cases from being a very thorough client of the relatively untested definitional error infrastructure.</p>
<p>But expect good things from this!</p>
<h2>A Bit Of History: How The Previous Model Came To Be</h2>
<p>When UPARSE was first conceived <em>(a mere year and a half ago)</em>, the combinators were responsible for returning three things:</p>
<ul>
<li>
<p>Whether the parser succeeded or not</p>
</li>
<li>
<p>A synthesized value</p>
</li>
<li>
<p>How much of the input was consumed (represented by a series position of the new "current" parse position, which could potentially be at the tail)</p>
</li>
</ul>
<p><em>(COLLECT and friends necessitated some more nuances, but you only have to worry about it manually if you need fine-grained control.  So most combinators look like these are the only results in play, with the other outputs being "autopiped" around by the machinery.)</em></p>
<p>The second two results would only be applicable if the parser succeeded.  So rather than return three results, it aimed to return just two... and fold together the success with some invalid state for the other result.</p>
<p>At first this seemed like it would be best to fold with the series position.  This would mean that the position could be either a series value or NULL.  That way, NULL could be a valid synthesized product.  This came in handy for things like OPT:</p>
<pre><code>&gt;&gt; x: y: &lt;before&gt;

&gt;&gt; did parse [1020] [x: integer! y: opt integer!]
== #[true]  ; parse succeeded

&gt;&gt; x
== 1020

&gt;&gt; y
; null
</code></pre>
<p>The first draft used the fledgling multi-return facility to do this, and it had the nice property of working with ELSE.  So when a combinator called a parser that failed, it was easy to handle that failure, e.g. to propagate that failure along:</p>
<pre><code>[pos synthesized]: parser input else [return null]
</code></pre>
<h2>But This Was Reversed... For... Reasons</h2>
<p>A mechanical issue came up that VOID could only be represented by the primary return result of a function.  If a multi-return argument was going to be returned and convey voids, it would have to use the ^META protocol... and the caller would have to be explicitly aware that the result they got would be pre-quoted by convention.</p>
<p>But I also noticed that some combinators didn't want to advance the input at all, only operate to transform one synthesized product into another.  Or that they didn't really need to plug into the overall parse architecture.  It seemed like making combinators match as closely to a "normal" function--by putting their synthesized result as the primary result--just made sense.</p>
<p>NULL isotopes were just coming on the scene, which gave a potential way to get out of this: a successful parser which wanted to return NULL would return the isotope form.  Pure NULL would be reserved as the signal for isotopic failure.  This meant the reversed parameters would be able to work:</p>
<pre><code>[synthesized pos]: parser input else [return null]
</code></pre>
<p>Internally, to OPT something like <strong><code>y: opt integer!</code></strong> would not return NULL, but a ~null~ isotope.</p>
<h2>But Now, It's Done With Definitional Errors!</h2>
<pre><code>[synthesized pos]: parser input except e -&gt; [return raise e]
</code></pre>
<p>Here you see the error being intercepted, and then passed on.  NULL is free to be dealt with as a normal product without interference.  And there's a difference between generating a new error (tagging it with the location in the parse rules and the context) vs. just passing on one that was generated by a subparser--you are actually keeping a record of what happened, to show in logs or otherwise.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922</link>
          <pubDate>Fri, 19 Aug 2022 02:27:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1922</guid>
          <source url="https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922.rss">The FAIL That Wins Big: Combinator Definitional Errors</source>
        </item>
        <item>
          <title>The ^META of NULL and VOID</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1915">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915/1">Q: Should ~ Be The Unevaluated Form of VOID ?</a>
</div>
<blockquote>
<p>That doesn't resolve saying what the ^META of an actual void state is. Of course it could just be some weird non-sequitur thing, like <strong><code>@void</code></strong> (that's what it currently is, not to be confused with the new <code>~@void~</code> which would be the meta of an inert word isotope)</p>
<p>One possibility that crossed my mind is that it could actually be an isotopic state, e.g. producing actual unset variables:</p>
<pre><code>&gt;&gt; ^(comment "hi")
== ~  ; isotope
</code></pre>
<p>This runs counter to the idea that ^META values are always non-ornery--to make them easy to pipe around.</p>
</blockquote>
</aside>
<p>I tried this out, and... <em>it was a terrible idea</em>.  I knew that would be bad, but it was worse than I thought.  It wrecks the whole thing.</p>
<h1>But there's a much better option!</h1>
<p>I've been creeping toward convergence of the "quoting ladder" and the "meta ladder".</p>
<p><strong>I now believe we should go whole hog with it, and say that the ^META of a NULL is the same answer as QUOTE NULL:</strong></p>
<pre><code>&gt;&gt; ^(null)
== '

&gt;&gt; meta null
== '

&gt;&gt; '
; null
</code></pre>
<p><strong>But even further, I believe the ^META of VOID should be a Quasi-NULL</strong></p>
<pre><code>&gt;&gt; quasi null
== ~

&gt;&gt; meta void
== ~

&gt;&gt; ~
; void

&gt;&gt; unquasi '~
; null
</code></pre>
<p><strong>When you look at this in the overall pattern it means...</strong></p>
<h1>...VOID is the isotope form of NULL!!!</h1>
<p>It's like everything inching up the reification scale by one notch.  <strong>And it's much better.</strong>  The way things cohere is instantly apparent.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/person_climbing.png?v=9" title=":person_climbing:" class="emoji only-emoji" alt=":person_climbing:"></p>
<h2>Why Was ^META of NULL Defined As NULL To Begin With?</h2>
<p>I thought that since NULL was being used as the signal of "soft failure" and ELSE was reacting to it, that it would be nice if you could react to it even if a value had been ^META'd.</p>
<p>UPARSE made use of this, e.g.</p>
<pre><code>([^synthesized remainder]: parser input) then [
    ; do stuff with synthesized' and remainder on parser success
] else [
    ; do stuff on failure, usually propagating the failure
    return null
]
</code></pre>
<p>The majority of the time, this pattern could have been done differently, simply by letting the ELSE branch run in the same operation as the parser, before the result is ^META'd:</p>
<pre><code>[^synthesized remainder]: parser input else [
    ; do stuff on failure, usually propagating the failure
    return null
]

; do stuff with synthesized' and remainder on parser success
</code></pre>
<p><em>But excitingly, this is changing so that NULL isn't the cue at all.</em>  Instead, definitional errors are being used...which can convey more information about why the parser failed and help diagnose the moments and contexts of failure!</p>
<pre><code>[^synthesized remainder]: parser input except e -&gt; [
    ; do stuff on failure, usually propagating the failure
    return raise e
]

; do stuff with synthesized' and remainder on parser success
</code></pre>
<p>With the synthesized NULL state recaptured, there's suddenly high value in having the null states quoted.  They're properly in the same family as all the other results.</p>
<p><em>This may seem like esoteric stuff but I can assure you it's incredibly foundational, and getting it right has extremely pleasing consequences!</em></p>
<h2>There's Still The Quandary of FOR-BOTH</h2>
<p>I've cited it a million times by now, but this means the resolution is that it will have to use some other operation besides meta and unmeta, which pass through void and null (if it's going to try the ALL trick):</p>
<pre><code>for-both: lambda ['var blk1 blk2 body] [
    unmeta* all [
        meta* for-each (var) blk1 body
        meta* for-each (var) blk2 body
    ]
]
</code></pre>
<p>Plain META of VOID would make ~, which is truthy and would corrupt any prior result.</p>
<p>Plain META of NULL would make a quoted null, which is truthy, and wouldn't break the ALL as desired.</p>
<p>At this point what it comes down to is we have a naming problem for whatever the versions that pass through void and null should be called.  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:">   I'll keep pondering it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-meta-of-null-and-void/1941">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-meta-of-null-and-void/1941</link>
          <pubDate>Thu, 18 Aug 2022 15:23:53 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1941</guid>
          <source url="https://forum.rebol.info/t/the-meta-of-null-and-void/1941.rss">The ^META of NULL and VOID</source>
        </item>
        <item>
          <title>Wish: Multi-Returns For UPARSE Combinators</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>Every combinator has a synthesized value.  But some combinators throw away values synthesized by their parser parameters.</p>
<p>For instance, TALLY.</p>
<pre><code>&gt;&gt; parse [1020 304] [int: some integer!]
== 304

&gt;&gt; parse [1020 304] [count: tally some integer!]
== 2
</code></pre>
<p>TALLY knows what the result of the last call it made was, but doesn't preserve it.  What if you could?</p>
<pre><code>&gt;&gt; parse [1020 304] [[count int]: tally some integer!]
== 2

&gt;&gt; count
== 2

&gt;&gt; int
== 304
</code></pre>
<p>That particular one is not necessarily a very interesting example, since you could get it yourself...</p>
<pre><code>parse [1020 304] [count: tally int: some integer!]
</code></pre>
<p>I only mention it because it was in a comment in UPARSE I wanted to delete, because it's a long enough file without becoming a wishlist compilation.  :-/</p>
<p>But there are certainly going to be other examples of combinators that might want to synthesize more than one value.  So hopefully the feature can be implemented at some point...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920</link>
          <pubDate>Wed, 17 Aug 2022 14:43:49 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1920</guid>
          <source url="https://forum.rebol.info/t/wish-multi-returns-for-uparse-combinators/1920.rss">Wish: Multi-Returns For UPARSE Combinators</source>
        </item>
        <item>
          <title>Should SET-WORD! Disallow Isotopic Assignments?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>Historically, Rebol2 and R3-Alpha wouldn't let you assign UNSET! via a SET-WORD!, regardless of whether it was provided literally or through an evaluation.  You had to use SET/ANY:</p>
<pre><code>rebol2&gt;&gt; x: #[unset!]
** Script error: x: needs a value

rebol2&gt;&gt; x: print "hi"
hi
** Script error: x: needs a value

rebol2&gt;&gt; set/any 'x #[unset!]

rebol2&gt;&gt; x
** Script Error: x has no value
</code></pre>
<p>At first, I thought Red made a concession in the direct assignment case:</p>
<pre><code>red&gt;&gt; x: #[unset!]
== unset!

red&gt;&gt; x: print "hi"
hi
*** Script Error: x: needs a value
</code></pre>
<p>However, that's not what's happening...it's an incompatible interpretation...where Red considers #[unset!] to be the datatype for unset!, and #[unset] (no exclamation point, illegal in Rebol2) is an actual unset value:</p>
<pre><code>red&gt;&gt; type? #[unset!]
== datatype!

red&gt;&gt; type? #[unset]
== unset!

red&gt;&gt; x: #[unset]
*** Script Error: x: needs a value
</code></pre>
<p><strong>But I bring it up because at one point in time, Ren-C actually had a specific behavior that it would only allow a SET-WORD! to assign an unset to a variable if it was <em>not</em> the product of a function call.</strong>  Today this would look something like:</p>
<pre><code>&gt;&gt; x: ~

&gt;&gt; x: print "hi"
** Error: Cannot assign evaluative isotopes to X

&gt;&gt; set/any 'x ~

&gt;&gt; x
** Error: X is ~ isotope (e.g. isotopic BLANK!, represents an unset state)
</code></pre>
<p><strong>I've wondered if this rule strikes the right balance.</strong>  If you really want to deal with isotopic values that are the result of an evaluation, you would use ^META, and get the non-isotopic (QUASI!) form.  There'd be several ways of saying it:</p>
<pre><code>&gt;&gt; x: ^ print "hi"
== ~

&gt;&gt; x: ^(print "hi")
== ~

&gt;&gt; x: meta print "hi"
== ~

&gt;&gt; [^x]: print "hi"
== ~
</code></pre>
<p>This makes much more sense now than when NULL and "unset" were the same state.  And it would help keep isotopes under control.</p>
<h2>Implications for the "Only Isotopic ACTION! Runs" Idea</h2>
<p>This would mess with my current experimental branch where <a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">isotopic actions stored in variables are the WORD!-triggered kind</a> (while regular actions would be inert).</p>
<p>It has FUNC returning isotopic actions, and you'd get an error:</p>
<pre><code>&gt;&gt; foo: func [/refine] [...]
** Error: Cannot assign isotope to FOO with SET-WORD! (see SET/ANY)
</code></pre>
<p>Making an exception for action isotopes, and saying they could be assigned without an annotation really feels like it undermines the entire proposal and the safety you'd get from it.</p>
<p>I will note that I really did get a warm fuzzy feeling when the generators produced plain ACTION!, and something had to tip it into being isotopic.  But I had to pan <strong><code>/foo: func [... /refine] [...]</code></strong> in no small part due to leading-slash being "taken" by refinements in function spec and apply.</p>
<p>This made me take a more serious look at the concept of retaking something like <strong><code>-&gt;</code></strong>.  Under the new rules that wouldn't have to finesse the assignment as well:</p>
<pre><code>foo: -&gt; func [/refine] [...]

foo: runs func [/refine] [...]  ; for those who dislike symbols
</code></pre>
<p>So either of these would act like <strong><code>set/any 'foo isotopic func [/refine] [...]</code></strong>.</p>
<p>Wait... <em>UNLESS...</em> <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji" alt=":thinking:"></p>
<p>I just had a rather compelling thought, that such a tool could <em>only accept isotopic ACTION!</em>, and that this would provide natural guidance not to screw it up... because a plain assignment would error:</p>
<pre><code>&gt;&gt; foo: func [/refine] [...]
** Error: Can't assign isotope ACTION! via SET-WORD!, use -&gt; or INERT
</code></pre>
<p><em>So if all the function generators were committed to returning isotopes, it would be self-correcting.</em>  You wouldn't be able to forget to triage the assignment.</p>
<pre><code>&gt;&gt; foo: inert func [x] [print ["x is" x]]
== #[action! [x]]

&gt;&gt; foo
== #[action! [x]]

&gt;&gt; foo: -&gt; func [x] [print ["x is" x]]
== ~#[action! [x]]~  ; isotope

&gt;&gt; foo 10
x is 10
</code></pre>
<p>Now THAT is clever.  You're forced into triage, and can't forget to do one or the other!  Forgetting the annotation was one of the big Achilles heels of making generator products inert by default (hard to find bugs) but this ties that up.</p>
<p>Very promising premise!  But there are tricky issues, like how today's METHOD needs to look back to quote what it's being assigned to, in order to know how to bind the value.  Maybe it wouldn't need to... if <strong><code>-&gt;</code></strong> also made that binding connection...and maybe there'd be no such thing as METHOD.  <img src="https://forum.rebol.info/images/emoji/twitter/exploding_head.png?v=9" title=":exploding_head:" class="emoji" alt=":exploding_head:"></p>
<h2>Related Question: What About VOID ?</h2>
<p>A corollary to this question is <strong>"Should SET-WORD! Stop Treating VOID Assignments as Unsetting Variables"</strong></p>
<p>It might seem obvious to say "yes, that should be an error too".  In fact...since I've vetoed the idea of variables actually being able to hold "voidness" it might seem like an <em>even worse sin</em> that should be prohibited... because you're not actually preserving the "integrity" of the assignment.</p>
<p><em>BUT</em>... when I tried to rule it out I noticed that it was used in frames for things like setting refinements, like:</p>
<pre><code>&gt;&gt; series [a b c]
&gt;&gt; value: 3

&gt;&gt; f: make frame! :append
&gt;&gt; f.series: series
&gt;&gt; f.value: value
&gt;&gt; f.dup: if integer? value [value]

&gt;&gt; do f
== [a b c 3 3 3]
</code></pre>
<p>But should the IF evaluate to void...the /DUP would not be set.  That not-set state was leading the default behavior for the refinement being not set (to coerce it to NULL in the call).</p>
<p>This is an interesting use case, and it arguably isn't "doing an isotopic assignment" (void is not an isotope, and it has no QUASI! form).  It's making a subtle judgment call, and it might be a good one.  I'll keep this as-is for now.</p>
<h2>Ultimate Goal: Freedom Of Choice  <img src="https://forum.rebol.info/images/emoji/twitter/statue_of_liberty.png?v=9" title=":statue_of_liberty:" class="emoji" alt=":statue_of_liberty:">
</h2>
<p>It's still definitely want to make it possible to override these behaviors if you find they get in your way.  Certainly we'd need it for Redbol...but it should work at other granularities.</p>
<p>Why shouldn't you be able to say <em>"hey, for just this function's body I want all the SET-WORD!s to assign isotopes without complaint"</em>?</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-disallow-isotopic-assignments/1919">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-disallow-isotopic-assignments/1919</link>
          <pubDate>Wed, 17 Aug 2022 08:32:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1919</guid>
          <source url="https://forum.rebol.info/t/should-set-word-disallow-isotopic-assignments/1919.rss">Should SET-WORD! Disallow Isotopic Assignments?</source>
        </item>
        <item>
          <title>A Justification of Generalized Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p><em>Here is a train of thought to help people realize why isotopes are needed, and why unifying their behaviors and mechanisms under a common umbrella makes sense.  It starts from the issue of solving /ONLY and then explains the generalization.</em></p>
<p><em>As time permits, I'll come back and try to improve this...</em></p>
<hr>
<p>Years of fretting over the /ONLY debacle converged on a somewhat inescapable conclusion:</p>
<p><em><strong>It's better to carry the intent of whether a value needs to be spliced on that value...as opposed to having subtle variants of core operations that modulate the splicing.</strong></em></p>
<p>I'd worked up to a point where I was implementing the "mark of intent" by adding a quoting level to <em>suppress</em> splicing.  Yet this faced likely accidents when someone had a quoted value in a variable...and really meant to use it somewhere as-is, with the quote--vs. thinking of the quote as a splice-suppression signal which the operation should remove.</p>
<p>Then <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">@rgchris made this remark</a>:</p>
<aside class="quote no-group quote-modified" data-username="rgchris" data-post="9" data-topic="1873" data-full="true">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"><a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">Putting Splicing Intent On APPEND'ed Value</a>
</div>
<blockquote>
<p>The issue I have with doing the opposite of ONLY—let's call it SPREAD—is what is the interim value?</p>
<pre><code>&gt;&gt; block: [a b c [a b c]]

&gt;&gt; find block pick block 4
[[a b c]]

&gt;&gt; find block spread pick block 4
[a b c [a b c]]

&gt;&gt; spread pick block 4
???
</code></pre>
<p>It would seem to have virtue over ONLY and is a better word.</p>
</blockquote>
</aside>
<h2>If Trying This In Historical Redbol, What Might One Do?</h2>
<p>As a rough first cut, let's represent splices with a specially recognizable 2-element wrapper block.  We'll signal it's a splice with a series in the first slot--checking for the unique identity of that series.  Then put the block itself as the second element:</p>
<pre><code>splice-cue: "!!!splice!!!"

spread: func [block [block!]] [
    return reduce [splice-cue block]
]

splice?: func [value] [
    if not block? :value [return false]
    return same? splice-cue first value
]
</code></pre>
<p>Then we can write our new versions of things like APPEND that are specifically aware of this construct.</p>
<pre><code>append*: func [series [series!] value] [
    return either splice? :value [
        append series second value
    ][
        append/only series :value
    ]
 ]
</code></pre>
<p>It works more or less in your average Redbol, e.g. in Red:</p>
<pre><code>red&gt;&gt; append* [a b c] spread [d e]
== [a b c d e]

red&gt;&gt; append* [a b c] [d e]
== [a b c [d e]]

red&gt;&gt; append* [a b c] 'd
== [a b c d]

red&gt;&gt; append* [a b c] first ['d]
== [a b c 'd]
</code></pre>
<p><em>In fact, this is essentially how the bootstrap executable for Ren-C simulates the SPREAD behavior.</em></p>
<p>But the weaknesses are <em>immediately</em> apparent!!!  <img src="https://forum.rebol.info/images/emoji/twitter/pouting_cat.png?v=9" title=":pouting_cat:" class="emoji" alt=":pouting_cat:"></p>
<h2>Not A Distinct Type: Too Easy To Overlook Handling</h2>
<p>There's no special type for the spliced block...it's just a BLOCK!.  This means any routine that hasn't been written to handle it, will just let it leak through.</p>
<pre><code>red&gt;&gt; reduce [spread [a b c] [a b c]]
== [["!!!splice!!!" [a b c]] [a b c]]  ; not [a b c [a b c]]
</code></pre>
<p>Changing to some other generic type that can contain a block...such as an OBJECT!...doesn't help matters.  You are kind of in trouble any time an operation willfully lets you put these into an array.</p>
<p><strong>The first instinct might be to introduce a new SPLICE! datatype, with a system-wide rule that splices can't be put into arrays.</strong>  <em>(Enforcing such a rule across all array-manipulating code is challenging...so let's sort of make a note of that fact, but continue.)</em></p>
<p>Because of the peculiar nature of not being able to be put in a block, there'd have to be a decision made about function arguments as to whether or not they took this type.  Many functions designed to handle generic values would not be able to handle them, so there'd presumably need to be some typeset like ANY-NOTSPLICE! or ANY-NORMAL!.</p>
<h2>How To Represent A Type That Can't Be Put In A Block?</h2>
<p>Now we've got several things to ponder about our new type.  For instance: what you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
<p>We just said that a defining feature of SPLICE! is that you can't accidentally put them in blocks.  But the argument to MAKE OBJECT!, namely <strong><code>[foo: ???]</code></strong>, is a block.  If <code>???</code> can't itself be a splice!, then what is it?</p>
<p>This brings up a possibly-related question: what if you want a way to put the intent of whether to splice or not into "suspended animation?"... in a way that you could collect it?</p>
<p>Here's a sort of contrived example of the puzzle:</p>
<pre><code>generate: func [n [integer!]] [
   if even? n [return reduce [n n + 1]]
   return spread reduce [n n + 1]
]

wrap: func [
    return: [...]
    in [splice! block!]
][
    ...
]

unwrap: func [
    return: [splice! block!]
    wrapped [...]
][
    ...
]

n: 0
pending: collect [while [n &lt; 4] [keep wrap generate n]]

data: copy []
for-each item pending [append data unwrap item]
</code></pre>
<p>How would you write WRAP and UNWRAP such that at the end of the code above, you'd get:</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
<p>If the system didn't provide some answer to this, you'd end up needing to re-invent something kind of equivalent to the primitive <code>["!!!splice!!!" [...]]</code> mechanic as a means of persistence:</p>
<pre><code>&gt;&gt; pending
== [[0 1] ["!!!splice!!!" [1 2]] [2 3] ["!!!splice!!!" [3 4]]]
</code></pre>
<h1>Isotopes Were Designed For This!</h1>
<p>Isotopes are a set of curated answers for these problems.  Originally they were introduced to address issues like what an UNSET! was...which has some of the same class of problems as SPLICE! (such as not wanting to be put in BLOCK!s, and not accepted by default or by most routines).</p>
<p>Isotopes are:</p>
<ul>
<li>
<p><strong>general</strong> - all base value types (e.g. unquoted things that can be put into blocks, so not NULL or VOID or QUOTED!) have isotopic forms</p>
</li>
<li>
<p><strong>efficient</strong> - isotopes do not require allocations, and merely are a different state of a byte in the value cell (the same byte that encodes quoting levels)</p>
</li>
<li>
<p><strong>"meta-representable"</strong> - all isotopes have a corresponding single-value form known as a "quasi-form", which when evaluated (or run through a more narrow UNQUASI operation) will yield the isotopic form</p>
</li>
</ul>
<p>I mentioned at the outset that it would be somewhat costly to bulletproof all of native code against the ability to do something like append a specific data type like "SPLICE!" to a block.  But with isotopes this problem has been solved once for all the forms...so the same code that prevents a so-called "UNSET!" from winding up in arrays works for splices.  <em>That's because a splice is actually an isotopic block!, and an unset is actually an isotopic blank!</em></p>
<p>Above I asked:</p>
<blockquote>
<p>What you should see here?</p>
<pre><code>&gt;&gt; obj: make object! [foo: spread [d e]]
== make object! [
    foo: ???
]
</code></pre>
</blockquote>
<p>Isotopes give us the answer, that it's <strong><code>foo: ~[d e]~</code></strong>.  This is the previously mentioned "QUASI!" form of BLOCK!, which when evaluated produces an isotope.</p>
<p><em>But isotopes themselves have no canon representation.</em>  The console can print out a comment or show them in a different color, but to talk about them having a representation doesn't make much sense as you'll never see them in source.</p>
<pre><code>&gt;&gt; ~[d e]~
== ~[d e]~  ; isotope
</code></pre>
<p>I also asked:</p>
<blockquote>
<p>"How would you write WRAP and UNWRAP such that at the end of the code above, you'd get:"</p>
<pre><code>&gt;&gt; data
== [[0 1] 1 2 [2 3] 3 4]
</code></pre>
</blockquote>
<p>With isotopic blocks representing splices, you don't need to write WRAP and UNWRAP... because these operations are built in operations called META and UNMETA.  And the pending array would look like:</p>
<pre><code>&gt;&gt; pending
== ['[0 1] ~[1 2]~ '[2 3] ~[3 4]~]
</code></pre>
<p>When the QUOTED! blocks are UNMETA'd, they become regular blocks and then are appended as-is.  When the QUASI! blocks are UNMETA'd they become isotopes and give the splice intent.  This produces the desired "suspended animation" to preserve the intent.</p>
<p><em>That suspended animation is also used in the ^META parameter convention, which indicates a function argument can accept isotopes... and the add-quoting-or-quasi behavior brings those isotopic variables into a reified state so they can be safely handled.</em></p>
<h2>The Proof Is In The Capabilities</h2>
<p>I've explained about splices, and mentioned how it crosses needs with unset variable states.</p>
<p>But isotopes are also a cornerstone of <a href="https://forum.rebol.info/t/default-values-and-make-frame/1412">how function and FRAME! specialization works</a>.</p>
<p>The ERROR! isotope is used to have a sneaky out-of-band way to return <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional errors</a></p>
<p>As their applications expand, they are slated to allow us to have non-literal modes to ask something like FIND that you want to look for <em>instances</em> of a datatype by passing that type isotopically... vs. looking for the datatype's appearance concretely in the target.  Concepts of making only isotopic ACTION!s run through WORD! references could make it completely safe to work with arguments passed as variables, saving you from needing GET-WORD!s to handle them.</p>
<p>It's natural for there to be some confusion with the new idea--especially given all its churn through the course of design.  But the design is becoming clearer, and I think people are going to find this gives solidity to writing complicated but coherent code...vastly outpacing historical Redbol.</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918</link>
          <pubDate>Tue, 16 Aug 2022 10:23:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1918</guid>
          <source url="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918.rss">A Justification of Generalized Isotopes</source>
        </item>
        <item>
          <title>Should REDUCE Heed SPREAD?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>When <a href="https://forum.rebol.info/t/putting-splicing-intent-on-appended-value/1873/9">suggesting the term SPREAD</a>, <a class="mention" href="/u/rgchris">@rgchris</a> gave this example for REDUCE behavior, which hadn't occurred to me previously:</p>
<pre><code>&gt;&gt; reduce [spread [a b c] [a b c]]
== [a b c [a b c]]
</code></pre>
<p>Nothing about the design makes this happen automatically.  REDUCE has historically errored on isotopes.  So code has to be added to override that.</p>
<p>I'm guessing most people would be in favor of having the splicing behavior.  Arguments that say that there should be a 1:1 correspondence between expressions and values in a REDUCE are already pretty much out the window, since VOID elements vanish (including conditionals that don't take any branch).</p>
<h2>DELIMIT Would Presumably Want It Too</h2>
<p>I've complained in the past that the often random-seeming treatments of blocks in Rebol2 functions like REJOIN lead to problems--and that it would be better if people had to be explicit about their intent.  This offers the ability to "inherit" whatever the enclosing delimiting strategy is, and fold into the existing operation (technically more efficient):</p>
<pre><code>&gt;&gt; block: ["c" "d"]

&gt;&gt; spaced ["a" "b" block]
** Error: BLOCK! not handled by DELIMIT, use SPREAD or desired string conversion

&gt;&gt; spaced ["a" "b" spread block]
== "a b c d"

&gt;&gt; spaced ["a" "b" unspaced block]  ; if you wanted another interpretation
== "a b cd"
</code></pre>
<p>I believe I prefer this over having some default way that blocks behave inside string conversions.  The odds of guessing right are low enough that it's better to have people be explicit.</p>
<p>So...presuming there's no objections....there's an agenda item to fuse together the stackless logic that performs a REDUCE so that it's the same code running in DELIMIT, so I'd probably go ahead and do that and make these things work.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-reduce-heed-spread/1917">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-reduce-heed-spread/1917</link>
          <pubDate>Tue, 16 Aug 2022 04:10:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1917</guid>
          <source url="https://forum.rebol.info/t/should-reduce-heed-spread/1917.rss">Should REDUCE Heed SPREAD?</source>
        </item>
        <item>
          <title>Asking Questions About &quot;Wrapped&quot; Things (QUOTED!, BAD!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>I've been held up on the new generalized isotopes due to looking at examples like this one:</p>
<pre><code>attempt: func [
    return: [&lt;opt&gt; any-value!]
    code [block!]
    &lt;local&gt; last'
][
    last': the ~
    reduce-each ^result' code [
        if error? result' [return null]
        if @void = result' [continue]
        last': result'
    ]
    return unmeta last'
]
</code></pre>
<p>Here you see ATTEMPT running a REDUCE-EACH, but asking for the ^META of each expression.  Asking for the result in meta form suppresses the automatic promotion of a definitional error (isotopic) to a generic failure.  (Re-read the <a href="https://forum.rebol.info/t/fail-vs-return-fail-the-new-age-of-definitional-failures/1852">definitional failure post</a> for a refresher.)</p>
<p>The meta of the isotopic error was received as a plain ERROR!.  And it handles it by returning null.  A void state is handled by continuing--leaving the cumulative result as-is.</p>
<p><em>(<a href="https://forum.rebol.info/t/q-should-be-the-meta-of-void-a-no/1915">I've explained why the meta state for void is weird.</a>  For the sake of argument, let's say it doesn't change under the new rules.)</em></p>
<h2>The BAD! Touch</h2>
<p>I've <a href="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/7">enumerated the reasons</a> why having isotopes generate a ^META which is actually a "BAD! ERROR!" has several advantages.  Wrapping up meta in BAD! makes it a better generalized inverse evaluator (UNEVAL) as well as making all the meta states truthy.</p>
<p><strong>But I'm displeased with the impact this has here.</strong></p>
<pre><code>    last': the ~
    reduce-each ^result' code [
        all [
            bad? result'
            error? unbad result'
        ] then [
            return null
        ]
        if @void = result' [continue]
        last': result'
    ]
    return unmeta last'
</code></pre>
<p>Obviously the naming is... bad.  But I don't like not being able to ask it in a single step, as I could before.  It makes it tempting to introduce constructs like BAD-ERROR?</p>
<pre><code>    last': the ~
    reduce-each ^result' code [
        if bad-error? result' [return null]
        if @void = result' [continue]
        last': result'
    ]
    return unmeta last'
</code></pre>
<h2>Can We Avoid Making BAD-XXX? or QUOTED-XXX? Tests</h2>
<p>One strategy could be if there was some kind of arity-2 BAD test, like:</p>
<pre><code>&gt;&gt; badly? integer! (first [~10~])
== #[true]
</code></pre>
<p>This would avoid having to fill the global namespace with a bunch of things like BAD-INTEGER?</p>
<p>You might get the idea that a TYPE OF could encode this, like:</p>
<pre><code>'~integer!~ = type of (first [~10~])
</code></pre>
<p>But that's not a BAD! DATATYPE! you're getting on the left.  It's a BAD! WORD!, and we don't have any kind of WORD!-to-DATATYPE! equivalence (there are reasons for this, beyond the scope of this thread).</p>
<p>Maybe there's a dialect of containment of some kind (?) like:</p>
<pre><code> match [bad!.integer!] (first [~10~])
</code></pre>
<p>Given some recent suggestions, it might be possible to say something like:</p>
<pre><code>if integer? try unbad (first [~10~])
</code></pre>
<p>The concept being that if it wasn't wrapped up like ~10~, then you'd get the original value out of the TRY instead of a type error.  But then this would be conflated if your original input had been an integer.  It would work for the error case since things that aren't bad are quoted, but it doesn't feel good.</p>
<h2>It Seems We Should Have a Way Of Asking This...</h2>
<p>I look at the ^META code where it doesn't have the bad wrapper on it, and I think "that's so much cleaner".  When you multiply it across all the other places that want to process meta arguments, it just feels wrong to throw in all the extra complexity.</p>
<p>Yet it feels like something of a failure that we don't have an easy way of asking if a value is a datatype wrapped in tildes or not.  It's a weakness that exists in our ability to ask questions about quoted types as well.</p>
<p>Ultimately, is it the best solution to backpedal on the QUOTE/META unification and accept different tracks?</p>
<ul>
<li>
<p><strong>META &amp; UNMETA</strong> - promotes isotopes to undecorated form, NULL &lt;=&gt; NULL, promotes non-isotopes to one level quoted higher than they were.  Because it can generate blanks and logic false, NULL is <strong>not</strong> the only falsey result you can receive from a META operation.</p>
</li>
<li>
<p><strong>QUOTE &amp; UNQUOTE</strong> - promotes isotopes to their ~bad~ value forms, NULL &lt;=&gt; single apostrophe ('), quotes everything else.  Acts as a proxy for "UNEVAL/EVAL" of single values.</p>
</li>
</ul>
<p>Then the question remains about what construct something like FOR-BOTH should use.  It wants to act like QUOTE and UNQUOTE except with NULL and VOID passthrough.</p>
<p>Under these rules, it's really a special "don't quote quite everything" version of QUOTE so maybe less is more, and just give it an asterisk... to say "quote but with some kind of twist".</p>
<pre><code>for-both: lambda ['var blk1 blk2 body] [
    unquote* all [
        quote* for-each (var) blk1 body
        quote* for-each (var) blk2 body
    ]
]
</code></pre>
<p>I can't think of what this could be as a refinement.  QUOTE/PASSTHRU-NULL-AND-VOID?  QUOTE/WITH-HOLES-IN-IT?  QUOTE/LEAKY?  QUOTE/USUALLY?</p>
<p>Not sure, but I really feel like these should be true by default:</p>
<pre><code>&gt;&gt; quote null
== '

&gt;&gt; quote void
** Error: VOID has no quoted form, use META (or QUOTE* if you want to passthru)
</code></pre>
<p>Anyway, this is just the same thing from a week ago running around, and I can't make progress until I pin it down!  I'll sleep on it a bit.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/asking-questions-about-wrapped-things-quoted-bad/1916">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/asking-questions-about-wrapped-things-quoted-bad/1916</link>
          <pubDate>Mon, 15 Aug 2022 18:22:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1916</guid>
          <source url="https://forum.rebol.info/t/asking-questions-about-wrapped-things-quoted-bad/1916.rss">Asking Questions About &quot;Wrapped&quot; Things (QUOTED!, BAD!)</source>
        </item>
        <item>
          <title>Q: Should ~ Be The Unevaluated Form of VOID ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p><em>Void is an elusive concept.  Reasoning about it is difficult.  But it's one of the things that makes the evaluator special, and there are tons of creative applications.  So it's worth the effort.</em></p>
<p>Tonight the thought crossed my mind (certainly not for the first time) that in the generalized isotope world, we might say that ~ is the isotopic form of void:</p>
<pre><code>&gt;&gt; ^(comment "Hi")
== ~

&gt;&gt; 1 + 2 ~
== 3

&gt;&gt; x: ~
; void

&gt;&gt; x
** Error: X is void (a.k.a. the variable is not set)

&gt;&gt; unset? 'x  ; asks "is the variable unset" (there is no UNSET!) type
== #[true]
</code></pre>
<p>This has the somewhat questionable property that the traditional GET/ANY of such a variable would be invisible rather than raise an alarm:</p>
<pre><code>&gt;&gt; var: ~
; void 

&gt;&gt; compose [&lt;a&gt; (get/any 'var) &lt;b&gt;]
== [&lt;a&gt; &lt;b&gt;]
</code></pre>
<p>This still makes me uneasy, because it doesn't feel "ornery" enough.  You have a variable that may have potentially never been set, and are being very quiet about its usage.  I'd prefer people purposefully store NULL in their variables, and then use MAYBE on the NULL to make a VOID.  That's cleaner and more intentional.</p>
<p>But Rebol2/Red/R3-Alpha would say this is not a problem, all of them give this answer:</p>
<pre><code>redbol&gt;&gt; unset 'var

redbol&gt;&gt; compose [&lt;a&gt; (get/any 'var) &lt;b&gt;]
== [&lt;a&gt; &lt;b&gt;]
</code></pre>
<p><em>(Of course, in their world, #[unset] could legally be put in blocks...so they're missing a possibility here.  Ren-C's situation isn't as bad, but still bothers me.)</em></p>
<p>Someone might say I'm being too uptight, and this is fine.</p>
<h2>But... There's Other Implications</h2>
<p>Consider another case:</p>
<pre><code>&gt;&gt; all [&lt;a&gt; &lt;b&gt; if false [&lt;c&gt;]]
== &lt;b&gt;  ; this is today's behavior with void IF FALSE, and considered correct

&gt;&gt; all [&lt;a&gt; &lt;b&gt; x: if false [&lt;c&gt;]]
== &lt;b&gt;  ; today this is different, X becomes unset ("none" isotope) and error

&gt;&gt; x
** Error: X is void (a.k.a. the variable is not set)
</code></pre>
<p>You might ask why the following should be an error, if it wouldn't be an error if the assignment is inside the ALL:</p>
<pre><code>&gt;&gt; x: if false [&lt;c&gt;]
&gt;&gt; all [&lt;a&gt; &lt;b&gt; x]
** Error: X is void (a.k.a. the variable is not set)
</code></pre>
<p>Also: the evaluator mechanics become more inefficient if you're expected to preserve invisibility across an assignment.  You'll kind of have to take my word on that, but it's happier if we don't do this:</p>
<pre><code>&gt;&gt; 1 + 2 [a b c]: call-void-multireturn arg1 arg2
== 3
</code></pre>
<p>This means that the cell holding the 3 is not available for scratch use by things like the SET-WORD! or multi-return.</p>
<p>But beyond the mechanics, something about the assignment makes me feel like there's kind of a "wall" there.  I don't know if my feeling is justified, but it does seem like it might be justified when I say you cannot assign voids to variables.</p>
<h2>You'll Still Need A "Nothing" Isotope</h2>
<p>When ~ was a "BAD-WORD! with no name", I called its isotopic form "none".  If ~ was the meta of void, there really isn't any such thing as a "~ isotope".  You can never make one, because it needs to vaporize.</p>
<p>So in the first cut of generic isotopes, I said ~ was the isotopic form of BLANK! (as opposed to ~_~, which looks pretty bad).  And it became the new none...since no more BAD-WORD! meant a BAD! WORD! had to follow all the rules of words (no null spellings).</p>
<p>You can re-read my <strong><a href="https://forum.rebol.info/t/why-isnt-print-invisible-void/1466/4">explanation of why void is a bad return value for things like PRINT or HELP.</a></strong>  If you want to communicate to the console that it not print anything, then you need to do that communication through some kind of non-void thing, otherwise that signal is too slippery.</p>
<p>So the "none" concept of a ~ isotope felt like a good pick.  It's the ornery contents of an unset variable, it has no string label or otherwise that's being suppressed when it's not shown...so it feels like a natural for the purpose.</p>
<h2>Could We Pick A New UNSET?</h2>
<p>If ~ were retaken for the specific purpose of representing a void isotope, we'd need some other answer for what an unset variable looked like.  I've mentioned that I'm pretty attached to <strong><code>~</code></strong> for how clean it looks, letting you see the things you've set and haven't:</p>
<pre><code>&gt;&gt; f: make frame! :append

&gt;&gt; f.dup: 2
&gt;&gt; f.value: "a string"

&gt;&gt; f
== make frame! [
    series: ~
    value: "a string"
    part: ~
    dup: 2
    line: ~
]
</code></pre>
<p>If ~ represented voids and we had to change these to a new representation for blank isotopes, that would look significantly crappier:</p>
<pre><code>&gt;&gt; f
== make frame! [
    series: ~_~
    value: "a string"
    part: ~_~
    dup: 2
    line: ~_~
]
</code></pre>
<p>We could go back to a full word:</p>
<pre><code>&gt;&gt; f
== make frame! [
    series: ~unset~
    value: "a string"
    part: ~unset~
    dup: 2
    line: ~unset~
]
</code></pre>
<p>But it's not just in these printouts, it's also in source.  Being able to simply type <strong><code>(x: ~)</code></strong> to unset a variable and have that be the right way to do it...in an object field or just in code, is just too good.</p>
<p>This makes me feel pretty attached to the idea that ~ is the contents of an unset variable, which is not displayed by the terminal, and which is ornery to things like ANY or ALL, and it's called "NONE".</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915</link>
          <pubDate>Mon, 15 Aug 2022 12:15:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1915</guid>
          <source url="https://forum.rebol.info/t/q-should-be-the-unevaluated-form-of-void/1915.rss">Q: Should ~ Be The Unevaluated Form of VOID ?</source>
        </item>
        <item>
          <title>Calling Combinators (Decoders?) as Normal Functions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>A few times I've talked about the potential of making it possible to call a COMBINATOR function from outside of PARSE.</p>
<p>This is to say that if some PARSE-specific parameter was missing (e.g. the "parse state") there'd be a mode in the guts of the COMBINATOR mechanic which cooked up something like a temporary parse session just for the input you passed in.</p>
<h2>Would It "Combinate" Parsers For You?</h2>
<p>The situations I had in mind weren't really combinators that take parsers as parameters.  And now that I look at it, I think that suggests that... no, you probably shouldn't call these kinds of combinators outside of parse.</p>
<p>Here's one imagination of calling a combinator like SOME:</p>
<pre><code>&gt;&gt; [value rest]: some "aaaabbb" [repeat 2 "a"]
== "a"

&gt;&gt; value
== "a"

&gt;&gt; rest
== "bbb"
</code></pre>
<p>This exposes how SOME is actually not arity-1.  Though it takes a "combinated parser" as a parameter, it also takes an INPUT...but that's usually implicit...specialized in by PARSE.  But calling directly from normal code it could offer that parameter being gathered normally.</p>
<p>it doesn't feel that compelling, since you're getting a synonym for:</p>
<pre><code>parse "aaaabbb" [some repeat 2 "a"]
</code></pre>
<p>But also, why would it take that interpretation instead of:</p>
<pre><code>parse "aaaabbb" [some ([repeat 2 "a"])]
</code></pre>
<p>One point of view would say it makes more sense to think of the expression as the product of evaluation, because the argument would presumably be otherwise evaluative:</p>
<pre><code>&gt;&gt; [value rest]: some "aaaabbb" append [repeat 2] "a"
== ??? ; infinite loop?
</code></pre>
<p>But this would make rule-taking combinators nearly useless.</p>
<h2>It Was Suggested For Sharing "Decoding", not "Combinating"</h2>
<p>Seeing how SOME isn't a good example for this, maybe the right way of saying what I'm trying to say here this is that there's some category of functions we might call "decoders"...and PARSE would be willing to call these.</p>
<p>They'd fit a standard format regarding things like taking an input series and giving back an amount of progress or an error.  But they would not be passed something like the parser stack or have any automatic composition of parsers as arguments.</p>
<p>Plain decoding operations--like <a href="https://forum.rebol.info/t/binary-dialected-encoding-decoding-instead-of-to-conversions/1270">ENBIN and DEBIN</a>--were the motivating cases:</p>
<pre><code>&gt;&gt; debin #{FEFFFF} [le + 3]
== 16777214

&gt;&gt; parse #{FEFFFFFEFFFF} [collect [keep debin [le + 3]]]
== [16777214 16777214]
</code></pre>
<p>The idea here was that you could write one version of DEBIN, and it would be able to implicitly pick up the INPUT when used in PARSE.</p>
<p>But because the input is an implicit parameter that you get automatically for all "decoders", then without extra information it would have to be at either the beginning or end of the parameter list.  Above it's at the beginning, which is different from how DEBIN was defined originally:</p>
<pre><code>&gt;&gt; debin [le + 3] #{FEFFFF}  ; original DEBIN design took dialect block first
== 16777214
</code></pre>
<p><em>(Note: I have a post about <a href="https://forum.rebol.info/t/parameter-order-in-rebol/1238">parameter ordering</a> which questions the series-first model.)</em></p>
<p>We could say that "decoders" have to manually mention their input parameter somewhere, and position it in the order that it would be consumed if it's used outside of PARSE...which would allow customization of this process.  It could default to being the first parameter if not positioned explicitly.  Not an idea-killer, in any case.</p>
<h2>If All The Input Wasn't Consumed, It Would Error</h2>
<p>One idea of calling these decoders on arbitrary input could be that if the end of input was not reached, it would give an error:</p>
<pre><code>&gt;&gt; debin [le + 3] #{FEFFFF00}  ; asking for 3 bytes of decode, passed 4
** Error: DEBIN did not consume all input, request remainder if intentional
</code></pre>
<p>Asking for a remainder could prevent the error:</p>
<pre><code>&gt;&gt; [value rest]: debin [le + 3] #{FEFFFF00}
== 16777214

&gt;&gt; rest
== #{00}
</code></pre>
<p>So this is kind of where the motivation is.  Once you've written the decoder version of DEBIN, you have everything you need to run a DEBIN operation inside or outside of PARSE.  So why should you need to write a separate combinator and non-combinator form?</p>
<h2>I Was Thinking About This Now Because of TRY</h2>
<p>I'm putting together some thoughts where if TRY is the way you say it's okay if a combinator doesn't succeed in PARSE, what would the behavior be outside of PARSE?</p>
<p>Up until now we've said that NULL is the reserved result for combinator failure.  But I've put forth the idea that NULL might be a legitimate combinator result, and so definitional errors could be used to say that an operation did not meet its requirements.</p>
<p>So now...how about these "decoders"?  Should a decoder run in isolation raise an error if it doesn't work, or should it just return NULL?</p>
<p><strong>It seems clear that at least <em>some</em> operations should raise errors instead of passively returning NULL.</strong>  If you ask to decode an invalid stream, it should be noisy about that failure.</p>
<p>I believe that some of these errors shouldn't be defused by TRY.  For instance, <strong>debin #{FEFFFF} [banana + 3]</strong>... that's an inability to understand what you're even asking.  To me this is on par with typos or passing invalid types; they are a sign of downright incorrect code, not the kind of thing that something like ATTEMPT should be able to ignore...much less should TRY quiet them.</p>
<h2>So...What Should Count As Things TRY Defuses?</h2>
<p>At first, the TRY error was specifically tied to the idea of a special error that happened when inputs were NULL.  This required special code in the FUNC typechecking, because by default a typechecking error does not produce a definitional error that can be trapped with something like EXCEPT.</p>
<p>Now I've expanded the idea that the word was short and useful enough that it might be used for any case where there were no adverse side effects, and a function wanted to say it simply couldn't do the thing it was asked to do.</p>
<p>Might we say that <em>all definitional errors</em> fit under this category?  That you shouldn't do <strong>return raise [...]</strong> unless the error can be swept under the rug by a TRY?  Does this suggest a "value surrogate" for TRY is a generic thing that any error can carry (if you TRY me, convert to this value).  Or is that just a characteristic of errors that TRY is willing to defuse?</p>
<p>As usual, more thought needed.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_head_bandage.png?v=9" title=":face_with_head_bandage:" class="emoji" alt=":face_with_head_bandage:"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914</link>
          <pubDate>Mon, 15 Aug 2022 07:39:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1914</guid>
          <source url="https://forum.rebol.info/t/calling-combinators-decoders-as-normal-functions/1914.rss">Calling Combinators (Decoders?) as Normal Functions</source>
        </item>
        <item>
          <title>Extending Contexts (OBJECT!, MODULE!, etc)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <p>In R3-Alpha, it is possible to append key/value pairs to objects via a block:</p>
<pre><code>&gt;&gt; obj: make object! [a: 10]
== make object! [
   a: 10
]

&gt;&gt; append obj [b: 20 c: 30]
== make object! [
    a: 10
    b: 20
    c: 30
]
</code></pre>
<p>You can't do that in Rebol2, and Red did not carry it forward.</p>
<p><strong>But in Ren-C, isotopes are not allowed in blocks.</strong>  It's more powerful if there is an operation which extends the object via a block which gets evaluated... much as the block in MAKE OBJECT! is evaluated.</p>
<p>As a general rule, APPEND should certainly not be REDUCE-ing block arguments.  So some other operation is needed</p>
<p>Red has an EXTEND operation, but it is "reserved for future use":</p>
<pre><code>USAGE:
     EXTEND obj spec

DESCRIPTION: 
     Extend an object or map value with list of key and value pairs. 
     EXTEND is a native! value.

ARGUMENTS:
     obj          [object! map!] 
     spec         [block! hash! map!] 

REFINEMENTS:
     /case        =&gt; Use case-sensitive comparison.
</code></pre>
<p>Given that it's not implemented, we don't know if that spec block is intended to be evaluated or not.  Also, we'd assume EXTEND would create a new object (since their objects don't expand).</p>
<p>Anyway, APPEND to an OBJECT! is something that probably doesn't make sense.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/extending-contexts-object-module-etc/1913">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/extending-contexts-object-module-etc/1913</link>
          <pubDate>Tue, 09 Aug 2022 22:00:37 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1913</guid>
          <source url="https://forum.rebol.info/t/extending-contexts-object-module-etc/1913.rss">Extending Contexts (OBJECT!, MODULE!, etc)</source>
        </item>
        <item>
          <title>Ideas About a More General Meaning for TRY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>TRY was changed from a "blank-in, null-out" meaning to use definitional errors.  This allowed NULL to be both the input and the output...without risking inadvertently trapping errors from arbitrary depths.  You'll really be intercepting the error emitted by the function just called:</p>
<pre><code>&gt;&gt; first null
** Error: FIRST on NULL requires use of TRY

&gt;&gt; try first null
; null
</code></pre>
<p>I mentioned something, which was that a "You need a TRY" ERROR! was actually able to carry a payload, saying what the TRY'd outcome value should be.  <em>(The only rule would be that a function emitting such an error should not have any side effects if it emits one of these errors.)</em></p>
<p>If we embrace this, it could really open the doors to what TRY means.  Various constructs could offer meanings for what the TRY actually does:</p>
<pre><code>&gt;&gt; unquote first ['abc]
== abc

&gt;&gt; unquote first [def]
** Error: Can't Unquote Plain WORD!, use TRY if Intentional

&gt;&gt; try unquote first [def]
== def
</code></pre>
<p>I'm sort of leaning to believing that this more general meaning of TRY may be much more interesting than the "null propagating" sense.  There's kind of an explosion of potential for the "couldn't do what you asked me to do, but if that's what you meant..." outcomes.</p>
<p>At one point I suggested it would be nice to be able to have a COLLECT that didn't actually KEEP anything return NULL, so it could be ELSE-reactive.  That meant if you really wanted an empty block, you'd have to do something like <strong><code>any [collect [...], copy []]</code></strong> which was ugly.  But the error could hold a freshly-copied block to be the result of a TRY:</p>
<pre><code>&gt;&gt; collect [keep if false [&lt;not kept&gt;]]
** Error: COLLECT didn't KEEP anything, use TRY if intended

&gt;&gt; try collect [keep if false [&lt;not kept&gt;]]
== []
</code></pre>
<p>There are various technical reasons why ELSE can't be reactive to TRY-style errors.  One fairly important one would be that if you used ELSE with a branching construct, it wouldn't be able to tell the difference between a branch that had a TRY-error and no branch taken:</p>
<pre><code>&gt;&gt; case [true [unquote first [def]]] else [print "Took branch, runs due to UNQUOTE"]
Took branch, runs due to UNQUOTE  ; this would be bad
</code></pre>
<p>But... maybe the trick could be that if you pass ELSE a function that takes an argument, it assumes that means you handle TRY-style errors?  (Because otherwise it could only be void/null... why take an arg?)</p>
<pre><code>&gt;&gt; (unquote first [def]) else arg -&gt; [print ["TRY error" arg]]
TRY error def
</code></pre>
<p>It's a weird thought.  Anyway, just wanted to write up the TRY concept...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912</link>
          <pubDate>Tue, 09 Aug 2022 13:28:03 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1912</guid>
          <source url="https://forum.rebol.info/t/ideas-about-a-more-general-meaning-for-try/1912.rss">Ideas About a More General Meaning for TRY</source>
        </item>
        <item>
          <title>&quot;I&#39;m not BAD!...I&#39;m just MOLD-ed that way...&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I'm tinkering with an implementation of <a href="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889/5">fully generic isotopes</a>.  The idea is that all types have an isotopic form, and routines can choose to react to this isotopic form giving it special meaning.</p>
<p>This means the tilde markings which used to designate a BAD-WORD! would be ways of making any value isotopic:</p>
<pre><code>&gt;&gt; ~foo~
== foo  ; isotope

&gt;&gt; ~[d e]~
== [d e]  ; isotope

&gt;&gt; ~1020~
== 1020  ; isotope

&gt;&gt; ~#[datatype word!]~
== #[datatype word!]  ; isotope
</code></pre>
<p>The notation is not an isotope itself, it's just used to produce them.  And if you're looking in an object and see it molds out fields that are these and non-quoted, that implies that the field itself actually holds an isotope.</p>
<pre><code>&gt;&gt; obj: make object! [x: spread [d e], y: ~[d e]~, z: '~[d e]~]
== make object! [
    x: ~[d e]~
    y: ~[d e]~
    z: '~[d e]~
]

&gt;&gt; obj.x
** Error: obj.x is a BLOCK! isotope, use ^META to access

&gt;&gt; obj.y
** Error: obj.y is a BLOCK! isotope, use ^META to access

&gt;&gt; obj.z
== ~[d e]~
</code></pre>
<p>So you can see how the notation works with the generic form, and can be quoted itself.</p>
<h2>I Kind Of Want To Curtail Use Of These In Source...</h2>
<p>The original thought about BAD-WORD! was that their ugly notation was supposed to be used to draw attention to them.  So like in the object molding above, you'd be able to see where the isotopes were and it would guide your eyes to the problem.</p>
<p><em>And in fact, I'm not even 100% sure that we want to support storing isotopes in variables unless we absolutely have to.</em>  Perhaps isotopic blocks would generate errors if you tried--and it would force you to use a ^META operation to persist it.  But a representation that evaluates to them is needed for mechanical reasons either way.</p>
<p>Nevertheless, you <em>could</em> use them to do things like splicing literal blocks:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]

&gt;&gt; append [a b c] ~[d e]~
== [a b c d e]
</code></pre>
<p>It would actually be an efficient way to do it, but I feel like it might numb people to the squiggles...which are intended to draw attention to cases where the isotopes leaked through an operation and shouldn't have.  So best practices would suggest using operators instead</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<h2>But The ~XXX~ Forms Need A Name... Is It BAD! ?</h2>
<p>I'd called ~xxx~ a BAD-WORD!.  Now that the tildes are a generic container kind of like QUOTED!, that would default to just being... BAD!</p>
<pre><code>&gt;&gt; type of fourth [a b c ~[d e]~]
== #[datatype! bad!]
</code></pre>
<p>So there's going to be a whole naming situation for operations to get the contained item out, and what to call this container.</p>
<p><em>(If it's so BAD, does it need to be... REFORMed?  <img src="https://forum.rebol.info/images/emoji/twitter/stuck_out_tongue.png?v=9" title=":stuck_out_tongue:" class="emoji" alt=":stuck_out_tongue:"> )</em></p>
<p>I don't know how to fit this into the isotope naming scheme...it's a thing that generates isotopes when it evaluates.  The analogy breaks down if you try to call it a NUCLEUS or something odd like that.</p>
<p>Calling the ~xxx~ forms BAD! does have the advantage of being able to combine that and say ~[d e]~ is a "bad block" and ~1020~ is a "bad integer", but... you'll see these in well-formed programs.  It makes it sound like something is <em>corrupt</em>, when the real intent is different.</p>
<p>It could be called QUASI! which could related it to QUOTED!.  <em>"~[d e]~ is a quasi-block"</em></p>
<p>Bear in mind they can be quoted, so <code>'~[d e]~</code> would then be a "quoted quasi-block".  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<p>In some sense, [d e] and ~[d e]~ and '[d e] and ''[d e] could all be thought of as "isotopes" of blocks...in addition to what we call the "isotope" form (which has no representation, because it's something you can only measure by turning it into another form).</p>
<p>So we might call ~[d e]~ a "block isotope", and then give some other name to the invisible status that it produces...?</p>
<pre><code>&gt;&gt; ~[d e]~  ; call this a block isotope?
== [d e]  ; then this could be... a... ghost block?
</code></pre>
<p>But overall my leaning is that I like calling the ephemeral form "isotope", because I think that captures its weird invisible/reactivity/decaying character.</p>
<h2>The Pejorative "BAD!" May Seem Harsh, But May Be Good?</h2>
<p>If the name can scare people out of trying to use these too much at source level, that's not the worst outcome.</p>
<p>But then there still have to be ways of getting the contents out.  QUOTED! has UNQUOTE and NOQUOTE to take off quoting layers, and QUOTE to add them on.</p>
<p>Right now I've got MAKE BAD! to produce them:</p>
<pre><code>&gt;&gt; make bad! 1020
== ~1020~

&gt;&gt; make bad! [d e]
== ~[d e]~
</code></pre>
<p>If we called them something like TOXIC! then there could be detox and toxify.  <img src="https://forum.rebol.info/images/emoji/twitter/radioactive.png?v=9" title=":radioactive:" class="emoji" alt=":radioactive:"></p>
<p><strong>There's plenty to be involved with working out the mechanics and not worrying about the names, but wanted to put the naming issue out to be mulled over.</strong></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911</link>
          <pubDate>Fri, 05 Aug 2022 09:33:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1911</guid>
          <source url="https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911.rss">&quot;I&#39;m not BAD!...I&#39;m just MOLD-ed that way...&quot;</source>
        </item>
        <item>
          <title>What&#39;s Cool (According to Danny)</title>
          <dc:creator><![CDATA[Danny]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Photos are nice. complex. but some how easy to understand most of the time without having to know the "who, what, when, where, and why." Just by looking at them, you can kinda tell what it's trying to show you. I want Rebol coding to look like that while working with any data context in its original form as possible.</p>
<blockquote>
<p>**<br>
var {whats-cool 0: Brett}<br>
Var Rebdol: {Rebdol cool: "what's-cool"}**</p>
</blockquote>
<p>The <a href="http://www.rebol.org/view-script.r?script=rebol-dom.r" rel="noopener nofollow ugc">%Rebol-dom.r</a> Var is named from the associated value strings/words, unless you *!, select-all-fetch-as strings/words. Then you can, Rebdol."cool" -&gt;select &amp; load "what's-cool". Wich is, whats-cool: { 0: Brett}. Then .[0], and  you get Brett.</p>
<p>Or change the *value to Ren-C. **</p>
<blockquote>
<p>whats-cool [ /rebdol.cool.&amp;.0 = Ren-C] <em>messy, noisy example</em><br>
**</p>
</blockquote>
<p>Is this musing when the origonal data context does'nt need to be changed. And if parsed into a Dialect Object Model, without changing syntax, this data can be searched, updated with DOM functions.</p>
<p>Creating Vars out of molded data/code with foreign syntax, is its own Sequence built notation.</p>
<blockquote>
<pre><code>struct: :Var

 struct qwerty {
                   Int #1
                   Char "hello"
                   Float 9.0
                   Char "there"
                } *! 'qwerty

*variable: "request" new[qwerty]
</code></pre>
</blockquote>
<p>This data looks like and can be used to construct *New nodes that can run as code without creating defined functions but remain as sequence(molded) data that needs no bindings or loading to take place.</p>
<p>I hope this is musing, for others as it is for me. Rebol-dom.r Sequence/molded data, strings as *keys have context all without loading anything but the *value. It's what i found and fished out of that Deep Lake.</p>
            <p><small>3 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/whats-cool-according-to-danny/1906">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/whats-cool-according-to-danny/1906</link>
          <pubDate>Fri, 29 Jul 2022 23:42:34 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1906</guid>
          <source url="https://forum.rebol.info/t/whats-cool-according-to-danny/1906.rss">What&#39;s Cool (According to Danny)</source>
        </item>
        <item>
          <title>Big Alien Proposal :flying_saucer: &quot;/REFINEMENTS&quot; Run Functions</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <blockquote>
<p><strong>UPDATE</strong>...This was tried out, and while interesting things were learned it ultimately didn't "feel right" <em>(in particular the competition of <code>/slash</code> for refinement and <code>/slash:</code> for function definition was more annoying than anticipated, and SET-PATH!s introduce a lot of complexity in places it wasn't needed.)</em>  See further down the thread.  It's informing new designs being tried out.</p>
</blockquote>
<hr>
<p>So far, <strong><code>/leading</code></strong> <strong><code>/slash</code></strong> <strong><code>/notation</code></strong> has just been evaluator inert, lining up with Rebol2 and Red and R3-Alpha:</p>
<pre><code>redbol&gt;&gt; /foo
== /foo
</code></pre>
<p>That inertness doesn't seem to get leveraged much.  And in Ren-C it's a particularly weak choice, since the evaluator has generic quoting to get you the literal result:</p>
<pre><code>ren-c&gt;&gt; '/foo
== /foo
</code></pre>
<p>Also, leading slash is an actual PATH!...encompassing arbitrary patterns like <strong><code>/lib.append/dup/part</code></strong>.  So I've always been wondering if there was some interesting evaluator behavior for it, like...</p>
<ul>
<li>
<p>...asking to pick from "global scope": if your function has an argument called ALL then /ALL might get you the definition outside your function?  (Something like <strong><code>::foo</code></strong> in C++)</p>
</li>
<li>
<p>...maybe a shorthand for <strong><code>self/foo</code></strong> for picking members out of objects inside of methods?</p>
</li>
</ul>
<p>Yet nothing has ever really stuck.  But <a class="mention" href="/u/ingohohmann">@IngoHohmann</a> pointed out that there's a basic thing that leading slashes might do for us which may have been overlooked...</p>
<p>...<em>simply running functions</em>.</p>
<h2>"But WORD!s Run Functions, Why Should /FOO Do That?"</h2>
<p>There are many reasons, but the biggest one is...</p>
<hr>
<p><strong>I feel pretty much 100% certain it is time that we switched to a world <em>where not all WORD!s holding ACTION!s will run them.</em></strong></p>
<hr>
<p>It's too cumbersome when writing generic code to worry that a value you got "from somewhere" and put into a SET-WORD! has to be handled with special operators:</p>
<pre><code> &gt;&gt; var: select obj 'item
 &gt;&gt; if integer? var [print "INT"]
 Muhaha the next thing at your callsite was [print "INT"]  ; eek, VAR was action

 &gt;&gt; var: first block
 &gt;&gt; if integer? var [print "INT"]
 HAH! Did you think blocks were safe?  Not at all: [print "INT"]  ; in blocks too!
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/man_facepalming.png?v=9" title=":man_facepalming:" class="emoji only-emoji" alt=":man_facepalming:"></p>
<p>Whether you think of it in terms of "security"--or simply bugs and chaos--this <em>persistent tax</em> on Redbol code authors has lacked a palatable solution.  Putting a GET-XXX! on every access is ugly, and easy to forget.  What we've ended up with is a mishmash...where people are constantly forced to choose between deciding if the brokenness is likely enough to cause a problem that it's worth it to make the code ugly.</p>
<p>(When code ages, it's like it develops some sort of pox--as leading colons are added on an ad-hoc basis, then no one really knows if they're safe to remove.)</p>
<p><strong>I propose that only specially marked assignments would <em>automatically</em> run a function through a word reference, requiring a ^META access to get the action value literally.</strong></p>
<pre><code>&gt;&gt; /foo: func [x] [print ["X is" x]]

&gt;&gt; foo 10
X is 10

&gt;&gt; ^foo
== #[action! {foo} [x]]
</code></pre>
<p><strong>If a function is assigned through a plain SET-WORD!, then that would be inert by default...but able to take advantage of this new leading-slash execution.</strong></p>
<pre><code>&gt;&gt; foo: func [x] [print ["X is" x]]

&gt;&gt; foo
== #[action! {foo} [x]]

&gt;&gt; /foo 10
X is 10
</code></pre>
<h2>Compliance Isn't Actually That Ugly!</h2>
<p>If you look at the definition of an object, then annotating the member functions isn't really so bad:</p>
<pre><code>obj: make object! [
    data: 1
    /accessor: does [return data + 1]
]
</code></pre>
<p>This also gives us some extra ammo: <strong>it can explain why we would use OBJ/ACCESSOR to invoke the function, and why OBJ.ACCESSOR can act as an error</strong>.</p>
<p>That can clean up examples like this:</p>
<pre><code> &gt;&gt; error: trap [...]
 &gt;&gt; if integer? error.arg1 [print "INT"]
 You forgot to worry about TUPLE! too! [print "INT"]  ; aaaargh...
</code></pre>
<p>All we have to do is say that TUPLE! accesses like that can't run methods.  It would have to be <strong><code>error/arg1</code></strong> to run it... which would also confirm that it was actually defined as a method.  (Otherwise you'd run it with <strong><code>/error.arg1</code></strong> if it was just a random non-method field that happened to be a function.)</p>
<p>This would be a systemic solution to historical annoyances.</p>
<h2>It Can Be A Nice Dialecting Pattern</h2>
<p><strong>It's useful in dialects where plain WORD! references are taken for another meaning.</strong>  For instance, UPARSE by default assumes a word means a combinator, so if you want to run a function that uses parse rules to gather its arguments you need something else:</p>
<pre><code>&gt;&gt; parse [1] [/negate integer!]
== -1

&gt;&gt; parse [1 2] [/add integer! integer!]
== 3
</code></pre>
<p>Initially I tried this with terminal slashes, as <strong><code>negate/</code></strong> and <strong><code>add/</code></strong>, but that doesn't look as good (and separates the functions from their arguments).</p>
<h2>What Do We Lose?</h2>
<p>Because I was trying to think of a meaningful evaluator behavior for leading-slash values, I didn't do much with them.  But eventually I decided to use them in New Apply:</p>
<p><a href="https://forum.rebol.info/t/apply-ii-the-revenge/1834" class="inline-onebox">APPLY II: The Revenge!</a></p>
<p>They're nice because they break up the space:</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]]
</code></pre>
<p>But SET-WORD! is reasonable at this, and commas can make it more visually separate if needed:</p>
<pre><code>&gt;&gt; apply :append [[a b c] [d e] dup: 2]
== [a b c [d e] [d e]]

&gt;&gt; apply :append [[a b c] [d e], dup: 2]
== [a b c [d e] [d e]]
</code></pre>
<p>Of course whatever we put here is being overloaded.  If you want a SET-WORD! for assignment purposes, you'd have to put it in a group:</p>
<pre><code>&gt;&gt; apply :append [(abc: [a b c]) [d e], dup: 2]
== [a b c [d e] [d e]]

&gt;&gt; abc
== [a b c]
</code></pre>
<p>So we could think of this similarly.  If you wanted to use a refinement-style path here, you just do it in a group:</p>
<pre><code>&gt;&gt; apply :append [(/reverse [a b c]) [d e], /dup 2]
== [c b a [d e] [d e]]
</code></pre>
<p><strong>APPLY is a dialect, and there are always going to be some tradeoffs made.</strong>   There's only so many parts.</p>
<p><strong>It's probably best to leave APPLY as it is.</strong>  I don't think we're going to be in the midst of some epidemic where suddenly every function invocation is done through a leading slash and it's going to be  contentious.  There will also be ways of running a function through REEVAL or maybe a dedicated RUN function that won't use the slash...</p>
<p>So nothing needs to be lost, really.</p>
<h2>The Big Win is that the <em>Obvious</em> Code is the <em>Correct</em> Code</h2>
<p>I've done some tentative implementation on all this, and all together, it seems pretty solid</p>
<p>Really all you're doing is paying the cost of an extra (easy-to-type) character to say that a word is intended to execute a function without needing to explicitly be told to.</p>
<p>There will be ways to subvert it, as of course you could do this:</p>
<pre><code>&gt;&gt; /func: enfix lambda [left [set-word!] spec body] [
       do compose [/(as word! left): lib/func (spec) (body)]
   ]

&gt;&gt; cheat: func [] [print "Breakin the law, breakin the law..."]

&gt;&gt; cheat
Breakin the law, breakin the law...
</code></pre>
<p>But we wouldn't make you do it that laboriously, if you're making something where words need to be associated with functions that run automatically.  And Redbol would do it through some evaluator parameterization as opposed to a mechanism like that.</p>
<p>However, the general expectation would be that most people would embrace the slash, as a useful piece of information...that makes everything work more coherently.</p>
            <p><small>12 posts - 5 participants</small></p>
            <p><a href="https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905</link>
          <pubDate>Fri, 29 Jul 2022 08:34:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1905</guid>
          <source url="https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905.rss">Big Alien Proposal :flying_saucer: &quot;/REFINEMENTS&quot; Run Functions</source>
        </item>
        <item>
          <title>SQLite&#39;s &quot;sqlean&quot;: C code for SQLite Extension Stuff</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>SQLite is a pretty carefully put together piece of C code.  Seems they've factored out some bits of interesting functions in C to a common library:</p>
<aside class="onebox githubfolder">
  <header class="source">
      <img src="https://github.githubassets.com/favicons/favicon.svg" class="site-icon" width="16" height="16">
      <a href="https://github.com/nalgeon/sqlean" target="_blank" rel="noopener">github.com</a>
  </header>
  <article class="onebox-body">
    <img src="https://repository-images.githubusercontent.com/343191804/5e00d0fc-d757-440b-a837-b2798de8e113" class="thumbnail onebox-full-image" width="60" height="60">

<h3><a href="https://github.com/nalgeon/sqlean" target="_blank" rel="noopener">GitHub - nalgeon/sqlean: The ultimate set of SQLite extensions</a></h3>


  <p><span class="label1">The ultimate set of SQLite extensions. Contribute to nalgeon/sqlean development by creating an account on GitHub.</span></p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>So there's random stuff like <a href="https://github.com/nalgeon/sqlean/blob/main/src/fuzzy/translit.c">transliteration</a>, for example or fuzzy string matching.  It could be a place to look if that kind of need comes up...</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904</link>
          <pubDate>Fri, 29 Jul 2022 05:09:20 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1904</guid>
          <source url="https://forum.rebol.info/t/sqlites-sqlean-c-code-for-sqlite-extension-stuff/1904.rss">SQLite&#39;s &quot;sqlean&quot;: C code for SQLite Extension Stuff</source>
        </item>
        <item>
          <title>Weird Idea: LIB/APPEND Runs, but LIB.APPEND Doesn&#39;t?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historical Redbol did not have generic TUPLE!.  So that meant it used paths for everything...whether you were specifying a refinement to a function, or doing a member selection out of an object, or coordinate out of a pair, or...whatever.</p>
<p>So far what Ren-C has done is to shift it such that tuples are for member selection, and pathing is for refinements only.</p>
<p>An additional twist is that a terminal-slash in a path (e.g. the last element is a BLANK!) means "run the action".  This is especially helpful when wanting to run a non-isotopic action in the new "activated actions" model:</p>
<pre><code>&gt;&gt; block: reduce [^print]

&gt;&gt; block.1
== #[action! {print} [line]]

&gt;&gt; block.1/ "The terminal slash comes in handy!"
The terminal slash comes in handy!
</code></pre>
<p>So if you have a non-isotopic action in your hand, the slash can run it.</p>
<p>It can also be helpful in a commentary sense--if you have some complex code and want to point out which bits are supposed to actually be actions getting invoked.</p>
<h2>Terminal Slashes Could Provide Safety...</h2>
<p>With the above, the pattern you would use to say you were going to run something like APPEND/DUP out of LIB would be this:</p>
<pre><code>&gt;&gt; lib.append/dup [a b c] [d e] 2
== [a b c [d e] [d e]]
</code></pre>
<p>But this means that you're on the hook for simple tuple references running, which you may not have expected:</p>
<pre><code>&gt;&gt; if integer? obj.something [print "What if SOMETHING is an ACTION! isotope?"]
Boo!
** Error: Some error coming from OBJ.SOMETHING running
</code></pre>
<p>One way of stopping this would be to say that if you were going to call a function that was a member of an object, you'd have to use a terminal slash, otherwise you'd get an error.</p>
<pre><code>&gt;&gt; if integer? obj.something [print "Clearer error if it's an ACTION! isotope"]
** Error: OBJ.SOMETHING is an ACTION! isotope, use OBJ.SOMETHING/ if intended
</code></pre>
<p>That would make field selection on the whole feel "safer".  But at the cost of looking at a lot of terminal slashes.</p>
<h2>More Succinct: Allow PATH!s to Pick The Action, Too</h2>
<p>If something like <strong>lib.append/dup</strong> is clearly an action (due to the use of refinements) it wouldn't need the terminal slash, like <strong>lib.append/dup/</strong>.  You already know an action is being run.</p>
<p>So what if you said <strong>lib/append</strong> instead of <strong>lib.append/</strong> ?</p>
<p>Of course, under such a rule, <strong>lib/append</strong> becomes conflated with a situation where LIB is a function and you're applying the <strong>/append</strong> refinement.  This does break away from a rule like "slashes always mean refinements".</p>
<p>That <em>kind of</em> sucks...BUT...it's still <em>far</em> less conflated than it was before.  Remember, historical Redbol used slashes for <em>EVERYTHING</em>.</p>
<p>The new rule could be "slashes always mean <em>from here on out, what we're talking about is function invocation"</em>.  So it's either picking a function to run, or narrowing it down by means of a refinement.</p>
<p>The advantage here system-wide would be that you could use field selection without worrying about it, as <strong>foo.bar</strong>, meaning "I want that field and I don't want any functions to run".  If there's no slash, there's no invocation.</p>
<p>I almost feel like the weird exception is worth it, because it would save a lot of bulletproofing that would otherwise be required on objects.  But it's also clearly a bit <em>bent</em>.</p>
<h2>The Other Direction: Terminal Dot as Invocation Suppressor</h2>
<p>With GET-WORD! changing its meaning, there's a possibility for saying "this reference is not an invocation", which could apply to WORD!s and to TUPLE!s alike.  That's the terminal dot.</p>
<pre><code>&gt;&gt; x: append.
** Error: APPEND. reference ends in dot but it's an ACTION! isotope
</code></pre>
<p>It has one downside of kind of being close to being a comma.</p>
<p>But the bigger reason I don't like this is just the mental tax that comes into effect.  It's the same as how I didn't like the creeping desire for correctness, meaning people putting colons in front of things in a fairly ad-hoc way.  We'd like the obvious code to just work.</p>
<p>I think the LIB/APPEND compromise may be worthwhile to get this correctness-by-default situation.</p>
<h2>Possible Objection: Value/Function Invariance?</h2>
<p>We might say that forcing you to distinguish at the callsite whether you are calling a function or not, prevents you from taking something that was a plain value previously, and substituting it with a function that calculates that value.</p>
<p>Under this principle, it's a feature that you "don't know" if <strong>obj.something</strong> is an action isotope or not...and making you commit to which it is by saying <strong>obj/something</strong> is bad.</p>
<p>It's kind of a narrow case--since you <em>have</em> to know at the callsite if it's a function that consumes arguments.  So it could only be argued for arity-0 functions.  And if the function doesn't return the same value every time, you're subject to some semantic questions.</p>
<p>I think that the answer here is that "accessor" functions (getter/setter) wouldn't count in this, if they existed.  They would use the tuple syntax but stay "behind the scenes".</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902</link>
          <pubDate>Thu, 28 Jul 2022 02:04:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1902</guid>
          <source url="https://forum.rebol.info/t/weird-idea-lib-append-runs-but-lib-append-doesnt/1902.rss">Weird Idea: LIB/APPEND Runs, but LIB.APPEND Doesn&#39;t?</source>
        </item>
  </channel>
</rss>

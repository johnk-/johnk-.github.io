<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest topics</title>
    <link>https://forum.rebol.info/latest</link>
    <description>Latest topics</description>
    
      <lastBuildDate>Sun, 25 Aug 2024 13:50:28 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/latest.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Asking Claude.ai About Longstanding Naming Conflations</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p><em>Given the <a href="https://forum.rebol.info/t/any-array-vs-any-list/1384/10">good progress made on the ANY-ARRAY! vs ANY-LIST!</a> discussion, and having brought Claude up to speed with our domain problems, I thought to keep going with related problems from history...</em></p>
<hr>
<p>This has been very productive!</p>
<p>And it makes me realize that the memory-oriented structure for BINARY! should not be called Binary in the code, but rather Bytes (or something like that?)  For the same reasons.</p>
<pre><code>Bytes bytes = Make_Bytes(10, NODE_FLAG_MANAGED);
Init_Binary(OUT, bytes);
</code></pre>
<p>I'm not sure about what to do with String... :-/  All the strings are stored as UTF-8 but Utf8 means something else and I like how it's being used.  Right now it's Make_String() and Init_String(), but what else could it be?</p>
<pre><code>Heart heart = is_tag ? TYPE_TAG : TYPE_TEXT;
Xxx xxx = Make_Xxx(10, NODE_FLAG_MANAGED);
Init_String(OUT, heart, xxx);
</code></pre>
<p>Then there's a longstanding question of what the superclass of Array, Bytes, and Xxx for string would be.  It has been Series, with the same problem:</p>
<pre><code>void Some_Function(Yyy yyy) {  // Yyy is superclass of Array, Xxx, Bytes..
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Series(OUT, heart, yyy);
}
</code></pre>
<p>Is it clear what I'm asking?</p>
<hr>
<blockquote>
<p>Yes, your question is clear, and it's an excellent extension of the naming considerations we've been discussing. Let's break this down:</p>
<ol>
<li>
<p>Binary / Bytes: Your suggestion to use <code>Bytes</code> for the memory-oriented structure of BINARY! is spot on. It follows the same logic as the Array/List distinction and improves clarity:</p>
<pre><code> Bytes bytes = Make_Bytes(10, NODE_FLAG_MANAGED);
 Init_Binary(OUT, bytes);
</code></pre>
</li>
</ol>
<p>This is a great improvement and consistent with the Array/List naming pattern.</p>
<ol start="2">
<li>String / Xxx: This is indeed trickier. Some possibilities to consider:</li>
</ol>
<ul>
<li>
<code>Chars</code>: Simple but might imply individual characters rather than a string.</li>
<li>
<code>Text</code>: Aligns with the TYPE_TEXT, but might be too high-level.</li>
<li>
<code>Utf8</code>: As you mentioned, it's already used for something else.</li>
<li>
<code>StringBuffer</code>: Descriptive but verbose.</li>
<li>
<code>Glyphs</code>: Emphasizes the visual representation, but might be too specific.</li>
</ul>
<p>Of these, I'm inclined towards <code>Text</code>, despite the potential confusion with TYPE_TEXT:</p>
<pre><code> Heart heart = is_tag ? TYPE_TAG : TYPE_TEXT;
 Text text = Make_Text(10, NODE_FLAG_MANAGED);
 Init_String(OUT, heart, text);
</code></pre>
<p>It's short, clear, and aligns well with the concept of a string. The potential confusion with TYPE_TEXT might actually be a feature, as it reinforces the relationship between the internal representation and the type.</p>
<ol start="3">
<li>Superclass for Array, Bytes, and Text (formerly Xxx): This is challenging because we want to avoid the term "Series" due to its historical baggage. Some options to consider:</li>
</ol>
<ul>
<li>
<code>Data</code>: Very generic, but could work as it encompasses all these types of data.</li>
<li>
<code>Buffer</code>: Emphasizes the idea of a contiguous memory area.</li>
<li>
<code>Sequence</code>: Similar to your use of ANY-SEQUENCE!, but for the internal representation.</li>
<li>
<code>Store</code>: Implies a place where data is held.</li>
<li>
<code>Span</code>: Suggests a contiguous range of memory.</li>
</ul>
<p>Of these, I'm leaning towards <code>Buffer</code> as it most accurately describes what these types have in common - a contiguous area of memory holding data:</p>
<pre><code>void Some_Function(Buffer buffer) {  // Buffer is superclass of Array, Text, Bytes
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Series(OUT, heart, buffer);
}
</code></pre>
<p>You might even consider renaming <code>Init_Series</code> to <code>Init_Buffer</code> for consistency:</p>
<pre><code>void Some_Function(Buffer buffer) {
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Buffer(OUT, heart, buffer);
}
</code></pre>
<p>This naming scheme provides a clear hierarchy:</p>
<ul>
<li>Buffer (low-level, contiguous memory)</li>
<li>Array (for Lists)</li>
<li>Text (for Strings)</li>
<li>Bytes (for Binaries)</li>
</ul>
<p>It maintains the distinction between implementation details and higher-level concepts while providing clear and consistent naming throughout the codebase.</p>
</blockquote>
<hr>
<p>One might call the actual dynamically allocated data structure a Deque (double ended queue), because that's what it is...but there's more baggage to it than that.  It has tons of fiddly properties.  It's truly a Rebol-specific concept.</p>
<p>I'm reminded of an old library I used called "flexlist".  Perhaps it could be a Flex?  Something like that... referring to its ability to be resized.  I used to work for Microsoft actually...and it was decades ago so I don't remember specifics anymore...but we had some weird names like that to try and avoid people making assumptions that they knew the properties of what they were dealing with.</p>
<p>And in fact I'm sort of feeling now that there's a bit of deception about the complexity of the abstraction by using simple terms like Bytes and Array.    (I'm a little nervous that Bytes sounds too much like a plain pointer to Byte and not a more interesting structure.)</p>
<p>But I don't like the idea of something like FlexString, FlexBinary, and FlexList because that would be almost as bad as the converse of dealing with the String/Init_Any_String distinction!  So compromising to say that within the domain of the source code of the project, Array is understood as being an Array of Rebol Cells built on top of the Flex seems reasonable.</p>
<hr>
<blockquote>
<p>Your thoughts on this are very insightful, and I agree that there's a balance to strike between simplicity and accuracy in naming these complex structures. The idea of using a term like "Flex" is intriguing, as it does capture the dynamic nature of these data structures without implying a specific implementation or set of properties. Let's explore this direction:</p>
<ol>
<li>Core dynamic structure: Flex</li>
</ol>
<p>This could be the superclass for all the dynamically resizable structures in Rebol. It conveys flexibility without tying to a specific implementation detail.</p>
<pre><code>void Some_Function(Flex flex) {
    Heart heart = is_array ? TYPE_BLOCK : TYPE_TEXT;
    Init_Value(OUT, heart, flex);
}
</code></pre>
<ol start="2">
<li>Specific types built on Flex:</li>
</ol>
<ul>
<li>For lists: ArrayFlex (or keep it as Array, understood to be built on Flex)</li>
<li>For strings: StringFlex (or TextFlex)</li>
<li>For binaries: BytesFlex (or BinaryFlex)</li>
</ul>
<p>This naming scheme acknowledges the complexity of these structures while maintaining a level of simplicity in day-to-day usage. It also provides a clear hint that these are not simple C arrays or strings, but more complex Rebol-specific structures.</p>
<p>So, the code might look like:</p>
<pre><code>ArrayFlex array = Make_ArrayFlex(10, NODE_FLAG_MANAGED);
Init_List(OUT, array);

StringFlex text = Make_StringFlex(10, NODE_FLAG_MANAGED);
Init_String(OUT, heart, text);

BytesFlex bytes = Make_BytesFlex(10, NODE_FLAG_MANAGED);
Init_Binary(OUT, bytes);
</code></pre>
<p>Or, if you prefer to keep the simpler names for daily use:</p>
<pre><code>Array array = Make_Array(10, NODE_FLAG_MANAGED);  // Understood to be a Flex-based Array
Init_List(OUT, array);

Text text = Make_Text(10, NODE_FLAG_MANAGED);  // Understood to be a Flex-based Text
Init_String(OUT, heart, text);

Bytes bytes = Make_Bytes(10, NODE_FLAG_MANAGED);  // Understood to be a Flex-based Bytes
Init_Binary(OUT, bytes);
</code></pre>
<p>This approach:</p>
<ol>
<li>Uses "Flex" to denote the core dynamic structure, hinting at its complexity and flexibility.</li>
<li>Allows for simpler names in daily use (Array, Text, Bytes) while understanding they're built on Flex.</li>
<li>Avoids confusion with plain C types.</li>
<li>Maintains the distinction between low-level structures and high-level types (List, String, Binary).</li>
</ol>
<p>The term "Flex" serves as a reminder that these are not simple data structures, but complex, Rebol-specific implementations with many properties. It's a good compromise between accuracy and simplicity, and it leaves room for future expansion or modification of the underlying implementation without breaking the conceptual model.</p>
</blockquote>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/asking-claude-ai-about-longstanding-naming-conflations/2221">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/asking-claude-ai-about-longstanding-naming-conflations/2221</link>
          <pubDate>Sun, 25 Aug 2024 13:50:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2221</guid>
          <source url="https://forum.rebol.info/t/asking-claude-ai-about-longstanding-naming-conflations/2221.rss">Asking Claude.ai About Longstanding Naming Conflations</source>
        </item>
        <item>
          <title>Why is &lt;/&gt; a TAG! and not a PATH! (or WORD!)?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="2218">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/wolfram-language/2218/4">Wolfram Language</a>
</div>
<blockquote>
<p><strong><code>&lt;/&gt;</code></strong> is a TAG!</p>
</blockquote>
</aside>
<p>This strikes me as being odd. It’s not a valid closing tag in HTML or XML, for instance. I find it natural to interpret this as ‘path from <code>&lt;</code> to <code>&gt;</code>’.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/why-is-a-tag-and-not-a-path-or-word/2219">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-is-a-tag-and-not-a-path-or-word/2219</link>
          <pubDate>Sun, 25 Aug 2024 03:58:41 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2219</guid>
          <source url="https://forum.rebol.info/t/why-is-a-tag-and-not-a-path-or-word/2219.rss">Why is &lt;/&gt; a TAG! and not a PATH! (or WORD!)?</source>
        </item>
        <item>
          <title>Wolfram Language</title>
          <dc:creator><![CDATA[vnzio]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Wolfram Mathematica = now called<br>
"Wolfram Language"</p>
<p>has some nice abreviation symbol/shortcuts  for typing</p>
<p>But all have the names visible when you invoke<br>
<strong>FullForm[]</strong><br>
and the good docs all suggest how to say them out loud<br>
Very nice &amp;important for teaching<br>
And or in any videos</p>
<p>Rebol I think was much inspired by Mathematica</p>
<p>(I don't know for sure)</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/wolfram-language/2218">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/wolfram-language/2218</link>
          <pubDate>Sun, 25 Aug 2024 03:23:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2218</guid>
          <source url="https://forum.rebol.info/t/wolfram-language/2218.rss">Wolfram Language</source>
        </item>
        <item>
          <title>The Theory of Meta-Representability</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p><em>I wrote this to try and give some context to an AI before asking it a naming question.  For a less high-level treatment, see <strong><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">A Justification of Generalized Isotopes</a></strong>.</em></p>
<hr>
<p>Most imperative programming languages do not delve into the relationships between things like null and undefined... as if they were mathematical, and you were going to discover that if you take the square root of undefined you get null, etc.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20">  But I am doing something analogous to that.</p>
<p>In particular, I'm making it possible to push variables which may contain states like undefined and null "upwards" representationally, to where whatever they are holding becomes "Meta".</p>
<pre><code>&gt;&gt; var
** Error: var is nothing

&gt;&gt; var: meta var
== ~

&gt;&gt; var  ; no error on access
== ~

&gt;&gt; var: meta var  ; again, no error
== '~

&gt;&gt; var
== '~

&gt;&gt; var: meta var  ; no error again
== ''~
</code></pre>
<p>If something is a special form (like nothing or null) the first META step will use tildes to indicate it has been raised to a "quasiform".  Quasiforms do not cause errors when accessed from variables, and can be put into "reified" contexts like arrays.  Then every META step after that adds a level of quoting, indicated by an apostrophe.</p>
<p>UNMETA reverses this process, ultimately getting back to the special form which cannot be put in arrays and--in the case of "nothing"--causes errors on access.</p>
<pre><code>&gt;&gt; var: unmeta first ['~]
== ~

&gt;&gt; var
== ~

&gt;&gt; var: unmeta var  ; result is nothing, shows nothing in the console

&gt;&gt; var
** Error: var is nothing
</code></pre>
<p>If something didn't start out as a special form, then it will just get quoting levels added by apostrophes:</p>
<pre><code>&gt;&gt; var
== 10

&gt;&gt; var: meta var
== '10

&gt;&gt; var: meta var
== ''10
</code></pre>
<p>So what this lets people do is kind of work generically and persist special states of interest to them in meta form, multiplexed alongside things that had been conventional values.</p>
<p>The special states are called "antiforms".  And they aren't just things like NULL and NOTHING, but also <a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880">VOID</a>... <a href="https://forum.rebol.info/t/why-theres-no-boolean-type-storable-in-a-block/2095">logical TRUE and FALSE</a> (which means all reified states can be truthy)... <a href="https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955">multi-return packs</a>, <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">raised errors</a>, <a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607">splice representations</a>...</p>
<p>To a newcomer, the merits or applications may not be obvious.  But this model gives phenomenal expressive power.  And I definitely do think of it as being like the "higher mathematics" of Rebol.</p>
<hr>
<p><a href="https://www.youtube.com/watch?v=B1J6Ou4q8vE">Animation vs. Math</a></p>

            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-theory-of-meta-representability/2217">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-theory-of-meta-representability/2217</link>
          <pubDate>Sat, 24 Aug 2024 18:38:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2217</guid>
          <source url="https://forum.rebol.info/t/the-theory-of-meta-representability/2217.rss">The Theory of Meta-Representability</source>
        </item>
        <item>
          <title>What to Call Lone Tilde (~)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So this little guy doesn't have a name:</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/98fe977bff93e2b3dfd91a030a3c088d925cc1ec.png" alt="1896_tilde" data-base62-sha1="lPs2dyWS6kN1weGeGoU7SyMbh5a" width="125" height="125"></p>
<p>Yes it's a "tilde", but if there's a TILDE definition I think it should be talking about the character.</p>
<pre><code>&gt;&gt; print ["name" tilde "me"]
name ~ me

&gt;&gt; char? tilde
== ~true~  ; anti
</code></pre>
<p>We're talking about something that evaluates to the antiform of blank (the contents of an unset variable):</p>
<pre><code>&gt;&gt; eval [~]
== ~  ; anti
</code></pre>
<h2>
<a name="quasi-blank-1" class="anchor" href="https://forum.rebol.info#quasi-blank-1"></a>QUASI-BLANK?</h2>
<p>It's an <em>accurate</em> name...</p>
<pre><code>&gt;&gt; quasi _
== ~
</code></pre>
<p>But if you're going to be testing for them easily in a block, you want something shorter.</p>
<p>Carl went on a bit of a bizarre track by deciding that #[none] was unweildy in blocks, and he liked zeros better... single characters... so <a href="http://www.rebol.net/r3blogs/0112.html">he started using zeros instead of nones, and made ZERO? accept everything</a>.</p>
<blockquote>
<p><em>I started using a lot more zeros in my data structures, especially those that had to be loaded from a file or database, because I knew that zero loaded more efficiently than NONE (no hash was required).</em></p>
<p><em>For example, where I would once create REBOL-stored DB records like this:</em></p>
<pre><code>["name" none none]
</code></pre>
<p><em>I would use:</em></p>
<pre><code>["name" 0 0]
</code></pre>
<p><em>Because using 0 does not require a hash-and-compare operation (as does the word NONE) nor does it require binding (as does the value NONE)... nor is it the long-form literal #[none], that seems just a bit too cumbersome to my coding style.</em></p>
</blockquote>
<p>You're getting a lot of single-character choices in Ren-C, and which one you use kind of depends on what you want.</p>
<p>QUASI-BLANK is as ornery as it can be while being legal to appear in a block.  e.g. if you try to ask it something like EMPTY? you'll get an error:</p>
<pre><code>&gt;&gt; block: ["name" ~ ~]

&gt;&gt; empty? second block
** Script Error: empty? expects [blank! any-series? object! port! bitset! map!]
      for its series argument
</code></pre>
<p>If you use BLANK! you have not just a different look, but more routines that are willing to think of it as being some kind of emptiness:</p>
<pre><code>&gt;&gt; block: ["name" _ _]

&gt;&gt; empty? second block
== ~true~  ; anti
</code></pre>
<p>There's also #, which is effectively the zero character.</p>
<pre><code>&gt;&gt; block: ["name" # #]

&gt;&gt; append #{DECAFBAD} second block
== #{DECAFBAD00}

&gt;&gt; append "Hello" second block
** Script Error: #{00} bytes illegal in ANY-STRING?, use BINARY!
</code></pre>
<h2>
<a name="does-it-need-a-name-2" class="anchor" href="https://forum.rebol.info#does-it-need-a-name-2"></a>Does It Need A Name?</h2>
<p>Something that makes it desirable for QUASI-BLANK to have a name is that because it's evaluative, you can't just compare to it directly without quoting it.</p>
<pre><code>if '~ = second block [...]
</code></pre>
<p>BLANK! and the NUL character don't have that problem.</p>
<pre><code>if _ = second block [...]

if # = second block [...]
</code></pre>
<p>But still, Rebol tries to reduce the symboly-ness, and that looks nicer if there's a test you're going to be performing a lot:</p>
<pre><code>if blank? second block [...]
</code></pre>
<p>So I think that QUASI-BLANK needs a nice short name, to help avoid people writing sequences like <strong><code>'~ =</code></strong> often in their code.</p>
<h2>
<a name="i-hate-to-suggest-it-but-what-about-none-3" class="anchor" href="https://forum.rebol.info#i-hate-to-suggest-it-but-what-about-none-3"></a>I Hate To Suggest It... But... What About NONE?</h2>
<p>I never liked the name NONE for what it was.  It's the wrong part of speech, and I want it to be like ANY and ALL to let you test a series of expressions for all of them being falsey.</p>
<pre><code>&gt;&gt; if none [1 &gt; 2, 3 &gt; 4, 5 &gt; 6] [print "Math is working"]
Math is working.
</code></pre>
<p>That's less awkward than <strong><code>all :: [/predicate :not, [1 &gt; 2, 3 &gt; 4, 5 &gt; 6]]</code></strong></p>
<p>But I'm having a hard time thinking of anything else short and good.  HOLE?  JUNK?</p>
<p>The AI <a href="https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204">really want something to be called WISP?</a> for some reason.</p>
<p>Something related to QUASI... QUASAR?  That's actually kind of cool but ridiculous.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>I'm sad to think that the best name is NONE.  Hopefully it isn't.</p>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-to-call-lone-tilde/2216">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-to-call-lone-tilde/2216</link>
          <pubDate>Sat, 24 Aug 2024 18:00:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2216</guid>
          <source url="https://forum.rebol.info/t/what-to-call-lone-tilde/2216.rss">What to Call Lone Tilde (~)</source>
        </item>
        <item>
          <title>Why @ Isn&#39;t A Precise Synonym For THE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>The SIGIL! @ has non-overrideable behavior in the evaluator.  It acts like THE (Ren-C's parallel to Redbol's QUOTE)</p>
<pre><code>&gt;&gt; @ foo
== foo

&gt;&gt; @ (1 + 2)
== (1 + 2)

&gt;&gt; the foo
== foo

&gt;&gt; the (1 + 2)
== (1 + 2)
</code></pre>
<p>But it does something a normal function can't...which is to effectively put antiforms in suspended animation in the API.</p>
<p>If it worked in the main language, it would be like this:</p>
<pre><code>&gt;&gt; eval impossible-compose [@ ('~null~)]
== ~null~

&gt;&gt; eval impossible-compose [@ (null)]
== ~null~  ; anti
</code></pre>
<p>You might imagine the @ operator doing a little cheat, by turning quasiform null into antiform null.  Then IMPOSSIBLE-COMPOSE could just do this:</p>
<pre><code>&gt;&gt; block: impossible-compose [@ (null)]
== [@ ~null~]

&gt;&gt; eval block
== ~null~  ; anti
</code></pre>
<p>For a time this is exactly what it did.  But then...how would you literally get a quasiform null?  It can't do both.</p>
<p>Today, using some magic in the evaluator, this API code works:</p>
<pre><code>Value* result1 = rebValue("eval [@", nullptr, "]);
assert(result1 == nullptr);

Value* result2 = rebValue("eval [@ ~null~"]);
rebElide("assert ['~null~ = first [", result2, "]]");
</code></pre>
<p>It depends on @ not being overrideable and always using the special evaluator magic that lets this work, when you can't do it inside Rebol.</p>
<h2>
<a name="why-let-the-api-do-something-the-language-cant-1" class="anchor" href="https://forum.rebol.info#why-let-the-api-do-something-the-language-cant-1"></a>Why Let The API Do Something The Language Can't?</h2>
<p>Because quite simply... <strong>rebQ(thing)</strong> in the API is uglier than <strong><code>'thing</code></strong> which you can do if you're in the language.</p>
<p>And which would you rather read?</p>
<pre><code>Value* result1 = rebValue("eval [", rebQ(nullptr), "]);

Value* result1 = rebValue("eval [@", nullptr, "]);
</code></pre>
<p>The second is also faster.</p>
<p>Anyway, there are other ways of doing it that don't use a literalizing operator.  But here, a literalizing operator is what we generally want.  We just want it to reconstruct antiforms, and a hack lets us do it.</p>
<h2>
<a name="is-this-dangerous-2" class="anchor" href="https://forum.rebol.info#is-this-dangerous-2"></a>Is This Dangerous?</h2>
<p>The hack has the slightly undesirable property that if you asked for the API code you are running as a block, you couldn't get a legitimate block out of it.</p>
<p>So if you were stepping in a debugger or something, there's an impossible situation in play... something that's not a legal array element is sitting in a slot where the antiform is.  And when the evaluator hits that thing it will almost always give an API error saying "you can't do that".</p>
<p>So this would fail:</p>
<pre><code>rebElide("block: [@", nullptr, "]")
</code></pre>
<p>There's no evaluation going on inside that block here, so no exception.  You can't put antiforms in blocks and receive that block as a normal value.</p>
<p>But as long as it is in an evaluative context immediately after @, then the action is to reconstitute the antiform as an evaluative product.</p>
<p>A debugger would have to have special awareness of this if it were to show you the array, and never let it leak out from the API feed.  If you copied it out you would have to get a warning that the antiforms had all been converted to quasiforms and the code wouldn't work.</p>
<p>My belief is that this is worth it.  I couldn't justify it (or even figure out how it would be done) when @ was just running an ordinary function, because it would create a crazy parameter convention exception, and leak the mechanic to places it should never be seen.  But this isolates it to where it's a built-in evaluator capability that you mostly don't need to know how it works.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/why-isnt-a-precise-synonym-for-the/2215">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/why-isnt-a-precise-synonym-for-the/2215</link>
          <pubDate>Sat, 24 Aug 2024 07:07:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2215</guid>
          <source url="https://forum.rebol.info/t/why-isnt-a-precise-synonym-for-the/2215.rss">Why @ Isn&#39;t A Precise Synonym For THE</source>
        </item>
        <item>
          <title>JUST the APOSTROPHE (&#39;) SIGIL!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p><em>This ties together quite nicely.  cc: <a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a></em></p>
<hr>
<p>So I'd been fretting over whether <strong><code>@</code></strong> would bind the thing you passed it or not.  It had to bind things for the system to work, so I went with that... even though it may not be what you want in all cases:</p>
<pre><code>&gt;&gt; abc: 10

&gt;&gt; word: @ abc
== abc

&gt;&gt; get word
== 10
</code></pre>
<p><strong><code>@foo</code></strong> is a THE-WORD! and so <strong><code>@</code></strong> makes sense as a synonym for an operator called THE.</p>
<pre><code>&gt;&gt; the abc
== abc ; bound
</code></pre>
<p>But what if you don't want a binding?  THE/UNBOUND?  Is there no symbol?</p>
<h2>
<a name="a-part-in-the-box-becomes-available-apostrophe-1" class="anchor" href="https://forum.rebol.info#a-part-in-the-box-becomes-available-apostrophe-1"></a>A Part In The Box Becomes Available: APOSTROPHE (')</h2>
<p>For a very long time, apostrophe was considered the quoted form of VOID (or NULL, before void existed).  So it evaluated to void, and voids were invisible in the console:</p>
<pre><code>&gt;&gt; if false [print "conditional returns void"]

&gt;&gt; meta if false [print "conditional returns void"]
'

&gt;&gt; quote void
== '

&gt;&gt; append [a b c] '
== [a b c]
</code></pre>
<p><em><strong>"Isn't that cool"</strong></em>, I thought.  <em><strong>"Void is the absence of anything, and so when you quote it you get just a lone apostrophe.  And when the lone apostrophe boils away after removing the quote in evaluation, you have nothingness!!!  It's perfect for displaying nothing as a result!"</strong></em></p>
<p>Slow clap.  <img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=12" title=":clap:" class="emoji" alt=":clap:" loading="lazy" width="20" height="20"></p>
<p>It was a cute idea in the pre-isotopic era.  But once we had quasiforms and antiforms, <strong><a href="https://forum.rebol.info/t/why-shouldnt-void-be-done-with-a-void-word-antiform/2160">making void the antiform of the word <code>void</code> has many more merits.</a></strong></p>
<p>So lone apostrophe went back into the "unused" bin, and I wondered what to do with it.  What type would it be?  Couldn't be a WORD!</p>
<h2>
<a name="but-sigil-were-invented-simultaneously-to-voidhttpsforumrebolinfotweird-word-s-allow-but-escape-them156010uhostilefork-2" class="anchor" href="https://forum.rebol.info#but-sigil-were-invented-simultaneously-to-voidhttpsforumrebolinfotweird-word-s-allow-but-escape-them156010uhostilefork-2"></a>But... <a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/10">SIGIL! Were Invented Simultaneously To ~void~</a>
</h2>
<p>They happened in basically the same week.  I'm not sure why it didn't occur to me to make <strong><code>'</code></strong> a SIGIL!</p>
<p>Why not?</p>
<pre><code>&gt;&gt; sigil of first [''a]
== '
</code></pre>
<p>Now we have our non-binding literal operator.</p>
<pre><code>&gt;&gt; abc: 10

&gt;&gt; word: ' abc

&gt;&gt; get word
** Script Error: abc word is not bound to a context
</code></pre>
<p>And I think a good name for it would be... JUST:</p>
<pre><code>&gt;&gt; just abc
== abc  ; not bound
</code></pre>
<ul>
<li>
<p>It's a good part of speech (LITERAL seems like a variable name)</p>
</li>
<li>
<p>It's short (LITERALLY would be obnoxious)</p>
</li>
<li>
<p>I think that JUST has a good shade of meaning of <em>"just give me the array element, I don't want the extras...no pickles, no lettuce, and no binding"</em></p>
</li>
</ul>
<h2>
<a name="seems-perfect-to-me-3" class="anchor" href="https://forum.rebol.info#seems-perfect-to-me-3"></a>Seems Perfect To Me</h2>
<p>This goes along with the idea of when you declare your function arguments as being literal, if you say <strong><code>'foo</code></strong> for the argument you will get it with no added binding, and if you say <strong><code>@foo</code></strong> it will bind in the context of the callsite.</p>
<p>Anyway, they're "literal arguments"... not "quoted arguments"... because no quoting level is added.  Except perhaps an imaginary quoting level added in your head at the callsite which the evaluator strips off, but that doesn't happen.  (In fact it can't happen for @, because for anything but a plain WORD!/BLOCK!/TUPLE!/etc. there's no way to add an @ onto something like an INTEGER! or the like.)</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/just-the-apostrophe-sigil/2213">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/just-the-apostrophe-sigil/2213</link>
          <pubDate>Sat, 24 Aug 2024 05:38:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2213</guid>
          <source url="https://forum.rebol.info/t/just-the-apostrophe-sigil/2213.rss">JUST the APOSTROPHE (&#39;) SIGIL!</source>
        </item>
        <item>
          <title>Trust the User&#39;s Judgment... *When You Can*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>When writing about <a href="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210">whether we should have SET-WORD! for initializing locals in function specs</a>, I talked about whether to enforce the right hand side of the SET-WORD! being a GROUP! for safety:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2210">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210/1">SET-WORD! To Initialize Locals In Function Specs?</a>
</div>
<blockquote>
<p>If plain words are being picked up as locals there's potential for error if you accidentally wrote an expression that didn't work, like:</p>
<pre><code class="lang-plaintext">func [
   arg [integer!]
   &lt;local&gt;
   local1 local2
   local3: arity-2-but-I-think-it's-3 a b c
   local4: 10
][
    ...
]
</code></pre>
<p>That could wind up making a local <strong><code>c</code></strong> that you didn't intend. But then again, sometimes it would be just a very obvious simple initialization, like <strong><code>local4: 10</code></strong>. Forcing people to use parentheses could do more harm than good, vs. trusting them to use the parentheses if they feel it's warranted.</p>
</blockquote>
</aside>
<p>I realized this kind of dove to the heart of Rebol philosophy:</p>
<p><strong>If you need to evaluate an expression multiple times, it has to be in an array.  But if you're doing an evaluation just once, trust the user to formulate the expression and use an array if they deem it necessary.</strong></p>
<p>Most people encounter this first with the difference between IF and WHILE.</p>
<p>Certainly IF <em>could</em> take its condition in a BLOCK!.  But it doesn't.  You can mess up:</p>
<p>In Rebol2:</p>
<pre><code>block: [a b]
data: [c]

if 3 = length? append block [
   print "Appending data to block gave us 3 elements"
]

stuff: [a b c]
</code></pre>
<p>You run the code and you get no output, because you forgot to say <strong>append block data</strong>.  So what did you get instead?</p>
<pre><code>&gt;&gt; block
== [a b
    print "Appending data to block gave us 3 elements"
]
</code></pre>
<p>What you thought was a branch got appended.  And the branch actually wound up being the block from the next expression (SET-WORD!s evaluate to what they are assigned).</p>
<p><em>(As it so happens in Ren-C, it catches this...due to <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">soft-quoted branching</a>.  Since it quotes its branch slot, it saw a SET-WORD! in the position, and it doesn't allow things like WORD! or SET-WORD! there.  If we didn't already have enough reasons to appreciate soft quoted branching, there's one more!)</em></p>
<h2>
<a name="should-it-have-required-a-block-for-the-condition-1" class="anchor" href="https://forum.rebol.info#should-it-have-required-a-block-for-the-condition-1"></a>Should It Have Required a Block For The Condition?</h2>
<p><strong>The answer for the Rebol Core is: No.</strong>  The goal is to trust the user to make that call.</p>
<p>If you think the expression you're writing is too risky to get right, you should use a GROUP! or break it into subexpressions or otherwise rethink your code so it's not risky.  Being able to cook up a DSL in ten minutes that solves patterns you find useful is the tool you use when you find yourself making code that's at risk of mistakes.</p>
<p><strong>The answer for You is: Your Choice.</strong>  If you find you're making lots of mistakes and want to set a policy that IF always takes a BLOCK! condition, suit yourself.  IF is yours, just like everything.  Redefine it.  It's about <a href="https://forum.rebol.info/t/back-to-personal-computing/186">putting the personal back into personal computing.</a></p>
<h2>
<a name="well-then-why-use-a-block-for-whiles-condition-2" class="anchor" href="https://forum.rebol.info#well-then-why-use-a-block-for-whiles-condition-2"></a>Well Then Why Use A BLOCK! For WHILE's Condition?</h2>
<p>Because there wasn't another choice.</p>
<p>You can't tell how long an expression is going to be just by looking at it.  You have to evaluate it.</p>
<p>The condition in a WHILE needs to be evaluated more than once.  So it's taken as a BLOCK!.</p>
<h2>
<a name="this-is-one-of-the-big-ideas-3" class="anchor" href="https://forum.rebol.info#this-is-one-of-the-big-ideas-3"></a>This Is One of The "Big Ideas"</h2>
<p>Whether you see it as a big idea or just kind of gonzo programming, is up to you.</p>
<p>With the state of software being how it is, I think we need the occasional Flower Sermon.</p>
<p><strong><a href="https://en.wikipedia.org/wiki/Flower_Sermon">https://en.wikipedia.org/wiki/Flower_Sermon</a></strong></p>
<p>Ren-C has <a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387">thrown in another big tool here, with COMMA!</a>.  Giving you yet more choice.</p>
<p>Yet EVAL and PARSE still let you write your streams of consciousness, giving the code a written-English like fluidity, of mostly words and spaces...which we are naturally good at working with.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/trust-the-users-judgment-when-you-can/2211">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/trust-the-users-judgment-when-you-can/2211</link>
          <pubDate>Sat, 24 Aug 2024 03:44:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2211</guid>
          <source url="https://forum.rebol.info/t/trust-the-users-judgment-when-you-can/2211.rss">Trust the User&#39;s Judgment... *When You Can*</source>
        </item>
        <item>
          <title>SET-WORD! To Initialize Locals In Function Specs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p><em>(cc: <a class="mention" href="https://forum.rebol.info/u/ingohohmann">@IngoHohmann</a> as you have had opinions on these kinds of things.)</em></p>
<p>It seems it would be nice if you had the option of setting your locals when you define them.</p>
<pre><code>foo: func [
    arg1 [integer!]
    arg2 [text!]
    &lt;local&gt;
    local1 local2
    local3: 10
    local4: (20 * 30)
][
    ...
]
</code></pre>
<p>As it so happens, there's potential to exploit this for efficiency.  The frame mechanics have a slot for each local in the function archetype that currently just holds trash, and it could hold this default value / expression.  So it wouldn't just save on typing the local name and then later the name again and the expression...but you're avoiding the need to perform the evaluation to do the assignment on each call!</p>
<p>There's a lot of questions to answer:</p>
<ul>
<li>
<p>What binding rules is it using?  Could you initialize local3 and then say <strong><code>local4: (local2 * arg1)</code></strong>?</p>
<ul>
<li>Almost certainly not, and it would just be using the binding of the spec block</li>
</ul>
</li>
<li>
<p>Does the code run on each invocation, or is it run only once to calculate a fixed value?  e.g. if it was <strong><code>local4: (global-var * 30)</code></strong> would each invocation of FOO recalculate what <strong><code>(global-var * 30)</code></strong> was at that moment?</p>
<ul>
<li>Almost certainly would just calculate a fixed value and use that value on each call.</li>
</ul>
</li>
<li>
<p>Do you need parentheses directly after the SET-WORD!?</p>
<ul>
<li>
<p>If the expression were run on each invocation (which it probably shouldn't be) then it would be a requirement, because there'd be no way to find the start and the end of the right hand expression without evaluating it.</p>
</li>
<li>
<p>If plain words are being picked up as locals there's potential for error if you accidentally wrote an expression that didn't work, like:</p>
<pre><code>func [
   arg [integer!]
   &lt;local&gt;
   local1 local2
   local3: arity-2-but-I-think-it's-3 a b c
   local4: 10
][
    ...
]
</code></pre>
<p>That could wind up making a local <strong><code>c</code></strong> that you didn't intend.  But then again, sometimes it would be just a very obvious simple initialization, like <strong><code>local4: 10</code></strong>.  Forcing people to use parentheses could do more harm than good, vs. trusting them to use the parentheses if they feel it's warranted.</p>
</li>
</ul>
</li>
</ul>
<h2>
<a name="compare-to-static-not-initialized-with-set-word-atm-1" class="anchor" href="https://forum.rebol.info#compare-to-static-not-initialized-with-set-word-atm-1"></a>Compare to <code>&lt;static&gt;</code>: Not Initialized With SET-WORD! ATM</h2>
<p>Right now the <code>&lt;static&gt;</code> feature lets you assign your variables, but it uses a non-Reboly-notation to do so:</p>
<pre><code>accumulate: func [
    item [any-element?]
    &lt;static&gt;
    block ([])
][
    append block item
]
</code></pre>
<p>The parentheses are optional to hold the initializer.  But  it seems much more normal to say:</p>
<pre><code>accumulate: func [
    item [any-element?]
    &lt;static&gt;
    block: []
][
    append block item
]
</code></pre>
<p>One reason for the parentheses notation was to try and be consistent with the idea of defaulting refinements.</p>
<pre><code>&gt;&gt; foo: func [/string [text!] ("default")] [print string]

&gt;&gt; foo/string "hello"
hello

&gt;&gt; foo
default
</code></pre>
<p>But that feature was removed</p>
<p>There's another reason why just WORD! was used...</p>
<h2>
<a name="return-has-owned-set-word-in-the-spec-dialect-2" class="anchor" href="https://forum.rebol.info#return-has-owned-set-word-in-the-spec-dialect-2"></a>RETURN: Has "Owned" SET-WORD! In The Spec Dialect</h2>
<p>We have a little bit of friction in that the dialect has been using RETURN: to indicate what a function returns.  The choice has not much to do with what comes after a return being an assignment any more than anything else, it was picked for looks:</p>
<pre><code>double-multiply: func [
    return: [integer!]
    value1 [integer!]
    value2 [integer!]
][
    return 2 * value1 * value2
]
</code></pre>
<p>The issue is that historical Rebol2 (and R3-Alpha, and Red) allow this:</p>
<pre><code>rebol2&gt;&gt; print-sum: func [return break] [print ["Sum is" return + break]]

rebol2&gt;&gt; print-sum 10 20
Sum is 30
</code></pre>
<p>Ren-C only lets you do that in LAMBDA.  FUNC prohibits it:</p>
<pre><code>ren-c&gt;&gt; print-sum: func [return break] [print [return + break]]
** Error: Generator provides RETURN:, use LAMBDA if not desired
</code></pre>
<p>I think Red/System decided on RETURN: first.  <a href="https://static.red-lang.org/red-system-specs-light.html#section-3.3">But they put it at the end of the spec.</a>  Red errors if you try to put the return elsewhere:</p>
<pre><code>red&gt;&gt; stringy: func [a b return: [string!]] [a + b]
== func [a b return: [string!]][a + b]

red&gt;&gt; stringy: func [return: [string!] a  b] [a + b]
*** Script Error: invalid function definition: [return: [string!] a b]
</code></pre>
<p>But either way, it's not checked.  On the <a href="https://www.red-lang.org/2012/12/red-v031-functions-support-added.html">2012 announcement of function support in Red</a>, DocKimbel says: <em>"Note: argument and return value type checking have not been implemented yet, they need typeset! and error! datatypes to be implemented first."</em>  Parameter type checking works, but I guess return type checking was never added.  It does show up in the HELP though.</p>
<pre><code>red&gt;&gt; help stringy
USAGE:
     STRINGY a b

DESCRIPTION: 
     STRINGY is a function! value.

ARGUMENTS:
     a             
     b             

RETURNS:
     [string!]
</code></pre>
<p>Note that they also put the RETURNS: at the end there, too.  Most people would expect the return value for functions to be the first thing you put down.</p>
<h2>
<a name="ive-wondered-if-a-leading-block-would-suffice-3" class="anchor" href="https://forum.rebol.info#ive-wondered-if-a-leading-block-would-suffice-3"></a>I've Wondered If A Leading Block Would Suffice...</h2>
<p>Off and on, I've been willing to consider the idea that return typing is just implicitly what you get if you have a leading block:</p>
<pre><code>double-multiply: func [
    [integer!]
    value1 [integer!]
    value2 [integer!]
][
   return 2 * value1 * value2
]
</code></pre>
<p>Yet while it looks clean there, it causes some problems when you are filling in documentation strings.</p>
<p>I've become a pretty true believer in the idea that documentation strings for arguments come after the argument name (and that we may do a service to the userbase by standardizing this, rather than by letting it be done either way and have people fight about it):</p>
<pre><code> my-style: func [
     "Overall function description here"
     argument "Argument description here"
         [integer! text!]
     /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>The rationale is that any good function will put labels on all its arguments.  But not all arguments are type-constrained, in particular refinements are not.  So you wind up either being inconsistent</p>
<pre><code> variation1: func [
     "Overall function description here"
     argument [integer! text!]
         "Argument description here"
     /refinement "Refinement description here"  ; this feels inconsistent
 ][
    ...
 ]
</code></pre>
<p>Or you're throwing in newlines for no reason</p>
<pre><code> variation2: func [
     "Overall function description here"
     argument [integer! text!]
         "Argument description here"
     /refinement
         "Refinement description here"  ; consistent, but annoying
 ][
    ...
 ]
</code></pre>
<p>This is why I chose "MY-STYLE" above.  But if return becomes implicit on a leading block, you wind up back in inconsistent land:</p>
<pre><code>my-style-with-leading-block: func [
     "Overall function description here"
     [integer!] "Description here"
     argument "Argument description here"
         [integer! text!]
     /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>So one thing RETURN: has historically bought us is making that look better:</p>
<pre><code>my-style-with-leading-block: func [
     "Overall function description here"
     return: "Description here"
         [integer!] 
     argument "Argument description here"
         [integer! text!]
     /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>And I think having the word RETURN in there makes it better.  Note how it's less obvious when the word isn't there what that is.</p>
<h2>
<a name="but-set-word-is-that-best-4" class="anchor" href="https://forum.rebol.info#but-set-word-is-that-best-4"></a>But SET-WORD!... is that best?</h2>
<p>If we're going to be allowing SET-WORD! for locals and statics, does it make sense to have a stray SET-WORD! for RETURN?</p>
<p>And one outside-the-box thought... given that modern FUNC doesn't allow you to name parameters RETURN, why not just go with a plain WORD! ?</p>
<pre><code>what-about-plain-word: func [
    "Overall function description here"
    return "Description here"
        [integer!] 
    argument "Argument description here"
        [integer! text!]
    /refinement "Refinement description here"
 ][
    ...
 ]
</code></pre>
<p>If you try that with a LAMBDA you'll not get an error, and maybe suffer some confusion when the lambda gets its first argument as a variable named RETURN.  You'll figure it out pretty quickly, though.</p>
<p>Though I have wondered about questions like "what if you want the behavior of a lambda with the bottom expression dropping out, and no RETURN declared, but you still want type checking?"</p>
<p>You might say "just use ENSURE"</p>
<pre><code> my-lambda: lambda [
    "Overall function description here"
    argument "Argument description here"
        [integer! text!]
    /refinement "Refinement description here"
 ][
    ensure [integer!] [
        ...
    ]
 ]
</code></pre>
<p>The problem is that the return type and any description don't make it to the HELP.  This is one reason that I pretty much always use FUNC.</p>
<p>This makes one want to lean back to the return type being something nameless, like just a leading block.</p>
<h2>
<a name="not-sure-on-return-but-i-like-set-word-locals-5" class="anchor" href="https://forum.rebol.info#not-sure-on-return-but-i-like-set-word-locals-5"></a>Not Sure On RETURN, But I Like SET-WORD! Locals</h2>
<p>I definitely feel that finding a way to not be using SET-WORD! for RETURN: would be good.  It's not like it has anything to do with assignment.</p>
<p>Plain word RETURN in FUNC is not an idea that I'm feeling is as crazy as it might sound.</p>
<p>I do think that I like the idea of SET-WORD! for local initialization... that runs the right hand side without required parentheses, and that only runs the evaluation once in the environment of the spec block... stowing that value in the currently-just-trash slots of the frame archetype for the local.</p>
<p>And I like the idea of bringing <code>&lt;static&gt;</code> on board with the same rules.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210</link>
          <pubDate>Sat, 24 Aug 2024 03:00:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2210</guid>
          <source url="https://forum.rebol.info/t/set-word-to-initialize-locals-in-function-specs/2210.rss">SET-WORD! To Initialize Locals In Function Specs?</source>
        </item>
        <item>
          <title>Cave-In: GUI Game In Red</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>GUI</category>
          <description><![CDATA[
            <p>Because I've idly started to think about what a Ren-C GUI dialect would look like (leveraging the web browser layout engine, of course), I've decided to reluctantly learn about Rebol's historical GUIs.  VID code has traditionally been an eyesore for me, but in the coming months I'll try to dedicate a little time to look at examples--both old and new--from all the various incarnations of the VID dialect <em>(<a href="https://www.rebol.com/docs/view-guide.html">VID</a>, <a href="https://github.com/red/docs/blob/master/en/vid.adoc">Red VID</a>, <a href="https://codeberg.org/hiiamboris/red-spaces/src/branch/master/vids.md">VID/S (Spaces)</a>, <a href="http://www.dobeash.com/rebgui.html">RebGUI</a>, <a href="http://www.rebol.org/view-script.r?script=glayout.r">GLASS</a>, and I've just found out that <a href="https://github.com/red/docs/blob/master/en/draw.adoc">DRAW is a different dialect from VID</a> so there's probably at least 12 more variants of all this stuff)</em></p>
<p>To try and have a little fun with my first one, I'll look at the game <strong>"Cave-In"</strong> by <span class="mention">@PlanetSizeCPU</span> from Red Gitter:</p>
<p><img src="https://gitter.ems.host/_matrix/media/v3/download/gitter.im/e0c12d3abca5509745b25a32a6866b3a502273791811281938799919104?allow_redirect=true" alt="Level.gif" width="637" height="500"></p>
<h2>
<a name="the-code-1" class="anchor" href="https://forum.rebol.info#the-code-1"></a>The Code</h2>
<p>The code is <a href="https://github.com/planetsizecpu/Cave-In">available on GitHub</a>, and it has been committed to as recently as July.</p>
<p>Curiously, the level definitions themselves <a href="https://github.com/planetsizecpu/Cave-In/blob/master/zLevelsDesign.txt">are not in Red syntax</a>.  They're like CSV files, except they use vertical bar as a separator instead of comma, and <strong>#</strong> for to-end-of-line comments</p>
<pre><code># ItemType|ObjectName|FaceName|FaceSize|FaceOffset|Rate|...
...
CAVERN|cavern1|cave|1599x600|0x0|0:0|0x0|0:0|0|0|cavern.png
GOLDBG|gold1|gld1|8x12|340x564|0:0|0x0|0:0|0|1|gold1.png
GOLDBG|gold2|gld2|8x12|310x461|0:0|0x0|0:0|0|1|gold1.png
GOLDBG|gold3|gld3|8x12|650x51|0:0|0x0|0:0|0|1|gold1.png
GOLDBG|gold4|gld4|8x12|200x185|0:0|0x0|0:0|0|1|gold1.png
...
</code></pre>
<p>The implementation is just <a href="https://github.com/planetsizecpu/Cave-In/tree/master/src">four<code> .red</code> source files</a>, three of which are small and the main implementation lives in something called <strong><code>makegame.red</code></strong></p>
<p><a href="https://github.com/planetsizecpu/Cave-In/blob/master/src/makegame.red">https://github.com/planetsizecpu/Cave-In/blob/master/src/makegame.red</a></p>
<h2>
<a name="theres-an-observable-lack-of-rebolism-2" class="anchor" href="https://forum.rebol.info#theres-an-observable-lack-of-rebolism-2"></a>There's an Observable Lack Of... <em>"Rebolism"</em>
</h2>
<p>I don't want to be too critical of someone's early efforts in programming.  This actually reminds me a lot of when I was a kid and got Turbo Pascal for a 286 PC, and tried to write a variation of <a href="http://blog.hostilefork.com/media/machine-language-commodore-64-128/react-compute-gazette.png">a Commodore 64 game called "React"</a>.  The example snippets I learned from were very simple and none even showed you how to break your code into different files, so I just had one long .PAS file... that grew and grew.  Instead of seeing the growing code with tons of conditionals as a problem, I was kind of excited about how big it was getting!</p>
<p>But that aside, there clearly are a lot of repetitive patterns and lack of abstraction.  To pick on <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/makegame.red#L462C1-L474C4">one short example at random</a>:</p>
<pre><code>if (first f/extra/name) = #"a" [
    foreach img GameData/AgentDead [f/image: get img wait GameData/AgentDeadDelay]		
]
if (first f/extra/name) = #"f" [
    foreach img GameData/FAgentDead [f/image: get img wait GameData/AgentDeadDelay]		
]
if (first f/extra/name) = #"p" [
   foreach img GameData/PAgentDead [f/image: get img wait GameData/AgentDeadDelay]		
]
if (first f/extra/name) = #"y" [
    foreach img GameData/YAgentDead [f/image: get img wait GameData/AgentDeadDelay]		
]
</code></pre>
<p>But you can see that large-scale repetition of this kind is pervasive.</p>
<p>What I find perplexing is that if people aren't using Rebol's mechanisms, what do they actually <em>like</em> about the language enough that keeps them going with it?</p>
<p>Ren-C takes the refactoring and streamlining potential to new heights.  It makes it easier to put expressions all on one line with good error locality with <a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880">VOID-in-NULL-out</a>.  It gives you foolproof <a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/9">truthiness of any item you can put in a block</a> (only antiforms can be are falsey).  NIHIL lets you use <a href="https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171/2">put code midstream in any evaluative context without disturbing it</a>, for things like ASSERT and ELIDE to be anywhere you please.  <a href="https://forum.rebol.info/t/the-simple-yet-powerful-magic-of-the-loop-result-protocol/609">The loop result protocol is super neat</a>, and I could go on and on...</p>
<p>...but the basic idea of enabling smooth composition has been there since Rebol2, e.g. you could rewrite the above as:</p>
<pre><code>if (dead: select [
    #"a" AgentDead
    #"f" FAgentDead
    #"p" PAgentDead
    #"y" YAgentDead
] first f/extra/name) [
    foreach img GameData/(dead) [
       f/image: get img wait GameData/AgentDeadDelay
    ]
]
</code></pre>
<p>As Carl said in <a href="https://forum.rebol.info/t/rebols-target-market-newbies-experts-or-other/581"><strong>Rebol: Not for everyone?</strong></a>:</p>
<blockquote>
<p><em>"I've glanced over a lot of REBOL code written by a wide variety of programmers, and quite often I'm floored. Many programmers use REBOL like they're writing in C or BASIC. I can spot it in an instant; they did not bother to learn the fundamental concepts of the REBOL language. When I see that kind of code, I wonder why they bothered to use REBOL at all. C is better written in C. You will never hear me contest that fact."</em></p>
</blockquote>
<p>...but the appeal may be "I <strong>can</strong> Use It Like BASIC!"  I dunno.</p>
<h2>
<a name="timers-and-frame-rates-3" class="anchor" href="https://forum.rebol.info#timers-and-frame-rates-3"></a>Timers And Frame Rates</h2>
<p>The <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/cave.red#L113">definition of the main "layout" GameScr(een)</a> includes a size and position, and uses what appears to be a RATE dialect keyword:</p>
<pre><code>GameScr: layout [
    title "Cave-In"
    size 800x600
    origin 0x0
    space 0x0

    ; Info field is also used for event management!
    at 10x610 info: base 780x30 orange blue font [
        name: "Arial" size: 14 style: 'bold
    ] focus 
    rate GameData/GameRate on-time [
        info/rate: none 
        if CheckStatus [alert "END OF GAME" quit] 
        info/rate: GameData/GameRate
    ]
]
</code></pre>
<p>RATE is defined <a href="https://www.rebol.com/docs/view-guide.html">in the VID dialect</a> as:</p>
<blockquote>
<p><strong>rate</strong> - An INTEGER or TIME that specifies the rate of time events for a face. This is used for animation or repetitive events (such as holding the mouse down on certain types of user interface styles). An INTEGER indicates the number of events per second. A TIME provides the period between events.</p>
</blockquote>
<p>Cave-In apparently uses the time-based parameter, <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/cave.red#L29C2-L34C3">which it initializes and then overwites</a>.</p>
<pre><code>GameRate: 0:00:00.003
either system/platform = 'Windows [
    ; Win cant handle 3ms rate so it goes as fast as possible
    GameRate: 0:00:00.006
][
    ; For other OSs as GTK we must test this value as they handle right
    GameRate: 0:00:00.065
]
</code></pre>
<p>So I take it that <strong><code>rate &lt;time or integer&gt; on-time [...]</code></strong> means that you want callbacks to run the code in the block at the given rate.  I'm not clear on why you would say ON-TIME there vs. just put the block there.</p>
<p>Searching <a href="http://rebol.org">rebol.org</a> for other VID examples using rate, I found <a href="http://www.rebol.org/view-script.r?script=tweener.r"><code>tweener.r</code></a> that does:</p>
<pre><code> rate 1 feel [
     engage: func [face action event] [...]
 ]
</code></pre>
<p>I don't know if ON-TIME is Red-specific or what, or what other things you can put there, or what this means.</p>
<p>There is actually code here for <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/cave.red#L174">adjusting the timings for different CPUs</a>.  That seems to undercut Red's value proposition if that's necessary...isn't this supposed to be speaking about a concrete amount of time that works on all platforms?</p>
<h2>
<a name="main-game-4" class="anchor" href="https://forum.rebol.info#main-game-4"></a>Main Game</h2>
<p>Anyway, the spawning of a modal graphic window instance is done with VIEW.  There's a splashscreen instantiation via VIEW, then a settings instantiation via VIEW, then an instance of GameScr with:</p>
<pre><code>view/options GameScr [
    actors: context [on-key: func [face event][CheckKeyboard face event/key]]
]
</code></pre>
<p>So I'm not clear on what the /OPTIONS is for, that can't be specified in the layout itself.  The <a href="https://www.rebol.com/docs/words/wview.html">Rebol2 documentation for VIEW says</a>:</p>
<blockquote>
<p>Additionally, calls to view can specify options, such as whether the window has borders and is resizable. Single options are provided as a word and multiple options are specified in a block.</p>
<pre><code>out: layout [vh1 "This is a window."]
view/options out [resize no-title]
</code></pre>
</blockquote>
<p>As per usual, I'm baffled...what goes in the layout and what doesn't?  Why isn't Cave-In able to just <strong><code>view GameScr</code></strong> with the keyboard handler mentioned alongside the rate timer in the definitoin of GameScr?</p>
<p>In any case, the code that runs at the RATE calls <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/makegame.red#L15">a function <code>CheckStatus</code></a> that does some work, and returns a truthy value if the game is over or a falsey value to keep on going.</p>
<p>CheckStatus adds the effect of gravity to objects, but that particular global timed function doesn't do things like make the bad guys move around.  It seems individual objects have timers associated with them, e.g. when an "Agent" is being instantiated from a Level <a href="https://github.com/planetsizecpu/Cave-In/blob/2ae789594f9bc38ff1fd310fbc184c9bc4452cd9/src/loadlevel.red#L139">it makes a FACE! which has its own RATE set</a>, leading to callbacks of its own ON-TIME function:</p>
<pre><code>"A" [  ; "(A)gent"
    set (w) make face! [
        type: 'base
        size: ItemObj/size
        offset: ItemObj/offset
        image: copy ItemObj/image
        extra: ItemObj
        rate: ItemObj/rate
        actors: context [
            on-time: func [f e][AgentMotion f]
        ]
        ItemObj/lives: 64
    ]
    append cave/pane (get w)
]
</code></pre>
<p>So then <code>AgentMotion</code> does the updating.</p>
<h2>
<a name="okay-i-understand-this-one-5" class="anchor" href="https://forum.rebol.info#okay-i-understand-this-one-5"></a>Okay, I Understand This One</h2>
<p>I can see a little bit of the appeal for why someone would have fun hacking on it this way.  Red is giving you some game-engine type autonomy to all the objects, with each face its own timer.  You get some very simple things like an <a href="https://github.com/red/red/blob/dbc93da47047667023a66c5edf1aa1d63ff6f0d0/modules/view/utils.red#L44"><strong><code>overlap?</code></strong> utility function</a> to see if two faces overlap (though it just checks bounding boxes, not collision detection on non-transparent portions).</p>
<p>Now that I'm learning a bit of the terminology, this isn't really using "VID" the dialect hardly at all.  The only VID code is in <a href="https://github.com/planetsizecpu/Cave-In/blob/master/src/cave.red">%cave.red</a> and it does nearly nothing.</p>
<p>But it's using "View", which is kind of like a browser layout engine.  VID is a shorthand for building View code--it's maybe a little like HTML for declaratively specifying the starting point of the DOM...that then gets dynamically juggled all around as objects after that.</p>
<p>Cave-In basically is like one of those pages where if you "View Source" the .HTML is nearly empty, and everything is created dynamically with code.  But that code does not leverage small VID fragments, the way some dynamic JavaScript might use HTML snippets to build DOM code.  (Could it?)</p>
<p>I'll add that I notice nowhere in the source for Cave-In is the <strong><code>on-change*</code></strong> method used, so this isn't using the <a href="https://www.red-lang.org/2016/06/061-reactive-programming.html">"reactive programming" features added by Red</a>, FWIW.</p>
<p>Tune in next week (month?) when I set aside some time to look at another Rebol GUI thing.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/cave-in-gui-game-in-red/2209">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/cave-in-gui-game-in-red/2209</link>
          <pubDate>Fri, 23 Aug 2024 23:08:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2209</guid>
          <source url="https://forum.rebol.info/t/cave-in-gui-game-in-red/2209.rss">Cave-In: GUI Game In Red</source>
        </item>
        <item>
          <title>No Raised Errors in PACK! (But Feel The Power!)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>I haven't been completely thrilled about being able to put raised errors in parameter packs.  But initially, I allowed it:</p>
<pre><code>&gt;&gt; block: []
== []

&gt;&gt; pack [take block, 10 + 20]
; first in pack of length 2
== ~make error! [
    type: 'Script
    id: 'nothing-to-take
    message: "Can't TAKE, no value available (consider TRY TAKE)"
    near: '[take [] **]
    where: '[take reduce pack console]
    file: ~null~
    line: 1
]~  ; anti
</code></pre>
<p>Honestly this seems wrong. I allow you to PACK a PACK, and that's okay. But glossing over the error at time of packing I do not like.</p>
<p>I much prefer:</p>
<pre><code>&gt;&gt; pack [take block, 10 + 20]
** Script Error: Can't TAKE, no value available (consider TRY TAKE)
</code></pre>
<h2>
<a name="only-one-use-case-maxmatch-d-and-maxmatch-chttpsgithubcommetaeducationren-cblob8516f0fca8ddce40a97e7647a087dc55e065cf3btestsparseexamplesmaxmatchparsetestreb-1" class="anchor" href="https://forum.rebol.info#only-one-use-case-maxmatch-d-and-maxmatch-chttpsgithubcommetaeducationren-cblob8516f0fca8ddce40a97e7647a087dc55e065cf3btestsparseexamplesmaxmatchparsetestreb-1"></a>Only One Use Case: <a href="https://github.com/metaeducation/ren-c/blob/8516f0fca8ddce40a97e7647a087dc55e065cf3b/tests/parse/examples/maxmatch.parse.test.reb">MAXMATCH-D (and MAXMATCH-C)</a>
</h2>
<p>In practice, only one place was making use of the ability to put raised errors in packs:</p>
<pre><code>maxmatch-D: combinator [  ; "(D)efault"
    {Match maximum of two rules, keeping side effects of both if match}
    return: "Result of the longest match (favors first parser if equal)"
       [any-value? pack?]
    parser1 [action?]
    parser2 [action?]
    &lt;local&gt; result1' result2' remainder1 remainder2
][
    [~^result1'~ remainder1]: parser1 input except e -&gt; [
        pack [raise e, null]
    ]
    [~^result2'~ remainder2]: parser2 input except e -&gt; [
        pack [raise e, null]
    ]
    if raised? unmeta result2' [  ; parser2 didn't succeed
        if raised? unmeta result1' [
            return unmeta result1'  ; neither succeeded
        ]
    ] else [  ; parser2 succeeded
        any [
            raised? unmeta result1'
            (index of remainder1) &lt; (index of remainder2)
        ] then [
            remainder: remainder2
            return unmeta result2'
        ]
    ]
    remainder: remainder1
    return unmeta result1'
]
</code></pre>
<p>Two parsers here are called with two results, and this tries to handle the case of when one "result" is a raised error...putting it into the same slot where a result would be.</p>
<p>The problem is that the EXCEPT statement is producing an expression that is targeting a pack.  And in the first slot of that pack is a potentially-anything-value... anything but a raised error, that is.  If you try to cheat and put a non-raised error in that slot, how would you know the parser you called wasn't just generating an ERROR! value to pass around?  You need another state.</p>
<h2>
<a name="no-other-choice-or-is-there-2" class="anchor" href="https://forum.rebol.info#no-other-choice-or-is-there-2"></a>No Other Choice... Or... Is There?</h2>
<p>The second slot is a series position.  You could poke a plain error there, and by virtue of seeing the <code>remainder1</code> is an ERROR! and not an ANY-SERIES! you'll know that parser1 raised an error.</p>
<p>So instead of:</p>
<pre><code>[~^result1'~ remainder1]: parser1 input except e -&gt; [
    pack [raise e, null]
]
</code></pre>
<p>You'd do:</p>
<pre><code>[^result1' remainder1]: parser1 input except e -&gt; [
    pack [~, e]  ; say result1 is trash, and remainder1 is e
]
</code></pre>
<p>Your variable names are a bit weird here, because it's actually <strong><code>remainder-or-error-1</code></strong>.  But you've built an expression that targets the pack.</p>
<p><strong>But why are we being so stingy about variables?</strong>  Why not expand the pack to three items?</p>
<pre><code>[^result1' remainder1 /error1]: parser1 input except e -&gt; [
     pack [~, ~, e]
]
</code></pre>
<p>(You have to use the <strong><code>/error1</code></strong> syntax if the non-erroring parser case returns a pack with only two items in it.  The slash means you're okay with fewer items in the source pack and it will set error1 to null in that case.)</p>
<p>Or... why are we bothering to make the error case use EXCEPT?  You have TRAP for definitional errors as well.  It returns NULL if no raised error, and the non-raised form of the ERROR! if there was one:</p>
<pre><code>&gt;&gt; trap [1 + 2]
== ~null~  ; anti

&gt;&gt; trap [1 / 0]
== make error! [
    type: 'Math
    id: 'zero-divide
    message: "attempt to divide by zero"
    near: '[1 / 0 **]
    where: '[/ entrap trap console]
    file: ~null~
    line: 1
]
</code></pre>
<p>Leveraging that gives you basically the cleanest code you could ask for:</p>
<pre><code>error1: trap [[^result1' remainder1]: parser1 input]
</code></pre>
<p><em>(Let me point out that the ability to intercept a definitional error coming from PARSER1 by having it "pass through" a SET-BLOCK! (or a SET-WORD!) is a feature to enable precisely this scenario.  None of the assignments will be performed. And <strong>that is the limit</strong> of how far it will jump and be allowed to TRAP before it will be promoted to a failure.  If you're not up to speed on definitional errors, <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">read up on them</a>, because they are absolutely critical to coherent error interception.)</em></p>
<h2>
<a name="so-forget-about-raised-errors-in-pack-3" class="anchor" href="https://forum.rebol.info#so-forget-about-raised-errors-in-pack-3"></a>So Forget About Raised Errors in PACK!</h2>
<p>It's a terrible idea.  I'm killing it off.</p>
<p>Compare the original maxmatch-D to this one using TRAP:</p>
<pre><code>maxmatch-D: combinator [  ; "(D)efault"
    {Match maximum of two rules, keeping side effects of both if match}
    return: "Result of the longest match (favors first parser if equal)"
       [any-value? pack?]
    parser1 [action?]
    parser2 [action?]
    &lt;local&gt; error1 error2 result1' result2' remainder1 remainder2
][
    error1: trap [[^result1' remainder1]: parser1 input]
    error2: trap [[^result2' remainder2]: parser2 input]
    if error2 [  ; parser2 didn't succeed
        if error1 [
            return raise error1  ; neither succeeded
        ]
    ] else [  ; parser2 succeeded
        any [
            error1
            (index of remainder1) &lt; (index of remainder2)
        ] then [
            remainder: remainder2
            return unmeta result2'
        ]
    ]
    remainder: remainder1
    return unmeta result1'
]
</code></pre>
<p>Ren-C gives you power and flexibility to solve your problems in better ways... take advantage of that!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/facepunch.png?v=12" title=":facepunch:" class="emoji only-emoji" alt=":facepunch:" loading="lazy" width="20" height="20"></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/no-raised-errors-in-pack-but-feel-the-power/2206">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/no-raised-errors-in-pack-but-feel-the-power/2206</link>
          <pubDate>Thu, 22 Aug 2024 19:13:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2206</guid>
          <source url="https://forum.rebol.info/t/no-raised-errors-in-pack-but-feel-the-power/2206.rss">No Raised Errors in PACK! (But Feel The Power!)</source>
        </item>
        <item>
          <title>Re-imagining EVAL/NEXT</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Internals</category>
          <description><![CDATA[
            <blockquote>
<p><strong>NOTE:</strong> <a href="https://forum.rebol.info/t/do-of-text-as-synonym-of-do-of-file-containing-string/2125">The nature of DO is to deal with whole scripts</a>.  We know <strong><code>do/next %foo.r</code></strong> doesn't make any sense, and in fact having DO take a BLOCK! of Rebol code should be a dialect about how to load and bind what you pass it... not expressions like <strong><code>do [1 + 2]</code></strong>.</p>
<p>So in modern Ren-C, array evaluation is handled by a primitive called <strong>EVAL</strong>.  Hence the /NEXT refinement has been removed from DO, and for a transitional period DO will not take BLOCK! at all... until all such references are gone.  At which point it will take a dialected LOAD spec, probably aligning closely with what IMPORT takes.</p>
</blockquote>
<h3>
<a name="right-now-evalnext-takes-a-variable-to-store-the-new-position-1" class="anchor" href="https://forum.rebol.info#right-now-evalnext-takes-a-variable-to-store-the-new-position-1"></a>Right Now, EVAL/NEXT Takes A Variable To Store The New Position</h3>
<pre><code>&gt;&gt; result: eval/next [1 + 2 10 + 20] $pos
== 3

&gt;&gt; pos
== [10 + 20]
</code></pre>
<p>This is exactly how Red and R3-Alpha handle DO/NEXT.</p>
<p>It was considered more convenient than how Rebol2 gave you a block of both the result and the new position...which you had to pick apart:</p>
<pre><code>rebol2&gt;&gt; do/next [1 + 2 10 + 20]
== [3 [10 + 20]]
</code></pre>
<p><em>(That couldn't work at all in Ren-C, because evaluation can produce antiforms, and antiforms can't be put in blocks.)</em></p>
<h3>
<a name="one-twist-evalnext-of-returns-a-null-position-2" class="anchor" href="https://forum.rebol.info#one-twist-evalnext-of-returns-a-null-position-2"></a>One Twist: EVAL/NEXT of [] Returns A NULL Position</h3>
<p>If you try to step with /NEXT over a BLOCK! like <strong>[1 + 2 10 + 20]</strong>, then there are EXACTLY TWO steps with meaningful results of 3 and 30.</p>
<p>So if you're going to be doing the evaluations in a WHILE loop, you want the EVAL/NEXT position result to return success twice, and then have a third call that returns null to signal the looping is done.</p>
<p>This gives you the possibly surprising (or not?) result that <code>EVAL/NEXT []</code> doesn't take a step and doesn't synthesize VOID, even though <code>EVAL []</code> is VOID.  It's a terminal condition.  So if you're trying to take steps and generate an overall accumulated result, you have to seed your result with VOID... and then <code>EVAL/NEXT []</code> will tell you there was nothing to do and you return your seeded result.</p>
<p>Make sense?</p>
<p>Rebol2, Red, and R3-Alpha all require you to check for the TAIL? of the block as your terminal condition.  Because DO/NEXT on a tail position just produces an UNSET! and another tail position.</p>
<pre><code>rebol2&gt;&gt; do/next [10 + 20]
== [30 []]

rebol2&gt;&gt; do/next []
== [unset []]

rebol2&gt;&gt; do/next []
 == [unset []]
</code></pre>
<p>That's quite a lot more awkward to handle for a terminal condition.  In fact it forces you to check for TAIL? on the block you're evaluating <em>before</em> the first call to DO/NEXT (because seeing the tail afterward won't tell you if the previous step synthesized a valid UNSET!).</p>
<p>R3-Alpha and Red didn't change this, and still make you check for TAIL? before you take steps:</p>
<pre><code>r3-alpha/red&gt;&gt; do/next [10 + 20] 'pos
== 30

r3-alpha/red&gt;&gt; pos
== []

r3-alpha/red&gt;&gt; do/next [] 'pos
; no console result here means unset

r3-alpha/red&gt;&gt; pos
== []

r3-alpha/red&gt;&gt; do/next [] 'pos
; no console result here means unset

r3-alpha/red&gt;&gt; pos
== []
</code></pre>
<p>Still very awkward, and unclear why they did this instead of making the POS be #[none].</p>
<h2>
<a name="but-ren-c-can-do-even-better-multi-returns-3" class="anchor" href="https://forum.rebol.info#but-ren-c-can-do-even-better-multi-returns-3"></a>But Ren-C Can Do Even Better: Multi-Returns!</h2>
<p>What if EVAL/NEXT turned the return result into a parameter pack, where you get both the evaluation product and the new position?</p>
<p><em>(I'm going to make it so it switches the main return result to be the position, and the secondary result is the evaluation product.  Then I'll explain why.)</em></p>
<pre><code>&gt;&gt; block: [1 + 2 10 + 20]
== [1 + 2 10 + 20]

&gt;&gt; pos: eval/next block  ; don't have to heed both returns
== [10 + 20]

&gt;&gt; [pos /result]: eval/next pos  ; but you can heed both returns
== []

&gt;&gt; result
== 30

&gt;&gt; [pos /result]: eval/next pos
== ~null~  ; anti

&gt;&gt; result
== ~null~  ; anti &lt;- not meaningful, because POS was null
</code></pre>
<p>The reason you (often) need the slash on /RESULT is that when EVAL/NEXT is done, it returns a pure null... not a multi-return.  This makes it correctly reactive to THEN and ELSE, which consider nulls inside of parameter packs to be "something" instead of "nothing".  But if you try to unpack a single null into two slots that is considered not enough.</p>
<p>Using a leading slash on a multi-return unpack is indication that you accept there may not be enough items in the pack to have one for that variable.  We could choose to have the multi-return unpacker make it trash or null, but in general null is more useful.</p>
<p><em>(To distinguish from a null that was actually in a pack and unpacked, you'd have to use <strong><code>^/result</code></strong>...which would meta the value so an unpacked null would be a quasiform ~null~, while the null resulting from too few values in the pack would be the antiform.  Caring about this is rare, but good to have a way to tell the difference if you do care.)</em></p>
<h2>
<a name="why-did-i-make-position-the-primary-return-result-4" class="anchor" href="https://forum.rebol.info#why-did-i-make-position-the-primary-return-result-4"></a>Why Did I Make Position The Primary Return Result?</h2>
<ol>
<li>
<p><strong>It Makes It Easier to Loop Through an Evaluation</strong> - There are some situations where EVAL/NEXT doesn't care about the value synthesized, but pretty much no cases where you don't care about the new position.  Being able to conditionally test if the returned position reached the end of a loop is super convenient.</p>
<pre><code>block: [1 + 2 10 + 20]

while [[block /result]: eval/next block] [
    print ["Step result was:" result]
]
</code></pre>
<p>It's true that with Ren-C's super multi-return powers, you could ask for the second argument to be the overall main result.  But that's uglier, why be ugly?</p>
<pre><code>block: [1 + 2 10 + 20]

while [[result @/block]: eval/next block] [
    print ["Step result was:" result]
]
</code></pre>
</li>
<li>
<p><strong>Avoids Ambiguity When EVAL Result Is Itself A Multi-Return</strong> - Imagine the following kind of confusion if we made the evaluation product the first result instead of the second:</p>
<pre><code>&gt;&gt; block: [1 + 2 comment "I don't care about this"]

&gt;&gt; result: eval/next block  ; I just want the first thing!
== 3  ; great, I didn't want that position anyway

&gt;&gt; block: [pack [&lt;left&gt; &lt;right&gt;] comment "I don't care about this"]

&gt;&gt; [left right]: eval/next block  ; just want to unpack that first thing
== &lt;left&gt;  ; great, just what I expected

&gt;&gt; right
== [comment "I don't care about this"]  ; whaaa? I wanted &lt;right&gt;!
</code></pre>
<p>Encountering problems with this in the past has made me back off from using multi-returns in places they seemed like they would be perfect.  But what I now realize is you simply don't want your primary return result of a multi-return to be something that can itself be a multi-return... unless you <em>really</em> know what you are doing.</p>
<p>If you intend to do something with the evaluation product and want to be truly general, you of course have to be using ^META conventions:</p>
<pre><code>[pos ^result]: eval/next pos
</code></pre>
<p>Whether you need to do that or not depends on what you are doing.  Why are you stepping through arrays one step at a time, anyway?  Usually intermediate results are discarded.  What is it precisely you are looking for?  (Again on my point of why making the position the primary result makes sense... usually you aren't looking at the result at all, you're a dialect and looking at what you advance to at the next position.)</p>
</li>
</ol>
<h2>
<a name="lgtm-1-5" class="anchor" href="https://forum.rebol.info#lgtm-1-5"></a>LGTM <img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=12" title=":+1:" class="emoji" alt=":+1:" loading="lazy" width="20" height="20">
</h2>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/re-imagining-eval-next/767">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/re-imagining-eval-next/767</link>
          <pubDate>Thu, 22 Aug 2024 04:00:00 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-767</guid>
          <source url="https://forum.rebol.info/t/re-imagining-eval-next/767.rss">Re-imagining EVAL/NEXT</source>
        </item>
        <item>
          <title>What To Call the Unstable Antiform of Empty Block?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <blockquote>
<p>I realized that one name among the nothingness antiforms that I don't know is optimal is "NIHIL".</p>
<p>I'll throw it out to the forum to see if there are any better ideas.  But I framed the question for the chatbots to see what they would say.</p>
<p><em>(My question is actually a pretty succinct summary of the situation...probably easier to digest than reading all the rambling that led up to it.)</em></p>
<p>Note that TRASH as described at the outset here was changed to NOTHING, and TRASH is now quasi-blank... the meta-state of nothing (e.g. lone <code>~</code> in source)</p>
<p>Credit for NIHIL actually goes to <a class="mention" href="https://forum.rebol.info/u/gchiu">@gchiu</a> who suggested it a while back, when I was asking what to call an arity-zero COMMENT construct.</p>
</blockquote>
<h2>
<a name="heirarchical-nothingness-in-a-programming-language-1" class="anchor" href="https://forum.rebol.info#heirarchical-nothingness-in-a-programming-language-1"></a>Heirarchical Nothingness In A Programming Language</h2>
<p>I have a programming language in which I have several layers of concepts of "nothing", each with unique properties.</p>
<p><strong>NULL</strong> is like most languages' null in that it is falsey when tested conditionally by something like IF.  But in general, if you pass it in a slot that is not conditional it is considered an error.  It's kind of a "soft failure" signal returned by many routines saying "I couldn't find what you were asking for".</p>
<p><strong>VOID</strong> is a kind of intentional nothingness.  When passed as an argument, it opts out of things...frequently causing the function to return NULL.  If you pass it to a function that tests many things logically <em>(like "are these items all truthy" or "all these items all falsey")</em> it will opt out of voting on the result.  Hence a single conditional test (e.g. passing it to an IF) must error as it isn't definitively true or false in isolation.</p>
<p><strong>TRASH</strong> is used as the contents of an unset variable <em>(like an <code>undefined</code> in JavaScript, perhaps)</em>.  It is also the result of many functions that have no meaningful result to return, such as a PRINT statement <em>(unless you pass PRINT a VOID in which case it returns NULL)</em>.  Trying to reference a variable holding this state will trigger an error, and special operations must be used to test for or extract the state from a variable.  It is conditionally truthy, which comes in handy e.g. if you wish to test the result of a PRINT to know whether it was opted out of or not.</p>
<p>But there is one more kind of nothingness I have to account for, which is a very strange transient state.  It can be an evaluation product but attempting to store it in a variable will trigger an error.  But you don't try to assign it to anything and it's in the middle of a stream of evaluation, then it will just be ignored and you will get whatever the previous result would be.  This makes it useful as the result of things like COMMENT.</p>
<pre><code>&gt;&gt; var: comment "illegal"
** Error: Some Error Message Here

&gt;&gt; 1 + 1
== 2

&gt;&gt; 1 + 1, 10 + 10
== 20

&gt;&gt; 1 + 1 comment "ignore me"
== 2
</code></pre>
<p>This transient state returned from COMMENT needs a name.  Without biasing you on what I've been calling it so far, I'll ask if you have any ideas!</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204</link>
          <pubDate>Wed, 21 Aug 2024 22:40:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2204</guid>
          <source url="https://forum.rebol.info/t/what-to-call-the-unstable-antiform-of-empty-block/2204.rss">What To Call the Unstable Antiform of Empty Block?</source>
        </item>
        <item>
          <title>Code Review Solicitation: C/C++ interface %rebol.h</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <p>The API has been relatively stable for a while, with the only major change this year <a href="https://forum.rebol.info/t/api-breakthrough-scope-detection-in-javascript-and-c/2157">being quite a good one</a>.</p>
<p>The actual %rebol.h file is generated by a <a href="https://github.com/metaeducation/ren-c/blob/master/tools/make-librebol.r">piece of Rebol code</a> that analyzes the <a href="https://github.com/metaeducation/ren-c/blob/master/src/core/a-lib.c">definitions in %a-lib.c</a>.</p>
<p>There I explain the premise of the API, and mention the trickery is accomplished via <a href="https://github.com/metaeducation/ren-c/blob/master/src/include/structs/struct-node.h">non-strict-alias endian-sensitive first-byte access</a>, where patterns are chosen for Cells and Stubs that do not overlap leading valid bytes for UTF-8.</p>
<p><em>(Also explained in the Rebol 2019 video: <strong><a href="http://2019.reb4.me/talks">Abusing UTF-8 For Fun And Profit</a></strong>)</em></p>
<hr>
<pre><code>This is the "external" API, and %rebol.h contains its exported
definitions.  That file (and %make-librebol.r which generates it) contains
comments and notes which will help understand it.

What characterizes the external API is that it is not necessary to #include
the extensive definitions of `struct Series` or the APIs for dealing with
all the internal details (e.g. Push_GC_Guard(), which are easy to get
wrong).  Not only does this simplify the interface, but it also means that
the C code using the library isn't competing as much for definitions in
the global namespace.

Also, due to the nature of the Node superclass (see %sys-node.h), it's
possible to feed the scanner with a list of pointers that may be to UTF-8
strings or to Rebol values.  The behavior is to "splice" in the values at
the point in the scan that they occur, e.g.

    RebolValue* item1 = ...;
    RebolValue* item2 = ...;
    RebolValue* item3 = ...;

    RebolValue* result = rebValue(
       "if not", item1, "[\n",
           item2, "| print {Close brace separate from content}\n",
        "] else [\n",
            item3, "| print {Close brace with content}]\n"
    );

 (Note: C can't count how many arguments a variadic takes, so this is done
 by making things like rebValue() a macro that uses __VA_ARGS__ and tacks
 a rebEND onto the tail of the list.  There's lots of tricks in play--see
 %make-librebol.r for the nitty-gritty details.)

 While the approach is flexible, any token must be completed within its
 UTF-8 string component.  So you can't--for instance--divide a scan up like
  ("{abc", "def", "ghi}") and get the TEXT! {abcdefghi}.  On that note,
 ("a", "/", "b") produces `a / b` and not the PATH! `a/b`.
</code></pre>
<hr>
<p>I think <a class="mention" href="https://forum.rebol.info/u/iarnold">@iArnold</a> may be the only person to have experienced the API at the C level besides myself.  But several people have engaged the JavaScript version, which bridges via WebAssembly to run the exact same code in %a-lib.c through some wrappers.</p>
<hr>
<p>I'm ready for feedback on it, and this post can be a thread for that.  (How's your C/C++, <a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a>?)</p>
<p>Since the <code>rebol.h</code> file is generated and not committed to the repository, I have made a gist of what it compiles to at this moment:</p>
<p><a href="https://gist.github.com/hostilefork/8a8cf776387e9b66fe99ca77f560b5a8" class="inline-onebox">Snapshot of auto-generated Ren-C rebol.h file, 20-Aug-2024 · GitHub</a></p>
<p>There are a couple of bad names (e.g. REBDNG) which are left bad as a reminder that those are parts that need review, so skip those.  The rest is about as good as I've been able to make it.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/code-review-solicitation-c-c-interface-rebol-h/2203">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/code-review-solicitation-c-c-interface-rebol-h/2203</link>
          <pubDate>Wed, 21 Aug 2024 02:05:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2203</guid>
          <source url="https://forum.rebol.info/t/code-review-solicitation-c-c-interface-rebol-h/2203.rss">Code Review Solicitation: C/C++ interface %rebol.h</source>
        </item>
        <item>
          <title>VID Expression Optimization</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>GUI</category>
          <description><![CDATA[
            <blockquote>
<p>I've really dodged looking at any of the GUI dialects and discussions, and the debates on <em>"what's a face, what's a pane, what's a panel"</em>...glancing at it I don't see any there, there.  My experience with the implementation of the GOB! left me thoroughly unimpressed and reinforced how likely non-interesting it is.  When it comes to UI, need I point out that <a href="https://www.youtube.com/watch?v=M-8k8GEGZPM">things like SeaDragon</a> were being demonstrated 17 years ago.</p>
<p>But given that I was <a href="https://forum.rebol.info/t/more-history-mining-rebol-3-0-front-line-blog/2199">going through all the Rebol 3.0 Front Line blog entries</a>, I did stop to look when a post ventured into some philosophy.</p>
<p>The post I stopped to read was <strong><a href="http://www.rebol.net/r3blogs/0135.html">VID Expression Optimization</a></strong>.  For commentary, I'll reproduce it below, all copyright to Carl.</p>
</blockquote>
<hr>
<p>When VID was created for R2, it was a revolutionary new approach to GUI construction, and we did not yet know what was common and what was not. Now, for R3, I think we know more, and we should use that knowledge.</p>
<p>In R2, VID faces were described mainly with a style name, followed by a sequence of datatypes. For example, you could write:</p>
<pre><code>button "Here" "There" red green 100x32 [browse home]
</code></pre>
<p>So, we placed a high value on expressing modifications in a minimal way. This made VID powerful for expression a great number of variations of styles easily, but we should ask, is that the most common usage?</p>
<p>Well, it's great for demos, but beyond that, most applications do not use that many variations of style, and when they do, they normally define them in a style-sheet for easier management, not within the description of a panel.</p>
<p>This is the CSS concept, where variations are provided via property names. I like this approach because it makes the GUI more readable to those who are not experts. You can see more than the value, you get to know what the value relates to.</p>
<p>For example it is clear to write variations of properties in this way:</p>
<pre><code>width: 20%
area-color: blue
text-color: white
edge-color: silver
</code></pre>
<p>So, indeed, that looks a lot like CSS (or should I say that CSS looks a lot like REBOL, interestingly enough), although not totally identical, it is close enough that HTML-aware users will not fear it.</p>
<p>In other words, we do not need to allow ten or more variations of face (style) properties via direct, unnamed datatypes. Instead, let's allow just a few of the main ones, and put the test into a property sheet format with named fields.</p>
<p>I mention this because as we move to the finalization of VID for the standard built-in GUI method, we want to evaluate the usage patterns and apply RISC concepts to make them optimal for users.</p>
<p>We can now re-examine and optimize the top level grammar of VID. I think we can say that, in order of importance, we have:</p>
<ol>
<li>
<p>style (the name, e.g. BUTTON, PANEL)</p>
</li>
<li>
<p>contents (e.g. button text, panel block)</p>
</li>
<li>
<p>name (the set-word label for it)</p>
</li>
<li>
<p>action (what to do on events)</p>
</li>
<li>
<p>variations (of the style)</p>
</li>
</ol>
<p>Let's take an example:</p>
<pre><code>user-name: field "default name"
</code></pre>
<p>Now, if for some reason you need that field to look different, such as use white text on black box area, you would first want to ask yourself if that should be defined as a new style in the style sheet. But, if not, you could write:</p>
<pre><code>user-name: field "default name" with [
    area-color: black
    text-color: white
]
</code></pre>
<p>This specification is simple and clear. Yes, it is a bit more wordy than VID in R2, but I think it is a better approach.</p>
<p>Some of you may be asking, is the word WITH really necessary? To that I would reply in RISCish way: "what is more common?" Is style variation the most common... probably not.</p>
<p>Something like this is will be much more common:</p>
<pre><code>panel [
    button "Yes"
    button "No"
]
</code></pre>
<p>It's quite common, so it seems to me it makes a better choice for the use of a block.</p>
<p>Finally, I want to mention that this subject can go on and on, and everyone will have their opinions. But, let's set opinions aside, because we must think in terms of usage, not in terms of REBOL dialecting capability, which we know is quite unbounded.</p>
<hr>
<p>Copyright © Carl Sassenrath 2008</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/vid-expression-optimization/2202">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/vid-expression-optimization/2202</link>
          <pubDate>Wed, 21 Aug 2024 00:30:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2202</guid>
          <source url="https://forum.rebol.info/t/vid-expression-optimization/2202.rss">VID Expression Optimization</source>
        </item>
        <item>
          <title>More History Mining: Rebol 3.0 Front Line Blog</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>I did a <a href="https://forum.rebol.info/t/mining-history-for-anything-relevant-carls-rebol-blog/2197">quick full skim-through of Carl's Rebol Blog</a>, which split off into a second blog to discuss technical issues in R3-Alpha.</p>
<p>The second blog kicked off on April 6, 2006:</p>
<p><a href="http://www.rebol.net/r3blogs/0001.html">http://www.rebol.net/r3blogs/0001.html - <strong>"Welcome to the REBOL 3.0 Front Line..."</strong></a></p>
<p>It got up to 352 entries, tapping out on February 20, 2011 (which was prior to the open-sourcing):</p>
<p><a href="http://www.rebol.net/r3blogs/0352.html">http://www.rebol.net/r3blogs/0352.html - <strong>"Relative speeds from compiler optimizations"</strong></a></p>
<h2>
<a name="again-im-skimming-it-for-anything-useful-1" class="anchor" href="https://forum.rebol.info#again-im-skimming-it-for-anything-useful-1"></a>Again, I'm Skimming It For Anything Useful</h2>
<p>However <strong>there is a lot more here to react to</strong>.  This could take days!</p>
<p>But I do think it's worth it, in part just to kind of help put together a big picture of where this project was and where it is now.</p>
<ul>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0002.html">Introduction of TYPESET!</a></strong> - Oh... Rebol2 didn't have them?  <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"> Well, neither does Ren-C... <a href="https://forum.rebol.info/t/the-typeset-representation-problem/1300/12">typesets are replaced by type constraints</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0003.html">MAKE Function Used To Be Variadic</a></strong> - I don't think I'm a fan of MAKE being variadic, but I have questioned the idea that <a href="https://forum.rebol.info/t/debunking-the-arity-1-make/1591">there even need to <em>be</em> a MAKE FUNCTION!</a>, vs just having FUNC be an arity-2 native to start with.  This actually may be more prescient than I imagined, as there is no function datatype any longer... <a href="https://forum.rebol.info/t/taking-action-on-function-vs-action/596/6">functions are just antiform FRAME!s</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0006.html">To COPY or not COPY</a></strong> - I've sometimes critiqued Carl for seeming to have not confronted Rebol's actual core flaws head on.  But here he does...mentioning new users getting bitten by mutability -and- also the problems from mutable binding on a block being passed in to two different MAKE OBJECT! calls.  I've been satisfied with Ren-C's answer to the first issue by the <a href="https://forum.rebol.info/t/value-vs-series-modification-bit-const-and-mutable/976">CONST implementation</a>--which has held up super well for years now.  And <a href="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190">how object creation works</a> is undergoing a renaissance as I type this...no mutable binding (or even virtual blanket binding) required.</p>
<ul>
<li>It turns out there was a period in R3-Alpha where it was deep copying object specs <a href="http://www.rebol.net/r3blogs/0212.html">and people eventually complained</a>.  He says he was waiting to see if anyone noticed.  I do think it goes to show how little truly sophisticated Rebol code there was in practice, for people to not be able to tell sooner.</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0007.html">Hot Errors Removed</a></strong> - He says <em>"These hot errors turned out to be overkill, and the benefit of error locality was offset by the difficulty of handling error values in general."</em>  But in effect this is another decision where Ren-C went more in a Rebol2 direction, <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-errors/1852">introducing a whole new antiform error design</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0008.html">No Out Of Range Errors With FIRST, SECOND, etc.</a></strong> - Because an early development of Ren-C was to make FIRST, SECOND, etc. specializations of PICK... I'd always thought of them as being related.  Apparently at one time they were not.  In any case, the issue of range errors has been something that's crossed my mind... and I think I'd rather you have to say <strong><code>try fourth</code></strong> in order to tolerate out of range errors.  <a href="https://forum.rebol.info/t/why-doesnt-third-1-2-trigger-a-range-check-error/1825/4">But the unification of PICK mechanics and TUPLE! selection, e.g. <strong><code>block.3</code></strong> is the same as <strong><code>pick block 3</code></strong> throws a wrench in it.</a>  This is still an open question.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0009.html">The 64-bit question</a></strong> - Wow, this is still not decided.  Ren-C still uses 32-bit indices (but stores them as <code>int_fast32_t</code> etc. so they'll use 64 bits of space if the registers make it faster).  It hasn't been an issue at the forefront.  I'm more interested in distinguishing in the code distinct datatypes for 1-based "Index" vs. 0-based "Offset" and making sure those are distinct types that are harder to mix up.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0010.html">JIT Binding</a></strong> - I've never heard of this and don't believe I saw any code for it.  On the surface it sounds like a relative of virtual binding, but it mutates the bindings in the block permanently and just sounds like something strange that never saw the light of day.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0011.html">Debug Hook</a></strong> - Here he talks about being able to essentially break into the console at the moment of a FAIL and inspect the stack.  One thing about historical Rebol is that because error trapping was frequent (e.g. ATTEMPT etc.) and being used as a programming style, you'd be getting a lot of false hits.  Ren-C's error handling model is such that if you handle an error that is generally done by reacting to a RAISE before it's actually promoted to a FAIL, so you would not be getting broken into the debugger constantly in the casual operation of your code.  We do need this.  I believe in my heart that I am being attentive to the needs of a debugger, but there some more giant issues to knock down first.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0012.html">CLOSURE functions</a></strong> - nope, <a href="https://forum.rebol.info/t/relative-binding-and-frame-internals/1344">all functions are closure-semantics now</a>...without the crazy overhead of deep copying and binding the body of a function on every call!</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0013.html">ALIAS</a></strong> - Old ALIAS was removed long ago, because it was crazy.  I've written about <a href="https://forum.rebol.info/t/the-return-of-alias/2129">reviving this idea more reasonably for modern times</a>.</p>
<ul>
<li>When <a href="http://www.rebol.net/r3blogs/0242.html">Carl wrote about his feelings about removing ALIAS</a>, he said <em>"Perhaps you've seen a change in my attitude... considering how long it's taking to get R3 out the door!"</em>
</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0014.html">HASH!</a></strong> - I covered this in the other blog response, but the comments here might be useful.  <a href="http://www.rebol.net/r3blogs/0052.html">He talks about it in a later post as well.</a>  And then again, <a href="http://www.rebol.net/r3blogs/0054.html">offers some conclusions</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0015.html">Getting More Information From FOR-EACH</a></strong> - Asking for not just the item but the series position is one idea.  But coming up with ways to ask for more information in enumerations has been explored a number of places.  I've wanted to be able to enumerate and know things like "is this the last element" or "is this the first element" and be able to check that easily.  <span class="mention">@hiiamboris</span> has a fancy FOR-EACH that <a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/new-each.red#L613">if you use a refinement in the spec it assumes you want the index at that position</a>, etc.  These are interesting ideas, so definitely want to look into them.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0016.html">OBJECT! Field Type Constraints</a></strong> - I've wondered about this.  It's definitely the case that languages which don't support type information wind up having another language layered on top of it that does (e.g. TypeScript).  But this was never in R3-Alpha, and hasn't been a priority.  I note <a href="http://www.rebol.net/r3blogs/0042.html">he also mentions this kind of type constraint in module specs.</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0017.html">! and !=</a></strong> - I was never a fan of adding <strong><code>!</code></strong> but we do support <strong><code>!=</code></strong> My biggest problem is that != and == are a pair in C, but not a pair in Rebol: != is paired with = for lax equality, and !== is paired with == for strict equality.  That makes it more confusing than anything, and I've meant to resolve this but it's another thing that's slipped.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0019.html">Considering Setters</a></strong> - I've mentioned in the past that Ren-C might have an answer to this, where you could use something like <strong><code>obj.member.</code></strong> to get at the "real" value bypassing the functions that assign them.  There's a big bag of tricks in Ren-C to implement these kinds of features, but seems there's always something more foundational to attack. R3-Alpha had no code for it, though <a href="https://www.red-lang.org/2014/12/050-objects-support.html">Red has ON-CHANGE* to react to assignments</a>.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0020.html">Bye Bye System Object?</a></strong> - The idea of making changes to Rebol to support multitasking the way it was being done was fundamentally flawed.  Needless to say the system object is still there (though <a href="https://forum.rebol.info/t/system-object-vs-sys-context/1687">the "system context" is now SYSTEM.UTILITIES, or SYS.UTIL for short</a>.)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0024.html">Should All Functions Return Values</a></strong> - Returning an UNSET! was a "value", just an ornery one historically, e.g. <strong><code>x: print "hello"</code></strong> was an error in Rebol2 and it remained one in R3-Alpha.  Though it has been debated, in Ren-C <a href="https://forum.rebol.info/t/why-doesnt-print-return-void-or-vaporize-via-nihil/1466">PRINT returns NOTHING</a> <em>(the moral equivalent of UNSET!)</em> and is legal to assign to a variable...it just unsets it.  The only thing that you can't assign is an empty block antiform (a multi-return parameter pack), because when empty it is considered to be holding no values.  This is called NIHIL and it is rarely returned.</p>
<ul>
<li>So... the answer here is "kind of" and the only remaining question is <a href="https://forum.rebol.info/t/the-truthiness-of-nothing/2180">should NOTHING be considered meaningfully truthy or falsey</a>  On a later blog <a href="http://www.rebol.net/r3blogs/0207.html">there was a vote taken</a> about how functions treat UNSET!</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0025.html">Leaky Functions</a></strong> - Not knowing this discussion was taking place in May 2006, <a href="https://forum.rebol.info/t/how-attached-are-we-to-functions-return-last-result/1219">I made a similar argument here in September 2019</a>.  But there's <a href="https://forum.rebol.info/t/implicit-execution-of-return-in-functions-bad/1656">an additional wrinkle that Ren-C has unique customizable per-function RETURN definitions</a>.  So it's pretty much a slam dunk to make the change, and introduce LAMBDA as both returning its body result and not having a RETURN.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0026.html">BIND Expands Contexts</a></strong> - Carl says <em>"A few of you will ask: why does this matter? The main reason is memory (something we are optimizing on R3.0). Why force allocation for "free" variables (module variables) that are never used?"</em>  Everything is different in Ren-C, though it does deal with <a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128">something called "Attachment Binding"</a> where module variables actually are not allocated until they are used.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0029.html">Current Module</a></strong> - I actually thought he was speaking about there being something available in a module similar to a SELF or THIS, which seemed like a pretty good idea. But instead he's talking about running DO on something and it expanding the module you called it from.  Ren-C doesn't do this, DO runs its code isolated and can only give you back its final result.  You have to use IMPORT if you want to bring in new definitions to the module.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0032.html">UNICODE Support</a></strong> - It is interesting to see the considerations here, where it seems being able to load old LATIN-1 scripts was a concern.  No consideration of UTF-8 Everywhere is given for storage, <a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">but that's what Ren-C does</a>.  He's wary of allowing UTF-8 in scripts themselves: <em>"Another possibility would be to allow UTF-8 encoding within strings in the source code. The advantage is that you will be able to view the strings in the appropriate editor. The disadvantage is that the script would contain a range of odd looking characters."</em>  I have thought that being able to limit what Unicode is permitted as a kind of security measure might be important, but there are higher priority issues.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0034.html">"Scant" Evaluation</a></strong> - FWIW, I do not really believe in the premise of scant evaluation.  I think if you do something like <strong><code>construct/only [foo: true bar: 'f]</code></strong> then you get FOO as the WORD! true and not the logic, and you deal with it with tests like <strong><code>== 'true</code></strong>.  I guess I have to see more examples, but I've only seen this in module headers and I prefer the you-get-what-you-see version.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0035.html">At a Class Crossroads</a></strong> - <a href="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190">I just brought this post up recently.</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0045.html">Overwriting System Functions</a></strong> - He mentions the general problem that since modules import their own copy of system functions under a word in their own variable space, they won't see changes made to the variable in the system.  He talks about making some kind of "search and replace re-set" that would find all those imported stubs and fix them up.  I've been thinking in pursuing this through <a href="https://forum.rebol.info/t/the-return-of-alias/2129">allowing variables to alias other variables</a>, so what you import starts out by default as an indirection and sees changes in the original.  But sSo far, if you want to hook a system function, in Ren-C, <a href="https://forum.rebol.info/t/monitoring-a-single-function-with-enclose-and-hijack/425">you have the option of HIJACK-ing the identity of the function value itself</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0048.html">Free Variables in Modules</a></strong> - I dislike these but the codebase has not been retrofit to not use them.  Only LIB and SYS.UTIL are currently enforced to not be able to create them.  But I think you shouldn't be able to by default anywhere (e.g. "strict mode" in JavaScript).</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0049.html">Source Reflection Returning Unbound Copies</a></strong> - Again speaking somewhat from a security standpoint, Carl points out that if a module gives you a function you can get at its source code, and if you can get at its source code you can get at its bindings, and if you can get the bindings then you can reach the data.  I think being able to get the source code itself would be problematic in this adversarial situation--with or without the bindings.  It would be nice if some day people go over the language and make it secure, but I think we're well into the phase where making it good and interesting is far more important.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0050.html">Should a Module Be Loadable More Than Once</a></strong> - e.g. if you are using different versions as dependencies of other different modules.  Hmmm.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0057.html">Do We Dare Add ++ and --</a></strong> - Ren-C addresses this with ME and MY.  e.g. <strong><code>counter: me + 1</code></strong>, <strong><code>counter: me * 10</code></strong>.  It fetches the value of the SET-WORD! on the left and substitutes that for ME.  It's a lot nicer, and saves ++ and -- for weird symbolic purposes.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0059.html">Deprecating CONTEXT</a></strong> - He's opposed to it because CONTEXT creates an OBJECT!, but there's no such thing as a CONTEXT! datatype.  I'm opposed to it based on it being a noun.  I'm thinking WRAP might be best applied to what this does.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0063.html">How Best to Blockify?</a></strong> - He proposes BLOCKIZE for what I call ENBLOCK (e.g. envelope/enclose in a block).  BLOCKIFY is something where if what you have in your hand isn't already a block, it will wrap it it one. <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0064.html">DIR?</a></strong> - I came to be of the belief that all directories must end in a slash, and we enforce this systemically.  Hence DIR? is just a question of whether a FILE! ends in a slash or not.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0069.html">PORT! Redesign Objectives</a></strong> - This probably belongs in the <a href="https://forum.rebol.info/t/what-is-a-port/617">What is a PORT! discussion</a>.  More to add there:</p>
<ul>
<li><a href="http://www.rebol.net/r3blogs/0070.html">problem with DELETE</a></li>
<li><a href="http://www.rebol.net/r3blogs/0071.html">problem with RENAME</a></li>
<li><a href="http://www.rebol.net/r3blogs/0128.html">SKIP and SEEK</a></li>
<li><a href="http://www.rebol.net/r3blogs/0130.html">OSI Model and PORT!</a></li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0078.html">Lexical Exceptions in LOAD</a></strong> - I'm against finding a way to load e.g. <strong><code>1st</code></strong>.  Ren-C gives you <strong><code>1.st</code></strong> if you want it.  This isn't a good investment of energy.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0084.html">IO Devices in R3</a></strong> - And all of <a href="http://www.rebol.net/r3blogs/0087.html">the Device Model</a> is happily gone. <a href="https://forum.rebol.info/t/libuv-integration-has-started-an-i-o-renaissance/1694">We use libUV now</a>, and it's a lot better while still being standard C, cross-platform with many more features, and maintained by other people.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0085.html">None Propagation</a></strong> - <a href="https://forum.rebol.info/t/the-void-in-null-out-protocol/1880">Ren-C has VOID-in-NULL-out</a> and it's working splendidly.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0086.html">Explicit Evaluation Terminator</a></strong> - After a failed attempt to convince people that vertical bar <strong><code>|</code></strong> would be BAR! and serve this purpose, <a href="https://forum.rebol.info/t/the-language-worlds-weirdest-comma-mechanic/1387">we have COMMA!</a>, and it has turned out to be a lot better.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0091.html">R3-Alpha Released to Select Developers</a></strong> - This was June 2007.  <a href="http://www.rebol.net/r3blogs/0094.html">The Beta was expected on July 15, 2007, then delayed (?!)</a>  Well there never was a Beta.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0093.html">Changes in MAKE FUNCTION!</a></strong> - Related to this, I just wrote a sort of new <a href="https://forum.rebol.info/t/make-should-be-using-dialected-constructors/2196">Dialected MAKE Manifesto</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0097.html">WITH and IN</a></strong> - I do admit to liking the <strong><code>do in context [...]</code></strong> construct.  The IN construct is completely virtual binding now.  BIND is still around but uses have been dropping as more and more of the codebase is able to work with virtual binds on top of largely unbound blocks of code, "viewed" several different ways without touching the binding bits.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0100.html">UNSET! As An Argument</a></strong> - R3-Alpha got fairly permissive, e.g. allowing comparisons of UNSET! to other values.  I've brought up that I think it <a href="https://forum.rebol.info/t/the-truthiness-of-nothing/2180">may be a mistake to allow things like comparisons to take NOTHING</a>, and offered justifications for that.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0104.html">Modules Ripping Carl Apart</a></strong> - <em>"I have to admit that so far modules have been, well, too much like taming a tiger. And, so far, the tiger has been winning... often, ripping me to pieces. The tiger is the main reason R3 is running late. Yes, blame the tiger. I've got many scars."</em></p>
<ul>
<li>In 2010 <a href="http://www.rebol.net/r3blogs/0339.html">he blamed them again for another release delay</a>: <em>"Battling the Module Monster, Again"</em>
</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0106.html">Admission that Unicode Was Harder Than Thought</a></strong> - <em>" So, Unicode is the focus of our current development, and it must be clearly stated, <em>this is a non-trivial project</em>. Our goal is to have it ready for initial testing by the end of the month. I'll admit that we under-estimated the magnitude of the Unicode project..."</em></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0107.html">R3 Alpha Public Release</a></strong> - This was in January 2008.  My first encounter with the Rebol language was <a href="http://blog.hostilefork.com/computer-languages-as-artistic-medium/">approximately April 2008</a>, and so I didn't use Rebol2 at all... believing from the community that Rebol3 was the hot new thing.  I didn't realize it had only become public that recently, because everyone else who was involved and talking about it was on the inside track I guess.  I don't know if this timing makes me fortunate or unfortunate, but it certainly explains why I never got attached to a Rebol GUI.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0108.html">ISSUE! as a WORD! datatype</a></strong> - I disagree with this decision (as many did), and in Ren-C it is an immutable textual type..used as the implementation for characters as well (characters are just single-character ISSUE!s).  I've proposed renaming these to TOKEN!.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0111.html">BITSET!s</a></strong> - BITSET! is terribly inefficient and buggy, if you try to do things like XOR a negated bitset with another <a href="http://www.rebol.net/r3blogs/0114.html">none of it works right</a>.  If your bitset is sparse (e.g. representing a Unicode character set, as one might do) then it will quickly consume megabytes.  I did some work with <a href="https://roaringbitmap.org/about/">Roaring Bitsets</a> and linked them up as the implementation for bitsets, which worked well but I didn't feel like maintaining the dependency given higher priorities.  But that branch is still around.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0112.html">The ZERO? Question</a></strong> - I hadn't thought of this.  POSITIVE? rejects non-numbers, NEGATIVE? as well, but ZERO? lets you test series as a simple synonym for <code>= 0</code> but then also considers 0:00 to be ZERO?  Ugh.  I like TRASH? (~) as a placeholder better than zero for many reasons, so the single-character-zero-filler argument doesn't apply.  I think ZERO? should apply to numbers only and error on other types.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0113.html">STRING! is not BINARY!</a></strong> - Because R3-Alpha used variable sized encoding for strings inside the system, it couldn't offer you a usefully invariant binary view of strings.  Ren-C can do it <a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">because it uses UTF-8 Everywhere</a>, and if you're looking at a BINARY! alias of a TEXT! you can make modifications only if that atomic modification leaves the result as valid UTF-8.  You can also alias WORD!s as TEXT! or as BINARY!, but it will be an immutable view.  The benefits inside the system of sticking to one string encoding are innumerable and well worth all the work.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0115.html">Script Error</a></strong> - Hadn't really thought about it but he has a point here.  Something to consider in an ERROR! redesign, if such a design ever happens.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0127.html">Pruning Down READ and WRITE</a></strong> - Despite <a href="http://www.rebol.net/r3blogs/0109.html">earlier assurances that READ and WRITE give BINARY! and it's LOAD that does the fancy work</a>, this shows some of the confusion slipping in about what READ is...and that's what provoked my own confusion at things like READ/STRING and READ/LINES and READ/AS.  Red has these refinements too.  It's all quite confusing, but Ren-C has the advantage of letting you do <strong><code>as text! read %some-file.txt</code></strong> which gives you a mutable alias over the UTF-8 data with no loss of efficiency.  I haven't killed off READ/STRING or READ/LINES but now I feel I really should... that's LOAD's business to have some convenient syntax for.  (Dialected? <strong><code>load %file.r</code></strong> or <strong><code>load [&lt;text-lines&gt; %file.txt]</code></strong>)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0135.html">VID Expression Optimization</a></strong> - So this is the first time I've felt there was something to comment on in a GUI post, since it's dialect philosophy.  <a href="https://forum.rebol.info/t/vid-expression-optimization/2202">I started a thread on it</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0137.html">MAP! Indexing</a></strong> - Again, this is <a href="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057/3">relevant to the determinism I've been discussing</a>, and it's interesting to see there was questioning about it.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0138.html">Multicontext Variable Lookup</a></strong> - Like it or not, this is what we have with Virtual Binding.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0139.html">Find on OBJECT!</a></strong> - He mentions using IN.  But with the binding logic of virtual binding, IN has to return the original item unbound if it wasn't found in the context... so it doesn't give a good answer.  Ren-C uses HAS for this (null if a word not present, vs. the unbound word) and disallows FIND on objects.  Use HAS.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0141.html">RFC: func-local, funclo, funco, funo, funx</a></strong> - Wow, I didn't know the name considerations were so bad...before FUNCTION was chosen.  Ren-C has virtually-bound LET and has dismissed with the bad idea of locals-gathering functions that gather all SET-WORD! as variables.  <a href="https://forum.rebol.info/t/rethinking-auto-gathered-set-word-locals/1150">That is not coherent...</a> SET-WORD!s are used in places where they should not create variables (object keys, other dialects).  So this idea is dead and will only be resurrected as a toy for code golf competitions or similar.  And <a href="https://forum.rebol.info/t/abbreviations-as-synonyms/1211">FUNC and FUNCTION are slated to be synonyms</a>, as all abbreviations are intended to be.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0142.html">Data Conversions that MAKE Sense</a></strong> - This definitely needs to be thought about, but also to eliminate needless duplication between TO and MAKE.  <a href="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649">I've written about the differences and the possible rules.</a></p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0155.html">PARSE Project</a></strong> - While a lot of this has gone offline, I did <a href="https://trello.com/b/zt7KvVSl/rebol-parse-project-the-trello">preserve the remarks from the wiki on a Trello board</a> (that seriously needs updating, now!).  Sigh.  Hurry up AI, I need you to edit all this for me.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/cgi-bin/r3blog.r?view=0165#comments">Angry Comments About A30 Not-Quite-Public Release</a></strong> - Here it's January 2009.  Rebol 3.0 was certainly positioned in a promise-making and not-delivering way, and Red followed that pattern.  Part of what keeps Ren-C from being completely exhausting is not doing that.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0169.html">Inklings of REWORD</a></strong> - It seems the REWORD we have today started with this discussion, right on the heels of the previous feedback also in January 2009.  The design, authorship, and testing of these things simply add up to so much time... it should have been obvious to anyone reading this at the time this would never be finished.  (I wasn't reading it, I didn't get involved until Rebol became open source in 2012...)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0173.html">PICKing Negatives and Zero</a></strong> - Have to admit I haven't thought about this at all in years.  Ren-C reverted to the Rebol2 behavior.  In practice, I don't think it comes up enough for people to care.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0178.html">Weird ASSERT/TYPE Refinement</a></strong> - I didn't like it and didn't see the point, so I killed /TYPE.  Ren-C lets you do <strong>ensure object! spec</strong> and <strong>ensure [~null~ tuple!] spec.version</strong> ... you can do your own FOR-EACH enumeration over a block of type/value pairs if you have enough of them to matter.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0179.html">Isolated Namespaces In Modules</a></strong> - <a href="https://forum.rebol.info/t/the-real-story-about-user-and-lib-contexts/764">Turning on isolation was horribly bloated</a>, but Ren-C has <a href="https://forum.rebol.info/t/a-quantum-leap-in-testing-isolating-into-contexts/1680">solved it efficiently</a> and makes it the default for all modules.</p>
<ul>
<li>
<p>May I just say that the code for all of the module stuff--especially isolation--<a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/c-frame.c#L679">is convoluted and buggy</a> with equally buggy usermode portions, and it literally made me give up trying to use my 2018 bootstrap executable for the FENCE! conversion.  I had to go gut the module system to make enough simplifications that it would work at all, and am still dealing with the issues of deploying new cross platform binaries that will serve for at least another year or two.</p>
</li>
<li>
<p>If you're wondering "why not just use a modern Ren-C for bootstrap" the answer is that in most areas unrelated to modules--e.g. places where I worked on hardening it--I can rely on it more than the dark corners of modern executables.  Bootstrap is rather demanding.  Also right now has various in flux instabilities and bad performance.</p>
</li>
</ul>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0184.html">DECODE and ENCODE</a></strong> - I never really got the split in responsibilities between ports and codecs.  We're told that if you want to do streaming hash calculations in chunks on large files to use a PORT! to do it.  But then DECODE and ENCODE aren't light wrappers over a chunking port but rather some very naive functions.  Trivial design that was used as an excuse to make some more weird monolithic C code... there's no architecture, it's just a function table.</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0186.html">Read Only Strings, Blocks, and Objects</a></strong> - So apparently PROTECT came along in 2019.  The interesting thing about Rebol being a C codebase with limited type checking is that it was scout's honor for all the code in the system to remember to check the protection bits before making a modification.  Ren-C can build as C++, and <a href="https://forum.rebol.info/t/value-vs-series-modification-bit-const-and-mutable/976/5">enforces the checking of mutability bits before changes with the type system</a>...so if anyone doesn't use a check routine to transition from const to mutable in the C, then when building with C++ that will be caught.  I'm quite proud of that...and it has been working without bugs enforcing CONST as well as PROTECT (and evaluator holds, etc.)</p>
</li>
<li>
<p><strong><a href="http://www.rebol.net/r3blogs/0189.html">PROTECT/HIDE</a></strong> - While I thought this was kind of cool when I first saw an example, it turns out that this is another features that was added on a whim without a systemic review of the implications.  But for this case I haven't come up with a way to really make it much other than the scout's honor I describe from R3-Alpha's basic protection bit.  I've not killed the feature because hidden bits are used to various effects in things like specializing fields out of frames, but I'm really not sure if it makes sense in other cases.</p>
</li>
</ul>
            <p><small>3 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/more-history-mining-rebol-3-0-front-line-blog/2199">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/more-history-mining-rebol-3-0-front-line-blog/2199</link>
          <pubDate>Tue, 20 Aug 2024 19:49:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2199</guid>
          <source url="https://forum.rebol.info/t/more-history-mining-rebol-3-0-front-line-blog/2199.rss">More History Mining: Rebol 3.0 Front Line Blog</source>
        </item>
        <item>
          <title>DEFAULT as Dialect?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Flipping through the entirety of Carl's old Rebol blog, I came across a surprising post in which he considers <a href="https://www.rebol.com/article/0388.html">a trick for implementing DEFAULT using left-quoting in Rebol2</a>.</p>
<p>While it's very odd that there were ways to hack that in, I found myself more curious about the alternative proposal... to have DEFAULT work as a dialect.</p>
<pre><code> x: y: default [10 + 20]  ; can't set X
 default [x: y: 10 + 20]  ; dialect can offer handling of leading SET-WORD!s
</code></pre>
<p>This isn't a situation like comparing <strong>let x: 10</strong> and <strong>let [x: 10]</strong>.  LET doesn't need the block, so you get something inherently messier.  But because the nature of DEFAULT requires the block to suppress evaluation in the case that it doesn't need to do the defaulting, you have it either way. <img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<pre><code>  &gt;&gt; x: null
  &gt;&gt; y: &lt;something&gt;

  &gt;&gt; default [x: y: 10 + 20]
  == ???  ; by convention, what's the answer?

  &gt;&gt; x
  == 30

  &gt;&gt; y
  == &lt;something&gt;
</code></pre>
<p>It's a bit of a problem on what the return result would be, and it's a bit misleading because you see on the screen [x: y: 10 + 20] but you get back something where after that <code>x &lt;&gt; y</code>.</p>
<p>I think I'm going to have to go with thinking that the current way is better.  But again, I was a bit surprised to see the Rebol2 backwards-quoting-hack.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/default-as-dialect/2198">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/default-as-dialect/2198</link>
          <pubDate>Tue, 20 Aug 2024 12:47:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2198</guid>
          <source url="https://forum.rebol.info/t/default-as-dialect/2198.rss">DEFAULT as Dialect?</source>
        </item>
        <item>
          <title>Mining History For Anything Relevant: Carl&#39;s Rebol Blog</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Carl maintained two Rebol blogs.  One was specifically for <a href="https://forum.rebol.info/t/more-history-mining-rebol-3-0-front-line-blog/2199">Rebol 3.0 development issues</a>.  But the other was for more general topics, essays, thoughts.</p>
<p>Here is the first post from February 5, 2008:</p>
<p><a href="https://www.rebol.com/article/0001.html">https://www.rebol.com/article/0001.html : <strong>"Ok, Let's Try It"</strong></a></p>
<p>That blog apparently made it up to 554 posts, stalling out on February 25, 2018:</p>
<p><a href="https://www.rebol.com/article/0554.html">https://www.rebol.com/article/0554.html : <strong>Website Update, New Projects, Fresh Thoughts"</strong></a></p>
<p>But it had been stalling out long before that (post <span class="hashtag">#553</span> was in January of 2016 as part of a little spurt of notes.)</p>
<h2>
<a name="i-decided-to-skim-through-it-for-anything-useful-1" class="anchor" href="https://forum.rebol.info#i-decided-to-skim-through-it-for-anything-useful-1"></a>I Decided To Skim Through It For Anything Useful</h2>
<p>It's a lot of material, but many of them are short (or obviously not relevant to Ren-C's interests).  I'm in a mode of feeling like I'm seeing answers to old questions through the lens of what Ren-C can do today, so I thought I'd flip through them to see if anything caught my attention.</p>
<p>Here are some notes on any thoughts triggered...</p>
<ul>
<li>
<p><strong><a href="https://www.rebol.com/article/0004.html">IO Redirection</a></strong> - Rebol2 and R3-Alpha had many quirks and broken aspects in IO redirection.  Ren-C actually does a pretty good job and <a href="https://github.com/metaeducation/ren-c-stdio/blob/main/.github/workflows/test-stdio.yml">has tests of it</a> in various shells.  At least a bit in part due to my hassling them, PowerShell actually changed the way they did IO to accommodate making binary redirection accommodate us (<a href="https://github.com/PowerShell/PowerShell/issues/1908">many other people wanted it too</a>).</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0015.html">MakeDoc</a></strong> - I have never touched Rebol's MakeDoc, and pretty much only use MarkDown.  Maybe someone who uses MakeDoc needs to write a post about it and if it matters at all in the modern ecology of such standards.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0020.html">HASH!</a></strong> - The predecessor to Rebol's MAP! was a sort of optimization layer on top of blocks, where you still could enumerate them and experience them as blocks.  But people insisted that a conventional key/value store which was dissociated from any order or enumeration structure was better.  But in light of some recent findings about <a href="https://forum.rebol.info/t/how-much-determinism-should-be-pursued/2057/3">Python's Dict becoming order-preserving and deterministic</a>, I wonder if MAP! was a wrong turn after all.  Hmm.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0050.html">Async Ports</a></strong> - Oh my, the <a href="https://forum.rebol.info/t/semantics-of-read-and-tcp-streams-past-and-future/1733/2">beginnings of the nightmare</a>.  Thankfully that's over.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0059.html">NEW-LINE</a></strong> - Naming a function NEW-LINE when NEWLINE is a character constant is pretty confusing.  Ren-C has made a lot of progress here (including controlling terminal newlines in blocks) but never really came up with a good answer for how to better define functions to tweak the meta-formatting information.  There's also a lot to be said about <a href="https://forum.rebol.info/t/testing-generic-tuple-and-path-structuring/1353">newline marker significance in dialects</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0059.html">Mixed Dialects and REDUCE/ONLY</a></strong> - The idea of providing constructs that are more careful about executing code is something I've gone after, but more in terms of primitives like GET and SET not running code in GROUP!s in paths or tuples unless you say so.  It's good to see Carl was thinking about "security" (or clarity).  Ren-C sort of <a href="https://forum.rebol.info/t/make-your-own-safety/1118">drifted away from thinking there's much hope in guessing what people will care about</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0102.html">No Style Guide</a></strong> and <strong><a href="https://www.rebol.com/article/0103.html">Deep Lake</a></strong> - The idea that you use the style that fits you is very critical I think.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0104.html">Context-Dependent Language</a></strong> - Hadn't seen this particular post before.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0108.html">Was XML Flawed From The Start</a></strong> - Yes.  I didn't know it but there is apparently a <a href="https://www.rebol.com/article/0110.html">follow-up post</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0126.html">Building in a DIFF Function</a></strong> - Hmmm.  Not necessarily the worst idea to have one... dialected diff sounds interesting.  But should probably be a module or extension.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0130.html">Rebol Internationalization</a></strong> - In the past I've said it might be interesting to "skin" Rebol in usermode to be in other languages.  Spanish or Chinese PARSE dialect, etc.  UPARSE would let you map the combinators to different words.  It's still interesting, but I think when it comes to stuff like internationalizing messages and error strings... it's probably time to just assume AI will be good enough for that.  I don't think this project is going to do any localization in my lifetime.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0144.html">Modules</a></strong> - <em>"I should mention that modules are the main point of the REBOL 3.0 version."</em> ... so unfortunate they <a href="https://forum.rebol.info/t/the-real-story-about-user-and-lib-contexts/764">more or less did not work at all</a>.  Ren-C has made great progress and things are much more promising, but there sure is a long way to go on the vision of a completely usermode module system that people can customize or override at will.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0153.html">SET and GET on Objects</a></strong> - I dropped this feature, but it does raise another question of determinism in field ordering, as to whether you should even be able to do such a thing.  It seems to me someone needs to lay down the fundamental philosophy about basic issues that persist in Redbols today, like:</p>
<pre><code>red&gt;&gt; obj1: make object! [a: 10 b: 20]
== make object! [
    a: 10
    b: 20
]

red&gt;&gt; obj2: make object! [b: 20 a: 10]
== make object! [
    b: 20
    a: 10
]

red&gt;&gt; obj1 = obj2
== false
</code></pre>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0177.html">Consistency in POKE</a></strong> - Aaah, this reminds me of all the <a href="https://forum.rebol.info/t/get-set-vs-pick-poke-whats-the-difference/1719">"what is picking and poking and setting and getting"</a> semantics issues.  The code is going to need to be revisited for the plan of <strong>obj.method</strong> passing the OBJ to the method as a "coupling".  It was a nightmare to work on, but maybe enough time has passed to where going in and cleaning it up will be "fun".</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0188.html">PARSE words are "commands"?</a></strong> - Hm.  Well, I like "combinators".  In any case, I don't know that I've used the word "command" much if ever.  Should I?</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0206.html">Is Rebol a Pure Functional Language?</a></strong> - No, but it does remind me that I was thinking of making a PURE designator where any function marked pure could only call other pure functions.  Could be a fun experiment.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0214.html">Rebcode</a></strong> - I don't think I ever heard of this (or if I did, confused it with the binary storage REBBIN format or something).  If I had infinite time I'd tinker with something like putting Red/System in the WebAssembly build and generating Wasm, but I don't.  It seems clear in retrospect that this tendency to drift off from language design issues really burned up RebolTech's time.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0229.html">BIND?</a></strong> - While Ren-C's Pure Virtual Binding is humming along running most code, being able to inquire and reflect the compounding environments is going to need a lot of deeper answers than this.  And I still don't know exactly what to do about <a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128">attached words</a>...they're just there to keep the ship afloat for the moment.  But worth pointing out that Rebol was pretty far along before it had the ability to query binding (AFAIK Red still doesn't have it, there's no BIND?)</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0233.html">Extending Objects</a></strong> - Thought is needed on this.  It should definitely be a different operation than APPEND.  My feeling is that APPEND on an OBJECT! should be reserved for interacting with that object's concept of what APPEND means (but does that mean it can't have its own idea of what EXTEND means?)</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0278.html">Checksum Ports</a></strong> - We have all the encryption code to do this but understanding what PORT!s are supposed to be keeps this on a very far back burner.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0284.html">RebolTech Priorities</a></strong> - Interesting in light of <a href="https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179">my own writing on the topic</a>.  It's a different era, where people have so many free tools to choose from... where the <em>only</em> relevance I see is whether the language design offers something truly unique and notable.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0288.html">Source For Carl's Blog</a></strong> - I didn't know he'd published it.  The link is dead, but the Internet Archive has it: <strong><a href="https://web.archive.org/web/20061218060625/http://www.rebol.net/cgi-bin/blog.r?get-source=1"><code>blog.r</code></a></strong>.  I never used the CGI facilities but it's interesting to see that it is indeed just one long single file.  (I'm idly curious about how this would compare to someone trying to do the same thing in PHP.)</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0294.html">Anthropomorphizing Errors</a></strong> - Interesting topic.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0316.html">Two Year Rebol Blog Anniversary</a></strong> - In two years from 2008-2010 the Rebol blog got to 316 out of its 554 total posts.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0338.html">FOLLOW was the original name of ALSO</a></strong> - Who knew.  <a href="https://forum.rebol.info/t/enfixing-also-stylizing-it-after-then-and-else/402">Either way, I don't like it.</a></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0367.html">PICK with LOGIC!</a></strong> - I never really cared for this.  It's not obvious to me if true is the first item or the second one.  Ren-C has <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">soft-quoted branching</a>, so you can do <strong><code>either (cond) 'this 'that</code></strong> and I find it a lot clearer.  Now that logic is an antiform, it means the whole picking system gets messed up by needing to support antiforms.  Not sure why I didn't kill this off yet...</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0372.html">Reacting to Complaints About Not Communicating</a></strong> - Seems the natives are getting restless around August 2008.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0374.html">Rebol: Not For Everyone</a></strong> - <a href="https://forum.rebol.info/t/rebols-target-market-newbies-experts-or-other/581">I wrote a bit here about this post in 2018</a>.  Should probably see if I have any updated thoughts now that I know more.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0377.html">The GUI: Harder Than It Seems</a></strong> - I've often been puzzled by the obsession the Rebol community has on the cross-platform GUI.  Here we see an admission from Carl that it's harder than it seemed and eating up time.  A prelude to today, where Red seems to drag along indefinitely with it.  I'm pretty well-versed in Rebol design points, yet I find what they're making to largely be gibberish.  HTML and CSS are pervasive, have been modernized with time, and I don't really think the GUI work has shown to be markedly ahead for any non-trivial task.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0382.html">The suffix of Rebol Files</a></strong> - After having campaigned a bit on the side of saying Rebol should accept it doesn't own the "R" language term and use <strong><code>.reb</code></strong> <a href="https://forum.rebol.info/t/revisiting-the-riddle-of-the-r/1664">I changed my mind.</a>  I think it should be <strong><code>.r</code></strong>.  The reason I haven't gone around renaming things is because the disruption it would create doesn't make much sense to do until there's a good reason to go around and muck with all the file organization.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0388.html">Enfix DEFAULT Before Enfix existed</a></strong> - I didn't know this had been considered, much less that you do it in Rebol2.  That's surprising.  The idea of making DEFAULT a dialect taking a BLOCK! is actually not something I had considered, and I'm not completely sure I hate.  You get advantages in the sense that you could potentially default more than one thing...<a href="https://forum.rebol.info/t/default-as-dialect/2198">I'm going to have to think about it.</a></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0459.html">Announcement of PowerMezz</a></strong> - <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a> had at one time undertaken a porting of this to Rebol3, and don't really remember what was in it.  I didn't look too closely.  But it could be a very good place to look for challenging problems in binding and parsing to ask <em>"has Ren-C raised the bar so people trying to do these things can do them more clearly"</em>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0467.html">CALL/SHOW</a></strong> - Never saw this.  I do think that for a GUI program, /SHOW should be the default.  Worth looking at.  I notice that <a href="https://github.com/microsoft/WSL/issues/6565"><code>call "explorer"</code> returns an exit code of 1</a>, which is now <a href="https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068">reported by CALL unless you do CALL/RELAX</a> (or intercept it with EXCEPT).</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0489.html">LIB and SYS</a></strong> - Since I started using Rebol only after R3-Alpha, I'm often surprised to find things that you can't do in Rebol2... such as get the original version of a function if you overwrite it.  I gather that to this day, in Red, if you say <code>append: func [] [print "Hi"]</code> without saving the old-append there's no way to get it back!</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0497.html">Fight Software Complexity Pollution</a></strong> - I cite this one a lot, I should cache it here on the forum and add some comments.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0508.html">Common PARSE Patterns</a></strong> - Link is broken, and internet archive is down, look these up when it comes back.  (Ok it's back and... <a href="https://web.archive.org/web/20110228053052/http://www.rebol.net/wiki/Common_Parse_Patterns">well, not much there</a>).</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0509.html">Simplicity Defined</a></strong> - While I respect that Carl certainly has thrown some unique vision into the mix of computing, no one knows the R3-Alpha code better than I do, and so sometimes these posts ring a bit hollow.  It may have been easier to ramble from on high before the code was open sourced, but really R3-Alpha is every bit the ball of mud he is critiquing!  But it is certainly the case that in its ideal form, Rebol is a rich-enough substrate for expressing one's domain knowledge simply... whereas other mediums (like say, bash) just are unsuitable...but people use them out of expedience or pragmatism.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0510.html">Carl Announces Giving Up</a></strong> - August 2012 solicits opinions on the future, stating: <em>"I also need to tell you that I don't have much time to help out with whatever the REBOL future may be."</em></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0511.html">Open-Sourcing Announcement</a></strong> - There was a bunch of debate over licensing, I said use the LGPL, it was made Apache to "appeal to more contributors".  Yeah, right.  <a href="https://forum.rebol.info/t/ren-c-license-changed-to-lgpl-3-0/1342">Ren-C has been LGPL since September 2020</a></p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0515.html">Rebol C Documentation Style</a></strong> - Comments in R3-Alpha weren't particularly copious.  Ren-C has tons of them.  I'm pretty pleased with how they're done, and have been adopting a kind of "headnote" style where I don't mix too much commenting directly into the code, but just tack on the end of the line <strong><code>// don't accept groups [3]</code></strong> and then have a section above somewhere that says <code>// 3. The reason that we don't accept groups here is...</code>  Of course, Ren-C has much improved embedding of native function specs directly in the comments above natives as well.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0518.html">"We Need a New Rebol Forum"</a></strong> - I have to wonder how things would have gone if we'd used Discourse earlier.  This question was asked in November of 2012, and Discourse was released in August 2014.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0522.html">Comparing Rebol and JSON</a></strong> - This is interesting because he is using BLOCK! for both arrays and key/value stores.  He glosses over what that winds up meaning for systems interpreting the data.  I'm suspicious that it is insignificant, <a href="https://forum.rebol.info/t/json-envy-serialization-dialect-in-rebol/2140">I wrote a bit about this</a>.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0525.html">Calling REBOL, Rebol</a></strong> - Yes.</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0537.html">Rebol Conference, Montreal, 2013</a></strong> - If not for me recording and editing the videos, there wouldn't be much left of it!</p>
</li>
<li>
<p><strong><a href="https://www.rebol.com/article/0543.html">FUNCTION and CLOSURE</a></strong> - There's no more CLOSURE in Ren-C <a href="https://forum.rebol.info/t/relative-binding-and-frame-internals/1344">because all the good parts of it are subsumed into every function</a> <em>(at reasonable cost)</em>.  Now I worry over LETs.  Kind of funny to think how much I take for granted these days...</p>
</li>
</ul>
<hr>
<h2>
<a name="and-thats-about-it-2" class="anchor" href="https://forum.rebol.info#and-thats-about-it-2"></a>And That's About It...</h2>
<p>So that took me a few hours, and feels worth it to have done so.  He started a separate Rebol 3.0 tech blog, and after that it was mostly philosophy and administrivia posts.  I'll do a similar survey of the tech blog.</p>
<p>While it seems to me the GUI is the killer of Redbols, it probably is what allowed Rebol2 to get the popularity that it did.  Probably they shouldn't have made any changes to VID or the graphics.  I think there's this tendency to want to go deep and burn time on grid controls or whatever the "one missing thing" is, when if an application is truly of any sophistication then it's always going to run up against the limit of what Rebol can offer.</p>
<hr>
<p>I'll do some posts on the follow-up items here at some point.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/mining-history-for-anything-relevant-carls-rebol-blog/2197">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/mining-history-for-anything-relevant-carls-rebol-blog/2197</link>
          <pubDate>Tue, 20 Aug 2024 11:01:54 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2197</guid>
          <source url="https://forum.rebol.info/t/mining-history-for-anything-relevant-carls-rebol-blog/2197.rss">Mining History For Anything Relevant: Carl&#39;s Rebol Blog</source>
        </item>
        <item>
          <title>MAKE Should Be Using *Dialected Constructors*</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1591">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/debunking-the-arity-1-make/1591/1">Debunking the Arity-1 MAKE</a>
</div>
<blockquote>
<p>No one really uses the "polymorphism" of <strong>make some-type some-definition</strong> without really knowing what type or definition is, right? That seems essentially meaningless.</p>
</blockquote>
</aside>
<p>In thinking more about "what is MAKE", I feel like it is fundamentally a constructor.</p>
<hr>
<p>When you think about Rebol's value proposition vs. other languages, what's the key idea?</p>
<p><strong>DIALECTS.</strong>  The freeform Jazz of programming.  <img src="https://forum.rebol.info/images/emoji/twitter/saxophone.png?v=12" title=":saxophone:" class="emoji" alt=":saxophone:" loading="lazy" width="20" height="20"></p>
<hr>
<p>So what should be the differentiating factor about constructors in Rebol vs. other languages?</p>
<p><strong>CONSTRUCTOR DIALECTS.</strong> <img src="https://forum.rebol.info/images/emoji/twitter/saxophone.png?v=12" title=":saxophone:" class="emoji" alt=":saxophone:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/guitar.png?v=12" title=":guitar:" class="emoji" alt=":guitar:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/drum.png?v=12" title=":drum:" class="emoji" alt=":drum:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/musical_keyboard.png?v=12" title=":musical_keyboard:" class="emoji" alt=":musical_keyboard:" loading="lazy" width="20" height="20"></p>
<hr>
<p>When I say <strong><code>make my-type! [...]</code></strong> then what goes in that BLOCK! needs to be delegated to MY-TYPE! in some way to allow it the freedom to interpret the hell out of that block.</p>
<p>And it shouldn't only be allowed to be a BLOCK! full of madness.  Consistent with history where you can write things like <strong><code>(make block! 10)</code></strong> to preallocate a size, you should be able to pass anything you want.</p>
<pre><code>make my-type! 'some-word

make my-type! /some-refinement

make my-type! ${...}  ; gimme a bound FENCE!

make my-type! @[...]  ; special meaning if "inert" block received?
</code></pre>
<hr>
<h3>
<a name="history-has-ridiculously-underformed-the-potential-1" class="anchor" href="https://forum.rebol.info#history-has-ridiculously-underformed-the-potential-1"></a>History Has Ridiculously Underformed The Potential</h3>
<p>When you look at the TO/MAKE Matrix, it's full of meaningless choices:</p>
<pre><code>rebol2&gt;&gt; make block! [a b c]
== [a b c]
</code></pre>
<p>Huh?  What the hell use is that.  Is it a copy?  Is it a deep copy?  <em><a href="https://www.youtube.com/watch?v=U80ebi4AKgs">Where's the beef?</a></em></p>
<p>Why isn't the constructor for block a literate landscape, subsuming the functionality of <a href="http://www.rebol.com/docs/words/warray.html">ARRAY</a> (a terrible name for a verb) and much more?</p>
<pre><code>&gt;&gt; make block! [4/8 initial: '*]
== [* * * *]  ; length 4, capacity 8, initialize elements with *

&gt;&gt; make block! /8
== []  ; just capacity 8

&gt;&gt; make block! 4
== [~ ~ ~ ~]  ; default to meta-TRASH
</code></pre>
<p>There's an answer here that "dialect design is hard", and it's scary to put a dialect in the core.  But there's decades of experience at this point.  And maybe even ways for people to do their own rewrites and transformations so they don't have to use a <strong><code>make-block</code></strong> function but can customize <strong><code>make block!</code></strong> itself.</p>
<hr>
<h3>
<a name="ren-c-has-opened-up-the-skies-and-will-do-more-2" class="anchor" href="https://forum.rebol.info#ren-c-has-opened-up-the-skies-and-will-do-more-2"></a>Ren-C Has Opened Up The Skies, and Will Do More</h3>
<p>I was musing on the behavior of FENCE! in the interpreter and thought, what if it wasn't narrowly defined as being OBJECT! related.  <em>What if it was MAKE-related, with an object-generating default?</em></p>
<pre><code>&gt;&gt; {x: 10, y: 20}
== #[object! x: 10 y: 20]

&gt;&gt; {[block!] 4/8 initial: '*}  ; maybe leading block means MAKE that?
== [* * * *]

&gt;&gt; {block! {4/8 initial: '*}}  ; maybe nesting FENCE! does it?
== [* * * *]

&gt;&gt; {block! 4/8 initial: '*}  ; maybe starting with WORD! is enough?
== [* * * *]

&gt;&gt; {block!}
== []
</code></pre>
<p>It's a half-baked thought, and I don't know what the ideal syntax is.  But I feel like this could make FENCE! so much more.</p>
<hr>
<h2>
<a name="so-coming-soon-the-great-make-purge-3" class="anchor" href="https://forum.rebol.info#so-coming-soon-the-great-make-purge-3"></a>So Coming Soon: The Great MAKE Purge.</h2>
<p>In the combinatoric TO/MAKE matrix, there is a ton of garbage.</p>
<p>I've previously suggested that TO should not do any evaluation (e.g. be binding agnostic on what it gets in).  I think that remains a good idea, that it be purely mechanical.  <a href="https://forum.rebol.info/t/hacking-away-on-the-to-and-make-matrix/649">I had some other ideas that are lingering.</a></p>
<p>I think it's time to further cull the "MAKE for the sake of thinking everything you pass needs to do something, even if it's trivial."  I've been wiping out some of the garbage, but more is needed.</p>
<p>And we have to find a way to give users the ability to hook MAKE on their objects... such that something like <strong><code>make point-3D! [...]</code></strong> isn't locked into a trivial extension syntax of SET-WORD! and value, but truly able to do interesting things.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/make-should-be-using-dialected-constructors/2196">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/make-should-be-using-dialected-constructors/2196</link>
          <pubDate>Tue, 20 Aug 2024 05:41:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2196</guid>
          <source url="https://forum.rebol.info/t/make-should-be-using-dialected-constructors/2196.rss">MAKE Should Be Using *Dialected Constructors*</source>
        </item>
        <item>
          <title>Usermode Multiple Dispatch in R and Common Lisp</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2190">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190/1">"Member Functions" (in the era of Pure Virtual Binding)</a>
</div>
<blockquote>
<p>Rebol's style of data mutation is done as "generics", e.g.:</p>
<pre><code class="lang-plaintext">append block [1 2 3]
;
; ... NOT block/append [1 2 3]
</code></pre>
<p>This dynamically chooses the right kind of APPEND procedure based <em>entirely</em> on the type of the first argument (blocks, strings, etc.)</p>
<p>But you can't implement this generic for your own objects.</p>
</blockquote>
</aside>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2190">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190/1">"Member Functions" (in the era of Pure Virtual Binding)</a>
</div>
<blockquote>
<p>It seems Rebol could use a better way of doing <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a> so that you could write things like <strong><code>append my-object [a b c]</code></strong> and get custom behavior for the "class".</p>
</blockquote>
</aside>
<p>The <a href="https://adv-r.hadley.nz/s3.html#s3-methods">R solution to this</a> is to make the function itself do the dispatch. A function like <code>append</code> would be defined as something which calls a different function name depending on the class of its argument: <code>append.matrix</code> for something of class <code>matrix</code>, <code>append.numeric</code> for something of class <code>numeric</code>, and so on. (Note that <code>.</code> in R is simply a normal character which can be used in identifier names.) I don’t know how well this would work for Ren-C, but it’s probably worth mentioning.</p>
<p>EDIT for clarification: the idea is that <code>append.matrix</code> etc. are completely normal functions which you can define yourself at any time. The generic method <code>append</code> simply dispatches to the relevant function based on its name. When defining a new class, you would also define whichever functions are relevant for use with that class.</p>
<p>(Also, for further inspiration, it may be worth looking at the <a href="https://lispcookbook.github.io/cl-cookbook/clos.html#methods">Common Lisp Object System</a>, though CL is less similar to Rebol than R is.)</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/usermode-multiple-dispatch-in-r-and-common-lisp/2193">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/usermode-multiple-dispatch-in-r-and-common-lisp/2193</link>
          <pubDate>Mon, 19 Aug 2024 05:40:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2193</guid>
          <source url="https://forum.rebol.info/t/usermode-multiple-dispatch-in-r-and-common-lisp/2193.rss">Usermode Multiple Dispatch in R and Common Lisp</source>
        </item>
        <item>
          <title>&quot;Member Functions&quot; (in the era of Pure Virtual Binding)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <h2>
<a name="lets-start-with-member-variable-binding-1" class="anchor" href="https://forum.rebol.info#lets-start-with-member-variable-binding-1"></a>Let's Start With "Member Variable" Binding</h2>
<p>The properties of historical Rebol binding created a bizarre environment in which to implement objects with methods and member variable references.</p>
<p>There's a pretty basic question one can ask:</p>
<blockquote>
<p><strong>You: "It appears that every WORD! can bind to at most one object containing that word's symbol.  So if I write a FUNC intended to act as a member function... what are the member word references bound to in that function's body, that allows them to apply the code to the field values of a new instance of the object?"</strong></p>
</blockquote>
<p>To make a long story short:</p>
<blockquote>
<p><strong>Redbol: "For every field of an object that holds a FUNCTION! value, making a new object instance will <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/t-object.c#L338"><em>clone a new FUNCTION! value for the associated field in the copy</em></a>.  The original function's body is <em><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/f-blocks.c#L139">copied deeply</a></em>, with any references to the original object's fields <em><a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/core/c-frame.c#L1040">rebound to the field of the new object.</a></em>"</strong></p>
</blockquote>
<p>This creates a pathological explosion.  Make an object with 20 methods, each of which has a body that is built up of... say... 10 blocks on average.  Now instantiate 10,000 of those objects.</p>
<p>Beyond the basic overhead you'd expect from a new object copy, <strong>you just allocated 200,000 new function identities... plus two million <em>nearly</em>-identical arrays for their bodies... <em>solely for the purpose of accomplishing what a single <code>this</code> or <code>self</code> pointer does in most OOP languages</em>.</strong></p>
<p>Those with non-trivial codebases (e.g. Atronix) who at first wrote code in this style...</p>
<pre><code>obj: make object! [
   x: 10
   f: func [y] [return x + y]
]

&gt;&gt; obj/f 20
== 30
</code></pre>
<p>...were forced to "de-methodize" it, passing the instance into a <a href="https://en.wikipedia.org/wiki/Free_function">"free function"</a>:</p>
<pre><code>free-f: func [o y] [return o/x + y]

obj: make object! [
   x: 10
]

&gt;&gt; free-f obj 20
== 30
</code></pre>
<hr>
<h2>
<a name="worth-noting-rebols-central-aesthetic-is-free-functions-2" class="anchor" href="https://forum.rebol.info#worth-noting-rebols-central-aesthetic-is-free-functions-2"></a>Worth Noting: Rebol's Central Aesthetic <em>is</em> "free functions"</h2>
<p>Rebol's style of data mutation is done as "generics", e.g.:</p>
<pre><code>append block [1 2 3]
;
; ... NOT block/append [1 2 3]
</code></pre>
<p>This dynamically chooses the right kind of APPEND procedure based <em>entirely</em> on the type of the first argument (blocks, strings, etc.)</p>
<p>But you can't implement this generic for your own objects.  Red doesn't let you APPEND to OBJECT! at all.  While in R3-Alpha if you APPEND to an OBJECT! it just adds fields--vs. delegate to any "append implementation" associated with some kind of object "class":</p>
<pre><code>r3-alpha&gt;&gt; obj: make object! [a: 10]
== make object! [
    a: 10
]

r3-alpha&gt;&gt; append obj [b: 20]
== make object! [
    a: 10
    b: 20
]
</code></pre>
<p>I will mention that if you had a PORT!, curiously there was a way to supply an "actor" to PORT!s that could implement a small set of "port actions".  For an example of this, see the original R3-Alpha ODBC extension:</p>
<p><a href="https://github.com/gurzgri/r3-odbc/blob/c15c70d61a2f5c39cb01f7c685c4310d4ee987de/src/boot/odbc.r3#L68" class="inline-onebox">r3-odbc/src/boot/odbc.r3 at c15c70d61a2f5c39cb01f7c685c4310d4ee987de · gurzgri/r3-odbc · GitHub</a></p>
<p>For the sake of documenting history, the list of "generic verbs" you can implement on a R3-Alpha are called "port actions" and <a href="https://github.com/rebol/rebol/blob/25033f897b2bd466068d7663563cd3ff64740b94/src/boot/actions.r#L361">limited to this arbitrary set</a>:</p>
<p>CREATE, DELETE, OPEN, CLOSE, READ, WRITE, OPEN?, QUERY, MODIFY, UPDATE, RENAME</p>
<p>So even that wouldn't help you with APPEND.</p>
<hr>
<h2>
<a name="were-classes-ever-on-the-table-in-r3-alpha-3" class="anchor" href="https://forum.rebol.info#were-classes-ever-on-the-table-in-r3-alpha-3"></a>Were "Classes" Ever On The Table in R3-Alpha?</h2>
<p>On Carl's blog, circa 2006, he wrote <strong><a href="http://www.rebol.net/r3blogs/0035.html">At a CLASS Crossroads?</a></strong>:</p>
<p>He said:</p>
<blockquote>
<p><em>"And, on top of all this, I've yet to mention the fact that <strong>REBOL 3.0 is likely to support object methods</strong> to make object function implementation more efficient (in memory usage). The implementing of methods in REBOL has always been considered difficult (mainly because there is no referential anchor for a group, a class, of objects -- they are prototypical and can be cloned from each other, not just a single parent). A class-based approach makes the implementation of methods much easier.</em>"</p>
</blockquote>
<p>The post wasn't without criticism in the comments, e.g. from "Pierre Johnson":</p>
<blockquote>
<p><em>"Class-based inheritance for REBOL? Why not just kill the product?"</em></p>
<p><em>"Class-based Aristotlean socialist thinking abounds in academic-based / near academic-based junk -- Java, C++, C#, Python."</em></p>
<p><em>"While not elegant, perhaps the <span class="hashtag">#1</span>, most used programming language of the world is Javascript. Why? Simpler, rapid prototyping using prototypes."</em></p>
</blockquote>
<p>You didn't really hear anything about it after that.  R3-Alpha got pretty bogged down just trying to be Rebol2 plus Unicode.</p>
<hr>
<h2>
<a name="how-about-red-any-ideas-there-4" class="anchor" href="https://forum.rebol.info#how-about-red-any-ideas-there-4"></a>How About Red?  Any Ideas There?</h2>
<p>When OBJECT! was first added to Red circa 2014, DocKimbel wrote the blog <strong><a href="https://www.red-lang.org/2014/12/050-objects-support.html">0.5.0: Objects support</a></strong>, and says (emphasis mine)</p>
<blockquote>
<p>"Red implements the same object concept as Rebol, called <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">prototype-based</a> objects. Creating new objects is done by cloning existing objects or the base OBJECT! value. During the creation process, existing field values can be modified and new fields can be added. It is a very simple and efficient model to encapsulate your Red code. <strong>There is also a lot to say about words binding and contexts, but that topic is too long for this blog entry, we will address that in the future documentation.</strong>"</p>
</blockquote>
<p>Uh... I think I've said above pretty much all there has historically been to say... and it only took me... maybe an hour?</p>
<p>The big idea in Red is essentially to implement the <a href="https://en.wikipedia.org/wiki/Mutator_method">"setters"</a> half of "getters and setters".  If you have a field in an object with that the precise name ON-CHANGE*, it will get the name of a field... the old value... and the new value it takes on.  A lot of the code they seem to be interested in uses that instead of methods: just write a value to a field, and code executes.  If you can get your work done with just that, you won't have method binding problems.</p>
<p>Although, presumably every copy of your object duplicates the ON-CHANGE* method itself?</p>
<pre><code>red&gt;&gt; obj: make object! [
    a: 10
    on-change*: func [word old new] [print [word old new]]
]

red&gt;&gt; obj/a: 20
a 10 20

red&gt;&gt; obj2: make obj [a: 30]
a 20 30  ; note obj2 sees creation w/new field value as a "change"

red&gt;&gt; body-of :obj/on-change*
== [print [word old new]]

red&gt;&gt; append body-of :obj/on-change* [print "that figures."]
== [print [word old new] print "that figures."]

red&gt;&gt; body-of :obj2/on-change*
== [print [word old new]]
</code></pre>
<p>I take it back, this is way too complicated to address in a blog post.  <em>It's too deep.</em>  <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"></p>
<hr>
<h2>
<a name="okay-ren-c-what-have-you-got-5" class="anchor" href="https://forum.rebol.info#okay-ren-c-what-have-you-got-5"></a><em>"Okay, Ren-C... What Have You Got?"</em>
</h2>
<p>Building up to the existence of <a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/9">Pure Virtual Binding II</a>, Ren-C just kind of got waves of new tricks:</p>
<ul>
<li>
<p>First there were <strong><a href="https://forum.rebol.info/t/what-are-definitional-returns/2191">"definitional returns"</a></strong>, which gave each function a cell to store a local RETURN function.  While the behavior was unique to each function, no actual new identity was allocated.  Instead a slot in the 4-platform-pointer cell (known as the "coupling") was used to hold the FRAME! of the instance of the running function...so it was efficient at doing so.</p>
</li>
<li>
<p>Then there was <strong><a href="https://forum.rebol.info/t/relative-binding-and-frame-internals/1344">"(function-)relative binding"</a></strong>.  This started a separation in the type system of the interpreter code distinguishing a "Cell" (which hadn't had its binding fully resolved) from a "Value" (which did have a resolved binding).  Each function instantiation would slowly trickle down the FRAME! of the function during evaluation, such that the "relative" Cells would have to be paired with that frame before they could be passed to a routine doing non-structural Lookup to follow the word to a "specific" Value.</p>
</li>
<li>
<p>This laid the foundation for what I called <a href="https://forum.rebol.info/t/introducing-derived-binding/2192"><strong>"derived binding"</strong></a>, which actually mixed the two approaches together.  Just as any particular local variable named RETURN could hold a FRAME! in a cell's "coupling" slot (while reusing the same canon RETURN implementation), you could use that technique to store an OBJECT! in <em>any</em> function's coupling slot.  So the function call would not only trickle down the frame, but also this object... so there would be two contexts that were searched during derelativization.</p>
</li>
</ul>
<p>So under derived binding, making a new object doesn't require either a new function identity or a deep copy.  It just means that the new object receives its function cells with an effective "this" pointer in one of the 4 platform-pointer-sized slots.  That pointer is stowed in the FRAME! and trickles down via the cells instantiated by the evaluator as it descends the relativized arrays.</p>
<h3>
<a name="originally-derived-binding-did-not-blindly-override-6" class="anchor" href="https://forum.rebol.info#originally-derived-binding-did-not-blindly-override-6"></a>Originally, Derived Binding Did Not Blindly Override...</h3>
<p>Here's something that didn't work in derived binding as you'd expect given what I described:</p>
<pre><code>old-ren-c&gt;&gt; x: 42

old-ren-c&gt;&gt; obj: make object! [x: 10, f: null]

old-ren-c&gt;&gt; obj2: make obj [x: 20, f: null]

old-ren-c&gt;&gt; obj2.f: func [] [print ["x is" x]]

old-ren-c&gt;&gt; obj2.f: couple :obj2.f obj2

old-ren-c&gt;&gt; obj2.f
x is 42
</code></pre>
<p>The reason it didn't work was because this function was defined outside the scope of the MAKE OBJECT!, meaning the binding of the X was to 42.  When applying derived binding, Ren-C wouldn't do any overriding of any WORD! references that weren't bound to an object that was in the same "inheritance chain".</p>
<p>You'd have to do something like this to see the effect:</p>
<pre><code>old-ren-c&gt;&gt; x: 42

old-ren-c&gt;&gt; obj: make object! [x: 10, f: func [] [print ["x is" x]]]

old-ren-c&gt;&gt; obj2: make obj [x: 20, f: null]

old-ren-c&gt;&gt; obj2.f: couple :obj.f obj2

old-ren-c&gt;&gt; obj2.f
x is 20
</code></pre>
<p>Here, the X was deep walked during the MAKE OBJECT! and bound to OBJ's X.  When derived binding went to run the rebound function in OBJ2, it noticed that the binding to X was to a relative of OBJ2 in the inheritance chain... so it was willing to "forward" that binding to the object in the FRAME! it was relativizing against.</p>
<p>Note that the sort of virtual "this" pointer is not coming from the fact that OBJ2 is on the left hand side of the instantiation of the call to <strong>OBJ2.F</strong> -- it's solely coming from the coupling slot in the cell stored in that field.  You could make OBJ2.F be derived-bound to anything you want.</p>
<p>And now I can tell you that if you had used METHOD instead of FUNC... and hadn't said <strong><code>(f: null)</code></strong> when making OBJ2, then the above behavior is what you would get automatically.  The MAKE OBJECT! would simply notice when any of the fields it was copying had a stowed function with a coupling slot of itself, and update the cell in the new object with a coupling pointer to the new object.</p>
<p><em>(All METHOD is, is an enfix operator that steals the binding from the SET-WORD! on its left to poke into the cell of the generated function.)</em></p>
<h3>
<a name="but-with-virtual-binding-ii-the-object-wins-mostly-7" class="anchor" href="https://forum.rebol.info#but-with-virtual-binding-ii-the-object-wins-mostly-7"></a>But With Virtual Binding II, The Object Wins (Mostly)</h3>
<p>We're not in binding Kansas anymore... there is no "deep walk" when the FUNC is created that gives X an initial binding of 10.  As of this moment, bindings aren't ever overridden <em>(hole punching is still on the table, but let's not go there right now...)</em></p>
<pre><code>&gt;&gt; x: 10

&gt;&gt; obj: make object! [x: 20, f: null]

&gt;&gt; obj.f: func [] [print ["x is" x]]

&gt;&gt; obj.f: couple :obj.f obj

&gt;&gt; obj.f
x is 20
</code></pre>
<p>I actually didn't know what the following would do until I tried it:</p>
<pre><code>&gt;&gt; obj.f: func [x] [print ["x is" x]]

&gt;&gt; obj.f: couple :obj.f obj

&gt;&gt; obj.f 30
x is 30
</code></pre>
<p>I guess locals to the function are looked up first, before member variables.  Maybe I meant to do that <em>(C++ does it that way)</em>.</p>
<hr>
<h2>
<a name="what-have-we-learned-8" class="anchor" href="https://forum.rebol.info#what-have-we-learned-8"></a>What Have We Learned?</h2>
<ul>
<li>
<p>It seems Rebol could use a better way of doing <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a> so that you could write things like <strong><code>append my-object [a b c]</code></strong> and get custom behavior for the "class".</p>
<ul>
<li>
<p>The aesthetic of the system is supposed to promote that kind of free-function syntax</p>
</li>
<li>
<p>It doesn't make a lot of sense that you can only do this with PORT! and only for a handful of "generic verbs"</p>
</li>
</ul>
</li>
<li>
<p>But to the extent people have wanted to do traditional <code>obj/member</code> calls (in Ren-C <code>obj.member</code>), the historical implementation of the idea was catastrophically bad</p>
<ul>
<li>
<p>Without changing the overall usage experience (much), Ren-C wiped out the pathological implementation aspects</p>
</li>
<li>
<p>While Ren-C may be on the whole slower than its peers for many things at the moment, derived binding is one area where it blows them away.</p>
<ul>
<li>The <a href="https://github.com/metaeducation/ren-c/blob/199db785027eaec3132b2edbd42bdf6364f64e8d/tests/datatypes/object.test.reb#L140">"O-Big" example</a> I came up with is simply not runnable in R3-Alpha or Red.</li>
</ul>
</li>
</ul>
</li>
</ul>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190</link>
          <pubDate>Mon, 19 Aug 2024 04:52:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2190</guid>
          <source url="https://forum.rebol.info/t/member-functions-in-the-era-of-pure-virtual-binding/2190.rss">&quot;Member Functions&quot; (in the era of Pure Virtual Binding)</source>
        </item>
        <item>
          <title>Back to Bedlam: August 2024 Status and...Plan? :confused:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Announcements</category>
          <description><![CDATA[
            <blockquote>
<p>So Ren-C had a pretty exciting first 3 months of 2024, and then started to drop off, until I wasn't working on it at all.</p>
<p>I'll try and sum up what's gone on, and where things might realistically go from here.</p>
</blockquote>
<hr>
<h1>
<a name="rapid-development-january-march-1" class="anchor" href="https://forum.rebol.info#rapid-development-january-march-1"></a>Rapid Development: January <img src="https://forum.rebol.info/images/emoji/twitter/arrow_right.png?v=12" title=":arrow_right:" class="emoji" alt=":arrow_right:" loading="lazy" width="20" height="20"> March</h1>
<h3>
<a name="binding-paradigm-shift-2" class="anchor" href="https://forum.rebol.info#binding-paradigm-shift-2"></a>Binding Paradigm Shift</h3>
<p>The <a href="https://forum.rebol.info/t/bradrn-brad/2088">arrival of @bradrn</a> who had been investigating "R" directed attention back to the central language issue of how binding works at all (if it can be made to work).  This prioritized revisiting "Pure Virtual Binding" with fresh eyes: <strong><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/9">Pure Virtual Binding II</a></strong></p>
<p>I feel the premises are sound.  But if you buy into the methodology, then there are many consequences that will seem more alien than usual to historical Rebol programmers.  BLOCK!s are not inert in the evaluator, but rather evaluate to a version of the BLOCK! with binding applied... so <strong><code>(blk: [a b c])</code></strong> is distinct from <strong><code>(blk: '[a b c])</code></strong> where the latter uses quoting to suppress the evaluation.  And since quoting suppresses any binding, <strong><code>(x: 10, y: get 'x)</code></strong> won't work because the <strong><code>'x</code></strong> term drops the quote and stays unbound, meaning you have to use the new VAR-WORD! type and write <strong><code>(x: 10, y: get $x)</code></strong>.</p>
<p><em>The epicycles of this new world touch every aspect of the design</em>--forcing "binding awareness" to the forefront of dialect authors and casual users.  I wish there were an easier answer, but "implicitly paste unique binding pointers on words in waves" is being proven to be non-composable sufficiently well by other Redbol implementations.  It doesn't work meaningfully, so they simply write anything non-trivial as C or Red/System.</p>
<p>I managed to get the system to run well enough to research the design.  It is very half-baked, and every few minutes I work with it triggers the need for a new meditation in the <a href="https://forum.rebol.info/c/development/binding/49">Binding category</a>.  But as a positive sign, the new model made it possible to add a LET combinator to UPARSE, and there are other longstanding problems that get solved.</p>
<h3>
<a name="isotopes-shape-up-more-clearly-3" class="anchor" href="https://forum.rebol.info#isotopes-shape-up-more-clearly-3"></a>Isotopes Shape Up More Clearly</h3>
<p>We now use a more consistent terminology where things like null are called <a href="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005/9">"antiforms" instead of "isotopes"</a> (e.g. the null antiform is one of the three isotopes of the WORD! <strong>null</strong>).</p>
<p>Some other shuffles were made, like saying that <a href="https://forum.rebol.info/t/why-shouldnt-void-be-done-with-a-void-word-antiform/2160">void is the antiform word of <strong>~void~</strong></a>, and flipping <a href="https://forum.rebol.info/t/why-nothing-is-the-name-for-unset-state/2078">"nothing" to the antiform of BLANK!</a>.  This was based on the realization that there wasn't really all that much value in trying to make voids some special magic type that wasn't an antiform and couldn't be put in blocks, just so its quoted form could be a lone apostrophe.</p>
<h3>
<a name="breaking-through-the-64-fundamental-types-barrier-4" class="anchor" href="https://forum.rebol.info#breaking-through-the-64-fundamental-types-barrier-4"></a>Breaking Through the 64 Fundamental Types Barrier</h3>
<p>Since the dawn of Rebol, the use of a 64-bit bitflag for type checking has meant there can be only 64 types.  We need more, and fully generalized typechecking wants to be able to test not just for fundamental types but also for predicates (like if something is EVEN? vs. just if it's an INTEGER!).</p>
<p>To keep the system from slowing down to a glacial pace by type checking through function calls, <a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">I hacked together an implementation of what I called "intrinsics"</a>.  These functions are faster to call than ordinary natives, helping make type checking faster, but also other simple function calls.</p>
<h3>
<a name="the-new-sigil-type-5" class="anchor" href="https://forum.rebol.info#the-new-sigil-type-5"></a>The New SIGIL! Type</h3>
<p>For a while there was a concept of tolerating "Weird Words" (e.g. with spaces in them) by putting them in vertical bars, <strong><code>|like this|</code></strong>.  That allowed a few new interesting "plain WORD!s" like <strong><code>::</code></strong> to exist because you could accomplish their "weird" forms with vertical bars like a SET-WORD! form as <strong><code>|::|:</code></strong>.</p>
<p>This turned out to be a bad idea.  So I simplified with <a href="https://github.com/metaeducation/ren-c/blob/master/tests/datatypes/sigil.test.reb">a new type called the SIGIL!</a>... with one for each decoration you could put on WORD!s and arrays.  These SIGIL!s only have a plain form, and have baked in evaluator behavior.  This also solves a problem elegantly, where you can write code like <strong><code>(x: '$abc, if '$ = sigil of x [...])</code></strong></p>
<h3>
<a name="api-antiform-splicing-solved-6" class="anchor" href="https://forum.rebol.info#api-antiform-splicing-solved-6"></a>API Antiform Splicing Solved</h3>
<p>Having the <code>@</code> symbol be a SIGIL! with built-in evaluator behavior finessed another longstanding problem that having it be a WORD! bound to a reassignable function couldn't do, which was to reconstruct antiforms in API splices, e.g.:</p>
<pre><code>Value* val = rebValue("~true~");  // quasiform evaluates to antiform (logic)

// rebElide("if", val, "[print {Error: no antiforms in source code blocks}]");

rebElide("if @", val, "[print {Special loophole for @ makes this work}]");
</code></pre>
<p>The @ sigil can be given a special baked-in behavior--specific to the API--allowing it to preserve and reconstitute the antiform state.  This helps bridge the fact that <code>val</code> above isn't a Rebol WORD!, but a C variable, but still give the indirection that a word would have.  <em>(Note that splicing antiforms as quasiforms would be too permissive, because you can't be certain that your splices are in code that is evaluative... it would be like saying <strong><code>compose [1 (null) 2]</code></strong> gives you <strong><code>[1 ~null~ 2]</code></strong> instead of raising the intended error.)</em></p>
<p>Resolving this major sticking point in the API was a big relief.</p>
<h3>
<a name="string-interpolation-solved-7" class="anchor" href="https://forum.rebol.info#string-interpolation-solved-7"></a>String Interpolation Solved?</h3>
<p>Whenever you are passing around a BLOCK! you may be passing along its environment, to which it holds a permanent reference (preventing that environment from GC'ing).  But even more costly would be if every string had to carry around an environment...which also meant anyone you passed a string to gets access to environments that may have incidentally been put on that string.</p>
<p>The solution seems a bit obvious in retrospect: if you want to do interpolation on a string, <a href="https://forum.rebol.info/t/could-strings-have-context/587/27">put it in something like a BLOCK!</a>.  Like I say, <em>"a lot better than starting to worry about having to quote your strings to suppress binding!"</em></p>
<hr>
<h1>
<a name="april-things-start-to-stall-8" class="anchor" href="https://forum.rebol.info#april-things-start-to-stall-8"></a>April : Things Start to Stall</h1>
<h3>
<a name="coming-to-terms-with-fence-and-brace-incompatibility-9" class="anchor" href="https://forum.rebol.info#coming-to-terms-with-fence-and-brace-incompatibility-9"></a>Coming to Terms with FENCE! and Brace Incompatibility</h3>
<p>For the past few years I'd been second-guessing the idea that plain braces should be used for strings, and that they should instead be another array type called FENCE!.  Comparing Rebol to the JSON it inspired made it seem like a thing that <a href="https://forum.rebol.info/t/json-envy-serialization-dialect-in-rebol/2140/2">once seen could not be unseen</a>.</p>
<p>Thinking through the natural alternatives for string representation made me think there could be an asymmetric pair of delimiters made by <strong><code>-{</code></strong> and <strong><code>}-</code></strong>.  Not only that, the pattern could be extended with more dashes.</p>
<pre><code> obj: {x: 10, y: "obj would be an object now"}

 print -{Hello new string "World"}-

 print -{Hello single } brace-containing string}-
 
 print --{Hello compound }- brace-containing double dash string}--
</code></pre>
<p>It might seem this would be a relatively simple-to-implement change compared to something like binding.  But it threw a wrench into things for many reasons:</p>
<ul>
<li>
<p>Historical binding was always complete garbage, whereas single-braced strings were actually touted as a pleasing aspect of the language (including by me).</p>
</li>
<li>
<p>This would be the first truly non-backwards-compatible LOAD change to Ren-C, meaning that either some special way to signal which interpretation would be needed, or the work in the Rebol2 compatibility module would go to waste.</p>
<ul>
<li>
<p>The idea of a single simple-switch covering this narrow issue always raises the question of whether you want a more generalized hook that you can give before loading.  Red offers such a thing as <code>system/lexer/pre-load</code> which is just a function that transform source UTF-8 before you load it, <a href="https://www.red-lang.org/2019/11/editorial-brief-essay-on-lexical.html">though claims it should not be abused</a></p>
</li>
<li>
<p>While I thought I could hack through a prototype with a kind of pre-load functionality using the existing bootstrap executable, trying to pre-empt the LOAD process exposed so many bugs in the R3-Alpha module implementation that it was basically impossible.</p>
</li>
</ul>
</li>
<li>
<p>Adding to the heaviness of the change, the concept that single-brace FENCE! creates an OBJECT! under evaluation just brings to attention the question of how binding works in such cases... e.g. does it make sense that <strong><code>{x: 10, y: y + 20}</code></strong> would try to make an object in which Y is adding 20 to the as-yet-to-be-defined Y field of the object being produced, necessitating you to write <strong><code>eval compose ${x: 10, y: (y) + 20}</code></strong> to capture an external Y?  Does that EVAL treat fences different than other array types, and if so should it treat groups different from blocks?</p>
</li>
</ul>
<h3>
<a name="i-went-down-the-rabbit-hole-of-updating-the-bootstrap-executable-10" class="anchor" href="https://forum.rebol.info#i-went-down-the-rabbit-hole-of-updating-the-bootstrap-executable-10"></a>I Went Down The Rabbit Hole Of Updating The Bootstrap Executable</h3>
<p>The makefile generation and other "prep" code has been building using a version of Ren-C from December 2018.  It's been somewhat impressive that techniques in a <code>bootstrap-shim</code> file have been able to largely twist the language to modern conventions from within the language itself.  (This continues the tradition from <code>r2-forward</code> which made Rebol2 act more like R3-Alpha without having to change the EXE itself, though the adaptations were much less radical and done without Ren-C's high-leverage function composition tools.)</p>
<p>But hitting the bugs in pre-empting the LOAD process made me realize that it was time to make new bootstrap executables that fixed those bugs, and supported a mechanism for the new string format (and perhaps even add the FENCE! type).</p>
<p>So long as I was doing that, I could fold <em>most</em> of the bootstrap-shim features into the executable itself, for better and cleaner performance.  While doing so I could take that time to assess whether all the improvements had actually turned out to be improvements or not...reverting anything that had turned out to be bad.  I could also make the bootstrap EXE's PARSE compatible with modern UPARSE, meaning the only Rebol2-style parsing we'd have would be in the Redbol emulation.</p>
<p>I also undertook modernizing the C code itself, where old names like <code>RELVAL</code> or <code>REBSER</code> could be replaced with newer stylization like <code>Cell</code> and <code>Series</code>.  This made it easier to read and compare older and newer code, and paste between them.</p>
<h3>
<a name="new-sigil-but-no-silver-bullet-for-types-11" class="anchor" href="https://forum.rebol.info#new-sigil-but-no-silver-bullet-for-types-11"></a>New <code>&amp;</code> Sigil, but No Silver Bullet For Types</h3>
<p>Opening up the number of fundamental types allowed bringing in a new sigil (<strong><code>&amp;[bl o ck]</code></strong>, <strong><code>&amp;word</code></strong>, <strong><code>&amp;(gr o up)</code></strong> etc.) which could be used for types.  While <a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">some ideas were thrown around</a>, no truly great coherent ideas for what Rebol's type system should be came up.</p>
<hr>
<h1>
<a name="may-july-not-really-thinking-about-rebol-12" class="anchor" href="https://forum.rebol.info#may-july-not-really-thinking-about-rebol-12"></a>May <img src="https://forum.rebol.info/images/emoji/twitter/arrow_right.png?v=12" title=":arrow_right:" class="emoji" alt=":arrow_right:" loading="lazy" width="20" height="20"> July : Not Really Thinking About Rebol</h1>
<p>I had a lot going on personally, and confronting Rebol's hard problems head-on was very wearying and not something I felt like doing (or even <em>able</em> to do).</p>
<p>Also wearying is that the world doesn't stand still.  The tools you use become deprecated and new versions have new flags and frustrations to deal with.  Every month (week?) you step away means you'll be coming back to something that broke, especially when you try to keep things running on as many platforms as Ren-C does.</p>
<p>So I found it easier to mess around with NixOS and discover more about what state it's in these days, watch YouTube math videos and <a href="https://github.com/ManimCommunity/manim">learn about Manim</a>, ask AI to turn my old <a href="http://metaeducation.com/media/music/harpsy.mp3">unfinished clips</a> into <a href="http://metaeducation.com/media/music/paper-planes.mp3">complete songs</a>, go to improv... basically anything but worry about the design of an esoteric language.</p>
<p><em>(I also have a "part-time job" as a product reviewer, that I was picked for on the basis of having written good reviews on Amazon for some years.  It doesn't pay directly, but I get free stuff to write reviews for: listening on <a href="https://www.pcmag.com/reviews/jabra-elite-10-gen-2">these $279-list-price earbuds right now</a>.)</em></p>
<hr>
<h1>
<a name="august-now-what-13" class="anchor" href="https://forum.rebol.info#august-now-what-13"></a>August : Now What?</h1>
<p>I'm back in Florida now, and settling into hermit mode...possibly for a couple of months, or maybe all winter.  More in the mood for doing some development.</p>
<p>I've synchronized Ren-C with all the updates of the compilers and tools, and made a new Linux development VM based on Ubuntu 24.04 LTS (since the last Long-Term-Support release I'd been using expired, long-term doesn't actually feel all that long).</p>
<p>And I'm now taking the important step of sitting down to write a status update.  It's good to remember the nifty stuff that happened earlier in the year, and consciously reflect on what has been blocking the desire to work on it since then.</p>
<p><strong>I sure wish I could make some conservative choices and create a mimimum viable product, without needing to single-handedly try and solve everything up front with the Ren-C artifact.</strong></p>
<p>Yet the sad fact is that when it comes to just "getting the idea out there", that ship sailed long ago with Rebol2.  From a design level, it found just enough that would stick to the wall.  But it was enough to inspire JSON, and then spawn a bunch of bus-factor-one derivative projects.</p>
<p>While Ren-C took R3-Alpha's <a href="https://en.wikipedia.org/wiki/Second-system_effect">Second-System Effect</a> to new heights of pathology, it has the merit of being full of ideas I find interesting.  Meanwhile in over a decade, Red's "getting the idea out there, part 2" mission hasn't even accomplished an artifact that achieves Rebol2 parity for our modern faster-evolving ecology... <em>despite being relatively unambitious about changing the language</em>.  And I don't personally find much interesting about it <sub>(<a href="https://codeberg.org/hiiamboris/red-common">except for some of the stuff @hiiamboris does</a>)</sub></p>
<p>Grafting one or two of the cool ideas onto R3-Alpha or Red, while leaving binding and the other big picture issues unsolved, isn't something the world needs (or can be made to want, nor should it).  So I've dug my own hole: too many nifty concepts, but not a complete enough picture to deploy as a system.</p>
<p><strong>Could I do small bite-size YouTube shorts (or similar) that demonstrate interesting ideas, without actually trying to sell people on an artifact that implements those ideas?</strong>  I'm not sure... but there are people who will watch <a href="https://www.youtube.com/watch?v=UCgoxQCf5Jg">entire documentaries on things like TempleOS</a> without feeling they've wasted their time, even though they don't intend to ever run it.</p>
<hr>
<h1>
<a name="step-one-is-write-update-post-step-two-is-14" class="anchor" href="https://forum.rebol.info#step-one-is-write-update-post-step-two-is-14"></a>Step One Is Write Update Post.  Step Two Is...</h1>
<p>I've actually had some topics I've wanted to write on in the last few weeks.</p>
<p>But I felt that since I hadn't said anything for a while, I needed to write a status post and speak some about what's been on my mind.</p>
<p>Ok...</p>
<p><strong>I'm going to do some low-pressure tinkering just to get back to making commits and posts and see what grabs me.</strong></p>
<p>I'll update here with any more thoughts.  Certainly I think that making the canon "Rebol: The Movie" documentary is something I'm uniquely qualified to do.  Maybe if I combined history, stories of the cast of characters and personalities, along with summarized design arguments and critiques it would be enough that the software-writing-AI of the future (<a href="https://www.youtube.com/shorts/MSuw5AoN7I8">or...Thursday?</a>) could sort it out.  If not, at least entertain.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188</link>
          <pubDate>Sun, 18 Aug 2024 00:43:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2188</guid>
          <source url="https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188.rss">Back to Bedlam: August 2024 Status and...Plan? :confused:</source>
        </item>
        <item>
          <title>The Robustness Principle Is Not Robust</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Something floating around that I've pretty much always hated--but experience has made me hate more--is the "Robustness Principle":</p>
<aside class="onebox wikipedia" data-onebox-src="https://en.wikipedia.org/wiki/Robustness_principle">
  <header class="source">

      <a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">en.wikipedia.org</a>
  </header>

  <article class="onebox-body">
    

<h3><a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">Robustness principle</a></h3>

<p>In computing, the robustness principle is a design guideline for software that states: "be conservative in what you do, be liberal in what you accept from others". It is often reworded as: "be conservative in what you send, be liberal in what you accept". The principle is also known as Postel's law, after Jon Postel, who used the wording in an early specification of TCP.
 In other words, programs that send messages to other machines (or to other programs on the same machine) should conform comple...</p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>I understand the motivation.  If you have something that imports to a vector graphics program and not all the Bezier curves have endpoints... then, sure.  Someone is going to appreciate that you were forgiving and they got some kind of maybe-a-bit-broken picture instead of an "Invalid File" error.</p>
<p>Pushing this further to those of us who remember the DOS days: we had those experiences where we accidentally deleted files, but the filesystem didn't delete everything--it just wrote a zero byte on the filename (or somesuch).  Norton Utilities let us catch our mistake and get our file back.  In some ways, a lax and forgiving attitude is a beautiful thing...</p>
<p>This so-called "robustness" cannot (and should not) be subconscious.  It needs to be mitigated with an in-your-face consciousness shift!  <em>(And I think Norton Utilities is an apt example, because if you were firing up that program <a href="https://www.youtube.com/watch?v=RRU3I_o1vLc">you knew you were in the Danger Zone</a>)</em>.</p>
<p>There must be a really jarring speedbump.  When a data file is not fitting the standards, you have to go through a procedure that transforms the broken file to the standard.  You have to be aware that you are dealing with a dirty file.  And the experience of that transformation informs you that the person who gave you the dirty file isn't playing with all their marbles, and you correct them for the next transmission.</p>
<p>Authentic programs should demand a standard form.  And when they aren't getting the standard form they should speak up, march you out the door, and force you to fix your input. "Real programs" should never pretend the byte sequence of bad input is okay--there should only be "Cleanup/Recovery programs" that fix the sequence to write a correct one.  And that recovery program should be terminated before the "Real program" runs.</p>
<hr>
<p>I don't need to rewrite the critiques of the "robustness principle" cited in Wikipedia.  But it is nonsense, and the opposite of robust.  It's a garbage idea, that anyone with a whit of sense regarding security can see right through immediately.</p>
<p>There is a better way: the better way is <em>consciousness</em> about what you are working with, and rejection of any sort of malignant "middleman" acting on your data without you knowing.</p>
<ul>
<li>
<p>"Normalization" you did not ask for is an attack on your information.</p>
</li>
<li>
<p>"Glossing over or fixing invalid sequences" you did not ask for is an attack on your information</p>
</li>
<li>
<p>Anything which makes a simple load of a file and save back of the same file not idempotent is an attack on your information</p>
</li>
</ul>
<p>Perhaps I've become even more religious than Carl in some of these ways.  But I certainly see things won't get better without pushing back.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187</link>
          <pubDate>Thu, 13 Jun 2024 05:45:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2187</guid>
          <source url="https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187.rss">The Robustness Principle Is Not Robust</source>
        </item>
        <item>
          <title>PicoLisp machine</title>
          <dc:creator><![CDATA[jjsullivan5196]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Pretty comprehensive reference on how picolisp's cons machine works <a href="https://software-lab.de/doc/ref.html#vm" class="inline-onebox" rel="noopener nofollow ugc">PicoLisp Reference</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/picolisp-machine/2185">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/picolisp-machine/2185</link>
          <pubDate>Thu, 23 May 2024 06:34:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2185</guid>
          <source url="https://forum.rebol.info/t/picolisp-machine/2185.rss">PicoLisp machine</source>
        </item>
        <item>
          <title>Om: concatenative homoiconic language</title>
          <dc:creator><![CDATA[jjsullivan5196]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p><a href="https://www.om-language.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.om-language.org/</a></p>
<p>This was a one hit wonder on hackernews a couple years ago. Probably the thing of greatest relevance is its "panmorphic" data representation: 3 terminal types of</p>
<ul>
<li>Separators, which compose any utf8 whitespace characters</li>
<li>Operator, essentially symbols of <code>any-other-utf8-text</code>.</li>
<li>Operand, a quoted program in <code>{curlie braces}</code> containing operators or <code>{{other} {operands} and operators}</code> with separators between.</li>
</ul>
<p>The evaluator can define a vocabulary of base "operations" tied to an operator symbol. Every operation takes the rest of the program as input and appends its output. For instance, <code>quote</code> and <code>dequote</code> wrap or unwrap the next term of the program in an enclosing operand. (using <code>-&gt;</code> to indicate output)</p>
<pre><code class="lang-plaintext">quote {A}
-&gt; {{A}}
</code></pre>
<pre><code class="lang-plaintext">dequote {A}
-&gt; A
</code></pre>
<p>More examples on the website</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/om-concatenative-homoiconic-language/2184">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/om-concatenative-homoiconic-language/2184</link>
          <pubDate>Thu, 23 May 2024 02:44:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2184</guid>
          <source url="https://forum.rebol.info/t/om-concatenative-homoiconic-language/2184.rss">Om: concatenative homoiconic language</source>
        </item>
        <item>
          <title>John Sullivan</title>
          <dc:creator><![CDATA[jjsullivan5196]]></dc:creator>
          <category>Introductions</category>
          <description><![CDATA[
            <p>Hi!</p>
<p>Love what you all are doing here. I came to know about REBOL from a talk Doug Crockford did on syntax and data formats. I learned more about Carl's vision for the design and principles of the language, and Ren-C seems to be carrying on that tradition of simplicity and sustainability.</p>
<p>I decided to join the forum because I've been craving a language that's easier to carry with me wherever I might be, and REBOL fits the bill. Excited to learn more from you all.</p>
<p>I'm particularly inspired by <a class="mention" href="https://forum.rebol.info/u/hostilefork">@hostilefork</a>'s talk from a few years ago where you could build a new interpreter using <a href="https://youtu.be/PT3GOe1pj9I?si=NJlWjA6r_9i9J5Rh" rel="noopener nofollow ugc">just the tools that come with it</a>.  I've been experimenting recently with the cosmopolitan libc toolchain, and I think it could supercharge that capability:</p>
<p><strong><a href="https://github.com/jart/cosmopolitan" rel="noopener nofollow ugc">https://github.com/jart/cosmopolitan</a></strong></p>
<p>Admittedly I'm still a novice getting used to everything, but you can try what I have so far here if you'd like:</p>
<p><a href="https://github.com/jjsullivan5196/r3/blob/renc-cosmo-testing/README-COSMO.md" class="inline-onebox" rel="noopener nofollow ugc">r3/README-COSMO.md at renc-cosmo-testing · jjsullivan5196/r3 · GitHub</a></p>
<p>Building with cosmo allows the executable image to run on just about any computer you can paste it on, no rebuilding required!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/john-sullivan/2182">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/john-sullivan/2182</link>
          <pubDate>Sun, 19 May 2024 03:09:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2182</guid>
          <source url="https://forum.rebol.info/t/john-sullivan/2182.rss">John Sullivan</source>
        </item>
        <item>
          <title>The Truthiness of Nothing</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><strong>Does it really add value to consider <strong><a href="https://forum.rebol.info/t/why-nothing-is-the-name-for-unset-state/2078">the nothing state</a></strong> (an antiform blank held by unset variables) to be neither truthy nor falsey?</strong></p>
<p>Here's a quick survey of how UNSET! (the most nothing-like thing in historical Rebol) is handled:</p>
<h3>
<a name="rebol2-1" class="anchor" href="https://forum.rebol.info#rebol2-1"></a>Rebol2</h3>
<pre><code>rebol2&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
** Script Error: either is missing its condition argument

rebol2&gt;&gt; unset? all [get/any 'asdf]
== true

rebol2&gt;&gt; unset? any [get/any 'asdf]
== true

rebol2&gt;&gt; case [get/any 'asdf [print "truthy"]]
** Script Error: Block did not return a value
</code></pre>
<h3>
<a name="r3-alpha-2" class="anchor" href="https://forum.rebol.info#r3-alpha-2"></a>R3-Alpha</h3>
<pre><code>r3-alpha&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
** Script error: either does not allow unset! for its condition argument

r3-alpha&gt;&gt; unset? all [get/any 'asdf]
== true

r3-alpha&gt;&gt; unset? any [get/any 'asdf]
== false  ; ...huh?

r3-alpha&gt;&gt; any [get/any 'asdf 1020]   
== 1020

r3-alpha&gt;&gt; case [get/any 'asdf [print "truthy"]]
** Script error: block did not return a value
</code></pre>
<h3>
<a name="red-3" class="anchor" href="https://forum.rebol.info#red-3"></a>Red</h3>
<pre><code>red&gt;&gt; if get/any 'asdf [print "truthy"]
truthy

red&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
*** Script Error: block did not return a value  ; &lt;-- huh?

red&gt;&gt; unset? all [get/any 'asdf]
== true

red&gt;&gt; unset? any [get/any 'asdf]
== true

red&gt;&gt; case [get/any 'asdf [print "truthy"]]
*** Script Error: block did not return a value  ; &lt;-- huh, again?
</code></pre>
<h2>
<a name="oldes-rebol3-4" class="anchor" href="https://forum.rebol.info#oldes-rebol3-4"></a>Oldes Rebol3</h2>
<p>Transparent in <a href="https://github.com/Oldes/Rebol3/commit/2ba01ead3b5da1ab609fa25a0c675b30e96bb163">ANY and ALL</a> (like a Ren-C void), but presumably still an error in plain IF or EITHER or CASE...</p>
<h2>
<a name="ren-cs-always-error-has-been-more-consistent-but-5" class="anchor" href="https://forum.rebol.info#ren-cs-always-error-has-been-more-consistent-but-5"></a>Ren-C's "Always Error" Has Been More <em>Consistent</em>, But...</h2>
<p>Clearly people have been pushing away from it being an error.</p>
<p>So does being "ornery" for conditional logic really help matters?  When we consider the dual role of nothing as an "uninteresting, but successful" result, might we get as much (or more?) value from considering it to be always truthy?</p>
<p>For example: Ren-C uses NOTHING as the result of PRINT when the print actually produces output.  Otherwise, you get NULL.</p>
<pre><code>&gt;&gt; message: "Hello"
== "Hello"

&gt;&gt; print message  ; won't have a console "==" due to being a nothing result
Hello

&gt;&gt; nothing? print message
Hello
== ~true~  ; anti

&gt;&gt; message: null
== ~null~  ; anti

&gt;&gt; print maybe message
== ~null~  ; anti

&gt;&gt; print []
== ~null~  ; anti
</code></pre>
<p>Nothing has the property of suppressing console output, which is desirable in most print cases--at least those that do print output.  And if you said <code>(x: print "Hello")</code> you'd get a variable that would create an error on access, which seems also desirable.</p>
<p>If nothing was truthy, that makes it easier to act on the nothing-vs-null distinction in something like an ANY or ALL construct.</p>
<h2>
<a name="should-meaningless-but-truthy-unset-variable-state-6" class="anchor" href="https://forum.rebol.info#should-meaningless-but-truthy-unset-variable-state-6"></a>Should "Meaningless but Truthy" = "Unset Variable State"?</h2>
<p>A related question may be if functions like PRINT should be returning the same value as what is held by an unset variable.</p>
<p>Now that non-antiform BLANK! itself is truthy, might it be a better choice?</p>
<pre><code>&gt;&gt; print "Hello"
Hello
== _
</code></pre>
<p>But then...</p>
<ul>
<li>
<p>For the visual we seek, the console would need to not print BLANK!.  But I find it unsatisfying to have a non-antiform be what has "no representation".</p>
</li>
<li>
<p>If you assigned the result of this "meaningless" value to a variable, you wouldn't have that added protection that the variable would appear unset.</p>
</li>
</ul>
<h2>
<a name="truthy-nothing-seems-to-have-more-pluses-than-minuses-7" class="anchor" href="https://forum.rebol.info#truthy-nothing-seems-to-have-more-pluses-than-minuses-7"></a>Truthy Nothing Seems To Have More Pluses than Minuses</h2>
<p>My "semantic safety" bias initially had made me think that when you have a function like PRINT, it's nice to catch potential mistakes when you tried to act like it was a function that could meaningfully be tested for some kind of logical result.  So I pushed R3-Alpha's error from IF and EITHER further into ANY and ALL.</p>
<p>Then I went and made it so that when the PRINT received an opted-out input, it gave back NULL instead of NOTHING.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20">  So it was something you could act on with ELSE, but not other conditional constructs.</p>
<p>The evolution from UNSET! to the blank-antiform that is today's NOTHING has been a long and winding one.  Working around its ornery-ness gave rise to all kinds of interesting designs like voids, and invisibles like ELIDE PRINT.</p>
<p>But though I'm sure that I haven't considered all the angles yet...having nothing be neither-true-nor-false is looking more like a dying historical artifact than something with a clear motivation applicable to the present.</p>
<p>Nothing being always truthy offers consistency...and it's possible to ELIDE it to get "no vote" so it won't affect an ANY or ALL (the way Oldes R3 treats unsets).  Yet having the vote isn't entirely useless either.  I can't think of a whole lot of downside, so I think it's worth trying.</p>
<hr>
<p>A better axis of orneryness that may actually catch more problems in practice is: <strong><a href="https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068/2">Should Nothing be Illegal in Comparisons</a></strong></p>
<p>(I point out in that discussion that simply disabling the ability to check nothing for truthiness/falseyness is kind of a strange counterpart to a routine that returns--say--an INTEGER! in all cases, where you get zero information from testing an integer conditionally but without anything to stop you...making the disablement of testing nothing conditionally seem like a fairly empty gesture.)</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-truthiness-of-nothing/2180">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-truthiness-of-nothing/2180</link>
          <pubDate>Fri, 03 May 2024 17:27:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2180</guid>
          <source url="https://forum.rebol.info/t/the-truthiness-of-nothing/2180.rss">The Truthiness of Nothing</source>
        </item>
        <item>
          <title>RE: The Ordering and Priorities of the Ren-C Project</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/5">Speed of UPARSE</a>
</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/4">Speed of UPARSE</a>
</div>
<blockquote>
<p>I’ll be blunt: this, to me, sounds unusably slow. Beyond the very simplest tasks, I can’t imagine a situation where I’d deliberately choose to take a 250× performance drop.</p>
</blockquote>
</aside>
<p>This is a first-of-its-kind design. And if you don't understand why I'm building things the way I'm building them, then...to be blunt...there's not much point in me listening to your feedback regarding the order in which I do things.</p>
</blockquote>
</aside>
<p>Remember, I come from well outside the Rebol world. The reason I don’t understand is, to a large extent, because this way of reasoning about code is one I’ve never seen before in my life. This is the reason I’m asking so many questions, setting out my opinions, and having these discussions with you… precisely so that I can begin to understand why it is that way.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179</link>
          <pubDate>Sat, 06 Apr 2024 19:16:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2179</guid>
          <source url="https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179.rss">RE: The Ordering and Priorities of the Ren-C Project</source>
        </item>
        <item>
          <title>Should SET-WORD!s Propagate Undecayed Packs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Packs are antiform blocks, which decay if not specifically handled.</p>
<pre><code>&gt;&gt; pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a: pack [1 2]
== 1

&gt;&gt; a
== 1
</code></pre>
<p>From time to time, I've wondered if there's a good reason why the plain SET-WORD! shouldn't propagate the pack:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (hypothetical)

&gt;&gt; a
== 1
</code></pre>
<p>One rationale is that intuitively, <strong>a:</strong> should be a synonym for <strong>[a]:</strong>, e.g. "unpack one item" is implicit.</p>
<p>But that just bumps the question to the next one we might ask: why doesn't a multi-return without a "circled" result just evaluate to the whole pack?</p>
<p>It looks to make some sense at first, it allows you to chain indefinitely:</p>
<pre><code>&gt;&gt; [a b]: [c d]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1

&gt;&gt; d
== 2
</code></pre>
<p>Though it feels a little bit unsettling when you drop it down:</p>
<pre><code>&gt;&gt; [a b]: [c]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1
</code></pre>
<p>But we could argue that if you're bothered, then you use circling (currently <code>@c</code>, but with FENCE! proposed to be <code>{c}</code>).  Note in the below example you'd have to use <code>/b</code> in order to indicate you were okay with unpacking more values than available.</p>
<pre><code>&gt;&gt; [a /b]: [{c}]: pack [1 2]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== ~null~  ; anti

&gt;&gt; c
== 1
</code></pre>
<p>We could then make a choice if <strong>a:</strong> was a synonym for <strong>[a]:</strong> or for <strong>[{a}]:</strong></p>
<h2>
<a name="most-recent-motivation-for-thinking-about-this-1" class="anchor" href="https://forum.rebol.info#most-recent-motivation-for-thinking-about-this-1"></a>Most Recent Motivation For Thinking About This</h2>
<p>I rewrote <a href="https://forum.rebol.info/t/speed-of-uparse/2177/3">some code in an example</a> from this:</p>
<pre><code>[^result' remainder]: parser input except e -&gt; [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
return unmeta result'  ; return successful parser result
</code></pre>
<p>...to this:</p>
<pre><code>return [@ remainder]: parser input except [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
</code></pre>
<p>The idea is that the parser being called has multiple return results... the first is the synthesized value, the second is the amount it advanced.  <em>(There's a third result on some parsers of "pending items", but this OPTIONAL combinator has an "autopipe" which is just bubbling the pending items through in the order of successful parsers called...so the third result is specialized out on its interface and on the parsers it calls.)</em></p>
<p><strong>However, the synthesized value can itself be a pack.</strong>  This means that if we named a variable in the slot where the <code>@</code> is, then that pack would be decayed to store in the variable unless we used a ^META result.</p>
<p>So does the act of not-naming and just circling subvert the decay?  Or should the circled result not be decayed even if the variable is?</p>
<pre><code>&gt;&gt; [{a} b]: pack [pack [1 2] 3]
== ~['1 '2]~  ; anti  (or should it be decayed to 1?)

&gt;&gt; a
== 1

&gt;&gt; b
== 3
</code></pre>
<p>It's a different--but related--question.  It seems it should align with the behavior of plain assignments:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (implied if the above behavior is chosen)

&gt;&gt; a
== 1
</code></pre>
<h2>
<a name="not-100-certain-but-i-think-undecayed-propagation-is-good-2" class="anchor" href="https://forum.rebol.info#not-100-certain-but-i-think-undecayed-propagation-is-good-2"></a>Not 100% Certain, But I Think Undecayed Propagation Is Good</h2>
<p>I'll point out that it's possible to DECAY things pretty easily, but you can't recover a pack after it has been decayed.</p>
<p>So I'm getting the feeling that it's probably best to decay the assignments, but propagate the undecayed pack.  It looks like the more general and useful behavior...even if it seems a bit confusing.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178</link>
          <pubDate>Fri, 29 Mar 2024 21:22:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2178</guid>
          <source url="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178.rss">Should SET-WORD!s Propagate Undecayed Packs?</source>
        </item>
        <item>
          <title>Speed of UPARSE</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>I’m just wondering if any benchmarking has been done on UPARSE. How does it compare to PARSE in Red or in Rebol? Or to parser combinators in Haskell? For that matter, how does it compare to an ordinary recursive-descent parser handwritten in Ren-C?</p>
<p>(Yes, I know UPARSE is unoptimised and slow. But it would be interesting to know <em>how</em> slow.)</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/speed-of-uparse/2177">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/speed-of-uparse/2177</link>
          <pubDate>Fri, 29 Mar 2024 06:47:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2177</guid>
          <source url="https://forum.rebol.info/t/speed-of-uparse/2177.rss">Speed of UPARSE</source>
        </item>
  </channel>
</rss>

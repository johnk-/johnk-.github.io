<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest topics</title>
    <link>https://forum.rebol.info/latest</link>
    <description>Latest topics</description>
    
      <lastBuildDate>Sun, 18 Aug 2024 00:43:55 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/latest.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Back to Bedlam: August 2024 Status and...Plan? :confused:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Announcements</category>
          <description><![CDATA[
            <blockquote>
<p>So Ren-C had a pretty exciting first 3 months of 2024, and then started to drop off, until I wasn't working on it at all.</p>
<p>I'll try and sum up what's gone on, and where things might realistically go from here.</p>
</blockquote>
<hr>
<h1>
<a name="rapid-development-january-march-1" class="anchor" href="https://forum.rebol.info#rapid-development-january-march-1"></a>Rapid Development: January <img src="https://forum.rebol.info/images/emoji/twitter/arrow_right.png?v=12" title=":arrow_right:" class="emoji" alt=":arrow_right:" loading="lazy" width="20" height="20"> March</h1>
<h3>
<a name="binding-paradigm-shift-2" class="anchor" href="https://forum.rebol.info#binding-paradigm-shift-2"></a>Binding Paradigm Shift</h3>
<p>The <a href="https://forum.rebol.info/t/bradrn-brad/2088">arrival of @bradrn</a> who had been investigating "R" directed attention back to the central language issue of how binding works at all (if it can be made to work).  This prioritized revisiting "Pure Virtual Binding" with fresh eyes: <strong><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/9">Pure Virtual Binding II</a></strong></p>
<p>I feel the premises are sound.  But if you buy into the methodology, then there are many consequences that will seem more alien than usual to historical Rebol programmers.  BLOCK!s are not inert in the evaluator, but rather evaluate to a version of the BLOCK! with binding applied... so <strong><code>(blk: [a b c])</code></strong> is distinct from <strong><code>(blk: '[a b c])</code></strong> where the latter uses quoting to suppress the evaluation.  And since quoting suppresses any binding, <strong><code>(x: 10, y: get 'x)</code></strong> won't work because the <strong><code>'x</code></strong> term drops the quote and stays unbound, meaning you have to use the new VAR-WORD! type and write <strong><code>(x: 10, y: get $x)</code></strong>.</p>
<p><em>The epicycles of this new world touch every aspect of the design</em>--forcing "binding awareness" to the forefront of dialect authors and casual users.  I wish there were an easier answer, but "implicitly paste unique binding pointers on words in waves" is being proven to be non-composable sufficiently well by other Redbol implementations.  It doesn't work meaningfully, so they simply write anything non-trivial as C or Red/System.</p>
<p>I managed to get the system to run well enough to research the design.  It is very half-baked, and every few minutes I work with it triggers the need for a new meditation in the <a href="https://forum.rebol.info/c/development/binding/49">Binding category</a>.  But as a positive sign, the new model made it possible to add a LET combinator to UPARSE, and there are other longstanding problems that get solved.</p>
<h3>
<a name="isotopes-shape-up-more-clearly-3" class="anchor" href="https://forum.rebol.info#isotopes-shape-up-more-clearly-3"></a>Isotopes Shape Up More Clearly</h3>
<p>We now use a more consistent terminology where things like null are called <a href="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005/9">"antiforms" instead of "isotopes"</a> (e.g. the null antiform is one of the three isotopes of the WORD! <strong>null</strong>).</p>
<p>Some other shuffles were made, like saying that <a href="https://forum.rebol.info/t/why-shouldnt-void-be-done-with-a-void-word-antiform/2160">void is the antiform word of <strong>~void~</strong></a>, and flipping <a href="https://forum.rebol.info/t/why-trash-is-the-name-for-unset-state/2078">"trash" to the antiform of BLANK!</a>.  This was based on the realization that there wasn't really all that much value in trying to make voids some special magic type that wasn't an antiform and couldn't be put in blocks, just so its quoted form could be a lone apostrophe.</p>
<h3>
<a name="breaking-through-the-64-fundamental-types-barrier-4" class="anchor" href="https://forum.rebol.info#breaking-through-the-64-fundamental-types-barrier-4"></a>Breaking Through the 64 Fundamental Types Barrier</h3>
<p>Since the dawn of Rebol, the use of a 64-bit bitflag for type checking has meant there can be only 64 types.  We need more, and fully generalized typechecking wants to be able to test not just for fundamental types but also for predicates (like if something is EVEN? vs. just if it's an INTEGER!).</p>
<p>To keep the system from slowing down to a glacial pace by type checking through function calls, <a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">I hacked together an implementation of what I called "intrinsics"</a>.  These functions are faster to call than ordinary natives, helping make type checking faster, but also other simple function calls.</p>
<h3>
<a name="the-new-sigil-type-5" class="anchor" href="https://forum.rebol.info#the-new-sigil-type-5"></a>The New SIGIL! Type</h3>
<p>For a while there was a concept of tolerating "Weird Words" (e.g. with spaces in them) by putting them in vertical bars, <strong><code>|like this|</code></strong>.  That allowed a few new interesting "plain WORD!s" like <strong><code>::</code></strong> to exist because you could accomplish their "weird" forms with vertical bars like a SET-WORD! form as <strong><code>|::|:</code></strong>.</p>
<p>This turned out to be a bad idea.  So I simplified with <a href="https://github.com/metaeducation/ren-c/blob/master/tests/datatypes/sigil.test.reb">a new type called the SIGIL!</a>... with one for each decoration you could put on WORD!s and arrays.  These SIGIL!s only have a plain form, and have baked in evaluator behavior.  This also solves a problem elegantly, where you can write code like <strong><code>(x: '$abc, if '$ = sigil of x [...])</code></strong></p>
<h3>
<a name="api-antiform-splicing-solved-6" class="anchor" href="https://forum.rebol.info#api-antiform-splicing-solved-6"></a>API Antiform Splicing Solved</h3>
<p>Having the <code>@</code> symbol be a SIGIL! with built-in evaluator behavior finessed another longstanding problem that having it be a WORD! bound to a reassignable function couldn't do, which was to reconstruct antiforms in API splices, e.g.:</p>
<pre><code>Value* val = rebValue("~true~");  // quasiform evaluates to antiform (logic)

// rebElide("if", val, "[print {Error: no antiforms in source code blocks}]");

rebElide("if @", val, "[print {Special loophole for @ makes this work}]");
</code></pre>
<p>The @ sigil can be given a special baked-in behavior--specific to the API--allowing it to preserve and reconstitute the antiform state.  This helps bridge the fact that <code>val</code> above isn't a Rebol WORD!, but a C variable, but still give the indirection that a word would have.  <em>(Note that splicing antiforms as quasiforms would be too permissive, because you can't be certain that your splices are in code that is evaluative... it would be like saying <strong><code>compose [1 (null) 2]</code></strong> gives you <strong><code>[1 ~null~ 2]</code></strong> instead of raising the intended error.)</em></p>
<p>Resolving this major sticking point in the API was a big relief.</p>
<h3>
<a name="string-interpolation-solved-7" class="anchor" href="https://forum.rebol.info#string-interpolation-solved-7"></a>String Interpolation Solved?</h3>
<p>Whenever you are passing around a BLOCK! you may be passing along its environment, to which it holds a permanent reference (preventing that environment from GC'ing).  But even more costly would be if every string had to carry around an environment...which also meant anyone you passed a string to gets access to environments that may have incidentally been put on that string.</p>
<p>The solution seems a bit obvious in retrospect: if you want to do interpolation on a string, <a href="https://forum.rebol.info/t/could-strings-have-context/587/27">put it in something like a BLOCK!</a>.  Like I say, <em>"a lot better than starting to worry about having to quote your strings to suppress binding!"</em></p>
<hr>
<h1>
<a name="april-things-start-to-stall-8" class="anchor" href="https://forum.rebol.info#april-things-start-to-stall-8"></a>April : Things Start to Stall</h1>
<h3>
<a name="coming-to-terms-with-fence-and-brace-incompatibility-9" class="anchor" href="https://forum.rebol.info#coming-to-terms-with-fence-and-brace-incompatibility-9"></a>Coming to Terms with FENCE! and Brace Incompatibility</h3>
<p>For the past few years I'd been second-guessing the idea that plain braces should be used for strings, and that they should instead be another array type called FENCE!.  Comparing Rebol to the JSON it inspired made it seem like a thing that <a href="https://forum.rebol.info/t/json-envy-serialization-dialect-in-rebol/2140/2">once seen could not be unseen</a>.</p>
<p>Thinking through the natural alternatives for string representation made me think there could be an asymmetric pair of delimiters made by <strong><code>-{</code></strong> and <strong><code>}-</code></strong>.  Not only that, the pattern could be extended with more dashes.</p>
<pre><code> obj: {x: 10, y: "obj would be an object now"}

 print -{Hello new string "World"}-

 print -{Hello single } brace-containing string}-
 
 print --{Hello compound }- brace-containing double dash string}--
</code></pre>
<p>It might seem this would be a relatively simple-to-implement change compared to something like binding.  But it threw a wrench into things for many reasons:</p>
<ul>
<li>
<p>Historical binding was always complete garbage, whereas single-braced strings were actually touted as a pleasing aspect of the language (including by me).</p>
</li>
<li>
<p>This would be the first truly non-backwards-compatible LOAD change to Ren-C, meaning that either some special way to signal which interpretation would be needed, or the work in the Rebol2 compatibility module would go to waste.</p>
<ul>
<li>
<p>The idea of a single simple-switch covering this narrow issue always raises the question of whether you want a more generalized hook that you can give before loading.  Red offers such a thing as <code>system/lexer/pre-load</code> which is just a function that transform source UTF-8 before you load it, <a href="https://www.red-lang.org/2019/11/editorial-brief-essay-on-lexical.html">though claims it should not be abused</a></p>
</li>
<li>
<p>While I thought I could hack through a prototype with a kind of pre-load functionality using the existing bootstrap executable, trying to pre-empt the LOAD process exposed so many bugs in the R3-Alpha module implementation that it was basically impossible.</p>
</li>
</ul>
</li>
<li>
<p>Adding to the heaviness of the change, the concept that single-brace FENCE! creates an OBJECT! under evaluation just brings to attention the question of how binding works in such cases... e.g. does it make sense that <strong><code>{x: 10, y: y + 20}</code></strong> would try to make an object in which Y is adding 20 to the as-yet-to-be-defined Y field of the object being produced, necessitating you to write <strong><code>eval compose ${x: 10, y: (y) + 20}</code></strong> to capture an external Y?  Does that EVAL treat fences different than other array types, and if so should it treat groups different from blocks?</p>
</li>
</ul>
<h3>
<a name="i-went-down-the-rabbit-hole-of-updating-the-bootstrap-executable-10" class="anchor" href="https://forum.rebol.info#i-went-down-the-rabbit-hole-of-updating-the-bootstrap-executable-10"></a>I Went Down The Rabbit Hole Of Updating The Bootstrap Executable</h3>
<p>The makefile generation and other "prep" code has been building using a version of Ren-C from December 2018.  It's been somewhat impressive that techniques in a <code>bootstrap-shim</code> file have been able to largely twist the language to modern conventions from within the language itself.  (This continues the tradition from <code>r2-forward</code> which made Rebol2 act more like R3-Alpha without having to change the EXE itself, though the adaptations were much less radical and done without Ren-C's high-leverage function composition tools.)</p>
<p>But hitting the bugs in pre-empting the LOAD process made me realize that it was time to make new bootstrap executables that fixed those bugs, and supported a mechanism for the new string format (and perhaps even add the FENCE! type).</p>
<p>So long as I was doing that, I could fold <em>most</em> of the bootstrap-shim features into the executable itself, for better and cleaner performance.  While doing so I could take that time to assess whether all the improvements had actually turned out to be improvements or not...reverting anything that had turned out to be bad.  I could also make the bootstrap EXE's PARSE compatible with modern UPARSE, meaning the only Rebol2-style parsing we'd have would be in the Redbol emulation.</p>
<p>I also undertook modernizing the C code itself, where old names like <code>RELVAL</code> or <code>REBSER</code> could be replaced with newer stylization like <code>Cell</code> and <code>Series</code>.  This made it easier to read and compare older and newer code, and paste between them.</p>
<h3>
<a name="new-sigil-but-no-silver-bullet-for-types-11" class="anchor" href="https://forum.rebol.info#new-sigil-but-no-silver-bullet-for-types-11"></a>New <code>&amp;</code> Sigil, but No Silver Bullet For Types</h3>
<p>Opening up the number of fundamental types allowed bringing in a new sigil (<strong><code>&amp;[bl o ck]</code></strong>, <strong><code>&amp;word</code></strong>, <strong><code>&amp;(gr o up)</code></strong> etc.) which could be used for types.  While <a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">some ideas were thrown around</a>, no truly great coherent ideas for what Rebol's type system should be came up.</p>
<hr>
<h1>
<a name="may-july-not-really-thinking-about-rebol-12" class="anchor" href="https://forum.rebol.info#may-july-not-really-thinking-about-rebol-12"></a>May <img src="https://forum.rebol.info/images/emoji/twitter/arrow_right.png?v=12" title=":arrow_right:" class="emoji" alt=":arrow_right:" loading="lazy" width="20" height="20"> July : Not Really Thinking About Rebol</h1>
<p>I had a lot going on personally, and confronting Rebol's hard problems head-on was very wearying and not something I felt like doing (or even <em>able</em> to do).</p>
<p>Also wearying is that the world doesn't stand still.  The tools you use become deprecated and new versions have new flags and frustrations to deal with.  Every month (week?) you step away means you'll be coming back to something that broke, especially when you try to keep things running on as many platforms as Ren-C does.</p>
<p>So I found it easier to mess around with NixOS and discover more about what state it's in these days, watch YouTube math videos and <a href="https://github.com/ManimCommunity/manim">learn about Manim</a>, ask AI to turn my old <a href="http://metaeducation.com/media/music/harpsy.mp3">unfinished clips</a> into <a href="http://metaeducation.com/media/music/paper-planes.mp3">complete songs</a>, go to improv... basically anything but worry about the design of an esoteric language.</p>
<p><em>(I also have a "part-time job" as a product reviewer, that I was picked for on the basis of having written good reviews on Amazon for some years.  It doesn't pay directly, but I get free stuff to write reviews for: listening on <a href="https://www.pcmag.com/reviews/jabra-elite-10-gen-2">these $279-list-price earbuds right now</a>.)</em></p>
<hr>
<h1>
<a name="august-now-what-13" class="anchor" href="https://forum.rebol.info#august-now-what-13"></a>August : Now What?</h1>
<p>I'm back in Florida now, and settling into hermit mode...possibly for a couple of months, or maybe all winter.  More in the mood for doing some development.</p>
<p>I've synchronized Ren-C with all the updates of the compilers and tools, and made a new Linux development VM based on Ubuntu 24.04 LTS (since the last Long-Term-Support release I'd been using expired, long-term doesn't actually feel all that long).</p>
<p>And I'm now taking the important step of sitting down to write a status update.  It's good to remember the nifty stuff that happened earlier in the year, and consciously reflect on what has been blocking the desire to work on it since then.</p>
<p><strong>I sure wish I could make some conservative choices and create a mimimum viable product, without needing to single-handedly try and solve everything up front with the Ren-C artifact.</strong></p>
<p>Yet the sad fact is that when it comes to just "getting the idea out there", that ship sailed long ago with Rebol2.  From a design level, it found just enough that would stick to the wall.  But it was enough to inspire JSON, and then spawn a bunch of bus-factor-one derivative projects.</p>
<p>While Ren-C took R3-Alpha's <a href="https://en.wikipedia.org/wiki/Second-system_effect">Second-System Effect</a> to new heights of pathology, it has the merit of being full of ideas I find interesting.  Meanwhile in over a decade, Red's "getting the idea out there, part 2" mission hasn't even accomplished an artifact that achieves Rebol2 parity for our modern faster-evolving ecology... <em>despite being relatively unambitious about changing the language</em>.  And I don't personally find much interesting about it <sub>(except for some of the stuff Boris does)</sub></p>
<p>Grafting one or two of the cool ideas onto R3-Alpha or Red, while leaving binding and the other big picture issues unsolved, isn't something the world needs (or can be made to want, nor should it).  So I've dug my own hole: too many nifty concepts, but not a complete enough picture to deploy as a system.</p>
<p><strong>Could I do small bite-size YouTube shorts (or similar) that demonstrate interesting ideas, without actually trying to sell people on an artifact that implements those ideas?</strong>  I'm not sure... but there are people who will watch <a href="https://www.youtube.com/watch?v=UCgoxQCf5Jg">entire documentaries on things like TempleOS</a> without feeling they've wasted their time, even though they don't intend to ever run it.</p>
<hr>
<h1>
<a name="step-one-is-write-update-post-step-two-is-14" class="anchor" href="https://forum.rebol.info#step-one-is-write-update-post-step-two-is-14"></a>Step One Is Write Update Post.  Step Two Is...</h1>
<p>I've actually had some topics I've wanted to write on in the last few weeks.</p>
<p>But I felt that since I hadn't said anything for a while, I needed to write a status post and speak some about what's been on my mind.</p>
<p>Ok...</p>
<p><strong>I'm going to do some low-pressure tinkering just to get back to making commits and posts and see what grabs me.</strong></p>
<p>I'll update here with any more thoughts.  Certainly I think that making the canon "Rebol: The Movie" documentary is something I'm uniquely qualified to do.  Maybe if I combined history, stories of the cast of characters and personalities, along with summarized design arguments and critiques it would be enough that the software-writing-AI of the future (<a href="https://www.youtube.com/shorts/MSuw5AoN7I8">or...Thursday?</a>) could sort it out.  If not, at least entertain.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188</link>
          <pubDate>Sun, 18 Aug 2024 00:43:55 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2188</guid>
          <source url="https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188.rss">Back to Bedlam: August 2024 Status and...Plan? :confused:</source>
        </item>
        <item>
          <title>The Robustness Principle Is Not Robust</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Something floating around that I've pretty much always hated--but experience has made me hate more--is the "Robustness Principle":</p>
<aside class="onebox wikipedia" data-onebox-src="https://en.wikipedia.org/wiki/Robustness_principle">
  <header class="source">

      <a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">en.wikipedia.org</a>
  </header>

  <article class="onebox-body">
    

<h3><a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener">Robustness principle</a></h3>

<p>In computing, the robustness principle is a design guideline for software that states: "be conservative in what you do, be liberal in what you accept from others". It is often reworded as: "be conservative in what you send, be liberal in what you accept". The principle is also known as Postel's law, after Jon Postel, who used the wording in an early specification of TCP.
 In other words, programs that send messages to other machines (or to other programs on the same machine) should conform comple...</p>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>I understand the motivation.  If you have something that imports to a vector graphics program and not all the Bezier curves have endpoints... then, sure.  Someone is going to appreciate that you were forgiving and they got some kind of maybe-a-bit-broken picture instead of an "Invalid File" error.</p>
<p>Pushing this further to those of us who remember the DOS days: we had those experiences where we accidentally deleted files, but the filesystem didn't delete everything--it just wrote a zero byte on the filename (or somesuch).  Norton Utilities let us catch our mistake and get our file back.  In some ways, a lax and forgiving attitude is a beautiful thing...</p>
<p>This so-called "robustness" cannot (and should not) be subconscious.  It needs to be mitigated with an in-your-face consciousness shift!  <em>(And I think Norton Utilities is an apt example, because if you were firing up that program <a href="https://www.youtube.com/watch?v=RRU3I_o1vLc">you knew you were in the Danger Zone</a>)</em>.</p>
<p>There must be a really jarring speedbump.  When a data file is not fitting the standards, you have to go through a procedure that transforms the broken file to the standard.  You have to be aware that you are dealing with a dirty file.  And the experience of that transformation informs you that the person who gave you the dirty file isn't playing with all their marbles, and you correct them for the next transmission.</p>
<p>Authentic programs should demand a standard form.  And when they aren't getting the standard form they should speak up, march you out the door, and force you to fix your input. "Real programs" should never pretend the byte sequence of bad input is okay--there should only be "Cleanup/Recovery programs" that fix the sequence to write a correct one.  And that recovery program should be terminated before the "Real program" runs.</p>
<hr>
<p>I don't need to rewrite the critiques of the "robustness principle" cited in Wikipedia.  But it is nonsense, and the opposite of robust.  It's a garbage idea, that anyone with a whit of sense regarding security can see right through immediately.</p>
<p>There is a better way: the better way is <em>consciousness</em> about what you are working with, and rejection of any sort of malignant "middleman" acting on your data without you knowing.</p>
<ul>
<li>
<p>"Normalization" you did not ask for is an attack on your information.</p>
</li>
<li>
<p>"Glossing over or fixing invalid sequences" you did not ask for is an attack on your information</p>
</li>
<li>
<p>Anything which makes a simple load of a file and save back of the same file not idempotent is an attack on your information</p>
</li>
</ul>
<p>Perhaps I've become even more religious than Carl in some of these ways.  But I certainly see things won't get better without pushing back.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187</link>
          <pubDate>Thu, 13 Jun 2024 05:45:28 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2187</guid>
          <source url="https://forum.rebol.info/t/the-robustness-principle-is-not-robust/2187.rss">The Robustness Principle Is Not Robust</source>
        </item>
        <item>
          <title>PicoLisp machine</title>
          <dc:creator><![CDATA[jjsullivan5196]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Pretty comprehensive reference on how picolisp's cons machine works <a href="https://software-lab.de/doc/ref.html#vm" class="inline-onebox" rel="noopener nofollow ugc">PicoLisp Reference</a></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/picolisp-machine/2185">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/picolisp-machine/2185</link>
          <pubDate>Thu, 23 May 2024 06:34:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2185</guid>
          <source url="https://forum.rebol.info/t/picolisp-machine/2185.rss">PicoLisp machine</source>
        </item>
        <item>
          <title>Om: concatenative homoiconic language</title>
          <dc:creator><![CDATA[jjsullivan5196]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p><a href="https://www.om-language.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://www.om-language.org/</a></p>
<p>This was a one hit wonder on hackernews a couple years ago. Probably the thing of greatest relevance is its "panmorphic" data representation: 3 terminal types of</p>
<ul>
<li>Separators, which compose any utf8 whitespace characters</li>
<li>Operator, essentially symbols of <code>any-other-utf8-text</code>.</li>
<li>Operand, a quoted program in <code>{curlie braces}</code> containing operators or <code>{{other} {operands} and operators}</code> with separators between.</li>
</ul>
<p>The evaluator can define a vocabulary of base "operations" tied to an operator symbol. Every operation takes the rest of the program as input and appends its output. For instance, <code>quote</code> and <code>dequote</code> wrap or unwrap the next term of the program in an enclosing operand. (using <code>-&gt;</code> to indicate output)</p>
<pre><code class="lang-plaintext">quote {A}
-&gt; {{A}}
</code></pre>
<pre><code class="lang-plaintext">dequote {A}
-&gt; A
</code></pre>
<p>More examples on the website</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/om-concatenative-homoiconic-language/2184">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/om-concatenative-homoiconic-language/2184</link>
          <pubDate>Thu, 23 May 2024 02:44:11 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2184</guid>
          <source url="https://forum.rebol.info/t/om-concatenative-homoiconic-language/2184.rss">Om: concatenative homoiconic language</source>
        </item>
        <item>
          <title>John Sullivan</title>
          <dc:creator><![CDATA[jjsullivan5196]]></dc:creator>
          <category>Introductions</category>
          <description><![CDATA[
            <p>Hi!</p>
<p>Love what you all are doing here. I came to know about REBOL from a talk Doug Crockford did on syntax and data formats. I learned more about Carl's vision for the design and principles of the language, and Ren-C seems to be carrying on that tradition of simplicity and sustainability.</p>
<p>I decided to join the forum because I've been craving a language that's easier to carry with me wherever I might be, and REBOL fits the bill. Excited to learn more from you all.</p>
<p>I'm particularly inspired by <a class="mention" href="https://forum.rebol.info/u/hostilefork">@hostilefork</a>'s talk from a few years ago where you could build a new interpreter using <a href="https://youtu.be/PT3GOe1pj9I?si=NJlWjA6r_9i9J5Rh" rel="noopener nofollow ugc">just the tools that come with it</a>.  I've been experimenting recently with the cosmopolitan libc toolchain, and I think it could supercharge that capability:</p>
<p><strong><a href="https://github.com/jart/cosmopolitan" rel="noopener nofollow ugc">https://github.com/jart/cosmopolitan</a></strong></p>
<p>Admittedly I'm still a novice getting used to everything, but you can try what I have so far here if you'd like:</p>
<p><a href="https://github.com/jjsullivan5196/r3/blob/renc-cosmo-testing/README-COSMO.md" class="inline-onebox" rel="noopener nofollow ugc">r3/README-COSMO.md at renc-cosmo-testing · jjsullivan5196/r3 · GitHub</a></p>
<p>Building with cosmo allows the executable image to run on just about any computer you can paste it on, no rebuilding required!</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/john-sullivan/2182">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/john-sullivan/2182</link>
          <pubDate>Sun, 19 May 2024 03:09:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2182</guid>
          <source url="https://forum.rebol.info/t/john-sullivan/2182.rss">John Sullivan</source>
        </item>
        <item>
          <title>The Truthiness of Trash</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>After a couple months of being otherwise occupied, I now have some time to get back to things here...</p>
<p>Picking up around where I left off...I was deep into making a new bootstrap executable, as part of being able to implement the new <a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">FENCE! array type</a>.  This new executable was being aligned to "modern" conventions <em>(though often doing a weakened version of them)</em>.  Doing that triggered a lot of...thoughts.  Here's another.</p>
<hr>
<p><strong>Does it really add value to consider <strong><a href="https://forum.rebol.info/t/why-trash-is-the-name-for-unset-state/2078">the trash state</a></strong> (an antiform blank held by unset variables) to be neither truthy nor falsey?</strong></p>
<p>Here's a quick survey of how UNSET! (the most trash-like thing in historical Rebol) is handled:</p>
<h3>
<a name="rebol2-1" class="anchor" href="https://forum.rebol.info#rebol2-1"></a>Rebol2</h3>
<pre><code>rebol2&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
** Script Error: either is missing its condition argument

rebol2&gt;&gt; unset? all [get/any 'asdf]
== true

rebol2&gt;&gt; unset? any [get/any 'asdf]
== true

rebol2&gt;&gt; case [get/any 'asdf [print "truthy"]]
** Script Error: Block did not return a value
</code></pre>
<h3>
<a name="r3-alpha-2" class="anchor" href="https://forum.rebol.info#r3-alpha-2"></a>R3-Alpha</h3>
<pre><code>r3-alpha&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
** Script error: either does not allow unset! for its condition argument

r3-alpha&gt;&gt; unset? all [get/any 'asdf]
== true

r3-alpha&gt;&gt; unset? any [get/any 'asdf]
== false  ; ...huh?

r3-alpha&gt;&gt; any [get/any 'asdf 1020]   
== 1020

r3-alpha&gt;&gt; case [get/any 'asdf [print "truthy"]]
** Script error: block did not return a value
</code></pre>
<h3>
<a name="red-3" class="anchor" href="https://forum.rebol.info#red-3"></a>Red</h3>
<pre><code>red&gt;&gt; either get/any 'asdf [print "truthy"] [print "falsey"]
*** Script Error: block did not return a value

red&gt;&gt; unset? all [get/any 'asdf]
== true

red&gt;&gt; unset? any [get/any 'asdf]
== true

red&gt;&gt; case [get/any 'asdf [print "truthy"]]
*** Script Error: block did not return a value
</code></pre>
<h2>
<a name="oldes-rebol3-4" class="anchor" href="https://forum.rebol.info#oldes-rebol3-4"></a>Oldes Rebol3</h2>
<p>Transparent in <a href="https://github.com/Oldes/Rebol3/commit/2ba01ead3b5da1ab609fa25a0c675b30e96bb163">ANY and ALL</a> (like a Ren-C void), but presumably still an error in plain IF or EITHER or CASE...</p>
<h2>
<a name="ren-cs-always-error-is-more-consistent-but-5" class="anchor" href="https://forum.rebol.info#ren-cs-always-error-is-more-consistent-but-5"></a>Ren-C's "Always Error" Is More <em>Consistent</em>, But...</h2>
<p>Clearly people have been pushing away from it being an error.</p>
<p>So does being "ornery" for conditional logic really help matters?  When we consider the dual role of trash as an "uninteresting, but successful" result, might we get as much (or more?) value from considering it to be always truthy?</p>
<p>For example: Ren-C uses trash as the result of PRINT when the print actually produces output.  Otherwise, you get NULL.</p>
<pre><code>&gt;&gt; message: "Hello"
== "Hello"

&gt;&gt; print message  ; won't have a console "==" due to being a trash result
Hello

&gt;&gt; trash? print message
Hello
== ~true~  ; anti

&gt;&gt; message: null
== ~null~  ; anti

&gt;&gt; print maybe message
== ~null~  ; anti

&gt;&gt; print []
== ~null~  ; anti
</code></pre>
<p>Trash has the property of suppressing console output, which is desirable in most print cases--at least those that do print output.  And if you said <code>(x: print "Hello")</code> you'd get a variable that would create an error on access, which seems also desirable.</p>
<p>If trash was truthy, that makes it easier to act on the trash-vs-null distinction in something like an ANY or ALL construct.</p>
<h2>
<a name="should-meaningless-but-truthy-unset-variable-state-6" class="anchor" href="https://forum.rebol.info#should-meaningless-but-truthy-unset-variable-state-6"></a>Should "Meaningless but Truthy" = "Unset Variable State"?</h2>
<p>A related question may be if functions like PRINT should be returning the same value as what is held by an unset variable.</p>
<p>Now that non-antiform BLANK! itself is truthy, might it be a better choice?</p>
<pre><code>&gt;&gt; print "Hello"
Hello
== _
</code></pre>
<p>But then...</p>
<ul>
<li>
<p>For the visual we seek, the console would need to not print BLANK!.  But I find it unsatisfying to have a non-antiform be what has "no representation".</p>
</li>
<li>
<p>If you assigned the result of this "meaningless" value to a variable, you wouldn't have that added protection that the variable would appear unset.</p>
</li>
</ul>
<h2>
<a name="truthy-trash-seems-to-have-more-pluses-than-minuses-7" class="anchor" href="https://forum.rebol.info#truthy-trash-seems-to-have-more-pluses-than-minuses-7"></a>Truthy Trash Seems To Have More Pluses than Minuses</h2>
<p>My "semantic safety" bias initially had made me think that when you have a function like PRINT, it's nice to catch potential mistakes when you tried to act like it was a function that could meaningfully be tested for some kind of logical result.  So I pushed R3-Alpha's error from IF and EITHER further into ANY and ALL.</p>
<p>Then I went and made it so that when the PRINT received an opted-out input, it gave back NULL instead of trash.  <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20">  So it was something you could act on with ELSE, but not other conditional constructs.</p>
<p>The evolution from UNSET! to the blank-antiform that is today's trash has been a long and winding one.  Working around its ornery-ness gave rise to all kinds of interesting designs like voids, and invisibles like ELIDE PRINT.</p>
<p>But though I'm sure that I haven't considered all the angles yet...having trash be neither-true-nor-false is looking more like a dying historical artifact than something with a clear motivation applicable to the present.</p>
<p>Trash being always truthy offers consistency...and it's possible to ELIDE it to get "no vote" so it won't affect an ANY or ALL (the way Oldes R3 treats unsets).  Yet having the vote isn't entirely useless either.  I can't think of a whole lot of downside, so I think it's worth trying.</p>
<hr>
<p>A better axis of orneryness that may actually catch more problems in practice is: <strong><a href="https://forum.rebol.info/t/making-call-raise-a-definitional-error-for-bad-exit-codes/2068/2">Should Trash be Illegal in Comparisons</a></strong></p>
<p>(I point out in that discussion that simply disabling the ability to check trash for truthiness/falseyness is kind of a strange counterpart to a routine that returns--say--an INTEGER! in all cases, where you get zero information from testing an integer conditionally but without anything to stop you...making the disablement of testing trash conditionally seem like a fairly empty gesture.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-truthiness-of-trash/2180">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-truthiness-of-trash/2180</link>
          <pubDate>Fri, 03 May 2024 17:27:29 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2180</guid>
          <source url="https://forum.rebol.info/t/the-truthiness-of-trash/2180.rss">The Truthiness of Trash</source>
        </item>
        <item>
          <title>RE: The Ordering and Priorities of the Ren-C Project</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="5" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/5">Speed of UPARSE</a>
</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2177">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/speed-of-uparse/2177/4">Speed of UPARSE</a>
</div>
<blockquote>
<p>I’ll be blunt: this, to me, sounds unusably slow. Beyond the very simplest tasks, I can’t imagine a situation where I’d deliberately choose to take a 250× performance drop.</p>
</blockquote>
</aside>
<p>This is a first-of-its-kind design. And if you don't understand why I'm building things the way I'm building them, then...to be blunt...there's not much point in me listening to your feedback regarding the order in which I do things.</p>
</blockquote>
</aside>
<p>Remember, I come from well outside the Rebol world. The reason I don’t understand is, to a large extent, because this way of reasoning about code is one I’ve never seen before in my life. This is the reason I’m asking so many questions, setting out my opinions, and having these discussions with you… precisely so that I can begin to understand why it is that way.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179</link>
          <pubDate>Sat, 06 Apr 2024 19:16:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2179</guid>
          <source url="https://forum.rebol.info/t/re-the-ordering-and-priorities-of-the-ren-c-project/2179.rss">RE: The Ordering and Priorities of the Ren-C Project</source>
        </item>
        <item>
          <title>Should SET-WORD!s Propagate Undecayed Packs?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Packs are antiform blocks, which decay if not specifically handled.</p>
<pre><code>&gt;&gt; pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a: pack [1 2]
== 1

&gt;&gt; a
== 1
</code></pre>
<p>From time to time, I've wondered if there's a good reason why the plain SET-WORD! shouldn't propagate the pack:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (hypothetical)

&gt;&gt; a
== 1
</code></pre>
<p>One rationale is that intuitively, <strong>a:</strong> should be a synonym for <strong>[a]:</strong>, e.g. "unpack one item" is implicit.</p>
<p>But that just bumps the question to the next one we might ask: why doesn't a multi-return without a "circled" result just evaluate to the whole pack?</p>
<p>It looks to make some sense at first, it allows you to chain indefinitely:</p>
<pre><code>&gt;&gt; [a b]: [c d]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1

&gt;&gt; d
== 2
</code></pre>
<p>Though it feels a little bit unsettling when you drop it down:</p>
<pre><code>&gt;&gt; [a b]: [c]: pack [1 2]
== ~['1 '2]~  ; anti

&gt;&gt; a
== 1

&gt;&gt; b
== 2

&gt;&gt; c
== 1
</code></pre>
<p>But we could argue that if you're bothered, then you use circling (currently <code>@c</code>, but with FENCE! proposed to be <code>{c}</code>).  Note in the below example you'd have to use <code>/b</code> in order to indicate you were okay with unpacking more values than available.</p>
<pre><code>&gt;&gt; [a /b]: [{c}]: pack [1 2]
== 1

&gt;&gt; a
== 1

&gt;&gt; b
== ~null~  ; anti

&gt;&gt; c
== 1
</code></pre>
<p>We could then make a choice if <strong>a:</strong> was a synonym for <strong>[a]:</strong> or for <strong>[{a}]:</strong></p>
<h2>
<a name="most-recent-motivation-for-thinking-about-this-1" class="anchor" href="https://forum.rebol.info#most-recent-motivation-for-thinking-about-this-1"></a>Most Recent Motivation For Thinking About This</h2>
<p>I rewrote <a href="https://forum.rebol.info/t/speed-of-uparse/2177/3">some code in an example</a> from this:</p>
<pre><code>[^result' remainder]: parser input except e -&gt; [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
return unmeta result'  ; return successful parser result
</code></pre>
<p>...to this:</p>
<pre><code>return [@ remainder]: parser input except [
    remainder: input  ; succeed on parser fail but don't advance input
    return null
]
</code></pre>
<p>The idea is that the parser being called has multiple return results... the first is the synthesized value, the second is the amount it advanced.  <em>(There's a third result on some parsers of "pending items", but this OPTIONAL combinator has an "autopipe" which is just bubbling the pending items through in the order of successful parsers called...so the third result is specialized out on its interface and on the parsers it calls.)</em></p>
<p><strong>However, the synthesized value can itself be a pack.</strong>  This means that if we named a variable in the slot where the <code>@</code> is, then that pack would be decayed to store in the variable unless we used a ^META result.</p>
<p>So does the act of not-naming and just circling subvert the decay?  Or should the circled result not be decayed even if the variable is?</p>
<pre><code>&gt;&gt; [{a} b]: pack [pack [1 2] 3]
== ~['1 '2]~  ; anti  (or should it be decayed to 1?)

&gt;&gt; a
== 1

&gt;&gt; b
== 3
</code></pre>
<p>It's a different--but related--question.  It seems it should align with the behavior of plain assignments:</p>
<pre><code>&gt;&gt; a: pack [1 2]
== ~['1 '2]~  ; anti  (implied if the above behavior is chosen)

&gt;&gt; a
== 1
</code></pre>
<h2>
<a name="not-100-certain-but-i-think-undecayed-propagation-is-good-2" class="anchor" href="https://forum.rebol.info#not-100-certain-but-i-think-undecayed-propagation-is-good-2"></a>Not 100% Certain, But I Think Undecayed Propagation Is Good</h2>
<p>I'll point out that it's possible to DECAY things pretty easily, but you can't recover a pack after it has been decayed.</p>
<p>So I'm getting the feeling that it's probably best to decay the assignments, but propagate the undecayed pack.  It looks like the more general and useful behavior...even if it seems a bit confusing.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178</link>
          <pubDate>Fri, 29 Mar 2024 21:22:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2178</guid>
          <source url="https://forum.rebol.info/t/should-set-word-s-propagate-undecayed-packs/2178.rss">Should SET-WORD!s Propagate Undecayed Packs?</source>
        </item>
        <item>
          <title>Speed of UPARSE</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>I’m just wondering if any benchmarking has been done on UPARSE. How does it compare to PARSE in Red or in Rebol? Or to parser combinators in Haskell? For that matter, how does it compare to an ordinary recursive-descent parser handwritten in Ren-C?</p>
<p>(Yes, I know UPARSE is unoptimised and slow. But it would be interesting to know <em>how</em> slow.)</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/speed-of-uparse/2177">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/speed-of-uparse/2177</link>
          <pubDate>Fri, 29 Mar 2024 06:47:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2177</guid>
          <source url="https://forum.rebol.info/t/speed-of-uparse/2177.rss">Speed of UPARSE</source>
        </item>
        <item>
          <title>VOID Branches (not branches that evaluate to void)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>I've mentioned before that <a href="https://forum.rebol.info/t/augment-add-parameters-and-refinements-after-the-fact/1216">AUGMENT can be used to implement the legacy SWITCH/DEFAULT behavior</a>.</p>
<p>But looking at what seems like the "correct" formulation of that code today, we get:</p>
<pre><code>switch-d: enclose (augment :switch [
    /default "Default case if no others are found"
        [block!]
]) lambda [f [frame!]] [
    let def: f.default
    eval f else (maybe def)
]
</code></pre>
<p>It points out the existence of <em>void branches</em>... so not branches that evaluate to void (e.g. <code>[void]</code>) but code that evaluates to a branch to run, and that branch is void.</p>
<p>Considering this specific usage only, it suggests a semantic for ELSE of a VOID branch, which is that you want it to act like there was no branch at all.  e.g. as if you'd written just <strong><code>eval f</code></strong> with no ELSE.</p>
<pre><code> &gt;&gt; if false [1 + 2]
 == ~void~  ; anti

 &gt;&gt; if false [1 + 2] else [10 + 20]
 == 30

 &gt;&gt; if false [1 + 2] else (void)
 == ~void~  ; anti
</code></pre>
<p>Would the same apply to THEN?</p>
<pre><code> &gt;&gt; if true [1 + 2]
 == 3

 &gt;&gt; if true [1 + 2] then [10 + 20]
 == 30

 &gt;&gt; if true [1 + 2] then (void)
 == 3
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>I don't know if it's great, but it's certainly better than evaluating to NULL (via some void-in-null-out rationale) because that would trigger an ELSE branch.</p>
<pre><code> &gt;&gt; if true [1 + 2] then (void) else [print "we don't want this."]
 we don't want this.
</code></pre>
<p>But what should other branching constructs do, like CASE or SWITCH?  Might a void branch suggest "opting out" of that particular branch?</p>
<pre><code> case [
     1 &lt; 2 (void)
     3 &lt; 4 [print "Should this run?"]
 ]
</code></pre>
<p>A CASE (at least CASE/ALL) is supposed to be synonymous with a series of IF statements.  And IF can't exactly do that, unless it decided to be NIHIL...</p>
<pre><code>&gt;&gt; 1 + 2 if false (void)
== 3
</code></pre>
<p>That would be a bit weird, but, it does sort of parallel what happens when ELSE and THEN effectively vaporize themselves.</p>
<p>As with most things on the edge of usefulness, I don't know about this... other than the situation of wanting to revoke the ELSE branch in SWITCH-D.  I'll keep an eye on it.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176</link>
          <pubDate>Thu, 28 Mar 2024 13:07:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2176</guid>
          <source url="https://forum.rebol.info/t/void-branches-not-branches-that-evaluate-to-void/2176.rss">VOID Branches (not branches that evaluate to void)</source>
        </item>
        <item>
          <title>Feb 2024 Talk, Functional Programming Sydney</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="1" data-topic="2136">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136/1">Fundamental distinguishing features of Rebol</a>
</div>
<blockquote>
<p>I offered to give a talk at my local Functional Programming meetup next month. Given my recent interests, I’m thinking of giving an intro to Rebol and its basic concepts.</p>
</blockquote>
</aside>
<p>As a follow-up to this, the talk slides are now online: <a href="https://github.com/fp-syd/meetings/blob/master/2024/2024-02-Neimann-Computing-with-eval.pdf">https://github.com/fp-syd/meetings/blob/master/2024/2024-02-Neimann-Computing-with-eval.pdf</a></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175</link>
          <pubDate>Fri, 22 Mar 2024 00:19:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2175</guid>
          <source url="https://forum.rebol.info/t/feb-2024-talk-functional-programming-sydney/2175.rss">Feb 2024 Talk, Functional Programming Sydney</source>
        </item>
        <item>
          <title>&quot;More arguments for a function on request&quot; (Variadics)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>On Red's Gitter, <a href="https://matrix.to/#/!EorVRCzrVpjojJtctJ:gitter.im/$9hee8CVtrrHeVB7GTvPmKo2hV04eYAjOrhH64C3j5kY?via=gitter.im&amp;via=matrix.org&amp;via=chat.weho.st">@GiuseppeChillemi asked</a>:</p>
<blockquote>
<p>Do you think it would be possible to get more arguments for a function on request?</p>
<p>Example:</p>
<pre><code>aaa: 1
bbb: 2
ccc: 3
f: func [arg1] [other-args: get-args 3]
f arg1-val aaa bbb ccc
</code></pre>
</blockquote>
<p>And Gregg says "oh that would make Red unsafe" (as if Red were somehow "safe").</p>
<p>Anyway, Ren-C has some support for variadics.  While the implementation hasn't gotten a lot of attention in a while, it's no less safe than anything else--the mechanisms used are the same ones that gather ordinary arguments.</p>
<pre><code> aaa: 1
 bbb: 2
 ccc: 3
 f: func [arg1 others [&lt;variadic&gt; any-value?]] [
     return collect [keep arg1, repeat 3 [keep take others]]
 ]

 &gt;&gt; f 1020 aaa bbb ccc
 == [1020 1 2 3]
</code></pre>
<p>The interface is probably not what it's going to ultimately be.  But for now, you can mark a parameter <code>&lt;variadic&gt;</code> and it will be a VARARGS!, that supports TAKE to acquire parameters after the call is made.</p>
<p>Variadics should be used sparingly, because they are difficult to wrap and abstract.  There are some mechanisms for APPLY'ing variadics using a BLOCK! to supply the variadic arguments, but the interface for that is also likely to change.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/more-arguments-for-a-function-on-request-variadics/2174">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/more-arguments-for-a-function-on-request-variadics/2174</link>
          <pubDate>Tue, 19 Mar 2024 09:51:30 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2174</guid>
          <source url="https://forum.rebol.info/t/more-arguments-for-a-function-on-request-variadics/2174.rss">&quot;More arguments for a function on request&quot; (Variadics)</source>
        </item>
        <item>
          <title>Haskell parser combinators</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>I’ve seen a few parsing-related threads recently in this forum. I haven’t been commenting much on them, since I don’t have enough experience with UPARSE (or for that matter historical PARSE) to say anything helpful.</p>
<p>On the other hand, I <em>do</em> have a lot of experience with parser combinators in Haskell. In terms of structure and purpose, they’re probably the concept most similar to UPARSE that I’ve seen from another language. So I thought I’d write this post in the hope that something, somewhere, might eventually prove useful somehow.</p>
<h2>
<a name="high-level-overview-1" class="anchor" href="https://forum.rebol.info#high-level-overview-1"></a>High-level overview</h2>
<p>The first and most important thing to realise about parser combinators is that <strong>they’re not built into the language</strong>. They’re simply ordinary libraries which make it easy to construct parsers compositionally.</p>
<p>(I mean, for that matter, UPARSE isn’t built in either. But there’s a different level of integration with the rest of the language.)</p>
<p>The basic approach is to define a new datatype for parsers, usually called something like <code>Parser a</code>. This is a parser which can process a string (or other datatype), returning a result of type <code>a</code> if it succeeds. Alongside this there will be a set of primitive parsers, most notably <code>char</code> (to parse single characters), <code>return</code> (which always succeeds with a result), and <code>empty</code> (which always fails).</p>
<p>(Of course, practical libraries will have more primitives. <code>megaparsec</code> has <a href="https://hackage.haskell.org/package/megaparsec-9.6.1/docs/Text-Megaparsec.html#g:4">a nice selection</a>, with good comments.)</p>
<p>The most interesting bit is the way these parser combinators are combined to create larger parsers. This, of course, relies on the standard abstractions of Haskell. Two operators are particularly important:</p>
<ul>
<li>Sequencing: <code>p &gt;&gt;= f</code> is a parser which runs <code>p</code> and passes the result to function <code>f</code>, then runs the resulting parser.</li>
<li>Choice: <code>p &lt;|&gt; q</code> is a parser which runs <code>p</code>, then backtracks and runs <code>q</code> if that failed.</li>
</ul>
<p>From these basic elements you can define a very wide range of generic combinators, for instance these useful ones:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">-- sequencing ignoring result
(&gt;&gt;) :: Parser a -&gt; Parser b -&gt; Parser b
p &gt;&gt; q = p &gt;&gt;= \_ -&gt; q

-- Match a whole string
string :: String -&gt; Parser ()
string "" = return ()
string (c:cs) = char c &gt;&gt; string cs

-- 1 or more
some :: Parser a -&gt; Parser [a]
some p =
    p &gt;&gt;= \first -&gt;
    many p &gt;&gt;= \rest -&gt;
    return (first : rest)

-- 0 or more
many :: Parser a -&gt; Parser [a]
many p = some p &lt;|&gt; return []
</code></pre>
<h2>
<a name="a-basic-implementation-2" class="anchor" href="https://forum.rebol.info#a-basic-implementation-2"></a>A basic implementation</h2>
<p>This is all a little abstract, though. Probably the easiest way to understand parser combinators is to implement them.</p>
<p>A basic implementation is quite simple. A parser is just a function which takes in a string, and on success returns the result alongside the unparsed portion of the string:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">newtype Parser a = Parser (String -&gt; Maybe (String, a))
</code></pre>
<p>You then run the parser simply by unwrapping the function and applying it to your input:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">runParser :: Parser a -&gt; String -&gt; Maybe (String, a)
runParser (Parser p) input = p input
</code></pre>
<p>Simple parsers work as you’d expect:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">char :: Char -&gt; Parser ()
char c = Parser $ \input -&gt; case input of
    (c':cs) | c == c' -&gt; Just (cs, ())
    _ -&gt; Nothing

return :: a -&gt; Parser a
return a = Parser $ \input -&gt; Just (input, a)

empty :: Parser a
empty = Parser $ \_ -&gt; Nothing
</code></pre>
<p>The combinators require more elaborate state-threading, but are still straightforward:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">(&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
p &gt;&gt;= f = Parser $ \input -&gt;
    case runParser p input of
        Nothing -&gt; Nothing
        Just (partiallyParsed, a) -&gt;
            runParser (f a) partiallyParsed

(&lt;|&gt;) :: Parser a -&gt; Parser a -&gt; Parser a
p &lt;|&gt; q = Parser $ \input -&gt;
    case runParser p input of
        Just result -&gt; Just result
        Nothing -&gt; runParser q input
</code></pre>
<p>This simple code suffices for a surprisingly wide variety of tasks. For instance, a slight variant is present in the base library as <a href="https://hackage.haskell.org/package/base-4.16.3.0/docs/Text-Read.html#t:ReadS"><code>ReadS</code></a>. (The variation is that <code>ReadS</code> can produce multiple results.)</p>
<h2>
<a name="managing-backtracking-3" class="anchor" href="https://forum.rebol.info#managing-backtracking-3"></a>Managing backtracking</h2>
<p>Unfortunately, <strong>this has serious problems with any larger-scale use</strong>. For one thing, it can’t do error reporting beyond ‘it failed somewhere’. But there are even bigger problems with this implementation of the choice combinator <code>(&lt;|&gt;)</code>:</p>
<ol>
<li>It behaves unpredictably: any error anywhere will result in the parser backtracking to the last choice, and so on until every single choice has been exhausted. This is bad for the time complexity, plus it leaves you no chance of ever reporting errors nicely.</li>
<li>It holds onto the input string during the whole time <code>p</code> is executing. This creates a space leak, which grows larger the more nested choices you have.</li>
</ol>
<p>The first parser combinator library to solve these issues was <code>Parsec</code>. Its design is described in <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/parsec-paper-letter.pdf">this paper</a> (which seems very readable). I won’t describe its implementation here… but the basic idea is simple to summarise: each parser keeps track of what it’s consumed, and <strong>commits to a parser as soon as it’s consumed any characters</strong>.</p>
<p>Some parsers require no changes under this new semantics. For instance, <code>string "first word" &lt;|&gt; string "second word"</code> works without problems. If it sees an input character <code>f</code>, the first choice <code>string "first word"</code> matches immediately, meaning the library can commit to the first parser, and know that the second parser never needs to run. On the other hand, upon seeing an input character <code>'s'</code>, that first parser will fail on that very first character: since no characters have been consumed, control passes over to the second parser to succeed or fail.</p>
<p>On the other hand, more elaborate lookahead becomes more difficult. For instance, <code>string "word 1" &lt;|&gt; string "word 2"</code> no longer works: as soon as this parser sees <code>'w'</code>, it matches the first parser, so the second parser will never be run.</p>
<p>To solve this, Parsec introduces a new primitive combinator: <code>try</code>, which creates a parser which never consumes characters on failure. The effect of this is to allow backtracking over whatever is in the <code>try</code>. For this example, <code>try (string "word 1") &lt;|&gt; string "word 2"</code> would work as expected.</p>
<p>The nice thing about this approach is the control it gives you. For instance, I can write things like:</p>
<pre data-code-wrap="hs"><code class="lang-plaintext">(try (string "App") &gt;&gt; string "le") &lt;|&gt; string "Apricot"
</code></pre>
<p>Here, as soon as the parser reaches a second <code>'p'</code>, it can commit to the first branch. But if it sees another character, it’s still able to backtrack through the <code>string "App"</code> and move on to the second branch. Of course, this is a contrived example — but in general, being able to specify the control flow of your parser like this is exceedingly useful in larger parsers.</p>
<h2>
<a name="what-use-is-this-for-rebol-4" class="anchor" href="https://forum.rebol.info#what-use-is-this-for-rebol-4"></a>What use is this for Rebol?</h2>
<p>Quite probably, none at all.</p>
<p>But like I said, I’m hoping potentially some of this might end up useful somewhere. If it can act as inspiration which helps solve any problems, I’m happy.</p>
<p>And, of course, now that we have this thread for it, feel free to ask me any questions about parser combinators you might have!</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/haskell-parser-combinators/2173">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/haskell-parser-combinators/2173</link>
          <pubDate>Mon, 11 Mar 2024 15:08:10 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2173</guid>
          <source url="https://forum.rebol.info/t/haskell-parser-combinators/2173.rss">Haskell parser combinators</source>
        </item>
        <item>
          <title>-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>So I'm still shoring up a new bootstrap executable, patching around in a 6-years-out-of-date codebase.   It's in some ways a cruel and unusual punishment... but in other ways a good trip down memory lane to revisit decisions that were made, and ask "was that the right decision?"</p>
<p>The 6-year-old EXE defined an enfix form of lambda as <strong><code>=&gt;</code></strong>.  I shifted it to the lighter form as <strong><code>-&gt;</code></strong>.  Contrast:</p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then (lambda [x] [
    assert [x = &lt;yes&gt;]
    1000 + 20
])
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x =&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]

y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p><em>(Supplemental: Reddit post on <a href="https://www.reddit.com/r/ProgrammingLanguages/comments/shllr3/whats_the_syntax_of_lambda_expressions_in_your/">"What's the syntax of lambda expressions in your language"</a>)</em></p>
<p><strong>I like the <code>-&gt;</code> and don't think there's a greater purpose for it in the box.</strong>  As with everything else, overriding it is a personal choice.</p>
<h2>
<a name="a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1" class="anchor" href="https://forum.rebol.info#a-speaking-with-ticshttpsforumrebolinfotspeaking-with-tics-should-quoted-arguments-always-be-apostrophed1359-note-1"></a>A <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359">Speaking-With-Tics</a> Note</h2>
<p>Mechanically getting this to work is non-trivial:</p>
<p><a href="https://forum.rebol.info/t/the-most-vexing-evaluation-lambda-meets-then-else/1361" class="inline-onebox">The Most Vexing Evaluation: LAMBDA meets THEN/ELSE</a></p>
<p>Part of what makes it non-trivial is the "literal lookback" by which <strong><code>-&gt;</code></strong> infixedly snatches the X without letting it evaluate.</p>
<p><a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> might argue such mechanics shouldn't be necessary, because source-level non-evaluation should be explicit, e.g. <strong><code>'x -&gt; [...]</code></strong></p>
<pre><code>y: case [
    1 &gt; 2 [&lt;no&gt;]
    1 &lt; 2 [&lt;yes&gt;]
] then 'x -&gt; [
    assert [x = &lt;yes&gt;]
    1000 + 20
]
assert [y = 1020]
</code></pre>
<p>But that's one more stroke of key than I want, and one more piece of dirt than I want to see.  <em>I know from context that slot is a variable name, in the most common case.</em>  I'm not upset by intricate work to faciliate it, if it actually works (and empowers other creative things).  So I need to see hard disproofs before sacrificing what I consider to be "the point" of the design.</p>
<p>I'm always ready to look at it from a further perspective to see a "greater point".  But still--from where I stand--that apostrophe sucks relative to not having it.  (And if you read the details of the implementation post, the only reason it's allowed to work in a quoted slot is because of left literalism, so...)</p>
<h2>
<a name="what-about-multiple-arguments-2" class="anchor" href="https://forum.rebol.info#what-about-multiple-arguments-2"></a>What About Multiple Arguments?</h2>
<p>Notationally there are questions about this form of lambda.  Does it use a block for multiple arguments?</p>
<pre><code>&gt;&gt; foo: [a b] -&gt; [a + b + 20]

&gt;&gt; foo 400 600
== 1020
</code></pre>
<p>It could, but you could be weirder:</p>
<pre><code>foo: a.b -&gt; [a + b + 20]

foo: a/b -&gt; [a + b + 20]
</code></pre>
<p>This would look a little tighter with branching, I think, since it wouldn't compete with the branches:</p>
<pre><code>case [
    ...
] then [a b] -&gt; [
    ...
]

case [
    ...
] then a.b -&gt; [
    ...
]
</code></pre>
<p><em>But wait, you'd never use it with a branch... because a branch only produces one value.</em></p>
<p>UNLESS... what if what this form of lambda did was unpack packs?</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]  ; makes antiform ~['30 '7]~
    ...
] then [a b] -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a -&gt; [
    assert [a = 30]
]
</code></pre>
<p>So I've been thinking this is what it should actually do.  It means -&gt; won't be a good way to define functions or lambdas generally, but you have FUNC(TION) and LAMBDA for that.</p>
<p>I don't know that enabling a lighter notation like <strong><code>a.b</code></strong> or <strong><code>a/b</code></strong> is worth it.</p>
<pre><code>case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a.b -&gt; [
    assert [a = 30, b = 7]
]

case [
    true [pack [10 + 20, 3 + 4]]
    ...
] then a/b -&gt; [
    assert [a = 30, b = 7]
]
</code></pre>
<p>Maybe just confusing, and limits what you can put in the spec.  Easier to add later if it seems useful than put it in now and take out later.</p>
<h2>
<a name="is-there-a-good-name-for-lambda-lite-3" class="anchor" href="https://forum.rebol.info#is-there-a-good-name-for-lambda-lite-3"></a>Is There A Good Name For "Lambda Lite"?</h2>
<p>We could call it an "unpacking lambda".  Maybe it's controlled with a refinement:</p>
<pre><code> &gt;&gt; foo: lambda/unpack [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :lambda/unpack</code></strong></p>
<p>We could just call it <em>"an unpacker"</em>.</p>
<pre><code> &gt;&gt; foo: unpacker [a b] [a + b + 20]

 &gt;&gt; foo pack [400 600]
 == 1020
</code></pre>
<p>Then <strong><code>-&gt;: :unpacker</code></strong></p>
<p>The problem with calling it an "unpacker" is that 9 (or more) times out of 10 it will only take a single argument and not unpack anything.  So it seems better to classify it as a shade of distinction on lambda, but still when you point to an <code>-&gt;</code> on the screen say <em>"then it passes the argument to the lambda..."</em></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172</link>
          <pubDate>Sun, 10 Mar 2024 15:21:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2172</guid>
          <source url="https://forum.rebol.info/t/for-lambda-or-lambda-lite/2172.rss">-&gt; for LAMBDA (or... &quot;LAMBDA-Lite?&quot;)</source>
        </item>
        <item>
          <title>Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In the post <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">"Shades of Distinction In Non-Valued Intents"</a>, I had originally written:</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/1">Shades of Distinction In Non-Valued Intents</a>
</div>
<blockquote>
<p>Eventually the NULL state became the isotopic status of the WORD! null, so a <strong>~null~</strong> antiform.</p>
<p>It joined <strong>~true~</strong> and <strong>~false~</strong> as being antiforms you could test for truthiness and falseyness. But if you were okay with getting an error on conditional testing, any other word could be used:</p>
<pre><code class="lang-plaintext">  config: ~initialize-system-not-called~

  initialize-system: func [
      {Let's say this function reads the config file}
  ][
      ...
      config: [...]
  ]
</code></pre>
<p>This usually causes a nice labeled message anytime someone tries to use CONFIG:</p>
<p>Going this route would create a pain point for anyone who thought they were going to test for whether you had a config initialized by testing <strong>if config [...]</strong>. So that has to be considered as whether it's what you want.</p>
</blockquote>
</aside>
<p>I've come to question this as things have gone on, to where I'm wondering if all antiform words should be reserved by the system (there are system purposes for the ~end~ antiform, for instance).</p>
<p>A generic "error trigger" might come from something like antiform TAG!, permitting spaces:</p>
<pre><code>config: ~&lt;INITIALIZE-SYSTEM not called&gt;~

initialize-system: func [
    {Let's say this function reads the config file}
][
    ...
    config: [...]
]

&gt;&gt; config
** Error: INITIALIZE-SYSTEM not called
</code></pre>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170</link>
          <pubDate>Sat, 09 Mar 2024 08:49:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2170</guid>
          <source url="https://forum.rebol.info/t/antiform-tag-as-triggers-an-error-on-access-type/2170.rss">Antiform TAG! As &quot;Triggers an Error On Access&quot; Type</source>
        </item>
        <item>
          <title>Getting an unset variable</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <p>Trash (now anti BLANK!) <a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604">has been established</a> as the value of unset variables. As the example in that thread states:</p>
<pre><code class="lang-plaintext">&gt;&gt; trash-value
** Error: TRASH-VALUE variable is unset

&gt;&gt; append [a b] get/any 'trash-value
** Error: APPEND does not allow adding ~ antiforms to blocks
</code></pre>
<p>But when I try this, I get quite different results:</p>
<pre><code class="lang-plaintext">&gt;&gt; trash-value
** Script Error: trash-value word is attached to a context, but unassigned

&gt;&gt; append [a b] get/any 'trash-value
** Script Error: trash-value word is not bound to a context
</code></pre>
<p>In fact, even GET/ANY doesn’t seem to work… even when I make sure the binding is right:</p>
<pre><code class="lang-plaintext">&gt;&gt; get/any 'trash-value
** Script Error: trash-value word is not bound to a context

&gt;&gt; get/any $trash-value             
** Script Error: trash-value word is attached to a context, but unassigned
</code></pre>
<p>So, what’s happening here? And how <em>do</em> I get trash out of an unset variable?</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/getting-an-unset-variable/2169">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/getting-an-unset-variable/2169</link>
          <pubDate>Sat, 09 Mar 2024 02:39:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2169</guid>
          <source url="https://forum.rebol.info/t/getting-an-unset-variable/2169.rss">Getting an unset variable</source>
        </item>
        <item>
          <title>How To Choose Between Returning VOID and NIHIL?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Questions</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1604">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/shades-of-distinction-in-non-valued-intents/1604/6">Shades of Distinction In Non-Valued Intents</a>
</div>
<blockquote>
<p>Void is used generically in many places when you want things to vanish:</p>
<pre><code class="lang-plaintext">&gt;&gt; compose [&lt;a&gt; (if false [&lt;b&gt;]) &lt;c&gt;]
== [&lt;a&gt; &lt;c&gt;]
</code></pre>
</blockquote>
</aside>
<p>Ah-ha… I’d completely missed this use of void, as a return value.</p>
<p>Though this does now raise the question of whether a function should return nihil or void. Both seem to vaporise in lists, after all. I guess it depends on whether you want the function call to be ignored or not.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171</link>
          <pubDate>Sat, 09 Mar 2024 02:30:26 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2171</guid>
          <source url="https://forum.rebol.info/t/how-to-choose-between-returning-void-and-nihil/2171.rss">How To Choose Between Returning VOID and NIHIL?</source>
        </item>
        <item>
          <title>Renaming SPECIFIER =&gt; CONTEXT ?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>There was a typeset in historical Rebol that was called ANY-OBJECT!, that tried to pull together anything that had WORD! keys that could be used as a binding target:</p>
<pre><code>r3-alpha&gt;&gt; help any-object!
ANY-OBJECT! is a typeset of value: make typeset! [
    object! module! error! task! port!
]
</code></pre>
<p>I had sort of a naming philosophy (which I still have) that you shouldn't name the category based on one of its instances like this.  Several reasons, but one is that it certainly confuses the implementation when you extract the pointed-to entity out of a cell:</p>
<pre><code> if (Cell_Type(cell) == TYPE_ERROR) {
     Object* = Cell_Object(cell);  // wait, but it's an ERROR! not an OBJECT!
     ...
 }
</code></pre>
<p>You could call it <code>AnyObject</code>, I guess.  But that's not the direction I took... instead calling the category ANY-CONTEXT!, and if you saw <code>Context*</code> in the source you wouldn't get confused to thinking it was an extraction from a CONTEXT! cell, because there was no such thing.  You knew it was the implementation of a superclass.</p>
<h2>
<a name="enter-specifier-1" class="anchor" href="https://forum.rebol.info#enter-specifier-1"></a>Enter "Specifier"</h2>
<p>"Specifier"--the aggregated inheritance of binding candidates--has moved from an implementation detail to something which is rising to the surface of user awareness.  For that, it's a lousy name... and am near-certain I want to take "Context" for it.</p>
<p>I like Context better than Environment, as it's shorter and leaves environment for "environment variables" (which being a script-class language Ren-C needs to be better at interacting with than it is today).</p>
<p>We could say the other types are ANY-DICTIONARY!, although the name DICTIONARY! has been suggested as a replacement for MAP!, since we are thinking of MAP more as a function now.  But Dictionary may make more sense for things that only permit "words" as keys.</p>
<p>A CONTEXT! itself--as a composition of other dictionaries (and possibly even just programmatic code that answers value-for-WORD!)--may itself be categorized as an ANY-DICTIONARY!</p>
<h2>
<a name="implementation-variance-needs-work-2" class="anchor" href="https://forum.rebol.info#implementation-variance-needs-work-2"></a>Implementation Variance Needs Work</h2>
<p>So something that has happened in the messy evolution of the code is that the one-size-fits all <strong><code>Context*</code></strong> data structure that backed things like OBJECT!, ERROR!, MODULE! etc. became fractured around the time of Sea of Words and LET.</p>
<p>Modules do not use the same representation, and have to be enumerated completely differently.  There's not really a lot of generic code that acts the same way for OBJECT! and MODULE!, to the point that we'd be better off dispelling the illusion in the C sources and making <strong><code>Module*</code></strong> its own distinct type.</p>
<p>There's a lot to consider here about what the limits of "Amish" implementation are:</p>
<ul>
<li>
<p>I'm pretty much sold on the known-integer-values concept for Frame.  And if <em><strong>I</strong></em> say that drifting away from that destroys what the project <em>is</em>, then it almost certainly does--because I'm known for being iconoclastic about a fair number of Rebol sacred cows.</p>
</li>
<li>
<p>BUT taking a diverging approach for Module from "parallel arrays of Key and Value cell indexed by integer" has proven essential.  Floating variable stubs hanging off the word symbols themselves is an answer that has been critical in giving some legitimacy to modules, and it still passes the "simple" test for me.</p>
<ul>
<li>R3-Alpha was utterly hopeless, and Red will be too if they follow down that path (should they ever get modules).  I do not think this is a problem appropriate to approach with two-parallel-arrays.</li>
</ul>
</li>
<li>
<p>Objects are kind of a wild card.  Given their attempt to be dirt-simple, we might more accurately call the current version "Struct" or "Structure" instead (major annoyance in C naming the variables though, <code>Struct _struct</code>, to dodge the <code>struct</code> keyword?)</p>
<ul>
<li>
<p>People want to dynamically add and remove keys from objects.  Rebol2 and Red don't allow it, and R3-Alpha only permitted growth (so the index numbers stored in words that were bound at an index wouldn't be invalidated)</p>
</li>
<li>
<p>Moving to a more amortized implementation that spreads and shares keys gets you to something more like a database, where you can't point to little contiguous packets of memory and say "there is the object."</p>
</li>
<li>
<p>As I said above, I think this was a necessity for Modules.  But the simple implementation that works quite well for them wouldn't scale to tens of thousands of objects which have keys with the same name.</p>
</li>
<li>
<p>There's plenty of prior art and writeups of how JavaScript engines and others have approached this, and gotten it to be fast.</p>
</li>
</ul>
</li>
</ul>
<p>Anyway, this all kind of culminates in saying that objects are due for a reckoning at some point.  We want to err on the side of simplicity over optimized complexity, but there may be a sufficiently elegant way to attack objects that can grow and shrink effectively and having better code overall than we have today.</p>
<h2>
<a name="anyway-back-to-the-naming-issue-3" class="anchor" href="https://forum.rebol.info#anyway-back-to-the-naming-issue-3"></a>Anyway, Back To The Naming Issue...</h2>
<p>The above sort of reveals why ANY-OBJECT! isn't a good name for ANY-DICTIONARY or ANY-BINDTARGET?.</p>
<p>Hm, maybe we consider ANY-BINDABLE? to be the category for things that can be bound <em>to</em>, and come up with another name for anything that can be bound?  ANY-REFERENCE?</p>
<p>Eh, that sounds confusing.  Dictionary may be about as good as it gets (?)</p>
<p>So basically, Dictionary would be a superclass offering lookup from Word Symbol =&gt; Value.  If you wanted anything else from it, you would have to figure out what subclass it was, because how you do things like enumerate keys and values diverges significantly.</p>
<h2>
<a name="or-maybe-some-unifying-theory-will-come-along-4" class="anchor" href="https://forum.rebol.info#or-maybe-some-unifying-theory-will-come-along-4"></a>Or Maybe Some Unifying Theory Will Come Along?</h2>
<p>It could be, that everything--including OBJECT! and MODULE!, have the "inheritance" powers of what Specifier has today.</p>
<p>Which would mean that you wouldn't have Specifiers.  You'd just ask for the binding of a block and maybe get a MODULE! that inherits from an OBJECT!, or an OBJECT! that inherits from a MODULE!, or a LET! that inherits from a LET! that inherits from an OBJECT!, etc.</p>
<p>It all warrants more thought, and maybe a quick attempt to swap out the current OBJECT! implementation with something like V8's <a href="https://v8.dev/docs/hidden-classes">Hidden Classes</a> and see how it meshes with the system.  I've been so focused on the "bricks" in the language that these sorts of "boring" implementation details have just sort of been left alone while that's sorted out, but now it's getting to the point where there seem to be some answers to guide the shape.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/renaming-specifier-context/2168">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/renaming-specifier-context/2168</link>
          <pubDate>Wed, 06 Mar 2024 18:56:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2168</guid>
          <source url="https://forum.rebol.info/t/renaming-specifier-context/2168.rss">Renaming SPECIFIER =&gt; CONTEXT ?</source>
        </item>
        <item>
          <title>Mapping from Series =&gt; Series By Co-Opting The Key Series</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <p>There was an unfinished idea in an old version of the interpreter.  It related to how to deal with problems like trying to make a copy of a block, and make sure any series with the same identity are only copied once in the new structure, and point to that one copied identity.</p>
<p>Rebol2 did not have this behavior:</p>
<pre><code>rebol2&gt;&gt; block: [a]
== [a]

rebol2&gt;&gt; original: reduce [block block]
== [[a] [a]]

rebol2&gt;&gt; append block 'b
== [a b]

rebol2&gt;&gt; original
== [[a b] [a b]]  ; both aliases see the append

rebol2&gt;&gt; duplicate: copy/deep original
== [[a b] [a b]]

rebol2&gt;&gt; append first duplicate 'c
== [a b c]

rebol2&gt;&gt; duplicate
== [[a b c] [a b]]  ; considered by many to be wrong: independent copies
</code></pre>
<p>This post isn't about whether that is right or wrong (and having such questions may seem to some as an indication of <em>"this language is madness! get me to Haskell"</em>, etc. But as I've said this is the game we're playing here so we roll with it.)</p>
<p>But to not get independent copies, you need a way to map series nodes to copies you've already created...so you can consult that mapping before making new copies.  And the direction that was being pursued by the old interpreter I am looking at was to actually do surgery on the originating series nodes, to alter them so they shifted out some of their content, such that they could be their own keys in the mapping.</p>
<p>Generally speaking, all the bits in a series stub are spoken for.  So it would seem there's nowhere to stow a pointer to the new series you are creating in it.  What the implementation was doing was pushing a 4 pointer cell on the data stack, writing one pointer's worth of information from the stub into that cell, then replacing that pointer slot in the stub with the stack index.  Then it wrote the new series into the cell...so the cell contained one stowed pointer from the original series and one pointer for the new series.</p>
<p>This meant the original series was now in a "weird" state, that things like the GC had to know about and tolerate.  Other operations looking for the missing information in the stub needed to be caught if they tried to get at it without following the stack index through to the stack cell.</p>
<p>Having the cells on the data stack meant it was not necessary to enumerate all the series stubs after a copy to "clean them up".  Otherwise, I'd imagine it may be possible to make some kind of guarantee that for any series appearing in source, the union of the bits in the source series and the bits of the copied series can hold all the information necessary to construct two valid series... e.g. one pointer's worth of information is always redundant in those two copies.  If you can get <em>two</em> pointers' worth of information redundant, the second could be used to chain a linked list as you go...removing the need for the stack cells to enumerate.</p>
<p>Though having the stack cells and no particular requirement of information redundancy in source series with their copies offers another benefit: being applicable for creating mappings that aren't copying-related.</p>
<p>Anyway, it was a little unfinished idea I ran across that I wanted to document.  I'm cleaning up the bootstrap executable to refresh it with something that will help <a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">in the FENCE! migration</a>, and mercilessly deleting any code in the bootstrap executable that does not specifically benefit bootstrap... to reduce the instability surface, speed things up, and make it easier to debug the 6-year old executable if worst comes to worst.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/mapping-from-series-series-by-co-opting-the-key-series/2166">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/mapping-from-series-series-by-co-opting-the-key-series/2166</link>
          <pubDate>Wed, 06 Mar 2024 15:24:07 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2166</guid>
          <source url="https://forum.rebol.info/t/mapping-from-series-series-by-co-opting-the-key-series/2166.rss">Mapping from Series =&gt; Series By Co-Opting The Key Series</source>
        </item>
        <item>
          <title>Revisiting a Maybe-Not-So-Weird Old Idea: &lt;- as IDENTITY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So at one point I had a kind of strange idea for what to do with <strong><code>&lt;-</code></strong>.</p>
<p>It would just pass through what you gave on its right.  And the idea was that you could use this in various situations as a kind of visual signal that you intended to produce a value that would be used by... something.</p>
<p>You could use it to hint when a line is being continued:</p>
<pre><code>browse join
    &lt;- https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
    &lt;- unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>That JOIN is arity 2.   The arrows do nothing, but quickly pass through what they were passed.</p>
<p>The current alternative you might reach for are parentheses, but you can only put it around the outermost level, and it's noticeably inferior:</p>
<pre><code>browse (join
    https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
    unspaced [system.version.1 "." system.version.2 "." system.version.3]
)
</code></pre>
<p>I had another idea that the arrow might be nice for signaling when you're at the end of a branch to help hint that the branch result is actually used.</p>
<pre><code> something: case [
     ... [...]
     ... [...]
     ; lots of code to where SOMETHING: has scrolled off the screen
     ... [
         your code here
         more code here
         &lt;- append data "stuff"
     ]
 ]
</code></pre>
<p>It gives you a nice hint that the result of the append (the head of the appended series) is actually used.<br>
<strong>But, these two uses are in contention.</strong>  You can't use it to mean "continue the line above" and "pipe result out to some higher level.  Perhaps this is better done with an impromptu CATCH/THROW?</p>
<pre><code> something: catch [case [
     ... [... throw ...]
     ... [... throw ...]
     ; lots of code to where SOMETHING: has scrolled off the screen
     ... [
         your code here
         more code here
         throw append data "stuff"
     ]
 ]]
</code></pre>
<p>(Note that CATCH/THROW have nothing to do with errors in Rebol, it's a lightweight construct for doing this kind of manipulation.)</p>
<h2>
<a name="why-did-i-kill-off-the-as-identity-1" class="anchor" href="https://forum.rebol.info#why-did-i-kill-off-the-as-identity-1"></a>Why Did I Kill Off The &lt;- As Identity?</h2>
<p>It was changed shortly after deciding to take <strong>-&gt;</strong> for an infix lambda operation.</p>
<pre><code> foo: x -&gt; [print ["I'm a lambda" x]]

 &gt;&gt; foo 1020
 I'm a lambda 1020
</code></pre>
<p>This is particularly nice-looking in branching when you want to pass the branch result.</p>
<pre><code>all [
    1 &lt; 2
    3 &lt; 4
    #something
] then x -&gt; [
   print ["X is" mold x]  ; X is #something
]
</code></pre>
<p>The first incarnation used <strong><code>=&gt;</code></strong> as JavaScript did.  But not only is the arrow lighter, it doesn't weigh on the question of whether <strong><code>=&gt;</code></strong> is an "arrow", when <strong><code>&lt;=</code></strong> is not one.  (Debate has been had over whether =&gt; should be a synonym for &gt;=, and =&lt; a synonym for &lt;=, etc. but status quo has won out.)</p>
<p>So <strong><code>&lt;-</code></strong> was targeted as another function generator, namely for doing tacit programming as an alias for POINTFREE.</p>
<pre><code>foo: &lt;- [append [a b c]]

&gt;&gt; foo 'd
== [a b c d]
</code></pre>
<p>The attempt to write POINTFREE entirely in usermode stalled a bit in the face of other priorities, though it's still very much desired.  And it doesn't seem like a bad idea to have &lt;- and -&gt; both connected as fundamental convenient function generators.</p>
<p>I've not really questioned the decision to strike &lt;- as identity until I realized looking at some old code that it really is nice to have some alias for identity, used for one of the annotation purposes I mention.</p>
<p>We do have single tick free, now <img src="https://forum.rebol.info/images/emoji/twitter/face_with_diagonal_mouth.png?v=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"></p>
<pre><code>browse join
  ' https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  ' unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>That actually looks kind of decent.  It's not super consistent, because quoting implies not binding...and we'd want binding applied.  Can people mentally separate "the tick operator" as IDENTITY, from the non-bindingness of quoting?</p>
<p>Backtick is available, though backticks are kind of a blight in general:</p>
<pre><code>browse join
  ` https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  ` unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p>Despite my hatred of backticks, I almost actually prefer that to the normal ticks in this narrow application.</p>
<p>There's a few other ugly options, e.g. backslash which we still haven't given meaning to either.</p>
<pre><code>browse join
  \ https://github.com/metaeducation/ren-c/blob/master/CHANGES.md#
  \ unspaced [system.version.1 "." system.version.2 "." system.version.3]
</code></pre>
<p><strong>Anyway, the cool idea here was just that line continuation not be a scanner feature, but be signaled by means of a normal token that ran the identity function... and you'd be cued into realizing that it was a continuation just because there's no point in calling the identity function in source unless you were applying it like this.</strong></p>
<p>We could throw in a little help by having the evaluator only allow this if it was--actually--an argument to a function.</p>
<p>Based on the above, I'm liking the backtick and apostrophe, and am not sure I'd want heavier for line continuation.</p>
<p>The idea of &lt;- being an alternate way of saying identity that is used for the other annotation purpose (this result is used by the higher up stack level) would then be a possibility.  The system could maybe help a little bit here too, by making sure the <strong>&lt;-</strong> <em>isn't</em> an argument to a function...</p>
<p>POINTFREE would need some other shorthand.  But maybe it's just an alternate mode of LAMBDA.  Or maybe it doesn't really need a shorthand.</p>
<pre><code>foo: ... -&gt; [append [a b c]]

foo: &lt;*&gt; -&gt; [append [a b c]]

foo: |-&gt; [append [a b c]]

foo: -|&gt; [append [a b c]]

foo: pointfree [append [a b c]]

&gt;&gt; foo 'd
== [a b c d]
</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165</link>
          <pubDate>Wed, 06 Mar 2024 14:20:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2165</guid>
          <source url="https://forum.rebol.info/t/revisiting-a-maybe-not-so-weird-old-idea-as-identity/2165.rss">Revisiting a Maybe-Not-So-Weird Old Idea: &lt;- as IDENTITY</source>
        </item>
        <item>
          <title>What deserves to be a datatype?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="7" data-topic="2159">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159/7">Header dialect and multiline strings</a>
</div>
<blockquote>
<p>(If I may philosophise for a moment… I feel there’s a big, gaping hole in my understanding of how we decide ‘what Rebol syntax is’, so to speak. Perhaps my caution around sigils and TYPE-BLOCK!s are a manifestation of that hole, as is this. I’ll make a new thread about it if I can figure out any clearer way to articulate my concerns.)</p>
</blockquote>
</aside>
<p>This is that thread.</p>
<p>I’ll begin by observing that in Rebol, the complexity of the lexer vs the parser is ‘reversed’ compared to other programming languages. In Rebol, the actual syntax is highly minimalistic: there’s only a few constructs which provide explicit grouping, and none provide anything more than a simple list of items. By contrast, the lexer is exceedingly complicated: nearly every datatype has its own literal form, oftentimes more than one.</p>
<p>Language design ends up ‘reversed’ in a similar way. In most languages, discussion centres around questions like ‘which new syntactic constructs should we add’. By contrast, Rebol (and especially Ren-C) more often poses the question: ‘which new datatypes do we want to include, with which literal syntax?’.</p>
<p>At the moment, I still feel uncomfortable discussing such questions. I don’t feel that I fully understand the kind of criteria we should consider to know whether a datatype is worth including or not. Or, more concisely, I don’t understand how decide: <strong>what deserves to be a Ren-C datatype?</strong>.</p>
<hr>
<p>One obvious criterion is simply, <em>datatypes representing common types of data</em>. This is why we have things like MONEY! and FILE! and DATE! and so on. Ultimately this stems from Rebol’s heritage as a data-transfer format, but obviously these types are far more broadly useful.</p>
<p>Another obvious criterion is <em>syntax which is important for programming</em>. This gives us GROUP! and GET-WORD! and PATH! and so on. These exist as datatypes ultimately because Rebol is homoiconic, but their presence has suggested a wide range of uses beyond simple programming.</p>
<p>This accounts for most of the types in Ren-C. And, if that were all to it, I’d have no objections.</p>
<hr>
<p>But, unfortunately, there are some other types, whose presence is explained by neither of those criteria. As I’ve said previously, the ones which make me feel most uncomfortable are THE-* and TYPE-*. Neither of these represent common types of data that one would want to pass around. And, with the possible exceptions of THE-WORD! and TYPE-BLOCK!, they’re basically useless in ‘regular’ programming.</p>
<p>Despite this, <a class="mention" href="https://forum.rebol.info/u/hostilefork">@hostilefork</a> has lobbied pretty hard for both of these. Hopefully it should be clear now why I find this viewpoint confusing. I can’t say the existence of these types is <em>problematic</em>, as such, but I feel this <strong>indicates a gap in my understanding of the language</strong>.</p>
<p>The closest to an explanation I’ve found is that these types are useful in dialecting. That is, they may not be useful for programming <em>per se</em>, but having the syntax around is useful for constructing new languages. (For instance, using TYPE-WORD!s in PARSE dialect, or THE-WORD!s for module inclusion.) The problem with this is, <a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147">as we’ve established</a>, that there’s a huge number of syntaxes which would be ‘useful in dialecting’: clearly, this is too low a bar for deciding ‘what deserves to be a datatype’.</p>
<p>(And, incidentally, this also establishes that we’re quite willing to reject datatypes that don’t seem to be of sufficiently general usage.)</p>
<p>Another argument is simply consistency: other sigils have versions for words, blocks, tuples, etc., so THE-* and TYPE-* should as well. But this doesn’t strike me as particularly convincing — there’s nothing intrinsic in Ren-C which requires sigils to generalise to all possible types. Indeed, we’re quite willing to avoid doing so when it would make no sense. (For instance, we don’t have ISSUE-TEXT!, ISSUE-BINARY!, ISSUE-EMAIL!… we just have a single textual ISSUE! type, because doing otherwise would be silly.)</p>
<p>So, when all is said and done, we have a set of types which don’t seem to be of general use, and have no convincing reason to exist, but are nonetheless kept in the language. And <strong>I want to know why that is</strong>, because I can’t figure it out.</p>
            <p><small>9 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164</link>
          <pubDate>Tue, 05 Mar 2024 08:20:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2164</guid>
          <source url="https://forum.rebol.info/t/what-deserves-to-be-a-datatype/2164.rss">What deserves to be a datatype?</source>
        </item>
        <item>
          <title>REIFY and DEGRADE: a Narrower META and UNMETA</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Feature Discover</category>
          <description><![CDATA[
            <p>In the "small improvements can be big" category, I think that I've settled on the name for the function that turns quasiforms into antiforms, but leaves everything else alone: <strong>DEGRADE</strong>...and its complement <strong>REIFY</strong> which turns antiforms into quasiforms (but leaves everything else alone).</p>
<pre><code>&gt;&gt; first [1020 ~null~]
== 1020

&gt;&gt; second [1020 ~null~]
== ~null~

&gt;&gt; degrade first [1020 ~null~]
== 1020

&gt;&gt; degrade second [1020 ~null~]
== ~null~  ; anti

&gt;&gt; 304
== 304

&gt;&gt; reify 304
== 304

&gt;&gt; true
== ~true~  ; anti

&gt;&gt; reify true
== ~true~
</code></pre>
<p>If you're dealing with a full-band situation where you genuinely don't know if you're working with a "meaningful quasiform" where <em>quasi means quasi</em>, you have to use META and UNMETA.  But if you know that quasiforms aren't part of your data of interest, REIFY and DEGRADE can help you dodge adding and removing quote marks much (or most) of the time.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="12" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/12">Weird WORD!s - Allow, But Escape Them?</a>
</div>
<blockquote>
<p>Maybe it would be better (and give Chris less of a heart attack) if it said:</p>
<pre><code class="lang-plaintext">for-each [sigil' items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    '::    [  word:  tu.p.le:  pa/th:  [bl o ck]:  (gr o up): ]
    ':     [ :word  :tu.p.le  :pa/th  :[bl o ck]  :(gr o up)  ]
    '^     [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    '&amp;     [ &amp;word  &amp;tu.p.le  &amp;pa/th  &amp;[bl o ck]  &amp;(gr o up)  ]
    '@     [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    '$     [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
 ][
      for-each item items [
          if (unmeta sigil') &lt;&gt; sigil of item [fail [mold item]]
      ]
 ]
</code></pre>
</blockquote>
</aside>
<p>I like how DEGRADE can be used in situations like this to help you strike the quotes on the normal values...since SIGIL OF never returns quasiforms, only SIGIL! or a null antiform:</p>
<pre><code>for-each [sigil items] [
    ~null~ [  word   tu.p.le   pa/th   [bl o ck]   (gr o up)  ]
    ::     [  word:  tu.p.le:  pa/th:  [bl o ck]:  (gr o up): ]
    :      [ :word  :tu.p.le  :pa/th  :[bl o ck]  :(gr o up)  ]
    ^      [ ^word  ^tu.p.le  ^pa/th  ^[bl o ck]  ^(gr o up)  ]
    &amp;      [ &amp;word  &amp;tu.p.le  &amp;pa/th  &amp;[bl o ck]  &amp;(gr o up)  ]
    @      [ @word  @tu.p.le  @pa/th  @[bl o ck]  @(gr o up)  ]
    $      [ $word  $tu.p.le  $pa/th  $[bl o ck]  $(gr o up)  ]
][
    for-each item items [
        if (degrade sigil) &lt;&gt; sigil of item [
            fail [mold item]
        ]
    ]
]
</code></pre>
<p>I think this will be a useful and common pattern.</p>
<p>Void being a word antiform is locking this all up into place!</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/atom_symbol.png?v=12" title=":atom_symbol:" class="emoji only-emoji" alt=":atom_symbol:" loading="lazy" width="20" height="20"> <img src="https://forum.rebol.info/images/emoji/twitter/+1.png?v=12" title=":+1:" class="emoji only-emoji" alt=":+1:" loading="lazy" width="20" height="20"></p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163</link>
          <pubDate>Sun, 03 Mar 2024 15:28:36 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2163</guid>
          <source url="https://forum.rebol.info/t/reify-and-degrade-a-narrower-meta-and-unmeta/2163.rss">REIFY and DEGRADE: a Narrower META and UNMETA</source>
        </item>
        <item>
          <title>Terminology MAP</title>
          <dc:creator><![CDATA[GiuseppeChillemi]]></dc:creator>
          <category>Site Feedback</category>
          <description><![CDATA[
            <p>Hi Hostile Fork,<br>
Ren-C has a lot changes and new features but it is hard to follow what has been changed/created, and the discussion that led to the development of a feature, from start to end.</p>
<p>To help undestand your project, could I ask to add a page or a post where you list all additions like: ANTIFORM, BLANK, ISOTOPES and a brief description. Also, it would be great to have a link to the introductiory post to each feature (like UPARSE) and all the subsequent posts regarding the design. This could be done either via a direct link to the introductory post for the new feature, and also filtering via TAG and DATE using tags like <span class="hashtag">#ANTIFORM</span> <span class="hashtag">#DESIGN</span></p>
<p>Thank you</p>
            <p><small>7 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/terminology-map/2162">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/terminology-map/2162</link>
          <pubDate>Sun, 03 Mar 2024 15:19:31 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2162</guid>
          <source url="https://forum.rebol.info/t/terminology-map/2162.rss">Terminology MAP</source>
        </item>
        <item>
          <title>Header dialect and multiline strings</title>
          <dc:creator><![CDATA[gchiu]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p>I've been reading the threads about multiline strings and using {} for arrays, and I'm thinking that the header is going to look rather messy given that's it's not uncommon to have multiline statements there.</p>
<pre><code>Rebol [
    Title: "Your module title here"
    Type: module
    Name: your-module
    Rights: -{
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors
    }-
    License: -{
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0
    }-
    Description: \{
       Weirdly this does not look as good, despite dropping a character.
       
            printf("The char is } and it need not be escaped\n");

       So that's good.  And here we can do \n\n\n for escaped lines.
   }\
]
</code></pre>
<p>As an alternative I quite like the way yaml is written, it's very clean without a lot of funny distracting escape characters.  Can we consider using a yaml dialect for the header?</p>
<pre><code>Rebol -{
    Title: Your module title here
    Type: module
    Name: your-module

    Rights: |
        Copyright 2012 REBOL Technologies
        Copyright 2017-2021 Ren-C Open Source Contributors

    License: |
        Licensed under the Apache License, Version 2.0
        See: http://www.apache.org/licenses/LICENSE-2.0

    Description: |
       This would be YAML-based.
       
            printf("The char is } and it need not be escaped\n");

       So that's good.  And here we can do \n\n\n for escaped lines.
}-
</code></pre>
            <p><small>8 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159</link>
          <pubDate>Wed, 28 Feb 2024 07:17:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2159</guid>
          <source url="https://forum.rebol.info/t/header-dialect-and-multiline-strings/2159.rss">Header dialect and multiline strings</source>
        </item>
        <item>
          <title>API Breakthrough: Scope Detection In JavaScript and C !</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Language Bridging</category>
          <description><![CDATA[
            <h2>
<a name="background-1" class="anchor" href="https://forum.rebol.info#background-1"></a>Background</h2>
<p>When writing the implementation of a Rebol function using C or JavaScript code, getting at the arguments and locals of that function was something of an annoyance.</p>
<p>You had to use a separate <strong><code>rebArg()</code></strong> API that looked on the Rebol stack for the last Rebol function call, and retrieved arguments in that frame.  This broke the flow, generating an extra API handle that had to be released:</p>
<pre><code>quadrupler: js-native [num [integer!]] {
    let rebol_num = reb.Arg("num")
    let num = reb.UnboxInteger(rebol_num, "* 2")  // Rebol multiplying
    reb.Release(rebol_num)
    return reb.Integer(num * 2)  // JavaScript multiplying
}
</code></pre>
<p>Of course, you could have used <strong><code>reb.R()</code></strong> to make a "releasing" splice, so the variadic would release it as it went along:</p>
<pre><code>quadrupler: js-native [num [integer!]] {
    let num = reb.UnboxInteger(reb.R(reb.Arg("num")), "* 2")
    return reb.Integer(num * 2)
}
</code></pre>
<p>This was made "prettier" <sub>cough</sub> with a fused instruction called <strong><code>reb.ArgR()</code></strong></p>
<pre><code>quadrupler: js-native [num [integer!]] {
    let num = reb.UnboxInteger(reb.ArgR("num"), "* 2")
    return reb.Integer(num * 2)
}
</code></pre>
<p>Kind of a headache.  <strong>But even worse... what if it's a WORD! or something evaluative?</strong></p>
<pre><code>reverse-spell: js-native [
    {If REVERSE-SPELL 'FOO you get "OOF"}
    word [word!]
]{
    return reb.Spell("reverse to text!", reb.ArgR("word"));  // !!! WRONG
}
</code></pre>
<p>The TO TEXT! won't convert the word, because the word will be spliced into the instruction stream and looked up as a variable..  You need to quote it (or meta it, if it's an antiform):</p>
<pre><code>reverse-spell: js-native [word [word!]] {
    return reb.Spell("reverse to text!", reb.Q(reb.ArgR("word")));
}

reverse-spell: js-native [word [word!]] {
    return reb.Spell("reverse to text! @", reb.ArgR("word"));  // as good as it got
}
</code></pre>
<p>This problem comes from what I have described as saying that all API calls are effectively doing an EVAL COMPOSE, because the C variable name isn't something Rebol can see...hence it cannot "protect" the value it holds.  You'd have the same problem with:</p>
<pre><code> eval compose [reverse to text! (word)]
</code></pre>
<h2>
<a name="wouldnt-it-be-nice-if-the-api-knew-it-was-inside-a-native-2" class="anchor" href="https://forum.rebol.info#wouldnt-it-be-nice-if-the-api-knew-it-was-inside-a-native-2"></a>Wouldn't it be nice if the API <em>knew</em> it was inside a native?</h2>
<p>Then it could just do the lookup by name, with normal code...:</p>
<pre><code>quadrupler: js-native [num [integer!]] {
    let num = reb.UnboxInteger("num * 2")
    return reb.Integer(num * 2)
}

reverse-spell: js-native [word [word!]] {
    return reb.Spell("reverse to text! word");
}
</code></pre>
<p>But how would it know when you called out from the code for the native body to some service routine that also used the API... where the parameters should not be visible?</p>
<h2>
<a name="well-ive-solved-it-star-in-cc-and-javascript-3" class="anchor" href="https://forum.rebol.info#well-ive-solved-it-star-in-cc-and-javascript-3"></a><strong>Well, I've Solved It!</strong> <img src="https://forum.rebol.info/images/emoji/twitter/star.png?v=12" title=":star:" class="emoji" alt=":star:" loading="lazy" width="20" height="20">  In C/C++ and JavaScript</h2>
<p>It's the most significant API change in a while, and it has a big impact:</p>
<p><strong><a href="https://github.com/metaeducation/ren-c/commit/71d86b67c05dddf5c90aff044ca3fb5e1c14952a">C Improvements</a></strong></p>
<p><strong><a href="https://github.com/hostilefork/replpad-js/commit/b6978ec43f83a97aabb14c2efa218e5da5048e8f#diff-839c9f79a45893495f4bf96067d8c1567ccac664d09a265e299079862040f2f1L907">JavaScript Improvements</a></strong></p>
<h2>
<a name="hows-it-done-for-starters-pure-virtual-binding-4" class="anchor" href="https://forum.rebol.info#hows-it-done-for-starters-pure-virtual-binding-4"></a>How's It Done?  For Starters, Pure Virtual Binding...</h2>
<p><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">"Pure Virtual Binding"</a> gives us the possibility finding function arguments and locals dynamically, once the function is already running...even if we just have text in our hand:</p>
<pre><code>demo: func [arg] [
    name: "arg"
    word: inside [] to word! name  ; BLOCK! evaluation captures specifier
    print ["The value of arg is" get word]
]

&gt;&gt; demo 1020
The value of arg is 1020
</code></pre>
<p>So that's how we're managing to look up the text.</p>
<h2>
<a name="capturing-shadowed-variables-as-a-proxy-for-stack-5" class="anchor" href="https://forum.rebol.info#capturing-shadowed-variables-as-a-proxy-for-stack-5"></a>Capturing Shadowed Variables As A Proxy For Stack</h2>
<p>The next trick is: how do functions like <strong>reb.UnboxInteger()</strong> or <strong>reb.Spell()</strong> (or their C equivalents <strong>rebUnboxInteger()</strong> or <strong>rebSpell()</strong>) know what Rebol function is currently executing... or if you're in the body of the implementation or not?</p>
<p>The variadic C API functions are actually macros that look like this:</p>
<pre><code>#define rebSpell(...) \
    rebSpell_helper( \
        LIBREBOL_SPECIFIER,  /* captured from callsite! */ \
        __VA_ARGS__, rebEND \
    )
</code></pre>
<p>LIBREBOL_SPECIFIER is something that is defined before you <code>#include "rebol.h"</code>, that gives the expression to evaluate which will give you the stack.  So when you see a native definition like:</p>
<pre><code>DECLARE_NATIVE(native_name_here) {
    INCLUDE_PARAMS_OF_NATIVE_NAME_HERE;
    ...
}
</code></pre>
<p>That expands to:</p>
<pre><code>RebolBounce N_native_name_here(RebolLevel* level_) {
    RebolSpecifier librebol_specifier;
    librebol_specifier = rebSpecifierFromLevel_internal(level_)
    ...
}
</code></pre>
<p>This overrides a global static.  If you're inside the function, the API macros will receive the specifier that's in the function, otherwise the static.  It drives its decision from there.</p>
<p>The JavaScript uses a similar technique, but in that case it can override the <strong>reb</strong> used in the <strong>reb.Xxx()</strong> functions.  There's a global <code>reb</code>, and then a <code>reb</code> that's tweaked which comes in as a parameter to the JavaScript function implementing the native.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/api-breakthrough-scope-detection-in-javascript-and-c/2157">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/api-breakthrough-scope-detection-in-javascript-and-c/2157</link>
          <pubDate>Mon, 26 Feb 2024 23:57:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2157</guid>
          <source url="https://forum.rebol.info/t/api-breakthrough-scope-detection-in-javascript-and-c/2157.rss">API Breakthrough: Scope Detection In JavaScript and C !</source>
        </item>
        <item>
          <title>Raku (Perl 6) Type System</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="19" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/19">Ugly Types: Less Ugly Than History, Can We Do Better?</a>
</div>
<blockquote>
<p>That’s why I think it’s a good idea to keep TYPE OF a direct reflection of the heart-byte, and use other constructions for code which needs other things.</p>
</blockquote>
</aside>
<p>I’ve just discovered a bit of prior art for this, in the form of Raku (i.e., the language formerly known as Perl 6). Its equivalent to TYPE OF, namely <a href="https://docs.raku.org/language/mop#WHAT">WHAT</a>, returns only the ‘type object’ of which the value is an instance. By contrast, type matching (and pattern matching) is done using <a href="https://docs.raku.org/type/Mu#method_ACCEPTS">ACCEPTS</a> with a <a href="https://docs.raku.org/language/signatures">signature literal</a>, which is a much more flexible syntax allowing all kinds of constraints to be expressed.</p>
<p>Actually, now that I think of it, Raku signature literals strike me as quite a nice approach. For Ren-C, they suggest the idea of having a ‘type-matching dialect’… though, then again, I guess that’s something I <a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2">already suggested above</a>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/raku-perl-6-type-system/2156">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/raku-perl-6-type-system/2156</link>
          <pubDate>Sun, 25 Feb 2024 12:53:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2156</guid>
          <source url="https://forum.rebol.info/t/raku-perl-6-type-system/2156.rss">Raku (Perl 6) Type System</source>
        </item>
        <item>
          <title>About the Math category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Rebol languages aren't a particularly great choice for math.</p>
<ul>
<li>
<p>Operator precedence follows the left-to-right nature of the evaluator, not the precedence many would expect:</p>
<pre><code>&gt;&gt; 1 + 2 * 3
== 9
</code></pre>
</li>
<li>
<p>Its syntax focus on words-separated-by-spaces, so this expands out expressions:</p>
<pre><code>&gt;&gt; length of [x+y*z]
== 1

&gt;&gt; type of first [x+y*z]
== &amp;[word]
</code></pre>
</li>
<li>
<p>The language is interpreted, meaning that even the simplest operation like <strong>add 1 2</strong> will run thousands of times slower than a compiled instruction.</p>
</li>
</ul>
<hr>
<p>But all programming involves math every now and again.  So this category is for discussing any math issues people want to talk about.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-math-category/2155">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-math-category/2155</link>
          <pubDate>Tue, 20 Feb 2024 23:27:47 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2155</guid>
          <source url="https://forum.rebol.info/t/about-the-math-category/2155.rss">About the Math category</source>
        </item>
        <item>
          <title>What is the use of typesets?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Recent discussions have brought the notion of ‘typesets’ to my attention. On reading the source code, this confused me a bit… they don’t seem to be used all that much. Moreover, they seem to be subsumed by the idea of optimised constraint functions.</p>
<p>So I set out to try them myself. Only to find myself thoroughly confused, because typesets don’t actually seem to be accessible from Ren-C itself. Or, at least, none seem to be defined — normal type names evaluate to TYPE-BLOCK!s as expected, but typeset names are unassigned:</p>
<pre><code class="lang-plaintext">&gt;&gt; word!
== &amp;[word]

&gt;&gt; text!
== &amp;[text]

&gt;&gt; any-utf8!
** Script Error: any-utf8! word is attached to a context, but unassigned
** Where: console
** Near: [any-utf8! **]
** Line: 1

&gt;&gt; any-type-value!
** Script Error: any-type-value! word is attached to a context, but unassigned
** Where: console
** Near: [any-type-value! **]
** Line: 1
</code></pre>
<p>[On which note, incidentally, let me yet again mention my conviction that the other TYPE-* datatypes are useless and should be removed.]</p>
<p>I expected to at least be able to use them in function signatures, but I can’t even do that, since it crashes a program:</p>
<pre><code class="lang-plaintext">&gt;&gt; test: func [x [word!]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8?]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8!]] [return x]
Assertion failure: QUOTE_BYTE(v) == ANTIFORM_0
Line 165, File: /home/bradrn/Documents/red/ren-c/src/include/cells/cell-quoted.h
Trace/breakpoint trap (core dumped)
</code></pre>
<p>So… if they can’t be accessed from Ren-C itself, then why does the interpreter have typesets at all?</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-is-the-use-of-typesets/2153">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153</link>
          <pubDate>Tue, 20 Feb 2024 04:29:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2153</guid>
          <source url="https://forum.rebol.info/t/what-is-the-use-of-typesets/2153.rss">What is the use of typesets?</source>
        </item>
        <item>
          <title>Dropping the ANY-XXX! from (Some) Type Constraints?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>There was a slightly confusing aspect of historical Rebol where some typesets were named so that they looked just like a datatype:</p>
<pre><code>red&gt;&gt; help append
USAGE:
    APPEND series value

DESCRIPTION: 
    Inserts value(s) at series tail; returns series head. 
    APPEND is an action! value.

ARGUMENTS:
    series       [series! bitset! port!] 
    value        [any-type!] 
...
</code></pre>
<p>Here, we see SERIES! which is not named in a way that makes it obvious that it's not a fundamental type.  It's named the same as BLOCK! or WORD!.</p>
<p><span class="mention">@earl</span> and I agreed that this was a stumbling block, so we thought that ANY-SERIES! was a better name.  That way you wouldn't make the mistake of saying:</p>
<pre><code>if series! = type? x [...]
</code></pre>
<p>...and have it always fail.  You'd be cued by that ANY- to know that it was a set of many types.  (You still might think that you could use the equals operator to see if something was in a typeset and be wrong, but that's a different level).</p>
<p><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">But Ren-C has done away with typesets.</a>  They were too limited, and we now use arbitrary functions to do typechecking via predicates (with some various supporting optimizations so the common cases aren't horrifically slow).</p>
<p>So ANY-SERIES! is pretty much going away.  Most of the time you just use ANY-SERIES? (e.g. in a function spec or regular code), and then &amp;ANY-SERIES? if you're in something like a parse rule.</p>
<h2>
<a name="do-we-still-need-the-any-1" class="anchor" href="https://forum.rebol.info#do-we-still-need-the-any-1"></a>Do We Still Need The ANY-?</h2>
<p>I'm a little torn on the question of whether we need the ANY-.</p>
<p>Sometimes it's required (e.g. with ANY-WORD?) because WORD? means specifically "plain word".  (Note you'd use WORD! generally in type specs, though technically you can use either...performance should be identical).</p>
<p>But on ANY-SERIES? it's now a bit superfluous. And SERIES? is certainly shorter.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>It's not a slam dunk to take the ANY- off.  I kind of like the realization it gives you as a reader... "hey, we're talking about multiple things here"... and it makes you stop and consider "just how many series are there?  is ANY-SERIES? really what I mean?"</p>
<p>I kind of lean to keeping it.  And I prefer ANY-VALUE? to just VALUE? as well.</p>
<p>But it's definitely less important than it was.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152</link>
          <pubDate>Sat, 17 Feb 2024 06:47:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2152</guid>
          <source url="https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152.rss">Dropping the ANY-XXX! from (Some) Type Constraints?</source>
        </item>
        <item>
          <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>
<a name="the-limited-and-ambiguous-historical-idea-1" class="anchor" href="https://forum.rebol.info#the-limited-and-ambiguous-historical-idea-1"></a>The Limited and Ambiguous Historical Idea</h2>
<p>People are used to being able to do things like:</p>
<pre><code> x: 10
 switch type? x [
     integer! [print "It's an integer"]
     block! [print "It's a block"]
 ]

 assert [parse [1 [second] 'foo] [integer! block! lit-word!]]

 assert [find any-word! (type? first [x:])]
</code></pre>
<p>But the historical DATATYPE! and TYPESET! were strange.</p>
<ul>
<li>
<p>DATATYPE! rendered as a WORD! but was really wrapping an integer of 0-63</p>
</li>
<li>
<p>TYPESET! was a 64-bit bitset, one bit for each type (this is where the 64 types limit came from)</p>
<ul>
<li>
<p>it lost its meaning in rendering (it kept no record of what the set actually was...just dumped words for each bit)</p>
</li>
<li>
<p>not preserving the name from a fixed list of typesets was based on the concept you could make your own or UNION/INTERSECT them</p>
</li>
</ul>
</li>
</ul>
<p>So it looked like this:</p>
<pre><code>red&gt;&gt; type? 1
== integer!

red&gt;&gt; type? type? 1
== datatype!

red&gt;&gt; print mold any-word!
make typeset! [word! set-word! lit-word! get-word!]

red&gt;&gt; print mold any-type!
make typeset! [datatype! unset! none! logic! block! paren! string! file! url!
    char! integer! float! word! set word! lit-word! get-word! refinement! issue!
    native! action! op! function! path! lit-path! set-path! get-path! routine!
    bitset! object! typeset! error! vector! hash! pair! percent! tuple! map!
    binary! time! tag! email! handle! date! port! money! ref! point2D! point3D!
    image! event!]
</code></pre>
<h2>
<a name="the-type-xxx-approach-2" class="anchor" href="https://forum.rebol.info#the-type-xxx-approach-2"></a>The TYPE-XXX! Approach</h2>
<p>So Ren-C attacked the ambiguity and extensibility with a new word type, TYPE-WORD!.  Then typesets used TYPE-GROUP! and TYPE-BLOCK!, referencing functions to act as type testing predicates, and using groups for intersections and blocks for unions:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer

&gt;&gt; type of type of 1
== &amp;type-word

&gt;&gt; print mold any-word!
&amp;(any-word?)

&gt;&gt; print mold any-value!
&amp;(any-value?)
</code></pre>
<p>This gives some realistic axis of extensibility, and gives distinguishable entities that can trigger behaviors in PARSE when something looks up to type-xxx!.  (this shows why using WORD! or URL! or ISSUE! wouldn't work, because the type intent has to be carried by what e.g. INTEGER! looks up to.)</p>
<p><strong>Calling functions to implement type checks vs. checks on a bitset, especially when an array of functions must be called when checking every parameter in every function call, is a difficult performance point.</strong></p>
<p><a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">Intrinsics and other magic are employed to rein it in.</a>  It's not particularly simple...but finding ways to speed up function calls where you can has systemic benefit.</p>
<h2>
<a name="new-consequence-find-must-find-type-word-normally-3" class="anchor" href="https://forum.rebol.info#new-consequence-find-must-find-type-word-normally-3"></a>New Consequence: FIND Must Find TYPE-WORD! Normally</h2>
<p>Being a legitimate datatype that can be stored in a block, some interpretations of datatype by functions like FIND were problematic:</p>
<pre><code>red&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" integer! 1]

red&gt;&gt; find block 'integer!
== none  ; rendering was a lie

red&gt;&gt; find block integer!
== [1]
</code></pre>
<p>You couldn't find a literal datatype in a block.  Ren-C is approaching this by saying FIND has to find the TYPE-WORD! (as it does for all non-antiforms), but that you can use antiform actions as predicates.</p>
<pre><code>&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" &amp;integer 1]

&gt;&gt; find block integer!
== [&amp;integer 1]

&gt;&gt; find block :integer?
== [1]
</code></pre>
<p>There was some thought that maybe you could create antiform TYPE-XXX! and call them "matchers", passing them to FIND.</p>
<ul>
<li>
<p>But this is an isotope for each TYPE-XXX!, so it's not even like there would be one "matcher"</p>
</li>
<li>
<p>It also would be the only instance of antiforms of types with sigils, which doubles the sigil to make <strong><code>~&amp;integer~</code></strong>, which I find kind of displeasing</p>
</li>
</ul>
<p>I feel that antiform actions cover it for FIND, and if you have higher level needs you should use something like PARSE which has richer options and isn't beholden to quite the "mechanical" answer that a series primitive like FIND has to abide by with its limited parameterization.</p>
<h2>
<a name="new-annoyance-type-of-quotes-and-antiforms-4" class="anchor" href="https://forum.rebol.info#new-annoyance-type-of-quotes-and-antiforms-4"></a>New Annoyance: TYPE OF Quotes And Antiforms</h2>
<p>When there were only two datatypes with quotedness, the quote was part of their datatype:</p>
<pre><code>red&gt;&gt; type? first ['a]
== lit-word!

red&gt;&gt; type? first ['a/b]
== lit-path!

red&gt;&gt; lit-word! = type? first ['a]
== true

red&gt;&gt; parse ['a 'a/b] [lit-word! lit-path!]
== true
</code></pre>
<p>Ren-C's approach affords the ability make type constraints to carry forward the PARSE behavior.  But the TYPE OF all quoteds is the same... &amp;QUOTED.</p>
<pre><code>&gt;&gt; lit-word?!
== &amp;(lit-word?)

&gt;&gt; lit-word?! = type of first ['a]
== ~false~  ; anti

&gt;&gt; type of first ['a]
== &amp;quoted
</code></pre>
<p>So perhaps you see the motivation to decorate as <strong>?!</strong> instead of just <strong>!</strong> for the type constraints.  People need to know that these aren't fundamental types.  You have to use e.g. MATCH with them:</p>
<pre><code> &gt;&gt; match lit-word?! first ['a]
 == 'a

 &gt;&gt; match lit-word?! 10
 == ~null~  ; anti

 &gt;&gt; match [lit-word?] first ['a]  ; alternative as 1st slot known "typelike"
 == 'a
</code></pre>
<p>This is something of a pain point, and I'm not entirely settled on whether it would be good to delve into some kind of ambiguity where we are actually allowed to get back constraint functions as the answer to TYPE OF, and make that the fundamental:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer?

&gt;&gt; type of spread [a b]
== &amp;splice?

&gt;&gt; type of ~true~
== &amp;logic?

&gt;&gt; type of first ['a]
== &amp;quoted? 
</code></pre>
<p>So I don't think this is a good idea for the quoted types, but for the antiforms it might be a narrow enough thing that it provides "what the people want".</p>
<pre><code>&gt;&gt; switch type of true [
     splice! [...]
     logic! [...]
     integer! [...]
  ]
</code></pre>
<p>Barring that, what we have to do today is flip SWITCH over into a MATCH mode (currently called SWITCH/TYPE but should probably be SWITCH/MATCH... or maybe it should take the MATCH name):</p>
<pre><code>&gt;&gt; switch/type true [
     splice?! [...]
     logic?! [...]
     integer! [...]
  ]
</code></pre>
<p>Note that the <code>?!</code> distinction is a new idea which hasn't made it to all type constraints yet, e.g. ANY-VALUE! is still as it was.  But because parameters use what is effectively a TYPE-BLOCK! you can say <strong><code>any-value?</code></strong> or <strong><code>splice?</code></strong> in them instead of going through the extra step.</p>
<h2>
<a name="should-type-be-a-bigger-concept-5" class="anchor" href="https://forum.rebol.info#should-type-be-a-bigger-concept-5"></a>Should TYPE Be A Bigger Concept?</h2>
<p>One thing that has nagged me is if when we ask for the fundamental "cell type" of something, if we should avoid using the word "TYPE" for that at all...</p>
<p>Maybe there's some bigger idea in an object/class system where TYPE is meaningful to say something more than "this is an object" but rather "this is a book", where you can ask also "is a book readable".  Etc.</p>
<p>Or maybe TYPE can be parameterized:</p>
<pre><code> &gt;&gt; type of matrix
 == &amp;[matrix 10x10]
</code></pre>
<p>So this would mean there's a smaller question about the fundamental type, maybe call it "KIND":</p>
<pre><code>&gt;&gt; kind of [a b c]
== &amp;block

&gt;&gt; kind of matrix
== &amp;object
</code></pre>
<p>It would be nice to just be able to say "64 types is enough for anyone" and say "there, it's done".  I'd be happy to do that if I felt that it was enough.  It wasn't, even when thinking along fairly limited lines that don't go in these fancier directions.</p>
<p><em>I don't think any near-term system will actualize on bigger visions of what TYPE might be, but it would help to know if that should be ruled out or not, just in order to pick the term KIND or TYPE!</em>  But even that question is murky.</p>
<h2>
<a name="some-related-reading-typesr-6" class="anchor" href="https://forum.rebol.info#some-related-reading-typesr-6"></a>Some Related Reading: %types.r</h2>
<p>The dialected table used to construct the type testing macros and other things is kind of neat, though some comments are out of date and parts of it need updating (it's getting upgraded in an upcoming commit which finally breaks the 64-type barrier and introduces the $ types):</p>
<p>See <a href="https://github.com/metaeducation/ren-c/blob/master/src/boot/types.r"><strong>%types.r</strong></a></p>
            <p><small>20 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151</link>
          <pubDate>Fri, 16 Feb 2024 23:29:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2151</guid>
          <source url="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
        </item>
  </channel>
</rss>

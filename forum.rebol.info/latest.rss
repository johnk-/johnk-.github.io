<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest topics</title>
    <link>https://forum.rebol.info/latest</link>
    <description>Latest topics</description>
    
      <lastBuildDate>Mon, 17 Apr 2023 23:10:16 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/latest.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</title>
          <dc:creator><![CDATA[vnzio]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p><a href="https://factorcode.org/" class="onebox" target="_blank" rel="noopener nofollow ugc">https://factorcode.org/</a></p>
<aside class="onebox wikipedia">
  <header class="source">
      <a href="https://en.wikipedia.org/wiki/Factor_(programming_language)?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">en.wikipedia.org</a>
  </header>
  <article class="onebox-body">
    <div class="aspect-image" style="--aspect-ratio:200/124;"><img src="//upload.wikimedia.org/wikipedia/en/thumb/f/ff/NewFactorLogo.png/200px-NewFactorLogo.png" class="thumbnail" width="200" height="124"></div>

<h3><a href="https://en.wikipedia.org/wiki/Factor_(programming_language)?wprov=sfla1" target="_blank" rel="noopener nofollow ugc">Factor (programming language)</a></h3>

<p>Factor is a stack-oriented programming language created by Slava Pestov. Factor is dynamically typed and has automatic memory management, as well as powerful metaprogramming features. The language has a single implementation featuring a self-hosted optimizing compiler and an interactive development environment. The Factor distribution includes a large standard library.
 Slava Pestov created Factor in 2003 as a scripting language for a video game. The initial implementation, now referred to as JFa...</p>

  </article>
  <div class="onebox-metadata">
    
    
  </div>
  <div style="clear: both"></div>
</aside>

<p>Google Tech Talk 2008</p><div class="onebox lazyYT lazyYT-container" data-youtube-id="f_0QlhYlS8g" data-youtube-title="Factor: an extensible interactive language" data-parameters="feature=oembed&amp;wmode=opaque">
  <a href="https://www.youtube.com/watch?v=f_0QlhYlS8g" target="_blank" rel="noopener nofollow ugc">
    <img class="ytp-thumbnail-image" src="https://i.ytimg.com/vi/f_0QlhYlS8g/hqdefault.jpg" title="Factor: an extensible interactive language" width="480" height="360">
  </a>
</div>

<p>Silicon Valley Forth Interest Group<br>
2022<br>
"Factor in 2022"</p><div class="onebox lazyYT lazyYT-container" data-youtube-id="OLh61q4c4XE" data-youtube-title="2022-03-26 --- Factor in 2022 --- John Benediktsson &amp; Doug Coleman" data-parameters="feature=oembed&amp;wmode=opaque">
  <a href="https://www.youtube.com/watch?v=OLh61q4c4XE" target="_blank" rel="noopener nofollow ugc">
    <img class="ytp-thumbnail-image" src="https://i.ytimg.com/vi/OLh61q4c4XE/maxresdefault.jpg?sqp=-oaymwEmCIAKENAF8quKqQMa8AEB-AH-CYAC0AWKAgwIABABGFMgXyhlMA8=&amp;rs=AOn4CLD3Gk9dNc354_7LCakXnmAr4PA3JA" title="2022-03-26 --- Factor in 2022 --- John Benediktsson &amp; Doug Coleman" width="690" height="388">
  </a>
</div>

            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029</link>
          <pubDate>Mon, 17 Apr 2023 23:10:16 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2029</guid>
          <source url="https://forum.rebol.info/t/factor-slava-pestovs-beautiful-language/2029.rss">&quot;Factor&quot; // Slava Pestov&#39;s beautiful language</source>
        </item>
        <item>
          <title>Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</title>
          <dc:creator><![CDATA[vnzio]]></dc:creator>
          <category>Offtopic</category>
          <description><![CDATA[
            <p>Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</p>
<p>???</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028</link>
          <pubDate>Mon, 17 Apr 2023 22:47:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2028</guid>
          <source url="https://forum.rebol.info/t/anyone-open-to-zoomcall-discussion-sessions-teaching-clarifying-about-ren-c-and-why-how-what-is-so-tantalizing/2028.rss">Anyone open to zoomcall discussion sessions teaching clarifying about Ren-C and why how what is so tantalizing &gt;&gt;&gt;</source>
        </item>
        <item>
          <title>Should ANY-VALUE! Include Isotopes?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>So if you don't put any type restrictions on a parameter, it will allow isotopes:</p>
<pre><code> &gt;&gt; foo: func [x] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p>And right now, that is a synonym for ANY-VALUE!.</p>
<pre><code> &gt;&gt; foo: func [x [any-value!]] [probe x]

&gt;&gt; foo null
~null~  ; isotope
</code></pre>
<p><strong>But what if you want to exclude isotopes?</strong>  We could have a name for the typeset excluding isotopes (perhaps ANY-CELL!).  Or we could say that ANY-VALUE! doesn't include isotopes by default, and so you have to write <strong>[any-value! isotope!]</strong> if you want them... or just include the specific ones you intend (like <strong>[null! any-value!]</strong>.</p>
<p>Right now I'm going the route of saying ANY-CELL! is the narrower set of values that do not include isotopes.  Is there a better term for saying something can be put into an array vs. not?</p>
<p><em>"10 is an integer! which is legal to use as a cell, while ~null~ isotopes are not legal as cells, but can be variable values"</em></p>
<p>It seems shorter and cleaner than ANY-REIFIED!  or something like that.  I don't know any better options.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-any-value-include-isotopes/2026">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-any-value-include-isotopes/2026</link>
          <pubDate>Fri, 14 Apr 2023 21:37:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2026</guid>
          <source url="https://forum.rebol.info/t/should-any-value-include-isotopes/2026.rss">Should ANY-VALUE! Include Isotopes?</source>
        </item>
        <item>
          <title>TRY... *again* :roll_eyes:</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I have proposed a concept for TRY as trapping definitional errors and turning them into nulls, like this:</p>
<pre><code>&gt;&gt; take []
** Error: you can't take from an empty block (stopping further code)

&gt;&gt; try take []
== ~null~  ; isotope
</code></pre>
<p>And I'll just give a reminder that as this is trapping <a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">definitional errors</a>.  So failures from deeper inside code would not be caught... only errors that are returned by contract from the function being called.</p>
<pre><code>&gt;&gt; try compose [(1 / 0)]
** Error: division by zero (e.g. COMPOSE itself didn't raise the error)
</code></pre>
<p><em>I'll remind everyone that it's a very slippery slope to trap "deep errors", and this is why the deep error trapping concept is <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871/3">hidden away as <code>sys.util.rescue</code></a>)</em></p>
<h2>Why Return NULL From TRY (vs. void) ?</h2>
<p>The decision to return null is to make the result falsey so it can be acted on:</p>
<pre><code>while [item: try take block] [
    ...
]

all [
    try take block  ; if this fails we don't want to keep going
    ...
]
</code></pre>
<p>In the vernacular I use, I call NULL "soft failure".  So TRY "converts a definitional failure into soft failure", passing through all other results as-is.</p>
<h2>Comparison with similar word MAYBE</h2>
<p>The MAYBE operation was defined as something that converts nulls to voids, and passes through everything else.  If you didn't know that, it's easy to see not intuiting what the difference between <strong>try take block</strong> and <strong>maybe take block</strong> would be.</p>
<p>You can get some odd-looking combinations with this, e.g.</p>
<pre><code> &gt;&gt; block1: [a b c]
 &gt;&gt; block2: []

 &gt;&gt; append block1 maybe try take block2
 == [a b c]
</code></pre>
<p>Which makes one wonder if MAYBE could be used to trap definitional errors as well as nulls and turn them into voids, so you could just write <strong>append block1 maybe take block2</strong>.</p>
<p>So it raises the question: are there null-returning operations that also return definitional errors, where one would want to suppress the null but not the error?  There's not enough experience for me to say yet.</p>
<h2>Usage in PARSE as opposed to OPT?</h2>
<p>I've wondered if TRY and MAYBE could have parallel meanings in PARSE, where you use TRY to continue but get NULL and MAYBE to skip things:</p>
<pre><code>&gt;&gt; parse "aaa" [some "a" maybe some "b"]
== "a"

&gt;&gt; parse "aaa" [some "a" var: try some "b"]
; first in pack of length 1
== ~null~  ; isotope

&gt;&gt; var
== ~null~  ; isotope
</code></pre>
<p>Seeing the two operations as being very similar--only one voids while the other one nulls--feels interesting.  I just hadn't thought of MAYBE as a definitional-error-suppressor before.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/try-again/2025">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/try-again/2025</link>
          <pubDate>Fri, 14 Apr 2023 21:22:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2025</guid>
          <source url="https://forum.rebol.info/t/try-again/2025.rss">TRY... *again* :roll_eyes:</source>
        </item>
        <item>
          <title>The Handling of NULL in UPARSE</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Parsing</category>
          <description><![CDATA[
            <p>By design, nulls are handled noisily--right at the moment of fetching the word!--in UPARSE (and PARSE3):</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [prefix, some "a", suffix]
** Error: (prefix is null, and we raise errors for that in parse)
</code></pre>
<p>If we didn't raise an error it seems there are only two other options:</p>
<ol>
<li>
<p>Make <strong><code>null</code></strong> always succeed, keeping the parse position where it is (synonym for <strong><code>[]</code></strong>)</p>
</li>
<li>
<p>Make <strong><code>null</code></strong> always be an unsuccessful combinator match, but not cause a failure (synonym for <strong><code>false</code></strong>)</p>
</li>
</ol>
<p>I think (1) feels like a pretty obvious bad idea, because null is supposed to represent a soft failure.  I've suggested that this is a better behavior for void, e.g. <strong><code>parse "ab" ["a" void "b"]</code></strong> would work.</p>
<p>I'm not too pleased with the idea of (2), and prefer the error as the default.</p>
<p><em>...that said...</em> it seems there should be some operators or combinators that let you get the other behaviors.</p>
<h2>What About a "MAYBE" Combinator To Use With Null?</h2>
<p>In standard code, the policy of "void-in-null-out" has worked well, with MAYBE transforming soft-failure nulls to voids:</p>
<pre><code> ; non-PARSE handling of NULL via MAYBE

 &gt;&gt; append [a b c] null
 ** Error: cannot append ~null~ isotope to a block

 &gt;&gt; append [a b c] maybe null
 == [a b c]

 &gt;&gt; block: null

 &gt;&gt; append maybe block [d e]
 == ~null~  ; isotope
</code></pre>
<p>So if we imagine applying this to the parse example, it would presumably do this:</p>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [maybe prefix, some "a", maybe suffix]
== ")"
</code></pre>
<p>For the above parse to succeed, the combinator made by <strong>maybe prefix</strong> would have to succeed and not advance the input.</p>
<h2>But It Doesn't Combine Well In Larger Rules</h2>
<p>What if what you intended was <em>"if there's a prefix, match some non-zero number of instances, but if prefix is null then don't worry about matching"</em>:</p>
<p>You might try doing that by COMPOSE'ing your rules.  But UPARSE actually lets us write that out literally using GET-GROUP! rule synthesis:</p>
<pre><code>&gt;&gt; parse "aaa)))" [:(if prefix '[some prefix]), some "a", :(if suffix '[some suffix])]
== ")"
</code></pre>
<p>But what if we tried to do that with MAYBE...could it work?</p>
<pre><code>&gt;&gt; parse "aaa)))" [some maybe prefix, some "a", some maybe suffix]
; infinite loop!
</code></pre>
<p>No dice.  We've said <strong>maybe prefix</strong> just succeeds and doesn't advance the input when prefix was null.  But if you combine that with <code>some</code> the null case will just match nothing in perpetuity, causing an infinite loop.</p>
<p>This may look familiar, because if you write <strong>some opt [...anything...]</strong> you'll always get an infinite loop.  But in that case it's just wrong thinking: you know that the repetitive nature of <code>some</code> looking for an eventual non-match meant you must have intended <strong>some [...anything...]</strong> (at least one) or <strong>opt some [...anything...]</strong> (zero or more).</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=9" title=":thinking:" class="emoji only-emoji" alt=":thinking:"></p>
<blockquote>
<h3>NOTE THAT HISTORICAL PARSE HAS NO GOOD ANSWER FOR THIS</h3>
<p>Rebol2 treats NONE! as a no-op which just succeeds but doesn't advance the input.  So the following gives you an infinite loop:</p>
<pre><code>rebol2&gt;&gt; prefix: none suffix: ")"

rebol2&gt;&gt; parse "aaa)))" [some prefix some "a" some suffix]   
; infinite loop
</code></pre>
<p>The hackish "must make progress" rules in R3-Alpha actually make the above "work as intended", because the SOME will bail out after one non-advancing match.  I don't consider that a "good" answer--more a random effect.</p>
</blockquote>
<h2>Another Problem: MAYBE is a very similar word to OPT</h2>
<p>Imagine looking at this code:</p>
<pre><code>&gt;&gt; prefix: "(", suffix: ")"

&gt;&gt; parse "aaa)" [maybe prefix, some "a", maybe suffix]
== ~null~  ; isotope
</code></pre>
<p><em>"But wait"</em>... I can imagine someone saying... <em>"doesn't that mean that if it's not there, you skip the rule"</em>?</p>
<blockquote>
<p>I've had some mental back-and-forth about the words <strong><code>try</code></strong>, <strong><code>opt</code></strong>, and <strong><code>maybe</code></strong>...with a general dislike of the word OPT.  The current idea is that TRY was intended to defuse harder definitional errors:</p>
<pre><code>&gt;&gt; take []
** Error: you can't take from an empty block (stopping further code)

&gt;&gt; try take []
== ~null~  ; isotope
</code></pre>
</blockquote>
<h2>An extra barrier to creating MAYBE is mechanical</h2>
<p>... <em>because the error that NULL generates is the "null combinator" itself</em>.  It is <em>not</em> a definitional error, because those just represent things like "type didn't match".</p>
<p>The only way I can see a null-disabling MAYBE parse combinator working would be by quoting its argument, doing the rule fetch itself, and turning into a failing combinator if it fetched null.  This breaks the model somewhat.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:"></p>
<h2>Maybe <strong>/prefix</strong> could Mean Optionally-Null variable?</h2>
<pre><code>&gt;&gt; prefix: null, suffix: ")"

&gt;&gt; parse "aaa)" [/prefix, some "a", /suffix]
== ")"
</code></pre>
<p>It's already the case that paths have to be quoted to match in blocks, but a leading slash could be used to deal with the rules.</p>
<p>It's a lot to think about on my first day of thinking about Rebol stuff for a while!  But there you go.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-handling-of-null-in-uparse/2023">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-handling-of-null-in-uparse/2023</link>
          <pubDate>Fri, 07 Apr 2023 00:14:18 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2023</guid>
          <source url="https://forum.rebol.info/t/the-handling-of-null-in-uparse/2023.rss">The Handling of NULL in UPARSE</source>
        </item>
        <item>
          <title>Naming void&#39;s isotopic, quoted, and quasi forms</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>I've called the state of unset variables "nihil"... <strong>this is the isotopic state of void</strong>.  I don't know if it's the best name but I definitely know I don't like calling it "unset" (I always say "variables are unset, not values").</p>
<p>The meta state of void is just a single apostrophe.  Evaluating it produces void:</p>
<pre><code>&gt;&gt; '
; void
</code></pre>
<p>The quasi state of void is a single tilde, and it evaluates to nihil:</p>
<pre><code>&gt;&gt; ~
== ~  ; isotope  &lt;-- a.k.a. nihil
</code></pre>
<p>I mentioned that I prefer this to be the default for making an ARRAY if you don't specify an /INITIAL value because it is the reified stand-in for uninitialized-ness.  Unlike blanks, it would error if you try to SPREAD it:</p>
<pre><code>&gt;&gt; block: array 10
== [~ ~ ~ ~ ~ ~ ~ ~ ~ ~]

&gt;&gt; spread block.2
** Error...
</code></pre>
<p>This seems to me a better default than blank for any slots that you miss filling in for your arrays.</p>
<p><strong>So what do we call <code>[']</code> and <code>[~]</code></strong>?  Metavoid and Quasivoid?  Tick and tilde?  Is tilde a Metanihil?</p>
<p>I've also wondered if there's any better name for nihil.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/naming-voids-isotopic-quoted-and-quasi-forms/2021">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/naming-voids-isotopic-quoted-and-quasi-forms/2021</link>
          <pubDate>Fri, 03 Mar 2023 21:55:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2021</guid>
          <source url="https://forum.rebol.info/t/naming-voids-isotopic-quoted-and-quasi-forms/2021.rss">Naming void&#39;s isotopic, quoted, and quasi forms</source>
        </item>
        <item>
          <title>Correct Formulation of ME and MY</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>The ME function is used with enfix to allow you to avoid repeating the name of a variable:</p>
<pre><code>&gt;&gt; variable: 10

&gt;&gt; variable: me + 1
== 11

&gt;&gt; variable
== 11
</code></pre>
<p>So that's the same as if you'd written <strong>variable: variable + 1</strong>.</p>
<p>There's an analogous operation for non-enfix functions called MY.</p>
<pre><code>&gt;&gt; block: [a b c]

&gt;&gt; block: my next
== [b c]

&gt;&gt; block
== [b c]
</code></pre>
<p>So the same if you had written <strong>block: next block</strong>.</p>
<h2>Here Is The "Naive" Macro Implementation of ME</h2>
<pre><code>me: enfixed macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
][
    reduce [left, plain left, right]
]
</code></pre>
<p>So the macro is looking for a SET-WORD! or SET-TUPLE! on the left, and then something indicating the action to run on the right.  It replaces the whole sequence with what was on the left, then a plain WORD! or TUPLE! version of what was on the left, and then what's on the right.</p>
<p>MY is done similarly, just with <strong>reduce [left, right, plain left]</strong> to put the repeated term after the call.</p>
<p>This is naive for two reasons:</p>
<ul>
<li>
<p>It doesn't check that what the RIGHT parameter looks up to is an action</p>
</li>
<li>
<p>If the SET-TUPLE! in LEFT has a GROUP! in it, then it will be executed twice.</p>
</li>
</ul>
<h2>Here is A "Non-Naive" Implementation of ME</h2>
<pre><code>macro [
    'left [set-word! set-tuple!]
    'right [word! tuple! path!]
    &lt;local&gt; value
][
    [left value]: resolve left  ; avoid double-evaluation
    :['set left meta value ensure action! get right]
]
</code></pre>
<p>The RESOLVE function is used to turn a TUPLE! or PATH! with groups in it into an inert representation:</p>
<pre><code> &gt;&gt; blk: [a b [c d]]

 &gt;&gt; resolve 'blk.(print "hi", 1 + 2).2
 hi
 == @[blk 3 2]
</code></pre>
<p>GET and SET accept these blocks as an alternative to words/tuples to be used to describe what to set or get.</p>
<p>It has to use a BLOCK! representation because not all things can be represented in paths that can be used with picking (note this implies you cannot pick with isotopes, otherwise not all blocks would be resolvable).</p>
<p>So long as RESOLVE is walking the path, you can ask it to give you back the value of what's there.</p>
<h2>But the non-naive version triggers a binding bug...</h2>
<p>It's also rather slow.  In trying to prioritize, it may be better to just document the right answer, as I've done here... :-/</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020</link>
          <pubDate>Fri, 03 Mar 2023 21:23:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2020</guid>
          <source url="https://forum.rebol.info/t/correct-formulation-of-me-and-my/2020.rss">Correct Formulation of ME and MY</source>
        </item>
        <item>
          <title>Pikchr Drawing Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>This is an interesting dialect-looking thing that's a Unix utility someone showed me for diagrams.  It might interest <a class="mention" href="/u/rgchris">@rgchris</a>, or others.  It's called PIKCHR.</p>
<p>You can try it online at <a href="https://pikchr.org/home/pikchrshow">https://pikchr.org/home/pikchrshow</a> ... there are a few examples.</p>
<p>It's a textual set of instructions that lets you lay things out... but differently from something like PDF, it captures intents in a pretty interesting way for aligments and duplication.</p>
<p>Look how it lays out this "swim lanes" example graphic:</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/babd46454d69ba774a09050d20d26dc3e2e9e326.png" alt="image" data-base62-sha1="qDYklKuijn94kAkO07RmNG9E6YS" width="520" height="449"></p>
<pre><code>$laneh = 0.75
# Draw the lanes
down
box width 3.5in height $laneh fill 0xacc9e3
box same fill 0xc5d8ef
box same as first box
box same as 2nd box
line from 1st box.sw+(0.2,0) up until even with 1st box.n "Alan" above aligned
line from 2nd box.sw+(0.2,0) up until even with 2nd box.n "Betty" above aligned
line from 3rd box.sw+(0.2,0) up until even with 3rd box.n "Charlie" above aligned
line from 4th box.sw+(0.2,0) up until even with 4th box.n "Darlene" above aligned
# fill in content for the Alice lane
right
A1: circle rad 0.1in at end of first line + (0.2,-0.2) fill white thickness 1.5px "1"
arrow right 50%
circle same "2"
arrow right until even with first box.e - (0.65,0.0)
ellipse "future" fit fill white height 0.2 width 0.5 thickness 1.5px
A3: circle same at A1+(0.8,-0.3) "3" fill 0xc0c0c0
arrow from A1 to last circle chop "fork!" below aligned
# content for the Betty lane
B1: circle same as A1 at A1-(0,$laneh) "1"
arrow right 50%
circle same "2"
arrow right until even with first ellipse.w
ellipse same "future"
B3: circle same at A3-(0,$laneh) "3"
arrow right 50%
circle same as A3 "4"
arrow from B1 to 2nd last circle chop
# content for the Charlie lane
C1: circle same as A1 at B1-(0,$laneh) "1"
arrow 50%
circle same "2"
arrow right 0.8in "goes" "offline"
C5: circle same as A3 "5"
arrow right until even with first ellipse.w "back online" above "pushes 5" below "pulls 3 &amp; 4" below
ellipse same "future"
# content for the Darlene lane
D1: circle same as A1 at C1-(0,$laneh) "1"
arrow 50%
circle same "2"
arrow right until even with C5.w
circle same "5"
arrow 50%
circle same as A3 "6"
arrow right until even with first ellipse.w
ellipse same "future"
D3: circle same as B3 at B3-(0,2*$laneh) "3"
arrow 50%
circle same "4"
arrow from D1 to D3 chop</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/pikchr-drawing-dialect/2018">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/pikchr-drawing-dialect/2018</link>
          <pubDate>Tue, 28 Feb 2023 22:17:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2018</guid>
          <source url="https://forum.rebol.info/t/pikchr-drawing-dialect/2018.rss">Pikchr Drawing Dialect</source>
        </item>
        <item>
          <title>Compiling ren-c with zig?</title>
          <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
          <category>Build System</category>
          <description><![CDATA[
            <p>Has anyone tried to compile ren-c with zig? ( <a href="https://www.ziglang.org">https://www.ziglang.org</a> ).</p>
<p>They claim to be able to compile c-code using zig cc , and have an impressive list of cross compilation targets, wasm among them.</p>
<p><a href="https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler">https://ziglang.org/learn/overview/#zig-is-also-a-c-compiler</a></p>
<p><a href="https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case">https://ziglang.org/learn/overview/#cross-compiling-is-a-first-class-use-case</a></p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/compiling-ren-c-with-zig/2017">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/compiling-ren-c-with-zig/2017</link>
          <pubDate>Wed, 22 Feb 2023 21:31:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2017</guid>
          <source url="https://forum.rebol.info/t/compiling-ren-c-with-zig/2017.rss">Compiling ren-c with zig?</source>
        </item>
        <item>
          <title>Kaitai Struct Declarative Language for Binary Formats</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>This is an interesting declarative language in YAML designed to generate classes for binary formats.  There are many formats defined:</p>
<p><a href="https://formats.kaitai.io/">https://formats.kaitai.io/</a></p>
<p>That's a lot of cases...but as one instructive example, you can look at how it describes a ZIP file--with little snippets of code in it for extracting the values:</p>
<p><a href="https://formats.kaitai.io/zip/" class="inline-onebox">ZIP archive file format spec for Kaitai Struct</a></p>
<p>The C++ code generated is like this:</p>
<p><a href="https://formats.kaitai.io/zip/cpp_stl_11.html" class="inline-onebox">ZIP archive file: C++11/STL parsing library</a></p>
<p>But it also can also be used to make code for C#, JavaScript, Python, Ruby, Nim, PHP, Lua, Perl... <em>(though we'd assume that if you escape code in, that part will only work be available for that language)</em></p>
<p>The regimentation of YAML provides the typical repetition in the "dialect".  This is the same as the Rebol complaint about JSON--not really leveraging "parts of speech", but repeating tags over and over like <code>id:</code> and <code>type:</code></p>
<pre><code>  - id: version
    type: u2
  - id: flags
    type: gp_flags
    size: 2
  - id: compression_method
    type: u2
    enum: compression
</code></pre>
<p>But it's still pretty hard to compete with, especially when you consider this is giving a compilable specification...so the performance is going to be much better.</p>
<p>I always thought BINARY! parse was something that Rebol would have a unique story for, and Ren-C's UPARSE makes that a stronger story (by allowing rules to synthesize arbitrary results via extraction)... but seeing this kind of stuff reminds me that there are diminishing returns.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/kaitai-struct-declarative-language-for-binary-formats/2016">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/kaitai-struct-declarative-language-for-binary-formats/2016</link>
          <pubDate>Tue, 21 Feb 2023 22:36:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2016</guid>
          <source url="https://forum.rebol.info/t/kaitai-struct-declarative-language-for-binary-formats/2016.rss">Kaitai Struct Declarative Language for Binary Formats</source>
        </item>
        <item>
          <title>Should SET-WORD!s Have &quot;Raised Error Interception&quot;?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Errors</category>
          <description><![CDATA[
            <p>Division by zero is a simple example of something that produces a "definitional error".  <em>It's considered to be "emitted" by the division</em>, and if you try to "move on" without handling it, the raised error becomes a failure that <a href="https://forum.rebol.info/t/discouraging-use-of-trap/1871">you can only catch at some top level by SYS.UTIL.RESCUE</a>.</p>
<p>For instance:</p>
<pre><code>&gt;&gt; 1 / 0, 2 + 0
** Math Error: attempt to divide by zero
** Where: / console
** Near: [1 / 0 **, 2 + ***]
</code></pre>
<p>What happened was that <strong>1 / 0</strong> evaluated, but rather than forcing a "hard failure" (e.g. running FAIL) it instead <em>returned a raised error</em>.  There's an opportunity if that raised error were to be intercepted, but in this case it just moseyed along to the next expression... so the raised error was promoted to a failure.</p>
<p>However a ^META oriented function can trap that, and react to it, allowing you to continue.  EXCEPT is such a function:</p>
<pre><code>&gt;&gt; 1 / 0 except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p>One thing that pretty obviously shouldn't count as "moving on" would be parentheses.  Adding parentheses shouldn't change the situation, they just pass any raised errors through:</p>
<pre><code>&gt;&gt; (1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2

&gt;&gt; ((((1 / 0)))) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p><strong>But what about things like SET-WORD!s?</strong>  Right now, it does not raise an error and just skips the assignment, and lets the code continue:</p>
<pre><code>&gt;&gt; num: &lt;before&gt;

&gt;&gt; (num: 1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2

&gt;&gt; num
== &lt;before&gt;
</code></pre>
<p><strong>This is a useful pattern, but if we do it for SET-WORD!s then we have to ask whether it should be done for SET the function as well...</strong></p>
<pre><code>&gt;&gt; (set 'num 1 / 0) except e -&gt; [print ["The error was" e.id]], 2 + 0
The error was zero-divide
== 2
</code></pre>
<p>If we do this then the SET function has to take its argument of the value to assign as a ^META argument.  Because raised errors can't be stored in variables, and function parameters are communicated via variables.</p>
<p>This does make SET a more complicated function, and any functions like it might also become complicated.  It's a hard decision to condemn all SET-like functions to take their arguments as ^META so they can proxy any errors and not perform the assignment.</p>
<p>I'll probably have more to say about this, but for the moment both SET and SET-WORD! react to definitional failures by <em>not performing the assignment</em> and <em>propagating the raised error</em>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-set-word-s-have-raised-error-interception/2015">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-set-word-s-have-raised-error-interception/2015</link>
          <pubDate>Tue, 07 Feb 2023 02:52:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2015</guid>
          <source url="https://forum.rebol.info/t/should-set-word-s-have-raised-error-interception/2015.rss">Should SET-WORD!s Have &quot;Raised Error Interception&quot;?</source>
        </item>
        <item>
          <title>Difficult Decision: Not Renewing (unlaunched!) Domain Names</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Community</category>
          <description><![CDATA[
            <p>A couple of years ago--at <a class="mention" href="/u/gchiu">@gchiu</a>'s urging--I had reserved a <code>.com</code>, <code>.org</code>, and <code>.net</code> for launching Ren-C to the public.</p>
<p>But in the intervening years, I put nothing on these domains.  They've been vacant lots, doing little but transferring money from me to the "Namecheap" registrar.  <img src="https://forum.rebol.info/images/emoji/twitter/angry.png?v=9" title=":angry:" class="emoji" alt=":angry:"></p>
<p>Feb 3rd was this year's renewal date, and I disabled auto-renew, and didn't pay.</p>
<h2>If I "Owned" Them, Why Didn't I Use Them?</h2>
<p>I put "owned" in quotes because you don't own domain names, you just rent them.</p>
<p>There are good reasons for not wanting to impart value to these domains prematurely--e.g. not even transferring the forum there.  My worries were:</p>
<ol>
<li>
<p>You don't get a second chance to announce a project.</p>
<ul>
<li>If you need a case study, Red has certainly worn out their welcome on hackernews.</li>
</ul>
</li>
<li>
<p>Once you start using a domain, the content becomes an issue of identity.</p>
<ul>
<li>
<p>You have imparted a value to URLs which is easily stolen by spammers.</p>
</li>
<li>
<p>You become obligated to pay recurring charges to protect your material and identity.</p>
</li>
</ul>
</li>
</ol>
<h2>Why I'm Not Renewing Them, Despite Believing in Ren-C...</h2>
<p><strong>While Ren-C is in my eyes, successful in many areas... given the (long!) timescale we are looking at... I don't think it is necessary to pay for specialized domain names for the project.</strong></p>
<p>The DNS system itself may be obsolete--and AI may be writing all the code--before I get around to finishing this myself. <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:">  Though perhaps I have helped set the goalposts.</p>
<p>I'm basically saying that I'm okay coupling the Ren-C work to the domain names I already have established, or their subdomains, rather than making a separate entity that others would manage.  Those identities (like hostilefork or metaeducation) are a sunk cost, and I can just use those.</p>
<h2>I Put Up Money For A Couple Of Years, Is Not Doing So "Giving Up"?</h2>
<p>Not really.  This is just an epicycle of my firm belief that DNS is not to be trusted any further than you can throw it.  It says more about how I feel about the domain name ecosystem than it says about how I feel about Ren-C.</p>
<p>...and if I hadn't mentioned it, you wouldn't have noticed any difference at all.  Things would seem the same.</p>
<p><em>But in my mind with the huge new design space opening up with isotopes,</em> I will admit that I'm moving closer to the idea that the final product of Ren-C is just more like "demos and papers and code golf gaming".  Not "download the solution to all your problems here".</p>
<p>After all, there are worse things than being the <a href="https://en.wikipedia.org/wiki/Antikythera_mechanism">Antikythera mechanism</a>.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p>So I'm not quitting, but I certainly am trying to do a lot more other things in my life these days.  I'll keep hacking on it as time permits, and hopefully we won't be taking too many steps backwards... and the WebAssembly stuff will remain the user-facing focus.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/difficult-decision-not-renewing-unlaunched-domain-names/2014">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/difficult-decision-not-renewing-unlaunched-domain-names/2014</link>
          <pubDate>Sat, 04 Feb 2023 17:56:24 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2014</guid>
          <source url="https://forum.rebol.info/t/difficult-decision-not-renewing-unlaunched-domain-names/2014.rss">Difficult Decision: Not Renewing (unlaunched!) Domain Names</source>
        </item>
        <item>
          <title>Future of the MATH Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>It is basically inevitable that people coming to Rebol will ask about its mathematical evaluation being left-to-right, instead of obeying the precedence order that they are used to.  Red just had a new user try to file it as a bug... 3 days ago:</p>
<p><a href="https://github.com/red/red/issues/5276">https://github.com/red/red/issues/5276</a></p>
<p><strong>What seemed to make sense to people like me and BrianH was that the core ship with a dialect called MATH.</strong>  The concept was that <strong>math [1 + 2 * 3]</strong> would give <strong>7</strong> and not <strong>9</strong>.  Having something in the box seemed better than having the first line of argument being <em>"you don't want the precedence you think you do"</em>.</p>
<p>But it turned out to be kind of hard to make pleasing.  One key difficulty which <a class="mention" href="/u/brett">@Brett</a> and I fretted over at some point was that since Rebol isn't "psychic" regarding arity, does not know a-priori how much code an expression will consume:</p>
<pre><code>math [1 + 2 * foo baz bar + 3]

; should it be...
[1 + (2 * (foo baz bar)) + 3]

; or perhaps...
[(1 + (2 * foo)) ((baz bar) + 3)]

; maybe...
[(1 + (2 * foo)) baz (bar + 3)]
</code></pre>
<p><strong>It started to appear that the user would have to put anything that wasn't a number or a math operator in groups.</strong>  There may be some heuristics which tolerate words that look up to numbers vs. functions, but it feels very slippery.</p>
<p>As I've said I hate to be dropping things, but MATH is something that Rebol programmers don't really want in the first place--and I don't think non-Rebol programmers would be satisfied by it.  If it's included in the core that suggests support for it, and there are just too many things in play.</p>
<p>Here is an implementation that was previously included, by Gabriele:</p>
<pre><code>; This MATH implementation is from Gabrielle Santilli circa 2001, found
; via http://www.rebol.org/ml-display-thread.r?m=rmlXJHS. It implements the
; much-requested (by new users) idea of * and / running before + and - in
; math expressions. Expanded to include functions.
;
math: func [
    {Process expression taking "usual" operator precedence into account.}

    expr [block!]
        {Block to evaluate}
    /only
        {Translate operators to their prefix calls, but don't execute}

    ; !!! This creation of static rules helps avoid creating those rules
    ; every time, but has the problem that the references to what should
    ; be locals are bound to statics as well (e.g. everything below which
    ; is assigned with BLANK! really should be relatively bound to the
    ; function, so that it will refer to the specific call.)  It's not
    ; technically obvious how to do that, not the least of the problem is
    ; that statics are currently a usermode feature...and injecting relative
    ; binding information into something that's not the function body itself
    ; isn't implemented.

    &lt;static&gt;

    slash (the /)

    expr-val (_)

    expr-op (_)

    expression  ([
        term (expr-val: term-val)
        opt some [
            ['+ (expr-op: 'add) | '- (expr-op: 'subtract)]
            term (expr-val: compose [(expr-op) (expr-val) (term-val)])
        ]
        &lt;end&gt;
    ])

    term-val (_)

    term-op (_)

    term ([
        pow (term-val: power-val)
        opt some [
            ['* (term-op: 'multiply) | slash (term-op: 'divide)]
            pow (term-val: compose [(term-op) (term-val) (power-val)])
        ]
    ])

    power-val (_)

    pow ([
        unary (power-val: unary-val)
        opt ['** unary (power-val: compose [power (power-val) (unary-val)])]
    ])

    unary-val (_)

    pre-uop (_)

    post-uop (_)

    unary ([
        (post-uop: pre-uop: [])
        opt ['- (pre-uop: 'negate)]
        primary
        opt ['! (post-uop: 'factorial)]
        (unary-val: compose [(post-uop) (pre-uop) (prim-val)])
    ])

    prim-val (_)

    primary ([
        set prim-val any-number!
        | set prim-val [word! | path!] (prim-val: reduce [prim-val])
            ; might be a funtion call, looking for arguments
            opt some [
                nested-expression (append prim-val take nested-expr-val)
            ]
        | ahead group! into nested-expression (prim-val: take nested-expr-val)
    ])

    p-recursion (_)

    nested-expr-val ([])

    save-vars (func [][
            p-recursion: reduce [
                :p-recursion :expr-val :expr-op :term-val :term-op :power-val :unary-val
                :pre-uop :post-uop :prim-val
            ]
        ])

    restore-vars (func [][
            set [
                p-recursion expr-val expr-op term-val term-op power-val unary-val
                pre-uop post-uop prim-val
            ] p-recursion
        ])

    nested-expression ([
            ;all of the static variables have to be saved
            (save-vars)
            expression
            (
                ; This rule can be recursively called as well,
                ; so result has to be passed via a stack
                insert nested-expr-val expr-val
                restore-vars
            )
            ; vars could be changed even it failed, so restore them and fail
            | (restore-vars) fail

    ])
][
    clear nested-expr-val
    let res: either parse3 expr expression [expr-val] [blank]

    either only [
        return res
    ][
        ret: reduce res
        all [
            1 = length of ret
            any-number? ret.1
        ] else [
            fail [
                unspaced ["Cannot be REDUCED to a number (" mold ret ")"]
                ":" mold res
            ]
        ]
        return ret.1
    ]
]</code></pre>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/future-of-the-math-dialect/2013">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/future-of-the-math-dialect/2013</link>
          <pubDate>Tue, 31 Jan 2023 19:08:42 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2013</guid>
          <source url="https://forum.rebol.info/t/future-of-the-math-dialect/2013.rss">Future of the MATH Dialect</source>
        </item>
        <item>
          <title>Should Quasiform Parameters Accept as the Plain Form?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p><strong><a href="https://forum.rebol.info/t/attack-of-the-activated-actions/1900">I'm very confident of the goodness of "isotopic actions"</a></strong>.</p>
<p>Not being able to put them in blocks gives us the <a href="https://forum.rebol.info/t/the-canonical-list-of-non-negotiables/1244/9">nice, mechanical invariant</a> of being able to manipulate blocks without inadvertently running functions in the process.  It opens the doors to other guardrails against isotopes being in variables when it might surprise you.</p>
<p>But what happens when you write something like SPECIALIZE, with a spec that looks something like:</p>
<pre><code>//
//  specialize: native [
//
//  {Create a new action through partial or full specialization of another}
//
//      return: [~action!~]  ; ~ notation since an isotopic action is returned
//      action "Function whose parameters will be set to fixed values"
//          [action!]
//      def "Definition for FRAME! fields for args and refinements"
//          [block!]
//  ]
//
</code></pre>
<p>Should SPECIALIZE tolerate being passed an isotopic action, maybe with a spec that looks like:</p>
<pre><code>return: [~action!~]
action "Function whose parameters will be set to fixed values"
    [action! ~action!~]
def "Definition for FRAME! fields for args and refinements"
    [block!]
</code></pre>
<p>This would lead to complexity inside most function, because now if it references the <strong>action</strong> variable it might run.  And this lack of automatic canonization to the inert form creates hassles for both usermode and native code alike.</p>
<p>Another thing is that the meaning of isotopic actions is potentially <em>very</em> different from that of a plain action.  For instance: <strong><code>find block :even?</code></strong> might know that since blocks cannot contain isotopes, it should interpret it as a function to call to test the items in the block for evenness.</p>
<p>So this led me to a bit of a thought...</p>
<h2>What if QUASI!-forms typechecked as the plain form?</h2>
<p>The idea is that there's an initial type check done.  If that check fails and it's a quasiform, it is tested again as its plain form.  If that passes, the plain form is received.</p>
<p>Producing a quasiform of an action from an isotope is easy, just use a meta operation.  So <strong><code>^append</code></strong> instead of <strong><code>:append</code></strong>.  All meta forms are inert, so code using the meta is less likely to do wild things.</p>
<p><em>To me, this feels like a safer exception than letting isotopes pass for plain forms.</em>  Due to their alien-ness, an isotopic form could intend something quite far from a mechanical brick in a block.  But what a quasiform has in common with a plain form is that both are inert.</p>
<p>Also, even the name "quasi" suggests a possibly loose relationship.  It carries the same payload as the plain form.  What if this were legal:</p>
<pre><code>&gt;&gt; add first [~1~] first [~2~]
== 3
</code></pre>
<p>I'm suggesting a general-enough mechanism that would work... so long as ADD didn't widen its net to taking actual ANY-VALUE! (which would indicate it had an actual meaning that applied to quasiforms).</p>
<p>This may not be the most brilliant thought to ever be thunk.  But in this more complex world there need to be succinct answers.  We don't want to have to write things like <strong><code>apply concretize :append [...]</code></strong>, and I feel like glossing over the fact that something is an isotope is a worse move than glossing over that something is a quasiform.</p>
<p>I even may like <strong><code>apply ^append [...]</code></strong> a bit more than <strong><code>apply :append [...]</code></strong> for looks, too.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012</link>
          <pubDate>Thu, 26 Jan 2023 18:42:40 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2012</guid>
          <source url="https://forum.rebol.info/t/should-quasiform-parameters-accept-as-the-plain-form/2012.rss">Should Quasiform Parameters Accept as the Plain Form?</source>
        </item>
        <item>
          <title>Axing --breakpoint switch, C-DEBUG-BREAK-AT</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Debugger</category>
          <description><![CDATA[
            <p><strong>I'm killing off features for whom their maintenance is not paying off.</strong></p>
<p>One is the "tick" based usermode <code>--breakpoint</code> feature, implemented on the command line as:</p>
<pre><code>        "--breakpoint" end (
            c-debug-break-at to-integer param-or-die "BREAKPOINT"
        )
</code></pre>
<p>The complex problem of taking a "tick" count to break on via a command line switch is that since command line processing is in usermode, you have a kind of observer-affects-the-experiment situation.  The code for adding in the breakpoint messes with the tick count you're trying to reproduce.</p>
<p>I had ideas to work around this.  So there's the /COMPENSATE feature of C-DEBUG-BREAK, which I don't even know if it works or if my idea is fundamentally flawed:</p>
<pre><code>; Taking a command-line `--breakpoint NNN` parameter is helpful if a
; problem is reproducible, and you have a tick count in hand from a
; panic(), REBSER.tick, Frame.tick, REBVAL.extra.tick, etc.  But there's
; an entanglement issue, as any otherwise-deterministic tick from a prior
; run would be thrown off by the **ticks added by the userspace parameter
; processing of the command-line for `--breakpoint`**!  :-/
;
; The /COMPENSATE option addresses this problem.  Pass it a reasonable
; upper bound for how many ticks you think could have been added to the
; parse, if `--breakpoint` was processed (even though it might not have
; been processed).  Regardless of whether the switch was present or not,
; the tick count rounds up to a reproducible value, using this method:
;
; https://math.stackexchange.com/q/2521219/
;
; At time of writing, 1000 ticks should be *way* more than enough for both
; the PARSE steps and the evaluation steps `--breakpoint` adds.  Yet some
; things could affect this, e.g. a complex userspace TRACE which was
; run during boot.
;
attempt [c-debug-break-at/compensate 1000]  ; fails in release build
</code></pre>
<p>Here was more of it:</p>
<pre><code>  #if !defined(NDEBUG) &amp;&amp; DEBUG_COUNT_TICKS
    if (REF(compensate)) {
        //
        // Imagine two runs of Rebol console initialization.  In the first,
        // the tick count is 304 when C-DEBUG-BREAK/COMPENSATE is called,
        // right after command line parsing.  Later on a panic() is hit and
        // reports tick count 1020 in the crash log.
        //
        // Wishing to pick apart the bug before it happens, the Rebol Core
        // Developer then re-runs the program with `--breakpoint=1020`, hoping
        // to break at that tick, to catch the downstream appearance of the
        // tick in the panic().  But since command-line processing is in
        // usermode, the addition of the parameter throws off the ticks!
        //
        // https://en.wikipedia.org/wiki/Observer_effect_(physics)
        //
        // Let's say that after the command line processing, it still runs
        // C-DEBUG-BREAK/COMPENSATE, this time at tick 403.  Imagine our goal
        // is to make the parameter to /COMPENSATE something that can be used
        // to conservatively guess the same value to set the tick to, and
        // that /COMPENSATE ARG(bound) that gives a maximum of how far off we
        // could possibly be from the "real" tick. (e.g. "argument processing
        // took no more than 200 additional ticks", which this is consistent
        // with...since 403-304 = 99).
        //
        // The reasoning for why the formula below works for this rounding is
        // given in this StackExchange question and answer:
        //
        // https://math.stackexchange.com/q/2521219/
        //
        Tick one = 1; // MSVC gives misguided warning for cast(Tick, 1)
        TG_tick =
            (one &lt;&lt; (ceil_log2(TG_tick) + 1))
            + VAL_INT64(ARG(tick))
            - 1;
        return nullptr;
    }
</code></pre>
<p>Also, I've never used the /RELATIVE tick feature, killing that too:</p>
<pre><code>  if (REF(relative))
      TG_break_at_tick = frame_-&gt;tick + 1 + VAL_INT64(ARG(tick));
</code></pre>
<p><strong>I'm going to be deleting a lot of things, I think, in the pursuit of simplification--now that isotopes are showing the way.</strong></p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/axing-breakpoint-switch-c-debug-break-at/2009">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/axing-breakpoint-switch-c-debug-break-at/2009</link>
          <pubDate>Tue, 24 Jan 2023 21:57:46 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2009</guid>
          <source url="https://forum.rebol.info/t/axing-breakpoint-switch-c-debug-break-at/2009.rss">Axing --breakpoint switch, C-DEBUG-BREAK-AT</source>
        </item>
        <item>
          <title>Working With Truthy BLANK!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Show &amp; Tell</category>
          <description><![CDATA[
            <p>The current re-imagining of the concept of truthy/falsey involves the idea that <em>anything you can put into a block is truthy</em>.  That includes BLANK!.</p>
<p>~null~ isotopes are falsey, and will REIFY to be <strong><code>~null~</code></strong> which can be somewhat clumsy-looking.</p>
<p>But consider some test cases for seeing how SPLIT-PATH works, looking a bit like this:</p>
<pre><code>split-path-tests:  [
    %foo                            [_ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%/ %/]
    %.                              [%./ _]
    %./                             [%./ _]
    %./.                            [%./ %./]
    &lt;...etc...&gt;
]
</code></pre>
<p>SPLIT-PATH is a multi-return routine, which gives back two values: the path and the filename.  But if one or the other is missing then that component will be null, which is useful for testing with IF (or using DEFAULT with).</p>
<p>But if we just blindly changed the tests to reify, it would become less legible:</p>
<pre><code>split-path-tests:  [
    %foo                            [~null~ %foo]
    %/c/test/test2                  [%/c/test/ %test2]
    %/c/test                        [%/c/ %test]
    %//test                         [%// %test]
    %/test                          [%/ %test]
    %//                             [%/ %/]
    %.                              [%./ ~null~]
    %./                             [%./ ~null~]
    %./.                            [%./ %./]
    &lt;...etc...&gt;
]
</code></pre>
<p>However...with blanks being truthy, this means you that you can take a variable which may be null and turn it into a blank, like this:</p>
<pre><code>reduce [any [path _] any [file _]]
</code></pre>
<p>That's rather succinct!  Probably so succinct that it doesn't need its own native to express.</p>
<p>(I thought it was neat.)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/working-with-truthy-blank/2007">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/working-with-truthy-blank/2007</link>
          <pubDate>Sat, 14 Jan 2023 15:21:04 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2007</guid>
          <source url="https://forum.rebol.info/t/working-with-truthy-blank/2007.rss">Working With Truthy BLANK!</source>
        </item>
        <item>
          <title>&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>It's no secret that I'm proud of the way the <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">design for generalized isotopes</a> is tearing through classic problems in Rebol.</p>
<p>At the same time, people's eyes can glaze over when you find yourself writing sentences like:</p>
<blockquote>
<p><em>"All quasiforms become isotopic forms when evaluated, and when going the other way through a meta operation on an isotope, you'll get a quasiform back."</em></p>
</blockquote>
<p>It all makes sense to me.  But I don't want to overlook better terms, if they exist.</p>
<h2>How Did "Isotopes" Come To Be Called That?</h2>
<p>The term isotope originated from the "decaying" behavior, where a special form of null would run a THEN branch.  But this special form would not be something you could store in a variable...it would become an ordinary null at that point.  So getting stored in a variable would cause "decay".</p>
<pre><code>&gt;&gt; null
; null

&gt;&gt; if true [null]
; null isotope

&gt;&gt; x: if true [null]
; null isotope

&gt;&gt; x
; null
</code></pre>
<p>The decay means variables captured from expressions would have a different behavior when substituted for the expressions.  That was deemed to be an acceptable cost.</p>
<pre><code>&gt;&gt; if true [print "then", null] else [print "else"]
then

&gt;&gt; temp: if true [print "then", null]
then

&gt;&gt; temp else [print "else"]
else
</code></pre>
<p>The parallel with decay of atomic isotopes seemed pretty clear, at least to me.  Many places would see it as a normal null, but a few special sites could use a "sensor" to detect the difference.  ELSE was an example of something that could detect.</p>
<p>As things moved forward, and when logic variables became ~true~ and ~false~ isotopes, it became clear these isotopic states would need to be able to stored in variables.  That meant there were "unstable isotopes" and "stable isotopes"... e.g. WORD! isotopes were stable, ERROR! isotopes were not.</p>
<p><em><strong>Having these stable isotopes actually strengthened the analogy.</strong></em>  Because some atomic isotopes are stable, while others are not.</p>
<h2>How Did "QUASI" Become Called That?</h2>
<p>Originally, things like <code>~foo~</code> were called "bad words", designed to cause errors when accessed through a variable by default.  They were like an old-school UNSET! where you could give it a custom label.  But eventually everything was generalized so that everything had an isotopic form.</p>
<p>The fact that these forms stopped conveying an error condition meant considering them "bad" wasn't sensible.  I kind of latched onto "quasi" in part because of the tilde's use in approximation, e.g. (3.0001 ~= 3).</p>
<p>(It also sounds a little like "queasy" and the squigglies look wavy and maybe a bit uncomfortable.  <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:">)</p>
<h2>So... Speak Now Or Hold Your Peace?</h2>
<p>Bad naming can have an impact.  I think calling complex numbers "imaginary" is a good example of a bad name that probably caused a few problems.</p>
<p>But I think the names here are good.  It's just going to be a matter of figuring out how to teach people to not be afraid of them.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005</link>
          <pubDate>Sun, 08 Jan 2023 21:18:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2005</guid>
          <source url="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005.rss">&quot;Quasiforms&quot;, &quot;Stable/Unstable Isotopes&quot;: Simpler Terminology?</source>
        </item>
        <item>
          <title>Websocket Support in Oldes Rebol3</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>Looking to see what Oldes has been up to, he added some kind of minimal websocket support to the HTTP scheme:</p>
<p><a href="https://github.com/Oldes/Rebol3/commit/bae6cffe97e662ec9a727a01cdcc1fdd61455ea6#diff-490ba807ac4a5ee57e7a587ca0936d36e4c0ff2798b0652fdf791e758ce079c2R718" class="inline-onebox">FEAT: Minimalistic WebSocket support in the `httpd` scheme  Oldes/Rebol3@bae6cff  GitHub</a></p>
<p>Websockets isn't something I'm looking into at this time, but I wanted to bookmark it here in case it comes up later.</p>
<p>He also updated zlib to a new version released in 2022... and <a href="https://github.com/Oldes/Rebol3/commit/15fcc00b84f6d0e386f2ba2f4fc7bdc32ebff75d">used Ren-C's %make-zlib.r to do it!</a>.  But he edited it so he'd be able to run it under his Rebol3.  It's not a huge priority to do that update, but seems like since his ported script still worked, it might not be too hard.  (And a good reminder that script exists, and should be part of a CI test...)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003</link>
          <pubDate>Fri, 06 Jan 2023 03:56:38 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2003</guid>
          <source url="https://forum.rebol.info/t/websocket-support-in-oldes-rebol3/2003.rss">Websocket Support in Oldes Rebol3</source>
        </item>
        <item>
          <title>Picking ACTION!s from BLOCK!s In The Age of Isotopes</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>In <strong><a href="https://forum.rebol.info/t/reds-design-issues-wiki/1282">Red's Design Questions wiki</a></strong>, they bring up the issue of why picking functions out of blocks runs them:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block
Evaluated.  ; d'oh
== false
</code></pre>
<p><a href="https://gitter.im/red/red?at=5c782ca0c1cab53d6f53dd6d">In the Gitter conversation</a>, Boris calls it a "shady area" that they can't get out of "under the current semantic model".  He suggests it is clear that <strong><code>block/1</code></strong> should not run an action, but possible that <strong>block/word</strong> would mean to.</p>
<p>They contemplate the idea that <strong>block/1</strong> would not run the action, but pick it:</p>
<pre><code>red&gt;&gt; block: reduce [does [print "Evaluated."]]
  == [func [][print "Evaluated."]]

red&gt;&gt; equal? block/1 first block  ; hypothetical behavior
== false
</code></pre>
<p><strong>I will argue this doesn't really help you much, the problem just becomes one step removed.</strong>  Quite often people are picking things out of blocks to put them in variables, and you'll just get bit there instead:</p>
<pre><code>red&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block/1
== func [][print "Evaluated."]

red&gt;&gt; append otherblock temp
Evaluated.  ; d'oh
== [unset]  ; double d'oh
</code></pre>
<h2>Isotopes Bring The Better Semantic Model!</h2>
<p>In Ren-C's concept (as I'm working on it), the only actions that will run from a word reference are those that are isotopic actions.  And FUNC or DOES creates an isotopic action.</p>
<p>So you would be stopped from making an illegal block up front:</p>
<pre><code>&gt;&gt; block: reduce [does [print "Evaluated."]]
** Script Error: Invalid use of ~#[action! []]~ isotope
</code></pre>
<p>You can put quasi-ACTION!s, plain ACTION!s, and quoted actions in blocks.  Just not isotopic ones.</p>
<p>Whichever you choose, the equality test will work... and picking out a value into a variable will give you an inert variable to work with, that can be used with things like append!</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; equal? block.1 first block
== ~true~  ; isotope  &lt;-- didn't run and print "Evaluated", yay!

&gt;&gt; otherblock: copy []
== []

red&gt;&gt; temp: block.1
== ~#[action! []]~

red&gt;&gt; append otherblock temp
== [~#[action! []]~]   ; &lt;-- didn't run and gave sensible block out
</code></pre>
<p>I used REIFY there and got a quasi-action.  BUT which would you rather put in the block: a quasi-action or a plain one?  This depends on what you plan to do with the block.  A plain action will execute when encountered by the evaluator, while a quasi-action will evaluate to an isotopic action--suitable for assigning via SET-WORD! when you meant to make that word dispatch the function when referenced.</p>
<p>My leaning is to say that either form can be used with APPLY, RUN, or the terminal path form:</p>
<pre><code>&gt;&gt; block: reduce [reify does [print "Evaluated."]] 
== [~#[action! []]~]

&gt;&gt; run block.1
Evaluated.

&gt;&gt; block: reduce [concretize does [print "Evaluated."]] 
== [#[action! []]]

&gt;&gt; apply block.1 []
Evaluated.
</code></pre>
<p><em>(See post on <a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">difference between REIFY and CONCRETIZE</a>, and the search for a better term...)</em></p>
<p>If you want to pick an action out of a block and put it into a variable, where it will execute from that variable, there is the RUNS transformer.  It will turn a quasi or plain ACTION! into an action isotope:</p>
<pre><code> &gt;&gt; active-var: runs block.1
 == ~#[action! {active-var} []]~  ; isotope  &lt;-- note: also cached name, neat!

 &gt;&gt; active-var
 Evaluated.
</code></pre>
<p><img src="https://forum.rebol.info/images/emoji/twitter/clap.png?v=9" title=":clap:" class="emoji only-emoji" alt=":clap:"></p>
<p>You can use UNMETA more generically to get an isotope back from any quasi-form (not just actions), or ISOTOPIC to get an isotope from a plain form.</p>
<h2>The Invariant Is What Counts, Here!</h2>
<p>The mountain that has been climbed is that we can now say that for any block, this is true:</p>
<pre><code>block2: collect [
    for-each item block1 [keep item]
]

assert [equal? block1 block2]
</code></pre>
<ul>
<li>
<p>I've just covered that there are no isotopic actions to implicitly execute; you'd get an error trying to put them in the block.</p>
</li>
<li>
<p>There are no blocks/groups/paths that will splice into the target, because splicing requires an explicit conversion to an isotope.</p>
</li>
<li>
<p>There are no "unsets" to trip on that you can find in a block, because the state conveying "unsetness" (nihil) is an isotope.</p>
</li>
</ul>
<p>Of course with objects, it's going to be a different story.  I think we'll still want some safeguards:</p>
<pre><code>for-each [key value] object [...]  ; will error when value is action

for-each [key :value] object [...]  ; will allow action isotopes as-is

for-each [key ^value] object [...]  ; will give a meta value
</code></pre>
<p>A key problem here is I'm wondering how much to cross purposes of GET-WORD! between action disarming and the other isotopic states.  But, it just takes time to work through.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002</link>
          <pubDate>Fri, 06 Jan 2023 03:16:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2002</guid>
          <source url="https://forum.rebol.info/t/picking-action-s-from-block-s-in-the-age-of-isotopes/2002.rss">Picking ACTION!s from BLOCK!s In The Age of Isotopes</source>
        </item>
        <item>
          <title>REIFY vs. META vs. SOMETHING</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>Originally I suggested that REIFY of an isotope would give its plain form, and you would META it if you wanted a quasiform:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1989">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989/1">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</a>
</div>
<blockquote>
<ul>
<li>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</li>
<li>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</li>
</ul>
</blockquote>
</aside>
<p><em>But that's not a full coverage answer.</em></p>
<ul>
<li>
<p>An operator that takes everything "one level up", where isotopes become quasiforms and everything else gets a quote level added.</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; meta true
== ~true~

&gt;&gt; meta 10
== '10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their quasiforms (and I think this probably is best called REIFY):</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; reify true
== ~true~

&gt;&gt; reify 10
== 10
</code></pre>
</li>
<li>
<p>An operator that leaves non-isotopes as they are, but turns isotopes into their plain forms:</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; something true
== true

&gt;&gt; something 10
== 10
</code></pre>
</li>
</ul>
<p>Specifically for ACTION! isotopes being turned into plain actions, I used an interim term UNRUN, but that's pretty awful.</p>
<p>Making things into isotopes is done with ISOTOPIC:</p>
<pre><code>&gt;&gt; isotopic 10
== ~10~  ; isotope
</code></pre>
<p>It could be a refinement to REIFY, like REIFY/PLAIN.  But at that point it could be two steps that might be clearer: NOQUASI REIFY, where NOQUASI would be like NOQUOTE and not complain if the thing you passed it was not a quasiform.</p>
<p>Maybe... CONCRETIZE?  That sounds like it might do a bit more work than what REIFY does :-/</p>
<pre><code>&gt;&gt; true
== ~true~  ; isotope

&gt;&gt; concretize true
== true

&gt;&gt; concretize 10
== 10
</code></pre>
<p>It's not awful.  Main thing is just to have <em>a</em> name for it while the gears turn.  But as usual, throw out suggestions if you have them...</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/reify-vs-meta-vs-something/2001</link>
          <pubDate>Thu, 05 Jan 2023 21:26:08 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2001</guid>
          <source url="https://forum.rebol.info/t/reify-vs-meta-vs-something/2001.rss">REIFY vs. META vs. SOMETHING</source>
        </item>
        <item>
          <title>Concept: Filters</title>
          <dc:creator><![CDATA[rgchris]]></dc:creator>
          <category>Development</category>
          <description><![CDATA[
            <p>Filters are a means of incrementally transcoding data from source to brokered output (bytes/binary! or characters/text!). A goal is to provide a standard API for transcoding that can be implemented and used as efficiently as possible (e.g. extracting a portion of encoded data without extracting the whole; native transcoders for Deflate). A filter could conceivably be implemented as a distinct type that has object-like properties (as the PORT! type does) and could thus be acted upon by the appropriate Rebol actors (COPY/SKIP/NEXT/TAIL, etc.).</p>
<p><em>I've alluded to a similar idea in <a href="https://forum.rebol.info/t/semantics-of-port-s-vs-streams-vs-iterators/1689/4">an earlier post</a>, however this concept is more focussed on transcoding one series of numbers/characters to another. Filters are NOT scanners/tokenizers/lexers.</em></p>
<p>A filter source can be:</p>
<ul>
<li>BINARY! or TEXT! values</li>
<li>PORT! values that stream BINARY! or TEXT! (including files/network resources)</li>
<li>filter values (i.e. filters can be layered)</li>
</ul>
<p>Examples of filter types:</p>
<ul>
<li>Retrieves binary contained within a file/network resource</li>
<li>Decodes text encoded as UTF-8, UTF-16, ISO-8859-1, CP-1252, etc. (or even unspecified using something like Chardet)</li>
<li>Decodes binary compressed per Deflate, LZW, etc.</li>
<li>Decodes binary encoded as 'text' per Base64, Ascii85, Hexadecimal, etc.</li>
<li>Decrypts binary encrypted per e.g. Rebol 2 ENCLOAK/DECLOAK (but obviously more)</li>
<li>Decodes text encoded mostly literally but with escape sequences, e.g. JSON strings, Rebol strings, XML/HTML data sequences/attribute values</li>
</ul>
<p>Filters should have at least the following capabilities:</p>
<ul>
<li>Copy all encoded data</li>
<li>Copy part of the encoded data</li>
<li>Skip part of the encoded data (Deflate could potentially iterate faster if it wasn't emitting simultaneously)</li>
</ul>
<p>Filters should possibly have the following capabilities:</p>
<ul>
<li>BACK/HEAD/negative SKIP support</li>
<li>TAKE/REMOVE/CLEAR as a means of clearing buffers</li>
</ul>
<p>Functions that consume data should support filters as a pseudo-series type, e.g.</p>
<ul>
<li>Parse</li>
<li>BINARY/READ (from Oldes/Rebol3)</li>
<li>CONSUME (from <a href="https://forum.rebol.info/t/bincode/1863">rgchris/bincode</a>)</li>
</ul>
<p>Filter values are exhausted when:</p>
<ul>
<li>An end-of-content signal/delimiter has been found e.g. self-terminating formats such as Deflate; quote marks ending a JSON string</li>
<li>A filter cap has been reached e.g. the filter has a specified length</li>
<li>An unrecoverable error occurs (e.g. invalid UTF-8 sequences in strict mode; the 'g' character in a hexadecimal stream)</li>
<li>The source has been exhausted</li>
</ul>
<p>It should be possible to recover the current source at the corresponding index within a filter value though this may require additional state info, e.g. in Deflate or Base64 where a byte within an encoding has information pertaining to more than one decoded byte</p>
<p>Filter algorithms can be native (e.g. Deflate tied to Zlib, UTF-8) or in user-mode (thus extensible).</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/concept-filters/2000">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/concept-filters/2000</link>
          <pubDate>Thu, 05 Jan 2023 03:49:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2000</guid>
          <source url="https://forum.rebol.info/t/concept-filters/2000.rss">Concept: Filters</source>
        </item>
        <item>
          <title>Rebolbot future</title>
          <dc:creator><![CDATA[johnk]]></dc:creator>
          <category>Community</category>
          <description><![CDATA[
            <p>Hi guys<br>
I think it is time to turn off the old rebolbot server as I have not been using it for a while. <a class="mention" href="/u/rgchris">@rgchris</a> may still have a few things running on it, so this is a heads up that I plan to turn it off in the next month or so.<br>
All the best,<br>
John</p>
            <p><small>5 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rebolbot-future/1999">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rebolbot-future/1999</link>
          <pubDate>Thu, 29 Dec 2022 07:31:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1999</guid>
          <source url="https://forum.rebol.info/t/rebolbot-future/1999.rss">Rebolbot future</source>
        </item>
        <item>
          <title>SPLIT Semantics</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p><a href="https://gitter.im/red/red?at=63523097f00b697fec501c7a">On Red Gitter</a>, it was discussed "which of the following is 'correct'":</p>
<pre><code>Red&gt; split "" ","
== [""]

R3&gt; split "" ","
== []
</code></pre>
<p>Rebolek thinks R3 is right.  Boris says:</p>
<blockquote>
<p>I don't think there's a correct answer, just choices. I prefer the Red version because:<br>
it strictly follows the rule: `number-of-segments = 1 + number-of-delimiters", no exceptions, so it's easier to reason about</p>
<p>it should be able thus to preserve the type in case one wants to rejoin it later (that it doesn't is a bug, try split %"" ",")</p>
</blockquote>
<p>So there's a couple of ways to look at it.</p>
<p>But I have a philosophy about these things where I want edge cases to be "noisy", because usually they require special handling.  I might even say:</p>
<pre><code>&gt;&gt; split "" ","
== ~null~  ; isotope</code></pre>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/split-semantics/1998">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/split-semantics/1998</link>
          <pubDate>Thu, 22 Dec 2022 04:04:52 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1998</guid>
          <source url="https://forum.rebol.info/t/split-semantics/1998.rss">SPLIT Semantics</source>
        </item>
        <item>
          <title>ChatGPT Speaking About Rebol</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>So ChatGPT actually knows a bit about Rebol (at least Rebol2)</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" data-download-href="https://forum.rebol.info/uploads/default/7b940f01f3801b53d0a1d4d412074bda30517443" title="image"><img src="https://forum.rebol.info/uploads/default/original/1X/7b940f01f3801b53d0a1d4d412074bda30517443.png" alt="image" data-base62-sha1="hDdWsU3sEBthVlysVvcHRLWmfWH" width="356" height="500" data-small-upload="https://forum.rebol.info/uploads/default/optimized/1X/7b940f01f3801b53d0a1d4d412074bda30517443_2_10x10.png"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use xlink:href="#far-image"></use></svg><span class="filename">image</span><span class="informations">634890 25 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use xlink:href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>This does raise some questions about the future of software, in general.  It's possible that AI models will plateau and maybe they'll never get too much better than this...</p>
<p>...but I don't think so.  I imagine year-over-year, we're going to see them learning.  I don't know exactly when they'd be able to come up with ideas like what I've been doing for Ren-C.</p>
<p>But something I did think about is that if they can write code, then giving them a super-expressive medium in which to do it could be very powerful.  If they can come up with the dialect and then use it, then they might be able to write concise programs that wind up being quite legible...whereas other languages might make them trade off length for clarity.</p>
<p>If you ask ChatGPT an interesting Rebol question, feel free to put it in this thread.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997</link>
          <pubDate>Sat, 17 Dec 2022 15:53:35 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1997</guid>
          <source url="https://forum.rebol.info/t/chatgpt-speaking-about-rebol/1997.rss">ChatGPT Speaking About Rebol</source>
        </item>
        <item>
          <title>Should Isotopes Be Legal in MAP! (Keys, Values?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>In the pre-isotopic era, there was a concept that MAP! would not allow you to store nulls.  Because null was the signal of not being in a map.  Assigning a key null was a way of removing items from that map.</p>
<pre><code>&gt;&gt; m: make map! [x 20]
== make map! [
    x 20
]

&gt;&gt; m.x
== 20

&gt;&gt; m.y
; null

&gt;&gt; m.x: null
; null

&gt;&gt; m
== make map! [
]
</code></pre>
<p>Additionally, NULL was not allowed as a key.</p>
<h2>How Should This Change In The Isotopic Era?</h2>
<p>I'll make the point that not allowing you to store isotopes as keys or values isn't a fundamental problem, because you can META a value to put it in, and then UNMETA it when taking it out.</p>
<p>You wind up with a fundamental issue that actions from a MAP! won't be run implicitly this way, and you can't put any falsey values in a map this way (because false is the ~false~ word isotope, and ~null~ isotopes are representations of not being in the map).</p>
<p>But that limitation can be a benefit.  I already think of it as a benefit that you cannot run an action by doing access of items out of a block.  e.g. <strong>block.1</strong> could never run a function now (since blocks can't store isotopic actions).  If that was true of <strong>map.key</strong> as well, that could be seen as a good thing... you'd have to APPLY or RUN a plain ACTION! (or QUASI-ACTION!).</p>
<pre><code>&gt;&gt; m: make map! []

&gt;&gt; m.1: :append
** Error: Cannot put ACTION! isotope in map

&gt;&gt; m.1: ^append
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; m.1
== ~#[action! {append} [series value /part /dup /line]]~

&gt;&gt; run m.1 [a b c] [d e]
== [a b c [d e]]

&gt;&gt; apply m.1 [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]

&gt;&gt; m.1/ [[a b c] [d e] /dup 2]
== [a b c [d e] [d e]
</code></pre>
<p>As with the peace of mind using BLOCK!, that seems like a good thing to me.</p>
<p><em>(I'm not entirely sure if RUN should allow QUASI-ACTION!s, or if you should have to UNQUASI it into a plain ACTION!.  Forcing the canonization might make more sane, so that routines that want to exchange actions as currency would have one standard they spoke.)</em></p>
<p>I also think it's likely a good thing that false isotopes wouldn't be in the map, only quasi-false and the word false.  So if you're putting logic into a map, you'd wind up writing <strong><code>if map.key = 'true [...]</code></strong> or <strong><code>if map.key = 'false [...]</code></strong> and save the <strong>if map.key</strong> and <strong>if not map.key</strong> for testing things being in the map.</p>
<h2>This Would Widen The Gap With Objects</h2>
<p>There have been questions about what the difference is between maps and objects, and this would be another: objects must be able to have members that are isotopes: action isotopes that can run implicitly, logic and null and other word isotopes, and I'm presuming splices and other stable forms as well.</p>
<p>It would mean a map has more in common with a block.</p>
<p>This doesn't strike me as being that much of a problem.</p>
<p><strong>So I'm going to be going ahead with the premise that isotopes can't be stored in maps, as either keys or values.</strong>  We'll see how it goes, but I think this is the right answer.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995</link>
          <pubDate>Fri, 02 Dec 2022 09:28:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1995</guid>
          <source url="https://forum.rebol.info/t/should-isotopes-be-legal-in-map-keys-values/1995.rss">Should Isotopes Be Legal in MAP! (Keys, Values?)</source>
        </item>
        <item>
          <title>Head-to-Head Battle of the Coding Fonts</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>So I don't think this did the best job of representing Inconsolata (the choice for the ReplPad), but it lets you pit monospace fonts against each other to find the one you like:</p>
<p><a href="https://www.codingfont.com/">https://www.codingfont.com/</a></p>
<p>I still think if the right weight of Inconsolata is chosen it's the best.</p>
<p><a href="https://fonts.google.com/specimen/Inconsolata?preview.text=0O1Iil&amp;preview.text_type=custom#styles" class="inline-onebox">Google Fonts: Inconsolata</a></p>
<p>For me, the competition would be Source Code Pro or Fira Code.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/head-to-head-battle-of-the-coding-fonts/1994">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/head-to-head-battle-of-the-coding-fonts/1994</link>
          <pubDate>Thu, 01 Dec 2022 14:43:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1994</guid>
          <source url="https://forum.rebol.info/t/head-to-head-battle-of-the-coding-fonts/1994.rss">Head-to-Head Battle of the Coding Fonts</source>
        </item>
        <item>
          <title>Python Speedup Proposals</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>The original "CPython" implementation is in some ways similar to Rebol/Red... though these days Ren-C is more aligned with the stackless Python implementation...which is also written in C, but distinct from CPython.</p>
<p><em>(But Ren-C's design overall is a lot less comparable to anything, due to the number of very "alien" ideas in it, but that I think are what gives it more notable properties.)</em></p>
<p>In any case, despite running an interpreter loop and doing kind-of-what-Rebol-does, they've committed themselves to doing some speedup proposals and apparently it's paying off:</p>
<p><a href="https://devblogs.microsoft.com/python/python-311-faster-cpython-team/" class="inline-onebox">A Team at Microsoft is Helping Make Python Faster - Python</a></p>
<p>Some of their proposals involve JIT-compiling things (which they know won't work on restrictive platforms like iOS).  But they apparently have done a lot of tweaks besides that which have turned out beneficial.  Because it's a C interpreter there might be something applicable to be learned by looking at their "Stage 1" and "Stage 2" changes.</p>
<blockquote>
<h3>Stage 1 -- Python 3.10</h3>
<p>The key improvement for 3.10 will be an adaptive, specializing interpreter. The interpreter will adapt to types and values during execution, exploiting type stability in the program, without needing runtime code generation.</p>
<h3>Stage 2 -- Python 3.11</h3>
<p>This stage will make many improvements to the runtime and key objects. Stage two will be characterized by lots of "tweaks", rather than any "headline" improvement. The planned improvements include:</p>
<ul>
<li>Improved performance for integers of less than one machine word.</li>
<li>Improved peformance for binary operators.</li>
<li>Faster calls and returns, through better handling of frames.</li>
<li>Better object memory layout and reduced memory management overhead.</li>
<li>Zero overhead exception handling.</li>
<li>Further enhancements to the interpreter</li>
<li>Other small enhancements.</li>
</ul>
<h3>Stage 3 -- Python 3.12 (requires runtime code generation)</h3>
<p>Simple "JIT" compiler for small regions. Compile small regions of specialized code, using a relatively simple, fast compiler.</p>
<h3>Stage 4 -- Python 3.13 (requires runtime code generation)</h3>
<p>Extend regions for compilation. Enhance compiler to generate superior machine code.</p>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/python-speedup-proposals/1992">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/python-speedup-proposals/1992</link>
          <pubDate>Sun, 27 Nov 2022 10:05:19 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1992</guid>
          <source url="https://forum.rebol.info/t/python-speedup-proposals/1992.rss">Python Speedup Proposals</source>
        </item>
        <item>
          <title>Should ELSE be FALSE-reactive? (in addition to void and null?)</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Semantics</category>
          <description><![CDATA[
            <p>Historically one might have asked why ELSE doesn't think falseness is something worth reacting to:</p>
<pre><code>&gt;&gt; 1 = 2 else [print "Why not print?"]
Why not print?  ; seems not so bad, right?
</code></pre>
<p>The idea was panned, because <code>#[false]</code> was <em>a value</em> and ELSE's main job was to react to the situation of a branching construct that didn't produce a value:</p>
<pre><code>&gt;&gt; math-broken: if 1 = 1 [false] else [true]
== #[false]  ; if this were #[true], math seems broken
</code></pre>
<p>But now, the actual falsey <code>~false~</code> state is isotopic.  And some years of struggle with the parallel problem of what to do with branches that returned "non-values" bore curious fruit: a box that could hold a "non-value" like a null.</p>
<pre><code>&gt;&gt; if false [null]
== ~null~  ; isotope
     ^-- there is no result

&gt;&gt; if true [null]
== ~[~null~]~  ; isotope
     ^-- there is a result and it is null
</code></pre>
<p>Isotopic blocks containing one element will decay to that one element in most situations.  But ELSE is sensitive to the difference via a ^META parameter.  If someone has gone through the effort to box up a null or void vs leave it as a plain isotope, the ELSE assumes it's a meaningful result and should pass it on.  And conditional expressions know to do this; they box up nulls and voids if they are produced by executing branches.</p>
<p><strong>The same technique could work for false.</strong></p>
<pre><code>&gt;&gt; if 1 = 1 [false]
== ~[~false~]~  ; isotope

&gt;&gt; if 1 = 1 [false] else [true]
== ~[~false~]~  ; isotope

&gt;&gt; math-broken: if 1 = 1 [false] else [true]
== ~false~  ; isotope
</code></pre>
<p>It's barely any additional work for conditionals to do on top of what they're doing already.  Although it can result in branches producing false to cost a small bit more than they do today <em>(I wouldn't worry about it, these single element boxes could be optimized if it was a problem)</em></p>
<p>But I don't know how useful it would actually be.  <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=9" title=":man_shrugging:" class="emoji" alt=":man_shrugging:">  Just writing down the observation.</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991</link>
          <pubDate>Sun, 27 Nov 2022 06:00:32 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1991</guid>
          <source url="https://forum.rebol.info/t/should-else-be-false-reactive-in-addition-to-void-and-null/1991.rss">Should ELSE be FALSE-reactive? (in addition to void and null?)</source>
        </item>
        <item>
          <title>~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>The concept of having isotopic <strong>~true~</strong> and <strong>~false~</strong> as WORD! isotopes instead of having a distinct LOGIC! type is admittedly somewhat weird.  It means they can't be put in blocks and need some sort of transformation if they're going to be put into blocks.</p>
<ul>
<li>
<p>The generic and reversible way to make them real it is to META them and get <code>~true~</code> and <code>~false~</code> quasiforms, which you can UNMETA back to the isotopes</p>
</li>
<li>
<p>The readable way to make them real is to REIFY them and get <code>true</code> and <code>false</code> as plain WORD!, which only gets turned back into the isotope form if they are bound to variables that hold the isotopes, and you evaluate them.</p>
</li>
<li>
<p>Your circumstance may mean that neither of those choices are what you want when in a situation where the isotopes can't work...maybe it means you have to rethink what you're doing, or maybe you want some other transformation.  It's good to be alerted to the fact that it's dodgy to put what you think of as a "logic" in a reified context.</p>
</li>
</ul>
<p>One should note that Lisp has no false at all, only NIL for false (since everything else is truthy, you could use anything else for true, but they have T predefined).  But their NIL isn't isotopic--so it can appear in lists literally.</p>
<p>And as I've repeatedly pointed out, Redbol's historical choice to render LOGIC! conflated with the words <code>true</code> and <code>false</code> (instead of <code>#[true]</code> and <code>#[false]</code>) shows a desire to avoid the logic literals "escaping" into the reified consciousness of the user.  Making the logic forms actually impossible to put into blocks without a conscious transformation feels like it's good.</p>
<p>I know it's a strange choice, but it's seeming like it fits with the territory.  It's a sort of tradeoff you need when you choose to be firm that TRUE and FALSE are redefinable words and not lexical forms of logic constants.</p>
<h2>So... Why Shouldn't NULL Be Done With <code>~null~</code> isotope ?</h2>
<p>Right now what I call "null" is isotopic BLANK!.  It is not pretty looking:</p>
<pre><code>&gt;&gt; null
== ~_~  ; isotope

&gt;&gt; _
== ~_~  ; isotope
</code></pre>
<p>But what <em>is</em> pretty looking is that if you assign a bunch of variables to null, the fact that blanks evaluate to the null isotope gives a great visibility to where the actual values to pay attention to are:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>If we used a word isotope, then at source level we're writing:</p>
<pre><code>obj: make object! [
    alpha: null
    beta: null
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: null
    omega: 'now
 ]
</code></pre>
<p>And if we view it after evaluation that fetches (<code>null</code> =&gt; <code>~null~  ; isotope</code>), it gets uglier:</p>
<pre><code>make object! [
    alpha: ~null~
    beta: ~null~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~null~
    omega: 'now
 ]
</code></pre>
<p>We can't show it as the WORD! null because there's no guarantee that word always will evaluate back to the null isotope.  But the concept is that since BLANK! can't be redefined, we can put it in an evaluative context as a substitute for <code>~_~</code> if we want.</p>
<p>If we were "more honest" and just META'd the isotopic blank, we'd get renders like:</p>
<pre><code>make object! [
    alpha: ~_~
    beta: ~_~
    delta: ~true~
    epsilon: ~
    gamma: "nutty"
    rho: ~_~
    omega: 'now
 ]
</code></pre>
<p>But I might actually like that less than seeing <strong><code>~null~</code></strong> there.</p>
<h2>Things To Weigh In This Consideration</h2>
<p>I'm really torn.  Certainly having people be able to see ~null~ written out as a word corresponds to what we want to refer to the state as.  We aren't going to replace people's vernacular to say "isotopic blank" instead of null.  And trying to teach people "isotopic blank is null" is an uphill battle.</p>
<p>Let's look back at that seemingly beautiful situation with all the blanks-to-nulls at source level:</p>
<pre><code>obj: make object! [
    alpha: _
    beta: _
    delta: true
    epsilon: ~
    gamma: "nutty"
    rho: _
    omega: 'now
 ]
</code></pre>
<p>But, hmmm.  The <strong><code>~</code></strong> is now an assignable state meaning variable is not set.  How often will you want to set something to NULL...which won't generate an error on access like being unset would, but is falsey and can't be passed to many routines without a MAYBE?</p>
<p><strong>Statistically, we might often have a situation where NULL is the minority initialization, more like this:</strong></p>
<pre><code>obj: make object! [
    alpha: ~
    beta: ~
    delta: true
    epsilon: null
    gamma: "nutty"
    rho: ~
    omega: 'now
 ]
</code></pre>
<p>My point is that intentionally initializing things to null may not be as common as setting to an error-provoking unset state.  And when null happens it may be just as noteworthy to call out as setting something to true or false.</p>
<h2>Are There Technical Barriers To This?</h2>
<p>It has some of the same problems as having to deal with the type checking of LOGIC! actually being an isotopic subclass of two words.  It means <code>&lt;opt&gt;</code> is an isotopic subclass of one word, so there's no specific null datatype.  :-/</p>
<p>I was already saying that TYPE OF NULL was probably an error, and TYPE OF MAYBE NULL would be void... anyway, this fits into some of the same type issues that logic has.</p>
<p>Previously NULL cells held nothing, so I'd put a payload of the file and line that were in effect in the evaluator.  This was supposed to give better errors about where a null originated from.  This could still be done if NULL was a special case of WORD! isotope that said it was null via a flag vs. storing the symbol, but could be complicated.  None of the better error mechanics were done yet.</p>
<p><strong>My general intuition is that from a user's standpoint, it's an uphill battle to teach them isotopic blank is something called "null"... and that the majority of technical problems that are involved in making NULL be a word isotope are problems that have to be tackled anyway with true and false as word isotopes.</strong></p>
<p>Additionally, I've written about my desire for BLANK!s to serve in dialects as spaces.  That gets very screwed by the (<strong><code>_</code></strong> =&gt; <strong><code>~_~</code>  ; isotope</strong>) evaluation.  Recovering blank for space intent would be good.</p>
<p>I'm going to likely give it a shot, when I get some programming time again, hopefully soon.</p>
            <p><small>4 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989</link>
          <pubDate>Tue, 25 Oct 2022 04:07:17 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1989</guid>
          <source url="https://forum.rebol.info/t/null-word-isotope-vs-blank-isotope-meaning-null/1989.rss">~null~ WORD! isotope vs. BLANK! isotope ~_~ meaning null</source>
        </item>
        <item>
          <title>Happy 2023, and 2022 General Status &amp; Reflection</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Announcements</category>
          <description><![CDATA[
            <h1>Happy New Year!</h1>
<p><img src="https://forum.rebol.info/images/emoji/twitter/champagne.png?v=9" title=":champagne:" class="emoji only-emoji" alt=":champagne:"> <img src="https://forum.rebol.info/images/emoji/twitter/partying_face.png?v=9" title=":partying_face:" class="emoji only-emoji" alt=":partying_face:"></p>
<blockquote>
<p>Note: This was originally an October 2022 status report, but I didn't do anything in November or December, so I'm really just going to add a bit to it...</p>
</blockquote>
<p><em>Having hit up against some pretty deep questions about redesigning datatypes in October, I've been taking a break.</em>  It's good to clear one's head sometimes. I packed up and moved, and there was a lot to do for that.</p>
<p>I've been poking around some other languages and tools... tinkering with things like the Rust compiler sources... looking at Stable Diffusion and what sorts of trends are on the rise in open-source AI.  Reading a lot of articles and watching YouTube Videos.</p>
<p>Hopefully some of the datatype-related ideas will settle in my head and I'll be able to start making progress on those.  But I thought I'd review some of what's gone on the last months.</p>
<ul>
<li>
<p>It's certainly worth pointing out that the <a href="https://forum.rebol.info/t/stackless-is-here-today-now/1844">system is using "stackless" processing</a>... which is a significant change, that from a practical standpoint has let us get rid of costly workarounds needed for browser interop in the web build.</p>
</li>
<li>
<p>Changes were made to <a href="https://forum.rebol.info/t/ren-c-is-now-on-the-clouds-with-wasi/1854">permit executing in WASI runtimes</a>, enabling a new cross-platform target as well as being used in "serverless" cloud computing scenarios.</p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/visual-parse-on-the-web-has-arrived/1837">Integrating a rich editor and tabbed interface to the web REPL</a> is a big cool thing.</p>
</li>
</ul>
<p>I could go on about every little thing (like updating the crypto, or that web tests now <a href="https://forum.rebol.info/t/js-testing-with-cypress-io/1778">run on cypress.io</a>) but there are posts and git commits for that.</p>
<p>Nearly every other major change worth discussing involves big changes surrounding isotopes.</p>
<h2>Generalized Isotopes Have Changed (Almost) Everything</h2>
<p>From the beginning, Ren-C's goal has been to attack the fundamental weaknesses in how Rebol works as a language.</p>
<p>Integral to attacks on several major problems has been the idea of <em>"generalized isotopes"</em>.  If anyone hasn't had a chance to read the thread describing the rationale, I suggest doing so now (or re-reading it):</p>
<p><strong><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">"A Justification of Generalized Isotopes"</a></strong></p>
<p>This development kind of touches everything in the system:</p>
<ul>
<li>
<p><strong><a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607">It strikes at the heart of the /ONLY issue</a></strong>.  When you see it used with something like REPLACE, you can really have that "A Ha" moment... that splicing intent should never have been carried by a refinement</p>
<pre><code>&gt;&gt; replace/all [[a b] a b a b] [a b] [c d e]
== [[c d e] a b a b] 

&gt;&gt; replace/all [[a b] a b a b] spread [a b] [c d e]
== [[a b] [c d e] [c d e]]

&gt;&gt; replace/all [[a b] a b a b] [a b] spread [c d e]
== [c d e a b a b]

&gt;&gt; replace/all [[a b] a b a b] spread [a b] spread [c d e]
== [[a b] c d e c d e]
</code></pre>
</li>
<li>
<p><strong><a href="https://forum.rebol.info/t/fail-vs-return-raise-the-new-age-of-definitional-failures/1852">"Definitional Errors" have arisen</a></strong> as a crucial combination of solutions: one of the earliest Ren-C mechanics (definitional returns) mixes with a new idea (error isotopes), to give an actual viable answer for error handling in the system:</p>
<pre><code>&gt;&gt; attempt [print "Attempting to read file" read %nonexistent-file.txt]
Attempting to read file
; null

&gt;&gt; attempt [print "Attempting but made typos" rread %nonexistent-file.txt]
Attempting but made typos
** Script Error: rread word is attached to a context, but unassigned
** Near: [rread ** %nonexistent-file.txt]
</code></pre>
</li>
<li>
<p>Moving away from a dedicated "LOGIC!" datatype to <strong><a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">~true~ and ~false~ isotopes</a></strong> solves a "top-of-the-page" representational issue... giving an in-between state that can be held in a variable, but must undergo some reification process before being carried in an array:</p>
<pre><code>&gt;&gt; 1 = 2
== ~false~  ; isotope

&gt;&gt; append [a b c] 1 = 2
** Error: Arrays cannot hold ~false~ isotopes, must REIFY or META

&gt;&gt; append [a b c] meta 1 = 2
== [a b c ~false~]

&gt;&gt; append [a b c] reify 1 = 2
== [a b c false]
</code></pre>
</li>
<li>
<p>Treatment of <strong><a href="https://forum.rebol.info/t/thought-reimplementing-multi-return-via-isotopic-block/1955">BLOCK! isotopes as "packs"</a></strong> gives answers to how to pipe and transform multi-return expressions... and has also been leveraged as a way to tell the difference between "true null" (e.g. should trigger an else) and "packaged null" (a null packed into a block that is "a positive result that just happens to be null").</p>
</li>
<li>
<p>It has reshaped "voidness"--as something <strong><a href="https://forum.rebol.info/t/non-interstitial-invisibles-more-trouble-than-theyre-worth/1582">which only vanishes in interstitial slots</a></strong>, and can be manipulated conveniently in its isotopic form.</p>
<ul>
<li>Being able to pass voids as arguments enables fully functional compositions, <a href="https://forum.rebol.info/t/demonstrating-for-both-loop-composability-for-the-win/1833">like the infamous FOR-BOTH case</a> of writing a loop wrapper that preserves the loop behavior invariants.</li>
</ul>
</li>
<li>
<p>Isotopes are also covering things like being able to tell the difference between <strong><a href="https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881/2">passing an ACTION! you want to run and an ACTION! you want to look for literally</a></strong> (by its identity)</p>
</li>
</ul>
<p>In some sense, this "discovery" has pushed a big reset button on the project... because it affects so many things.  Nearly everything has to be revisited.  But the biggest issue is with the type system.</p>
<h2>Isotopes Further Stress Weaknesses Of DATATYPE! / TYPESET!</h2>
<p>Rebol and all of its clones deal with datatypes in the exact same simplistic way, limiting it to 64 datatypes... with a TYPESET! being a 64-bit number with one bit for each type.</p>
<p>Perhaps there are those out there who think this is fine.  They may see it as like the <a href="https://www.danielsen.com/jokes/objecttoaster.txt">engineer and the toaster story</a>... where making a toaster with very few settings is virtuous, and it's unnecessary complexity to have any more complicated type system.</p>
<p>I've laid out some of my beliefs...such as that "kinds" of values (in a coarse sense) are at the very least based on WORD!, so you can add new things like <strong><code>vector</code></strong> and <strong><code>matrix</code></strong> and <strong><code>image</code></strong>...none of which I believe should be mandatory to build into the core...so lighter builds can be made.</p>
<p>Beyond that I have suggested that getting a full "type" description could be a more descriptive structure, telling you not only that something is a matrix but also giving you its dimensions.</p>
<p>The more these kinds of thoughts seem true, it makes TYPESET! seem like a bogus kind of thing... and type checking functions might make more sense.  Why not something like:</p>
<pre><code>foo: func [bar [integer! series? even?]] [...]
</code></pre>
<p>Performance aside, trading off typesets has some dangerous implications...such as what if a function gets specialized with a value that passes, but either the function or something about the value changes so it wouldn't pass?  As it happens, today's specialized values are written in the place where type information for a parameter would usually be--so you can't typecheck after the fact.</p>
<p>With so many aspects of isotopes working out, it's unfortunate that the terrible type system is getting in the way.  A dissatisfying answer would be just to say that all isotopes report that they are ISOTOPE! and you have to perform operations on them to find out the actual type... but this is what you historically have to do with items in BLOCK! (you can't typecheck for "block that contains one integer!" vs. "block that contains two strings").</p>
<p>Anyway: this is a longstanding problem area, that isotopes are now making it more imperative to solve.</p>
<h2>Still...There Are A Lot Of New And Interesting Things</h2>
<p>The biggest takeaway here is that isotopes have added new dimensions that are letting Ren-C bring really advanced capabilities within reach of very novice users.</p>
<p>There are many examples, but some of the most amazing to me are things like hooking the default UPARSE combinators--which have multiple return values--by being able to turn those return values into blocks and transform them.</p>
<p>So I'm still "finding the cool" in new behaviors, so that's motivating.  But maybe with the basics sorted out, it's getting closer to time to start ripping out some unnecessary parts, so that a committed subset can be pushed out to people on the web.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/happy-2023-and-2022-general-status-reflection/1988">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/happy-2023-and-2022-general-status-reflection/1988</link>
          <pubDate>Sun, 16 Oct 2022 04:56:58 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-1988</guid>
          <source url="https://forum.rebol.info/t/happy-2023-and-2022-general-status-reflection/1988.rss">Happy 2023, and 2022 General Status &amp; Reflection</source>
        </item>
  </channel>
</rss>

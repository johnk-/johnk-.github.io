<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:discourse="http://www.discourse.org/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>AltRebol - Latest topics</title>
    <link>https://forum.rebol.info/latest</link>
    <description>Latest topics</description>
    
      <lastBuildDate>Sun, 25 Feb 2024 12:53:56 +0000</lastBuildDate>
      <atom:link href="https://forum.rebol.info/latest.rss" rel="self" type="application/rss+xml" />
        <item>
          <title>Raku (Perl 6) Type System</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="19" data-topic="2151">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/19">Ugly Types: Less Ugly Than History, Can We Do Better?</a>
</div>
<blockquote>
<p>That’s why I think it’s a good idea to keep TYPE OF a direct reflection of the heart-byte, and use other constructions for code which needs other things.</p>
</blockquote>
</aside>
<p>I’ve just discovered a bit of prior art for this, in the form of Raku (i.e., the language formerly known as Perl 6). Its equivalent to TYPE OF, namely <a href="https://docs.raku.org/language/mop#WHAT">WHAT</a>, returns only the ‘type object’ of which the value is an instance. By contrast, type matching (and pattern matching) is done using <a href="https://docs.raku.org/type/Mu#method_ACCEPTS">ACCEPTS</a> with a <a href="https://docs.raku.org/language/signatures">signature literal</a>, which is a much more flexible syntax allowing all kinds of constraints to be expressed.</p>
<p>Actually, now that I think of it, Raku signature literals strike me as quite a nice approach. For Ren-C, they suggest the idea of having a ‘type-matching dialect’… though, then again, I guess that’s something I <a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151/2">already suggested above</a>.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/raku-perl-6-type-system/2156">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/raku-perl-6-type-system/2156</link>
          <pubDate>Sun, 25 Feb 2024 12:53:56 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2156</guid>
          <source url="https://forum.rebol.info/t/raku-perl-6-type-system/2156.rss">Raku (Perl 6) Type System</source>
        </item>
        <item>
          <title>About the Math category</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Math</category>
          <description><![CDATA[
            <p>Rebol languages aren't a particularly great choice for math.</p>
<ul>
<li>
<p>Operator precedence follows the left-to-right nature of the evaluator, not the precedence many would expect:</p>
<pre><code>&gt;&gt; 1 + 2 * 3
== 9
</code></pre>
</li>
<li>
<p>Its syntax focus on words-separated-by-spaces, so this expands out expressions:</p>
<pre><code>&gt;&gt; length of [x+y*z]
== 1

&gt;&gt; type of first [x+y*z]
== &amp;[word]
</code></pre>
</li>
<li>
<p>The language is interpreted, meaning that even the simplest operation like <strong>add 1 2</strong> will run thousands of times slower than a compiled instruction.</p>
</li>
</ul>
<hr>
<p>But all programming involves math every now and again.  So this category is for discussing any math issues people want to talk about.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/about-the-math-category/2155">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/about-the-math-category/2155</link>
          <pubDate>Tue, 20 Feb 2024 23:27:47 +0000</pubDate>
          <discourse:topicPinned>Yes</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2155</guid>
          <source url="https://forum.rebol.info/t/about-the-math-category/2155.rss">About the Math category</source>
        </item>
        <item>
          <title>What is the use of typesets?</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Recent discussions have brought the notion of ‘typesets’ to my attention. On reading the source code, this confused me a bit… they don’t seem to be used all that much. Moreover, they seem to be subsumed by the idea of optimised constraint functions.</p>
<p>So I set out to try them myself. Only to find myself thoroughly confused, because typesets don’t actually seem to be accessible from Ren-C itself. Or, at least, none seem to be defined — normal type names evaluate to TYPE-BLOCK!s as expected, but typeset names are unassigned:</p>
<pre><code class="lang-plaintext">&gt;&gt; word!
== &amp;[word]

&gt;&gt; text!
== &amp;[text]

&gt;&gt; any-utf8!
** Script Error: any-utf8! word is attached to a context, but unassigned
** Where: console
** Near: [any-utf8! **]
** Line: 1

&gt;&gt; any-type-value!
** Script Error: any-type-value! word is attached to a context, but unassigned
** Where: console
** Near: [any-type-value! **]
** Line: 1
</code></pre>
<p>[On which note, incidentally, let me yet again mention my conviction that the other TYPE-* datatypes are useless and should be removed.]</p>
<p>I expected to at least be able to use them in function signatures, but I can’t even do that, since it crashes a program:</p>
<pre><code class="lang-plaintext">&gt;&gt; test: func [x [word!]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8?]] [return x]
== ~#[frame! {test} [x]]~  ; anti

&gt;&gt; test: func [x [any-utf8!]] [return x]
Assertion failure: QUOTE_BYTE(v) == ANTIFORM_0
Line 165, File: /home/bradrn/Documents/red/ren-c/src/include/cells/cell-quoted.h
Trace/breakpoint trap (core dumped)
</code></pre>
<p>So… if they can’t be accessed from Ren-C itself, then why does the interpreter have typesets at all?</p>
            <p><small>8 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/what-is-the-use-of-typesets/2153">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-is-the-use-of-typesets/2153</link>
          <pubDate>Tue, 20 Feb 2024 04:29:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2153</guid>
          <source url="https://forum.rebol.info/t/what-is-the-use-of-typesets/2153.rss">What is the use of typesets?</source>
        </item>
        <item>
          <title>Dropping the ANY-XXX! from (Some) Type Constraints?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Naming</category>
          <description><![CDATA[
            <p>There was a slightly confusing aspect of historical Rebol where some typesets were named so that they looked just like a datatype:</p>
<pre><code>red&gt;&gt; help append
USAGE:
    APPEND series value

DESCRIPTION: 
    Inserts value(s) at series tail; returns series head. 
    APPEND is an action! value.

ARGUMENTS:
    series       [series! bitset! port!] 
    value        [any-type!] 
...
</code></pre>
<p>Here, we see SERIES! which is not named in a way that makes it obvious that it's not a fundamental type.  It's named the same as BLOCK! or WORD!.</p>
<p><span class="mention">@earl</span> and I agreed that this was a stumbling block, so we thought that ANY-SERIES! was a better name.  That way you wouldn't make the mistake of saying:</p>
<pre><code>if series! = type? x [...]
</code></pre>
<p>...and have it always fail.  You'd be cued by that ANY- to know that it was a set of many types.  (You still might think that you could use the equals operator to see if something was in a typeset and be wrong, but that's a different level).</p>
<p><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">But Ren-C has done away with typesets.</a>  They were too limited, and we now use arbitrary functions to do typechecking via predicates (with some various supporting optimizations so the common cases aren't horrifically slow).</p>
<p>So ANY-SERIES! is pretty much going away.  Most of the time you just use ANY-SERIES? (e.g. in a function spec or regular code), and then &amp;ANY-SERIES? if you're in something like a parse rule.</p>
<h2>
<a name="do-we-still-need-the-any-1" class="anchor" href="https://forum.rebol.info#do-we-still-need-the-any-1"></a>Do We Still Need The ANY-?</h2>
<p>I'm a little torn on the question of whether we need the ANY-.</p>
<p>Sometimes it's required (e.g. with ANY-WORD?) because WORD? means specifically "plain word".  (Note you'd use WORD! generally in type specs, though technically you can use either...performance should be identical).</p>
<p>But on ANY-SERIES? it's now a bit superfluous. And SERIES? is certainly shorter.</p>
<p><img src="https://forum.rebol.info/images/emoji/twitter/thinking.png?v=12" title=":thinking:" class="emoji only-emoji" alt=":thinking:" loading="lazy" width="20" height="20"></p>
<p>It's not a slam dunk to take the ANY- off.  I kind of like the realization it gives you as a reader... "hey, we're talking about multiple things here"... and it makes you stop and consider "just how many series are there?  is ANY-SERIES? really what I mean?"</p>
<p>I kind of lean to keeping it.  And I prefer ANY-VALUE? to just VALUE? as well.</p>
<p>But it's definitely less important than it was.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152</link>
          <pubDate>Sat, 17 Feb 2024 06:47:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2152</guid>
          <source url="https://forum.rebol.info/t/dropping-the-any-xxx-from-some-type-constraints/2152.rss">Dropping the ANY-XXX! from (Some) Type Constraints?</source>
        </item>
        <item>
          <title>Ugly Types: Less Ugly Than History, Can We Do Better?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <h2>
<a name="the-limited-and-ambiguous-historical-idea-1" class="anchor" href="https://forum.rebol.info#the-limited-and-ambiguous-historical-idea-1"></a>The Limited and Ambiguous Historical Idea</h2>
<p>People are used to being able to do things like:</p>
<pre><code> x: 10
 switch type? x [
     integer! [print "It's an integer"]
     block! [print "It's a block"]
 ]

 assert [parse [1 [second] 'foo] [integer! block! lit-word!]]

 assert [find any-word! (type? first [x:])]
</code></pre>
<p>But the historical DATATYPE! and TYPESET! were strange.</p>
<ul>
<li>
<p>DATATYPE! rendered as a WORD! but was really wrapping an integer of 0-63</p>
</li>
<li>
<p>TYPESET! was a 64-bit bitset, one bit for each type (this is where the 64 types limit came from)</p>
<ul>
<li>
<p>it lost its meaning in rendering (it kept no record of what the set actually was...just dumped words for each bit)</p>
</li>
<li>
<p>not preserving the name from a fixed list of typesets was based on the concept you could make your own or UNION/INTERSECT them</p>
</li>
</ul>
</li>
</ul>
<p>So it looked like this:</p>
<pre><code>red&gt;&gt; type? 1
== integer!

red&gt;&gt; type? type? 1
== datatype!

red&gt;&gt; print mold any-word!
make typeset! [word! set-word! lit-word! get-word!]

red&gt;&gt; print mold any-type!
make typeset! [datatype! unset! none! logic! block! paren! string! file! url!
    char! integer! float! word! set word! lit-word! get-word! refinement! issue!
    native! action! op! function! path! lit-path! set-path! get-path! routine!
    bitset! object! typeset! error! vector! hash! pair! percent! tuple! map!
    binary! time! tag! email! handle! date! port! money! ref! point2D! point3D!
    image! event!]
</code></pre>
<h2>
<a name="the-type-xxx-approach-2" class="anchor" href="https://forum.rebol.info#the-type-xxx-approach-2"></a>The TYPE-XXX! Approach</h2>
<p>So Ren-C attacked the ambiguity and extensibility with a new word type, TYPE-WORD!.  Then typesets used TYPE-GROUP! and TYPE-BLOCK!, referencing functions to act as type testing predicates, and using groups for intersections and blocks for unions:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer

&gt;&gt; type of type of 1
== &amp;type-word

&gt;&gt; print mold any-word!
&amp;(any-word?)

&gt;&gt; print mold any-value!
&amp;(any-value?)
</code></pre>
<p>This gives some realistic axis of extensibility, and gives distinguishable entities that can trigger behaviors in PARSE when something looks up to type-xxx!.  (this shows why using WORD! or URL! or ISSUE! wouldn't work, because the type intent has to be carried by what e.g. INTEGER! looks up to.)</p>
<p><strong>Calling functions to implement type checks vs. checks on a bitset, especially when an array of functions must be called when checking every parameter in every function call, is a difficult performance point.</strong></p>
<p><a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">Intrinsics and other magic are employed to rein it in.</a>  It's not particularly simple...but finding ways to speed up function calls where you can has systemic benefit.</p>
<h2>
<a name="new-consequence-find-must-find-type-word-normally-3" class="anchor" href="https://forum.rebol.info#new-consequence-find-must-find-type-word-normally-3"></a>New Consequence: FIND Must Find TYPE-WORD! Normally</h2>
<p>Being a legitimate datatype that can be stored in a block, some interpretations of datatype by functions like FIND were problematic:</p>
<pre><code>red&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" integer! 1]

red&gt;&gt; find block 'integer!
== none  ; rendering was a lie

red&gt;&gt; find block integer!
== [1]
</code></pre>
<p>You couldn't find a literal datatype in a block.  Ren-C is approaching this by saying FIND has to find the TYPE-WORD! (as it does for all non-antiforms), but that you can use antiform actions as predicates.</p>
<pre><code>&gt;&gt; block: reduce ["hello" integer! 1]
== ["hello" &amp;integer 1]

&gt;&gt; find block integer!
== [&amp;integer 1]

&gt;&gt; find block :integer?
== [1]
</code></pre>
<p>There was some thought that maybe you could create antiform TYPE-XXX! and call them "matchers", passing them to FIND.</p>
<ul>
<li>
<p>But this is an isotope for each TYPE-XXX!, so it's not even like there would be one "matcher"</p>
</li>
<li>
<p>It also would be the only instance of antiforms of types with sigils, which doubles the sigil to make <strong><code>~&amp;integer~</code></strong>, which I find kind of displeasing</p>
</li>
</ul>
<p>I feel that antiform actions cover it for FIND, and if you have higher level needs you should use something like PARSE which has richer options and isn't beholden to quite the "mechanical" answer that a series primitive like FIND has to abide by with its limited parameterization.</p>
<h2>
<a name="new-annoyance-type-of-quotes-and-antiforms-4" class="anchor" href="https://forum.rebol.info#new-annoyance-type-of-quotes-and-antiforms-4"></a>New Annoyance: TYPE OF Quotes And Antiforms</h2>
<p>When there were only two datatypes with quotedness, the quote was part of their datatype:</p>
<pre><code>red&gt;&gt; type? first ['a]
== lit-word!

red&gt;&gt; type? first ['a/b]
== lit-path!

red&gt;&gt; lit-word! = type? first ['a]
== true

red&gt;&gt; parse ['a 'a/b] [lit-word! lit-path!]
== true
</code></pre>
<p>Ren-C's approach affords the ability make type constraints to carry forward the PARSE behavior.  But the TYPE OF all quoteds is the same... &amp;QUOTED.</p>
<pre><code>&gt;&gt; lit-word?!
== &amp;(lit-word?)

&gt;&gt; lit-word?! = type of first ['a]
== ~false~  ; anti

&gt;&gt; type of first ['a]
== &amp;quoted
</code></pre>
<p>So perhaps you see the motivation to decorate as <strong>?!</strong> instead of just <strong>!</strong> for the type constraints.  People need to know that these aren't fundamental types.  You have to use e.g. MATCH with them:</p>
<pre><code> &gt;&gt; match lit-word?! first ['a]
 == 'a

 &gt;&gt; match lit-word?! 10
 == ~null~  ; anti

 &gt;&gt; match [lit-word?] first ['a]  ; alternative as 1st slot known "typelike"
 == 'a
</code></pre>
<p>This is something of a pain point, and I'm not entirely settled on whether it would be good to delve into some kind of ambiguity where we are actually allowed to get back constraint functions as the answer to TYPE OF, and make that the fundamental:</p>
<pre><code>&gt;&gt; type of 1
== &amp;integer?

&gt;&gt; type of spread [a b]
== &amp;splice?

&gt;&gt; type of ~true~
== &amp;logic?

&gt;&gt; type of first ['a]
== &amp;quoted? 
</code></pre>
<p>So I don't think this is a good idea for the quoted types, but for the antiforms it might be a narrow enough thing that it provides "what the people want".</p>
<pre><code>&gt;&gt; switch type of true [
     splice! [...]
     logic! [...]
     integer! [...]
  ]
</code></pre>
<p>Barring that, what we have to do today is flip SWITCH over into a MATCH mode (currently called SWITCH/TYPE but should probably be SWITCH/MATCH... or maybe it should take the MATCH name):</p>
<pre><code>&gt;&gt; switch/type true [
     splice?! [...]
     logic?! [...]
     integer! [...]
  ]
</code></pre>
<p>Note that the <code>?!</code> distinction is a new idea which hasn't made it to all type constraints yet, e.g. ANY-VALUE! is still as it was.  But because parameters use what is effectively a TYPE-BLOCK! you can say <strong><code>any-value?</code></strong> or <strong><code>splice?</code></strong> in them instead of going through the extra step.</p>
<h2>
<a name="should-type-be-a-bigger-concept-5" class="anchor" href="https://forum.rebol.info#should-type-be-a-bigger-concept-5"></a>Should TYPE Be A Bigger Concept?</h2>
<p>One thing that has nagged me is if when we ask for the fundamental "cell type" of something, if we should avoid using the word "TYPE" for that at all...</p>
<p>Maybe there's some bigger idea in an object/class system where TYPE is meaningful to say something more than "this is an object" but rather "this is a book", where you can ask also "is a book readable".  Etc.</p>
<p>Or maybe TYPE can be parameterized:</p>
<pre><code> &gt;&gt; type of matrix
 == &amp;[matrix 10x10]
</code></pre>
<p>So this would mean there's a smaller question about the fundamental type, maybe call it "KIND":</p>
<pre><code>&gt;&gt; kind of [a b c]
== &amp;block

&gt;&gt; kind of matrix
== &amp;object
</code></pre>
<p>It would be nice to just be able to say "64 types is enough for anyone" and say "there, it's done".  I'd be happy to do that if I felt that it was enough.  It wasn't, even when thinking along fairly limited lines that don't go in these fancier directions.</p>
<p><em>I don't think any near-term system will actualize on bigger visions of what TYPE might be, but it would help to know if that should be ruled out or not, just in order to pick the term KIND or TYPE!</em>  But even that question is murky.</p>
<h2>
<a name="some-related-reading-typesr-6" class="anchor" href="https://forum.rebol.info#some-related-reading-typesr-6"></a>Some Related Reading: %types.r</h2>
<p>The dialected table used to construct the type testing macros and other things is kind of neat, though some comments are out of date and parts of it need updating (it's getting upgraded in an upcoming commit which finally breaks the 64-type barrier and introduces the $ types):</p>
<p>See <a href="https://github.com/metaeducation/ren-c/blob/master/src/boot/types.r"><strong>%types.r</strong></a></p>
            <p><small>20 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151</link>
          <pubDate>Fri, 16 Feb 2024 23:29:33 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2151</guid>
          <source url="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151.rss">Ugly Types: Less Ugly Than History, Can We Do Better?</source>
        </item>
        <item>
          <title>copy all files in a directory ... a little help please?</title>
          <dc:creator><![CDATA[hcfe]]></dc:creator>
          <category>Usage</category>
          <description><![CDATA[
            <p>Hi everybody,</p>
<p>I'd like to modify this script from the script library: <a href="http://rebol.net/cookbook/recipes/0011.html" rel="noopener nofollow ugc">copy all files in a directory</a> so that it can exclude directories and or files like you can with rsync.</p>
<p>It has been a long time since I've used rebol, and I was never much good at it!</p>
<p>Any help appreciated...</p>
            <p><small>4 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/copy-all-files-in-a-directory-a-little-help-please/2149">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/copy-all-files-in-a-directory-a-little-help-please/2149</link>
          <pubDate>Thu, 15 Feb 2024 00:10:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2149</guid>
          <source url="https://forum.rebol.info/t/copy-all-files-in-a-directory-a-little-help-please/2149.rss">copy all files in a directory ... a little help please?</source>
        </item>
        <item>
          <title>A proliferation of $#@^&#39;:~WORD~:s</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>One of the things which surprised me when I first looked into Ren-C was the number of WORD variants it has. By my count, this includes:</p>
<ul>
<li>plain WORD</li>
<li>:GET-WORD</li>
<li>SET-WORD:</li>
<li>
<code>@THE-WORD</code> *</li>
<li>^META-WORD</li>
<li>&amp;TYPE-WORD</li>
<li><span class="hashtag">#ISSUE</span></li>
<li>'QUOTED</li>
<li>~ANTIFORM~</li>
<li>…and probably more that I’ve forgotten.</li>
</ul>
<p><small>* monospaced so Discourse doesn’t think it’s a ping</small></p>
<p>Now, in many ways this is perfectly expected for a language like Ren-C. Firstly, dialecting means we value having as many syntactic options as possible. Secondly, Ren-C has a lot of different kinds of values — plain, quoted, anti and quasi, and now bound and unbound versions of each — and most of these words are simply making it easier to deal with that huge variety.</p>
<p>But, on the other hand, I feel we’re starting to encounter some problems with the current way of doing things. Most notably:</p>
<ol>
<li>None of this is compositional. When we <a href="https://forum.rebol.info/t/speaking-with-tics-should-quoted-arguments-always-be-apostrophed/1359/7">run into a situation</a> where we’d like to, say, have a word which is both META- and THE-, it’s impossible.</li>
<li>Some dialects would like to use words outside this fixed inventory. For instance, it would be nice to have <a href="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146">$WORDs to use in a shell dialect</a>.</li>
</ol>
<p>The root cause of both is the same: the inventory of word-like datatypes is hard-coded into the interpreter. If you want to use something outside that set, you can’t, no matter how similar to the existing types it may seem.</p>
<p>I can imagine a hypothetical design which would avoid this. This would allow some characters to be freely added to the beginning and end of words — let’s call those special characters ‘sigils’, like in Perl. Every combination of sigils would then specify a separate datatype. So you would still have :WORDs and ^WORDs and ~WORD~s, but also $WORDs and ^@WORDs and ~#WORD&amp;s and whatever else you could imagine. This would quite easily solve both of the problems I mentioned.</p>
<p>One might even contemplate generalising this ‘sigil’ idea to non-word types. We already have {GET,SET,THE,META}-{BLOCK,GROUP}s, so it would make sense to allow arbitrary sigils on blocks and groups too.</p>
<p>Unfortunately, I’m not sure this would work with the current design of Ren-C. At the moment, there is currently a hard maximum of (as I recall) 256 possible datatypes, whereas this proposal obviously allows for an infinite amount of datatypes. However, I do think it’s at least worth thinking about, for the simple reason that it would give us a lot more flexibility than we currently have.</p>
            <p><small>10 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/a-proliferation-of-word-s/2147">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/a-proliferation-of-word-s/2147</link>
          <pubDate>Tue, 13 Feb 2024 12:58:43 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2147</guid>
          <source url="https://forum.rebol.info/t/a-proliferation-of-word-s/2147.rss">A proliferation of $#@^&#39;:~WORD~:s</source>
        </item>
        <item>
          <title>Upcoming Datatype $WORD... What Will It Mean?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Something that has been nagging at me is that I've known I want to introduce <strong>$WORD</strong>, <strong>$(GR O UP)</strong>, <strong>$TU.P.LE</strong> etc. (tentative names VAR-WORD!, VAR-GROUP!, VAR-TUPLE!).</p>
<p>At first glance it seems like it would be a loss if $XXX didn't in the baseline evaluator evaluate to looking up environment variables.</p>
<p>But this would be a different behavior for an ANY-WORD!...which up until now, the type of word has not mattered.  Would it spread to SET?</p>
<pre><code>&gt;&gt; set-env "SOMETHING" "TRUE"

&gt;&gt; SOMETHING: 10

&gt;&gt; set (in [] '$SOMETHING) "FALSE"
== "FALSE"

&gt;&gt; SOMETHING
== 10

&gt;&gt; get-env "SOMETHING"
== "FALSE"
</code></pre>
<p>Hmmm.  Lots of issues there...including that Unix environment variables are case-sensitive, Windows ones are not.</p>
<p>The implementation mechanism of this would presumably have to introduce some sort of "pseudo-object" named <code>environment</code>/<code>env</code>, and then the "specifier" would have to say (in a similar way to which the ".WORD" lookups would say to look in a "current object") that the $ words should look up in env.   <em>(See related discussion about <a href="https://forum.rebol.info/t/binding-indirection/2112">"Binding Indirection"</a>)</em></p>
<h2>
<a name="simpler-thought-1" class="anchor" href="https://forum.rebol.info#simpler-thought-1"></a>Simpler Thought...</h2>
<p>A simpler thought (that doesn't rock the boat for one feature) would be that this is a bridge too far for an ANY-WORD!, and they should look up just like any other word, and it's only weird shell dialects that would think that a $WORD meant environment variables.</p>
<p>But then the question might be what the $ buys you.</p>
<p>Maybe I was too hasty in saying that the @ was the right thing to sacrifice for "get variable with binding", and $ should have done that?</p>
<pre><code>&gt;&gt; $word
== word  ; bound

&gt;&gt; @word
== @word  ; bound?
</code></pre>
<p>(A line of argumentation that <code>@word</code> should be bound, is that if you want an unbound one you can get it by quoting with <code>'@word</code>, but then again if the @ operator does not bind e.g. @ foo... but $ does, e.g. $ foo.  So maybe not affecting the binding is the better choice.)</p>
<p>This would let us put back the @ for "as-is" variable usage in parse.  And it would make more sense for a thing named VAR-WORD! (bound variable in evaluator, environment var in shell dialect...)</p>
<p>Urrrgh.  I hate that it seems like that's probably right.  :-/   <em>(Thankfully, git lets us audit/reverse such decisions...assuming you're diligent about not changing too many unrelated things in one commit, which I thankfully was careful about with the @ change.)</em></p>
<h2>
<a name="loss-of-for-weird-idea-i-had-2" class="anchor" href="https://forum.rebol.info#loss-of-for-weird-idea-i-had-2"></a>Loss of $ For Weird Idea I Had</h2>
<p>If the $ operator were used for binding that would be a bit sad, as I'd kind of hoped that could be a variadic function that could run the <a href="https://github.com/metaeducation/ren-c/blob/3e5f724197f55d2745436a52ca1dfa7c5d7e4db5/scripts/shell.r#L4">shell dialect</a>:</p>
<pre><code>extension: "txt"

$ ls -alF *.(extension)
</code></pre>
<p>But, maybe that's a bad way to package it in the box, and specialty scripts that don't care about a $ operator for binding purposes can override it, encouraging the more traditional:</p>
<pre><code>extension: "txt"

shell [ls -alF *.(extension), echo $SOMETHING]
</code></pre>
            <p><small>11 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146</link>
          <pubDate>Tue, 13 Feb 2024 11:51:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2146</guid>
          <source url="https://forum.rebol.info/t/upcoming-datatype-word-what-will-it-mean/2146.rss">Upcoming Datatype $WORD... What Will It Mean?</source>
        </item>
        <item>
          <title>HTTPD Response Handler Hook</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>As another instance of <em>"I want to augment this block as a function body, with some stuff"</em> there's this pattern in HTTPD.  Here is a usage:</p>
<p>The idea is that SERVER.SPEC.ACTIONS is a plain BLOCK! of what to do.  Here's a sample usage:</p>
<pre><code>    import %httpd.reb
    trap [
        str: {Test} n: 0
        wait srv: open [scheme: 'httpd 8000 [
            n: n + 1
            expected: copy str
            repeat n [append expected expected]
            lib.print [{SERVER} n {:} (length of as binary! expected) {bytes}]
            render expected
        ]]
    ] then (func [e] [print mold/limit e 2000])
</code></pre>
<p>If you do something like fetch %index.html, that BLOCK! after the 8000 is executed.  Here what's happening is it's just incrementing a number and doubling the length of the response sent back each time.</p>
<p>The implementation was like this:</p>
<pre><code>    server.locals.handler: func [
        return: [~]
        request [object!]
        response [object!]
    ] compose [
        render: :response.render
        redirect: :response.redirect
        print: :response.print

        (spread (
            match block! server.spec.actions else [default-response]
        ))
    ]
</code></pre>
<p>It wants to override PRINT so that what you print becomes part of the response.  So you're supposed to get these three service functions RENDER / REDIRECT / PRINT as well as access to the REQUEST and RESPONSE objects.</p>
<p>Now that SPREAD is spreading unbound material, this does not work.</p>
<p>PUNCH would be one way of doing this:</p>
<pre><code>    server.locals.handler: func [
        return: [~]
        request [object!]
        response [object!]
    ] compose [
        render: :response.render
        redirect: :response.redirect
        print: :response.print

        (punch [request response render redirect print] as group! (
            match block! server.spec.actions else [default-response]
        ))
    ]
</code></pre>
<p>Though if you had <a href="https://forum.rebol.info/t/hiiamboriss-with/2138">something like WITH</a> you could imagine it like:</p>
<pre><code>    server.locals.handler: func [
        return: [~]
        request [object!]
        response [object!]
    ] compose [
        do with [request response {  ; idea of FENCE! representing object
            render: :response.render
            redirect: :response.redirect
            print: :response.print
        }] (
            match block! server.spec.actions else [default-response]
        )
    ]
</code></pre>
<p>The COMPOSE is not strictly necessary there, but it lets you do at least a little work once vs. every time the function is called.</p>
<p>Which points to something useful about the PUNCH-based concept... beyond being <a href="https://forum.rebol.info/t/what-dialects-need-from-binding/2111">usable in dialects where things like DO WITH aren't available</a>... it has the potential to perform better (assuming punch-merges are faster than usermode function calls, which I believe they would be).</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/httpd-response-handler-hook/2144">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/httpd-response-handler-hook/2144</link>
          <pubDate>Mon, 05 Feb 2024 19:02:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2144</guid>
          <source url="https://forum.rebol.info/t/httpd-response-handler-hook/2144.rss">HTTPD Response Handler Hook</source>
        </item>
        <item>
          <title>Racket&#39;s Language-Oriented Programming</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Foreign Inspiration</category>
          <description><![CDATA[
            <p>Racket has something called <a href="https://school.racket-lang.org/2019/plan/mon-mor-lecture.html">"Language-Oriented Programming"</a>.  <a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> brought it up, and wrote:</p>
<aside class="quote no-group" data-username="bradrn" data-post="10" data-topic="2136">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136/10">Fundamental distinguishing features of Rebol</a>
</div>
<blockquote>
<p>I think there’s an interesting contrast to be made here to <a href="https://racket-lang.org/">Racket</a>’s ‘language-orientated programming’ (basically a different name for dialecting). Racket people talk a lot about defining new languages to solve problems, just like Rebol… but in practice, I’m not sure how much they actually do it. Part of the problem may be that those new languages <em>are</em> very different to base Racket — so not only do you have to write the interpreter, you have to write the parser as well. By contrast, since Rebol dialects have a similar free-form nature as Rebol code, you can get away with minimal parsing and no lexing, which in turn makes dialecting easier to achieve. (Still not as easy as macros, though.)</p>
</blockquote>
</aside>
<p>So I've moved that here to a thread to discuss Racket, if there are any interesting ideas there.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rackets-language-oriented-programming/2143">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rackets-language-oriented-programming/2143</link>
          <pubDate>Thu, 01 Feb 2024 00:54:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2143</guid>
          <source url="https://forum.rebol.info/t/rackets-language-oriented-programming/2143.rss">Racket&#39;s Language-Oriented Programming</source>
        </item>
        <item>
          <title>Rendering Difference For Bound/Unbound Code</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Console</category>
          <description><![CDATA[
            <p>With the new binding model tending to have things sparsely bound, it helps to know what is and isn't bound.</p>
<p>It seems to me it would be very useful (and educational) in rich consoles to make the rendering of code reflect the binding status.</p>
<p><img src="https://forum.rebol.info/uploads/default/original/1X/c7cac409fc3ebb1db0467fb9c8c94b531ff1ec11.png" alt="image" data-base62-sha1="svrriultuZqA01aLNlih32dDyRr" width="258" height="201"></p>
<p>So there you can see that a plain block will evaluate so the block itself is bound, while the contents are left unbound.  A quoted block will be all unbound.</p>
<p>Even better would be if you could hover over the bound bits and see what they were bound to.  It may be best if the coloring was very subtle by default (e.g. just bold black vs a dark gray) and then if you hovered, maybe it would colorize it... perhaps even making things bound the same match colors.</p>
            <p><small>2 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/rendering-difference-for-bound-unbound-code/2142">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rendering-difference-for-bound-unbound-code/2142</link>
          <pubDate>Thu, 01 Feb 2024 00:13:45 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2142</guid>
          <source url="https://forum.rebol.info/t/rendering-difference-for-bound-unbound-code/2142.rss">Rendering Difference For Bound/Unbound Code</source>
        </item>
        <item>
          <title>`import @json` broken under new @ rules, what now?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p>The IMPORT statement was using <code>@NAME</code> to mean "look up the module in the registry".  So you could just write something like:</p>
<pre><code>import @json
</code></pre>
<p>This was a replacement for the original syntax, of using TAG!.</p>
<pre><code>import &lt;json&gt;
</code></pre>
<p>The reason tag was replaced is because as a string type, it came to be in demand for relative-to-script paths, as opposed to relative-to-current-directory paths.</p>
<p>So if your file is in <code>C:\MyProject\something.reb</code> and you do:</p>
<pre><code>D:\Documents&gt; r3 ..\MyProject\something.reb
</code></pre>
<p>The system doesn't change the working directory to <code>C:\MyProject</code> any longer (it was decided that's an undesirable behavior).  So you'll still be in <code>D:\Documents\</code> and so <code>%libs/whatever.reb</code> would be relative to that.  But using TAG! lets you get the desired effect:</p>
<pre><code>Rebol [File: %something.reb]
import &lt;libs/whatever.reb&gt;  ; relative to C:\MyProject where %something.reb lives
</code></pre>
<p>Strings are still used for literal source if you want to put that right inline:</p>
<pre><code>import "Rebol [Title: &lt;{my module}&gt;] export foo: lambda [] [print &lt;{Foo}&gt;]"
</code></pre>
<p>(trying new string notation.. not that terrible...)</p>
<h2>
<a name="but-now-json-is-an-attempted-bound-wordhttpsforumrebolinfotrepurposing-the-xxx-xxx-for-undecorated-values2135-1" class="anchor" href="https://forum.rebol.info#but-now-json-is-an-attempted-bound-wordhttpsforumrebolinfotrepurposing-the-xxx-xxx-for-undecorated-values2135-1"></a><a href="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135">But Now <code>@json</code> Is An (Attempted-Bound) Word</a>
</h2>
<p>We can change it so that the handling is for word, so it works... and <strong><code>import 'json</code></strong> would also work.</p>
<p>But then the binding is superfluous, and we should change the callsites to just use a plain tick mark.</p>
<p>There's nothing particularly <em>wrong</em> with just using a word here, but it kind of makes the import statement lose some of its... heft.  It doesn't stand out as much.</p>
<p>We could use an issue/token:</p>
<pre><code>import #json
</code></pre>
<p>But then we can't do tuple or path tricks and have them be actual tuples and paths.</p>
<pre><code>import 'json/1.2.20  ; path with two items, second is a 3-elemnent tuple
import #json/1.2.20  ; just a utf8 string
</code></pre>
<p>Anyway, I guess we should just have import take WORD!, and it's not a big deal.  In fact it will keep working, because since the argument to import isn't quoted we can't tell it had the @ on it.  But future IMPORTs should omit the @, because it's now superfluous.</p>
<p>(Though actually, should <code>@word</code> fail if it can't bind a word?  That's a question for the other thread, though...)</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/import-json-broken-under-new-rules-what-now/2141">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/import-json-broken-under-new-rules-what-now/2141</link>
          <pubDate>Wed, 31 Jan 2024 05:15:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2141</guid>
          <source url="https://forum.rebol.info/t/import-json-broken-under-new-rules-what-now/2141.rss">`import @json` broken under new @ rules, what now?</source>
        </item>
        <item>
          <title>Rethinking `&lt;static&gt;` in the Function Spec Dialect</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>In R3-Alpha, the FUNCTION construct was built on top of FUNC, and added features like statics as a refinement.  It looked pretty awkward, because the static was added at the end of the expression:</p>
<pre><code> r3-alpha&gt;&gt; foo: function/with [x] [return staticvar: add staticvar x] [staticvar: 0]

 r3-alpha&gt;&gt; foo 10
 == 10

 r3-alpha&gt;&gt; foo 20
 == 30
</code></pre>
<p>Ren-C tried extending the function spec dialect to support this in a nicer way:</p>
<pre><code> foo: function [x &lt;static&gt; staticvar (0)] [return staticvar: add staticvar x]
</code></pre>
<p>The low-level FUNC implementation doesn't know what <code>&lt;static&gt;</code> is, so it's added by a higher layer, that makes things slower... and since the function spec dialect is kind of foundational it may be the wrong place to be putting this for the core.</p>
<p><span class="mention">@hiiamboris</span> <a href="https://forum.rebol.info/t/hiiamboriss-with/2138">approaches this differently</a>:</p>
<aside class="quote no-group">
<blockquote>
<h4>create static storage for functions where existing literal forms don't allow you to:</h4>
<pre><code class="lang-plaintext">factorial: func [x] with [cache: make hash! [0 1]] [
    any [
        select/skip cache x 2
        put cache x x * factorial x - 1
    ]
]
</code></pre>
</blockquote>
</aside>
<p>It's not the first time I've thought it would be a better direction to break it out.  But putting it all as part of the function spec was supposed to have an advantage in that when the body was walked to create the copy, the binding to the static members would be done as well.  This is no longer applicable, because the bodies of functions are largely left unbound...</p>
<p>We do lose a feature of noticing when you are naming the static the same thing as something in your function frame and you don't get an error in that case, but maybe you don't want an error (perhaps you inherited the frame through an adaptation or something like that, and you don't care about the frame variable).</p>
<p>Boris's dialect is a bit overloaded, and Ren-C has more parts to help with that...<a href="https://forum.rebol.info/t/rethinking-braces-as-an-array-type/1727">but it would help even more if there were FENCE!</a></p>
<pre><code>foo: func [x] with [
    {staticvar: 0}
][
    return staticvar: add staticvar x
]

foo: func [x] with {staticvar: 0} [
    return staticvar: add staticvar x
]
</code></pre>
<p>So this wouldn't be confused with any other WITH things you were doing, like trying to use objects or words and add them to a block that already had a binding.</p>
<pre><code>&gt;&gt; body: [keep staticvar: staticvar + x]

&gt;&gt; collect [
       wrapper: func [x] with ['keep {staticvar: 0}] body
       wrapper 1
       wrapper 10
       wrapper 100
   ]
== [1 11 111]
</code></pre>
<p>(Just trying to drum up a little excitement for FENCE! there, but I think it's the tip of the iceberg.)</p>
<p>Anyway, there've been educational lessons from showing that you <em>can</em> extend the FUNC spec dialect and build higher level features... but I think we should probably tear those out of the core and move to something like this.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139</link>
          <pubDate>Tue, 30 Jan 2024 21:48:12 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2139</guid>
          <source url="https://forum.rebol.info/t/rethinking-static-in-the-function-spec-dialect/2139.rss">Rethinking `&lt;static&gt;` in the Function Spec Dialect</source>
        </item>
        <item>
          <title>hiiamboris&#39;s WITH</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>I've mentioned that binding might be helped by a dialect, and it turns out there is some precedent in <strong><a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/with.red">hiiamboris's WITH</a></strong>:</p>
<blockquote>
<h3>USAGE SUMMARY</h3>
<pre><code>with x  [..]          == bind [..] x
with 'x [..]          == bind [..] 'x
with :fun [..]        == bind [..] :fun
with [:fun] [..]      == bind [..] :fun
with [x y 'z] [..]    == bind bind bind [..] 'z y x
with [x: 1 y: 2] [..] == bind [..] context [x: 1 y: 2]
</code></pre>
<h3>EXAMPLES</h3>
<h4>omit the path to an object, but work inside it's context:</h4>
<pre><code>do with face/parent/pane/1 [
    color: red
    text: mold color
    visible?: yes
]

if true with system/view/fonts [print [serif size]]

f: func [/- /+ /*] [        ;-- redefines important globals locally
    (do something with local flags)
    foreach x [set..] with system/words [
        (do something with global * + -)
    ]
]
</code></pre>
<h4>create static storage for functions where existing literal forms don't allow you to:</h4>
<pre><code>factorial: func [x] with [cache: make hash! [0 1]] [
    any [
        select/skip cache x 2
        put cache x x * factorial x - 1
    ]
]
</code></pre>
<h4>anonymize words used during initialization of the program:</h4>
<pre><code>first item in the block should be of set-word! type

do with [x: 1 y: 2] [
    z: x * y
    ... other code that uses x or y ...
]
</code></pre>
<h4>bind a block to multiple contexts at once (in the list order):</h4>
<p>First item in the block should be of word!/get-word!, path!/get-path! or lit-word! type</p>
<ol>
<li>
<p>words and paths values are fetched, while lit-words are converted into words<br>
get-words and get-paths should be used for function context, otherwise they get evaluated</p>
</li>
<li>
<p>if resulting value is a context, block is bound to it<br>
if resulting value is a word, block is bound to the context of this word</p>
<p>the following example illustrates usage of words and lit-words:</p>
<pre><code>a: b: x: y: none
c: context [
    a: 1
    b: 2
    f: func [x y] [
       ; calls `with` internally
       print composite [self 'x] "a=(a) b=(b) x*y=(x * y)"
       ; equivalent
       print composite [self :f] "a=(a) b=(b) x*y=(x * y)"
    ]
]
</code></pre>
</li>
</ol>
<p>Thus, <code>with [c]</code> is equivalent to <code>with c</code>, while <code>with ['c]</code> - to <code>with 'c</code>.</p>
<h3>WHY IS IT DESIGNED LIKE THIS?</h3>
<ol>
<li>
<p>It does not evaluate</p>
<p><code>with</code> does not evaluate the block, so:</p>
<ul>
<li>it can be used after <code>context</code>s, <code>if</code>s, <code>loop</code>s, <code>func</code>s, etc.</li>
<li>it can be chained <code>with x with y ...</code>
</li>
</ul>
<p>I've found that this makes code much more readable than it would be with <code>bind</code>.<br>
Prefix it with <code>do</code> if you want immediate evaluation.</p>
</li>
<li>
<p>It accepts blocks</p>
<p>Design question here was - if we allow block! for <code>ctx</code>, how should we treat it?</p>
<ul>
<li>
<p>convert it to a context? <code>ctx: context ctx</code></p>
<p>that shortens the <code>with context [locals...] [code]</code> idiom</p>
</li>
<li>
<p>list multiple contexts in a block as a sequence and bind to each one?</p>
<p>that shortens <code>with this with that [code]</code> idiom</p>
</li>
</ul>
<p>Personally, I've used the 1st at least a few times, but 2nd - never, though I admit there are use cases.<br>
This can be solved by checking type of the 1st item in the block is a set-word or not <img src="https://forum.rebol.info/images/emoji/twitter/wink.png?v=12" title=":wink:" class="emoji" alt=":wink:" loading="lazy" width="20" height="20"><br>
But still ambiguous! When <code>with</code> gets a <code>word!</code> argument it can:</p>
<ul>
<li>get the value of this word, which should be an <code>object!</code>, and bind to this object</li>
<li>get the context of this word, and bind to this context</li>
</ul>
<p>When inside a context, 2nd option is nice:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with [self x] [x * y * a]
    ]
 ]
</code></pre>
<p>..where the alternative would be:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with context? 'x with self [x * y * a]
    ]
]
</code></pre>
<p>When outside of it, 1st option is better:</p>
<pre><code>x: context [x: 10]
y: context [y: 20]
do with [x y] [x * y]
</code></pre>
<p>..where the alternative would be:</p>
<pre><code>x: context [x: 10]
y: context [y: 20]
do with in x 'x with in y 'y [x * y]
</code></pre>
<p>But this still can be solved: let <code>word!</code>s evaluate to contexts and <code>lit-word!</code>s, same as we have <code>bind code ctx</code> vs <code>bind code 'ctx</code>:</p>
<pre><code>context [
    a: 1
    f: func [x y] [
        with [self 'x] [x * y * a]
    ]
]

x: context [x: 10]
y: context [y: 20]
do with [x y] [x * y]
</code></pre>
</li>
</ol>
</blockquote>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/hiiamboriss-with/2138">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/hiiamboriss-with/2138</link>
          <pubDate>Tue, 30 Jan 2024 21:14:23 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2138</guid>
          <source url="https://forum.rebol.info/t/hiiamboriss-with/2138.rss">hiiamboris&#39;s WITH</source>
        </item>
        <item>
          <title>How to Capture Binding Of PARSE Items</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>Consider some simple code that used to "work" (in of course only the simplest of cases)</p>
<pre><code>&gt;&gt; parse [word: 10] [
       let word: set-word! let val: integer! (
           set word val
       )
   ]
</code></pre>
<p>We're getting some unbound values by structural extraction.  But now that structural extraction doesn't propagate bindings... how do we look those values up in an environment?</p>
<p>We'd get the wrong answer if we said <strong>set (inside [] word) val</strong>... that would try to bind the "word" word to the LET variable from the rule.  I made it conflict just to stress the point that the processing code is not the right environment to be looking up values in the data most of the time.</p>
<p>When PARSE is doing the processing (and recursions in our data for us), we're cut out of the loop on binding.</p>
<h2>
<a name="solution-tactics-1" class="anchor" href="https://forum.rebol.info#solution-tactics-1"></a>Solution Tactics</h2>
<p>You can use the <code>&lt;input&gt;</code> TAG! combinator to get the input, and if there were an IN combinator you could do this yourself... handling recursions</p>
<pre><code>&gt;&gt; parse [[word: 10]] [
       let i: &lt;input&gt;
       subparse in (i) block! [  ; make subparse input propagate specifier
           let sub: &lt;input&gt;
           let word: set-word! let val: integer! (
               set (in sub word) val 
           )
       ]
   ]
</code></pre>
<p>Making this a little easier might be a combinator for capturing the parse state object, for getting the input more easily at any time.</p>
<pre><code>&gt;&gt; parse [[word: 10]] [
       let s: &lt;state&gt;
       subparse in (s.input) block! [  ; subparse changes s.input
           let word: set-word! let val: integer! (
               set (in s.input word) val
           )
       ]
   ]
</code></pre>
<p>Certainly some pain involved here.  Perhaps <a class="mention" href="https://forum.rebol.info/u/bradrn">@bradrn</a> can appreciate the reason why propagating binding through structure automatically seemed necessary so things like this worked "like magic".</p>
<p><em>But it was bad magic.</em>  If the structural operations presume ideas about binding, that ties our hands in the interpretation of binding for the input block.  We have <strong>[[word: 10]]</strong> now, but what if we wanted something like <strong>[let word [word: 10]]</strong>?  It's up to the parse of this "dialect" to decide the bindings, not have it automatic.  It's only the refusal of the automaticness allowing the LET in PARSE above to be implemented!</p>
<p>Though actually in this simple case, you could just say:</p>
<pre><code>&gt;&gt; parse [[word: 10]] [
       subparse in &lt;input&gt; block! [  ; make subparse input propagate specifier
           let word: in &lt;input&gt; set-word! let val: integer! (
               set (in sub word) val 
           )
       ]
   ]
</code></pre>
<p>Even briefer, a TAG! combinator <code>&lt;in&gt;</code> that means <strong><code>in &lt;input&gt;</code></strong>:</p>
<pre><code>parse [[word: 10]] [
   subparse &lt;in&gt; block! [
       let word: &lt;in&gt; set-word! let val: integer! (
           set word val
       )
   ]
]
</code></pre>
<p>Not too arduous, and you have the necessary hook points for alternative binding interpretation when you need it.  And if you're just processing code structurally, you don't have to worry about it.</p>
<p><em>(Note: Trying this I remembered that TAG! combinators haven't been set up to take arguments.  Should they be able to?  Maybe not... none do at the moment, and it seems a reasonable policy to say they don't.  If not a TAG! then what should this be?  It could be the behavior of the <code>@</code> operator... which is a bit incongruous with how <code>@word</code> etc. are handled in PARSE, but lines up sort of with wanting to capture the current sense of binding on the next argument.  Something to think about, I'm calling it <strong><code>*in*</code></strong> as a placeholder just to move along)</em></p>
<h2>
<a name="other-places-this-pops-up-2" class="anchor" href="https://forum.rebol.info#other-places-this-pops-up-2"></a>Other Places This Pops Up</h2>
<p>If you're writing something like a FOR-EACH loop, and you want to get the bindings of things, you can look the thing up in an environment that you have on hand:</p>
<pre><code>&gt;&gt; block: [word: 10]
&gt;&gt; for-each [word val] block [
      set (in block word) val
   ]

&gt;&gt; word
== 10
</code></pre>
<p>It's manual, but it works.  But what if the block were literal, and you didn't have access to it?</p>
<pre><code>&gt;&gt; for-each [word val] [word: 10] [
      set (??? word) val
   ]
</code></pre>
<p>Where this may be pointing is that instead of trying to imagine weirdly designed FOR-EACH variants that incorporate binding, it may be that you should think in terms of PARSE as the tool for when you want to enumerate with binding...</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/how-to-capture-binding-of-parse-items/2137">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/how-to-capture-binding-of-parse-items/2137</link>
          <pubDate>Mon, 29 Jan 2024 19:44:22 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2137</guid>
          <source url="https://forum.rebol.info/t/how-to-capture-binding-of-parse-items/2137.rss">How to Capture Binding Of PARSE Items</source>
        </item>
        <item>
          <title>Fundamental distinguishing features of Rebol</title>
          <dc:creator><![CDATA[bradrn]]></dc:creator>
          <category>Philosophy</category>
          <description><![CDATA[
            <p>Perhaps foolishly, I offered to give a talk at my local Functional Programming meetup next month. Given my recent interests, I’m thinking of giving an intro to Rebol and its basic concepts.</p>
<p>So that’s gotten me thinking: what <em>are</em> the basic concepts of Rebol as a programming paradigm, which distinguish it from all others? Here’s what I’ve come up with so far:</p>
<ul>
<li>
<p><strong>Everything is a datatype</strong>: Rebol was built for networking. This means you should be able to take any value, serialise it in a human-readable way, and parse it back into a value. This means a lot of built-in datatypes for useful concepts.</p>
</li>
<li>
<p><strong>Data is code</strong>: Everything starts out its life as data. If you want, you can evaluate it in some way to get a result. Naturally, you can evaluate it using any rules you want, which gives you <strong>dialecting</strong> as a corollary.</p>
<p>(It’s worth noting that this is the converse of Lisp’s famous maxim, ‘code is data’.)</p>
</li>
<li>
<p><strong>Binding</strong>: Word values are associated with their storage. This can be arbitrarily manipulated by the programmer, leading to <strong>definitional scoping</strong>.</p>
</li>
<li>
<p>More generally, I might summarise all the above points as natural consequences of <strong>computing with evaluation</strong>: the fundamental operation of Rebol is taking values and extracting some kind of result from them. This necessitates the other points above: a rich set of datatypes to store both the original value and the result, the ability to treat those datatypes as code which can be evaluated, and a way to look up references during the evaluation process.</p>
</li>
</ul>
<p>Does this all seem reasonable? Have I missed anything?</p>
            <p><small>13 posts - 3 participants</small></p>
            <p><a href="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136</link>
          <pubDate>Mon, 29 Jan 2024 12:55:14 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2136</guid>
          <source url="https://forum.rebol.info/t/fundamental-distinguishing-features-of-rebol/2136.rss">Fundamental distinguishing features of Rebol</source>
        </item>
        <item>
          <title>Meaning of META-BLOCK! ^[...]</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2135">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135/1">Repurposing THE-XXX! (@xxx) For Undecorated Values</a>
</div>
<blockquote>
<p>In any case, preliminary looking at the results <strong><a href="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135">(of repurposing the @xxx types)</a></strong>, I think this is a solid change and much needed in the new binding world.</p>
</blockquote>
</aside>
<p>Found one glitch... there was an idiom of using the inertness in some places with blocks.</p>
<pre><code>&gt;&gt; spaced ["Reduced" 1 + 2 "Content"]
== "Reduced 3 Content"

&gt;&gt; spaced @["Unreduced" 1 + 2 "Content"]
== "Unreduced 1 + 2 Content"

&gt;&gt; meta pack [1 + 2 10 + 20]
== ~['3 '30]~

&gt;&gt; meta pack @[1 + 2 10 + 20]
== ~['1 '+ '2 '10 '+ '20]~
</code></pre>
<p>This won't work anymore, as the evaluator isn't inert here.</p>
<p>HOWEVER... there is a construct that can pick up the slack.  The META-BLOCK!</p>
<pre><code>&gt;&gt; ^[1 + 2 10 + 20]
== '[1 + 2 10 + 20]
</code></pre>
<p>It produces a block which is quoted, and which captured a binding.  So it is suitable for this purpose.  It does raise questions like "what to do if the block is double or triple quoted" etc, but I think raising an error is fine for the moment.</p>
<hr>
<p>Coincidentally, I was thinking about my desire to have a proper FOR dialect.</p>
<pre><code> &gt;&gt; for x [1 to 3] [print x]
 1
 2
 3
</code></pre>
<p>And then, the concept of "going meta" struck me as interesting:</p>
<pre><code> &gt;&gt; for x meta [1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>Which would mean that FOR when given a quoted block would enumerate its contents vs. run the dialect.  Then you could also write that as:</p>
<pre><code> &gt;&gt; for x ^[1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>If you didn't want a binding you need a quoted block and a generator applied to the resulting unbound block:</p>
<pre><code> &gt;&gt; for x each '[1 to 3] [print x]
 1
 to
 3
</code></pre>
<p>It's interesting to see the parts coming together with some things not being as useless as first thought.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/meaning-of-meta-block/2145">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/meaning-of-meta-block/2145</link>
          <pubDate>Mon, 29 Jan 2024 08:50:02 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2145</guid>
          <source url="https://forum.rebol.info/t/meaning-of-meta-block/2145.rss">Meaning of META-BLOCK! ^[...]</source>
        </item>
        <item>
          <title>Repurposing THE-XXX! (@xxx) For Undecorated Values</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Datatypes</category>
          <description><![CDATA[
            <p>Historical Rebol used quoted words (LIT-WORD!) to pass variables to functions, with the idea the function could then later set or get those variables.  The quote level was removed under evaluation, meaning the function got a WORD!</p>
<pre><code>rebol2&gt;&gt; whatever: 10

rebol2&gt;&gt; foo: func [var [word!]] [print [var "is" get var]]

rebol2&gt;&gt; foo 'whatever
whatever is 10
</code></pre>
<p>But we now have a general rule that quoting insulates whatever you quote from binding.  So you have to add the binding, by saying something like <strong><code>foo in [] 'whatever</code></strong></p>
<p>This isn't the only option, if the callee was willing to receive something other than WORD!.  We also have THE-WORD!, which currently evaluates to the bound version of itself.</p>
<pre><code>&gt;&gt; @whatever
== @whatever

&gt;&gt; foo: func [var [the-word!]] [print [var "is" get var]]

&gt;&gt; foo @whatever
@whatever is 10
</code></pre>
<p>This gets you the binding you want, but now you have a decorated word, which would be annoying if FOO is trying to do something besides GET/SET the value.  Plain words are the norm.</p>
<p>If you wanted an undecorated word, you could use the standalone @ operator... which gives back its argument literally:</p>
<pre><code>&gt;&gt; @ a
== a
</code></pre>
<p><strong><code>@ a</code></strong> is a little bit uglier than <strong><code>'a</code></strong> but not as bad as <strong><code>in [] 'a</code></strong></p>
<pre><code>&gt;&gt; foo: func [var [word!]] [print [var "is" get var]]

&gt;&gt; foo @ whatever
whatever is 10
</code></pre>
<p>But the spacing just throws it off to where it no longer looks like a single argument.  And it doesn't look like one because it isn't (e.g. can't fill exactly one slot in the API or a COMPOSE).  @ is also a function under the current design (you can redefine it), so calling it incurs some overhead.</p>
<h2>
<a name="or-we-could-say-that-things-evaluate-and-drop-the-1" class="anchor" href="https://forum.rebol.info#or-we-could-say-that-things-evaluate-and-drop-the-1"></a>Or... We Could Say that @ Things Evaluate And Drop The @</h2>
<pre><code>&gt;&gt; @word
== word  ; bound

&gt;&gt; @(print "Hello")
== (print "Hello")  ; bound

&gt;&gt; @[print "Hello"]
== [print "Hello"]  ; bound, less useful as plain block would have done that
</code></pre>
<p>This would make <strong><code>@word</code></strong> and <strong><code>@ word</code></strong> symmetrical, which is appealing.</p>
<p>But it's at the cost of losing the idea of a category of ANY-WORD! that stays somewhat as-is.</p>
<h2>
<a name="how-big-a-loss-is-the-inert-wordgrouptuplepath-2" class="anchor" href="https://forum.rebol.info#how-big-a-loss-is-the-inert-wordgrouptuplepath-2"></a>How Big A Loss Is The "Inert" WORD!/GROUP!/TUPLE!/PATH!</h2>
<p>In practice, the idea of inert words hasn't lived up to my hopes for them.  I thought maybe since they would be shielded from multiple phases of reducing, they might become popular for some kind of enumerated types.  But being a bit ugly, that's not materialized.</p>
<p>If it gives you any idea of how not-popular the application has been, I changed the evaluator behavior and it <a href="https://github.com/metaeducation/ren-c/blob/0d2d7c39733f21e1088240ab2e5c7614072c8059/src/mezz/uparse.r#L151">only required <em>one</em> change in UPARSE to boot</a>:</p>
<pre><code>  (if spec.1 = '@pending [
        assert [spec.2 = [&lt;opt&gt; block!]]
        autopipe: false  ; they're asking to handle pending themselves
        spread reduce [@pending spec.2]  ; &lt;-- this has to be '@pending
        elide spec: my skip 2
    ] else [
        autopipe: true  ; they didn't mention pending, handle automatically
        spread [@pending [&lt;opt&gt; block!]]
    ])
</code></pre>
<p>They're still free to be used in dialects for whatever purpose (here we see them marking output parameters in the function spec dialect).  And they serve a good purpose in PARSE for "treat this value literally":</p>
<pre><code>&gt;&gt; block: [some "a"]

&gt;&gt; parse ["a" "a"] [block]
== "a"

&gt;&gt; parse [[some "a"] [some "a"]] [some @block]
== [some "a"]
</code></pre>
<p>But it seems that with the new binding model, they have a higher calling in the evaluator... for producing undecorated bound things!</p>
<p>If you want wordlike things that do not reduce, there's blank-headed paths like <strong><code>/FOO</code></strong> ("refinement").  They have a binding and can be looked up.  Today, blank-headed tuples like <strong><code>.FOO</code></strong> don't evaluate, but I'm aiming to say that they do--and that they do member lookup in methods.  Or... y'know... you could put the word in a block! <strong><code>[foo]</code></strong></p>
<h2>
<a name="note-that-decorated-types-have-to-use-3" class="anchor" href="https://forum.rebol.info#note-that-decorated-types-have-to-use-3"></a>Note That Decorated Types Have To Use @</h2>
<p>There's no such thing as a THE-SET-BLOCK! (and I don't imagine there ever will be).</p>
<pre><code> &gt;&gt; @[x y]:
 ** Error: That doesn't exist

 &gt;&gt; @ [x y]:
 == [x y]:
</code></pre>
<p>So it's only the plain WORD!, TUPLE!, PATH!, GROUP! and (redundantly) BLOCK! that you can do this without a space.</p>
<p>But it's likely much rarer to be generating such material bound in isolation.</p>
<p>In any case, preliminary looking at the results, I think this is a solid change and much needed in the new binding world.</p>
            <p><small>6 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135</link>
          <pubDate>Mon, 29 Jan 2024 06:12:50 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2135</guid>
          <source url="https://forum.rebol.info/t/repurposing-the-xxx-xxx-for-undecorated-values/2135.rss">Repurposing THE-XXX! (@xxx) For Undecorated Values</source>
        </item>
        <item>
          <title>Optimizing Environment Lookup</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Optimization</category>
          <description><![CDATA[
            <h2>
<a name="object-storage-object-frame-port-error-1" class="anchor" href="https://forum.rebol.info#object-storage-object-frame-port-error-1"></a>Object Storage (OBJECT!, FRAME!, PORT!, ERROR!)</h2>
<p>Rebol objects were designed as two parallel arrays, which we can call the "keylist" and the "varlist".  Originally these were entire cells, like this:</p>
<pre><code>obj: make object! [a: 10 b: 20]

            0     1     2
KEYLIST  [     |  a  |  b  ]   ; 4 platform pointers per cell

            0     1     2
VARLIST  [self |  10 |  20 ]   ; 4 platform pointers per cell
</code></pre>
<p>The idea is that the <code>[0]</code>th cell of the varlist contains an instance of the object itself.  This means if the implementation has a pointer to the varlist in its hand, it also has a cell instance of the object.  This also means you can find out from just the varlist what subtype it is (ERROR!, FRAME!, PORT!, etc.)</p>
<p>R3-Alpha used full 4-platform-pointer-sized WORD! cells for each element in the keylist, and left the [0]th cell empty.</p>
<p>Ren-C optimized this to just point to symbols.  So keylists are arrays of single pointers, and there is no [0]th element.</p>
<pre><code>                  0     1 
KEYLIST        [  a  |  b  ]   ; 1 platform pointer per cell

            0     1     2
VARLIST  [self |  10 |  20 ]   ; 4 platform pointers per cell
</code></pre>
<p>Keylists are shared among objects that are used as prototypes for each other, e.g. <strong>obj2: make obj [...]</strong>.  They will become un-shared if any of the objects are expanded.</p>
<p>(Object expansion is allowed in R3-Alpha and Ren-C, but not Rebol2 or Red).</p>
<h2>
<a name="module-storage-module-2" class="anchor" href="https://forum.rebol.info#module-storage-module-2"></a>Module Storage (MODULE!)</h2>
<p>R3-Alpha used the same layout for modules containing hundreds of items as it did for objects.</p>
<p>Ren-C instead allocates small variable "stubs" for each variable in a module.  Each stub is 8 platform pointers in size.</p>
<ul>
<li>4 of those platform pointers are for the cell of the variable's value</li>
<li>1 pointer is for the symbol of the variable</li>
<li>1 pointer is to the module the variable is for</li>
<li>1 pointer to the next stub with the same symbol for another module</li>
<li>1 pointer-sized slot unused at this time</li>
</ul>
<p>These form a linked list of all the same-named variable instances in modules.  This list is pointed to by the symbol itself.</p>
<p>If we want to check if a WORD! cell has a variable in a module, the cell contains a pointer to the word's symbol.  We follow that, and get to the list of variables.  We can walk that list and see if there is an instance matching the module we are looking for.</p>
<h2>
<a name="let-variables-3" class="anchor" href="https://forum.rebol.info#let-variables-3"></a>LET Variables</h2>
<p>At the moment, LET variables are similar to the stubs holding variables for a module... except they don't have an associated module.</p>
<h2>
<a name="specifier-chains-are-linked-lists-of-contexts-or-containers-4" class="anchor" href="https://forum.rebol.info#specifier-chains-are-linked-lists-of-contexts-or-containers-4"></a>Specifier Chains Are Linked Lists Of Contexts -or- Containers</h2>
<p>Things like FRAME! or OBJECT! or MODULE! have one pointer for their "parent specifier".  So when you do something like:</p>
<pre><code> let x: 10
 obj: make object! [y: x + 10, z: x + 20]
</code></pre>
<p>The BLOCK! that object receives has a specifier put onto it... in this case, it will be a LET variable.  That LET variable presumably points up to something else (an enclosing function frame, or a module, or whatever).</p>
<p>The object creates its varlist, and then that varlist has a pointer to the LET.  It uses this as the edited specifier when running the body block of the object.</p>
<p>But if you later try to leverage that object elsewhere e.g. with <strong>overbind obj [...]</strong>, it wants to chain that object onto some other specifier.  However its parent link is already in use for the other chain.  So this means a little stub USE container is needed... which points at the object and provides a new slot to put a pointer in.</p>
<h2>
<a name="looking-up-an-unbound-word-walks-this-chain-5" class="anchor" href="https://forum.rebol.info#looking-up-an-unbound-word-walks-this-chain-5"></a>Looking Up An Unbound Word Walks This Chain</h2>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="12" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/12">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<p>Though I do spy one low-hanging fruit…</p>
<aside class="quote no-group" data-username="hostilefork" data-post="11" data-topic="1751">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/11">Rebol And Scopes: Well, Why Not?</a>
</div>
<blockquote>
<p>a linked list of objects</p>
</blockquote>
</aside>
<p>Might it not be quicker to use a hashmap or similar data structure?</p>
</blockquote>
</aside>
<p>It's not entirely obvious what to hash, here.  And it's not so much that any particular lookup is all that slow.  It's just that there's lots of them, and you can't reliably cache the answer between runs.</p>
<p><a href="https://forum.rebol.info/t/semantics-and-optimization-of-copying-function-bodies/2119/2">One thing I cited to exploit</a> was the fact that when you copy a function body, you tend to wind up with elements that look up either in a module or in the frame of that function.</p>
<ul>
<li>
<p>Module lookup is relatively fast because there aren't all that many redundant names (e.g. there's typically only one APPEND and it's in LIB.)</p>
</li>
<li>
<p>Function frames are not allowed to expand.</p>
</li>
<li>
<p>You can use the space in the unbound elements to give an answer to something knowable--like "this isn't defined in the frame for function X" or "this is defined in the frame for function X at offset Y", that can let you skip along to searching in the module or beeline for the pointer to what you want in the frame.</p>
</li>
</ul>
<p>I'm sure this will help.  Will have to see how much.</p>
<h2>
<a name="gc-load-is-a-big-problem-6" class="anchor" href="https://forum.rebol.info#gc-load-is-a-big-problem-6"></a>GC Load Is A Big Problem</h2>
<p>Ren-C's garbage collector has some interesting points, but it's still a mark-and-sweep strategy.</p>
<p>These specifier chains are being allowed to leak out, with every function call producing tons of them... and function frames have to be GC'd because you can't assume there are no extant references.  (Natives are an exception, they will free their frames when they end, but you can't do that with usermode functions because they use frames as specifiers in the blocks they run... and you don't know what happens to that block).</p>
<p>LETs are pretty bad too... a LET inside a loop creates a little piece of junk each time that needs to get cleaned up.</p>
<p>I think reference counting would be helpful, because most of these aren't referenced very long and aren't involved in cycles.  So reaching a 0 refcount would be a moment the memory could be reclaimed.  My guess is it would outweigh the cost of the reference counting by a fair bit.  But it's difficult to do reference counting correctly in C-like code (although having a C++ build variant it could be double-checked).</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/optimizing-environment-lookup/2134">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/optimizing-environment-lookup/2134</link>
          <pubDate>Thu, 25 Jan 2024 03:27:25 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2134</guid>
          <source url="https://forum.rebol.info/t/optimizing-environment-lookup/2134.rss">Optimizing Environment Lookup</source>
        </item>
        <item>
          <title>Tunnelling BREAK and CONTINUE Across Binding</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>In <code>%make-reb-lib.r</code>, there's are abstractions for helping you do something for every API definition.  The APIs are in an array of objects, and the idea is to go through all the objects and run some code bound into each one... so you don't have to specify the object name each time.</p>
<p>So instead of:</p>
<pre><code>names: map-each api api-objects [
    print ["The API name is" api.name]
    api.name
]
</code></pre>
<p>You could instead write:</p>
<pre><code>names: map-each-api [
    print ["The API name is" name]
    name
]
</code></pre>
<h2>
<a name="implementation-of-map-each-api-1" class="anchor" href="https://forum.rebol.info#implementation-of-map-each-api-1"></a>Implementation of MAP-EACH-API</h2>
<p>In order to make the API member fields visible to code, we use the OVERBIND instruction, which patches in the object:</p>
<pre><code>map-each-api: lambda [code [block!]] [
    map-each api api-objects compose [
        eval overbind api (code)
    ]
]
</code></pre>
<h2>
<a name="problem-continue-and-break-2" class="anchor" href="https://forum.rebol.info#problem-continue-and-break-2"></a>Problem: CONTINUE and BREAK</h2>
<p>We'd like to be able to run the CONTINUE and BREAK of the MAP-EACH.  Previously, using a COMPOSE bought that.  Now, because the code block has a binding, those do not override.</p>
<p>If the API's object's bindings were on the block passed to MAP-EACH, then it would patch the BREAK and CONTINUE onto them.  But we can't do that, because the API object is not available until the MAP-EACH is already running and the block has been passed.</p>
<p>Using the current primitive tools for binding at hand, we can try making an object carrying BREAK and CONTINUE and overbind into that as well:</p>
<pre><code>map-each-api: lambda [code [block!]] [
    map-each api api-objects compose [
        let aux: make object! compose [break: (^break) continue: (^continue)]
        eval overbind aux overbind api (code)
    ]
]
</code></pre>
<p>It works...and the COMPOSE isn't really necessary anymore.  But, it certainly leaves a lot to be desired.  If we were to dialect this <em>(in the spirit of something like <a href="https://codeberg.org/hiiamboris/red-common/src/branch/master/with.red">hiiamboris's WITH</a>)</em>, it might look more like:</p>
<pre><code>map-each-api: lambda [code [block!]] [
    map-each api api-objects [
        eval with [break continue :api] code
    ]
]
</code></pre>
<p>Overall though, it feels good to have things under more strict control.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/tunnelling-break-and-continue-across-binding/2133">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/tunnelling-break-and-continue-across-binding/2133</link>
          <pubDate>Wed, 24 Jan 2024 20:56:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2133</guid>
          <source url="https://forum.rebol.info/t/tunnelling-break-and-continue-across-binding/2133.rss">Tunnelling BREAK and CONTINUE Across Binding</source>
        </item>
        <item>
          <title>Binding Contention: Visibility of Statics to Each Other</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>The feature of functions having <code>&lt;static&gt;</code> variables is implemented by making an OBJECT! holding those variables, and then binding the body of the function to that object.</p>
<p>You can give code in a GROUP! after the static to provide its initial value.</p>
<pre><code> foo: func [x &lt;static&gt; s (5 + 5)] [
      print ["static is" s]
      s: s + x
 ]

 &gt;&gt; foo 20
 static is 10

 &gt;&gt; foo 100
 static is 30

 &gt;&gt; foo 0
 static is 130
</code></pre>
<p>And so on.  So effectively there is code here which is:</p>
<pre><code> make object! [
     s: (5 + 5)
 ]
</code></pre>
<p>Now, what should the specifier/environment for that GROUP! of code be?  We can argue it should be whatever it would be in the spec... the spec block had a context, and then maybe the GROUP! has one that overrides it, but if not it should be the same as the spec.</p>
<p>Under that logic, we expect the following to work:</p>
<pre><code> n: 5

 foo: func [x &lt;static&gt; s (n + 5)] [
      print ["static is" s]
      s: s + x
 ]
</code></pre>
<p>This would seem to mean that the BLOCK! we pass to MAKE OBJECT! doesn't need an environment, relying on MAKE OBJECT! to add the object context so the <strong>s:</strong> has a binding, but then the GROUP! evaluates however it wishes.</p>
<p>And that appears to work, until the statics try to depend on each other:</p>
<pre><code> n: 5

 foo: func [x &lt;static&gt; s1 (5 + 5) s2 (s1 + 5)] [
      print ["statics are" s1 s2]
      s1: s1 + x
      s2: s2 + x
 ]
</code></pre>
<p>(Instances of this were encountered <a href="https://github.com/metaeducation/rebol-httpd/blob/c7ef495f6c3d8f0a9904ac37fcd94f9b1018a5a6/httpd.reb#L316">in the HTTP server</a>.)</p>
<p>If this is to work, you have to somehow allow the object's binding to penetrate the groups.  One avenue of attack could be to unbind the groups and then move the spec's binding onto the block passed to MAKE OBJECT! instead of leaving it unbound.  But if the GROUP! was bound to somewhere in particular vs. just getting the default binding of what was in the spec, you lose that information.</p>
<p>If you're going to try specifically grafting the object's context onto the groups, you might do it more like:</p>
<pre><code> make object! [
     s1: do overbind tip of [] [5 + 5]
     s2: do overbind tip of [] [s1 + 5]  ; s1 + 5 block has established binding
 ]
</code></pre>
<p>I'm using TIP OF there as a way of getting the top thing in the environment, as a way of extracting the object.  Perhaps that could be the default behavior of an OVERBIND instruction (that it should know not to try and deeply insinuate all the way down to the user/lib contexts on top of something that already has contexts).</p>
<p>In order to get things to work for now, I'm going to just unbind the groups, and bind the block passed to make object! to match the spec.  But a better answer is needed.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/binding-contention-visibility-of-statics-to-each-other/2132">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/binding-contention-visibility-of-statics-to-each-other/2132</link>
          <pubDate>Tue, 23 Jan 2024 17:56:51 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2132</guid>
          <source url="https://forum.rebol.info/t/binding-contention-visibility-of-statics-to-each-other/2132.rss">Binding Contention: Visibility of Statics to Each Other</source>
        </item>
        <item>
          <title>The Fate of Redbol Emulation In A Mostly Unbound World</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Redbol</category>
          <description><![CDATA[
            <p>100% Emulation of historical Rebol was always going to be impossible.  But if we go forward with the model that most code is unbound, that's going to break even code that didn't do anything sophisticated with binding.  Not only will any values you PICK out of a block or iterate over be unbound, but even basic quoting won't be bound:</p>
<p>e.g. this won't work:</p>
<pre><code>rebol2&gt;&gt; thing: 10

rebol2&gt;&gt; foo: func [w [word!]] [return get w]

rebol2&gt;&gt; foo 'thing
== 10
</code></pre>
<p>I had a problem with this in emulating my very, very old whitespace interpreter.  It <a href="https://github.com/hostilefork/rebol-whitespacers/blob/1d69ea0e79e60ba79fe680d3af657d0823dcbe9e/historical/whitespace-old.reb#L595">quoted ADD</a> and then <a href="https://github.com/hostilefork/rebol-whitespacers/blob/1d69ea0e79e60ba79fe680d3af657d0823dcbe9e/historical/whitespace-old.reb#L424">put it in a block</a>, expecting a DO of that block to run the ADD it meant.</p>
<h2>
<a name="simulating-waves-of-binding-probably-impractical-1" class="anchor" href="https://forum.rebol.info#simulating-waves-of-binding-probably-impractical-1"></a>Simulating Waves of Binding (Probably?) Impractical</h2>
<p>You might think that so long as every word can still hold a binding, then historical behavior could be simulated by manually binding everything.</p>
<p>When a module loads, you could walk through it binding every word.  Then when a function runs, you could copy its body and walk through it...overwriting those module bindings for functions and arguments.</p>
<p>But it would really mean rewriting everything.  You'd have to redo MAKE OBJECT!, otherwise the <a href="https://forum.rebol.info/t/sticky-set-word-binding-problem-in-make-object/2127">indiscriminate binding would break its expectations</a>--as it doesn't override explicit binding anymore.</p>
<h2>
<a name="hooked-evaluator-may-fix-some-cases-2" class="anchor" href="https://forum.rebol.info#hooked-evaluator-may-fix-some-cases-2"></a>Hooked Evaluator May Fix (Some) Cases</h2>
<p>We already are going to need a hooked evaluator to handle things like PATH! looking up in objects (done presently with a hack to the main evaluator).</p>
<p>Another hook could just say that quoted things wound up bound under the same rules that non-quoted things use.</p>
<p>That would make this one whitespace example work, and maybe it would be able to run some more simple historical example scripts.  But anything that mixes COMPOSE and DO is likely doomed.</p>
<p>This may just be the price of progress.  Rebol2 emulation remains a good experiment of changing your baseline library, and it still would be a good example of that... for all the changes to primitives like FUNC and APPEND etc.  It just may not be able to accommodate the different expectations of binding.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131</link>
          <pubDate>Tue, 23 Jan 2024 15:11:47 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2131</guid>
          <source url="https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131.rss">The Fate of Redbol Emulation In A Mostly Unbound World</source>
        </item>
        <item>
          <title>What is LOAD, Anyway?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <h2>
<a name="ways-to-turn-a-string-into-a-block-in-rebol2-1" class="anchor" href="https://forum.rebol.info#ways-to-turn-a-string-into-a-block-in-rebol2-1"></a>Ways To Turn A String Into A BLOCK! In Rebol2</h2>
<p>There was TO BLOCK!, which would give you unbound code:</p>
<pre><code>rebol2&gt;&gt; code: to block! "print {Hello} x: 10"
== [print "Hello" x: 10]

rebol2&gt;&gt; do code
** Script Error: print word has no context
</code></pre>
<p>And then there was LOAD, which would bind code into the user context, falling back on the lib context:</p>
<pre><code>rebol2&gt;&gt; code: load "print {Hello} x: 10"
== [print "Hello" x: 10
]

rebol2&gt;&gt; do code
Hello
== 10

rebol2&gt;&gt; x
== 10
</code></pre>
<p>LOAD had an additional option of /NEXT, so you could go one item at a time:</p>
<pre><code>rebol2&gt;&gt; load/next "print {Hello} x: 10"
== [print " {Hello} x: 10"]
</code></pre>
<p>The block you get back has the item scanned as the first element, and then the rest of the string as a remainder.</p>
<p>What you receive is bound into the user/lib contexts, so this actually works:</p>
<pre><code>&gt;&gt; do load/next "print {Hello} x: 10"
{Hello} x: 10
</code></pre>
<h2>
<a name="refactoring-things-in-terms-of-transcode-2" class="anchor" href="https://forum.rebol.info#refactoring-things-in-terms-of-transcode-2"></a>Refactoring Things In Terms of TRANSCODE</h2>
<p>A goal of R3-Alpha was to support modularization, and ambitiously to make the module system itself implemented as usermode code.  So LOAD would not be native.</p>
<p>The code for scanning UTF-8 strings into unbound Rebol values one-at-a-time was done via TRANSCODE.  But because R3-Alpha added unicode support, it had a quirk that it only took BINARY!, because Rebol strings could be encoded under the hood as 1, 2, or 3 bytes per character:</p>
<pre><code>r3-alpha&gt;&gt; transcode/next to binary! "print {Hello} x: 10" 
== [print #{207B48656C6C6F7D20783A203130}]
</code></pre>
<p>You could also transcode things entirely in one go, but the result would still have an empty binary at the end:</p>
<pre><code>r3-alpha&gt;&gt; transcode to binary! "print {Hello} x: 10"
== [print "Hello" x: 10 #{}]
</code></pre>
<p>Ren-C improved on this in several ways.</p>
<ul>
<li>
<p><a href="https://forum.rebol.info/t/realistically-migrating-rebol-to-utf8-everywhere/374">Uses "UTF-8 Everywhere"</a>, and is technically able to accept a string anywhere a UTF-8 binary would otherwise be required... if it makes sense to do so.  You can transcode strings without making a copy as a UTF-8 binary first.</p>
</li>
<li>
<p>Multi-return values allowed the separation of the remainder into its own result.  It is NULL when transcode is used without a /NEXT refinement (renamed to /ONE)</p>
</li>
<li>
<p>Antiforms not being legitimate block elements allow the distinction of "nothing scanned" as a main result from TRANSCODE/ONE</p>
<ul>
<li><a href="https://github.com/red/red/issues/5183">See Red spin their wheels on this point, due to lack of isotopes.</a></li>
</ul>
</li>
</ul>
<p>The results of TRANSCODE were unbound, leaving it up to higher-level functions to add binding if they wanted to.</p>
<h2>
<a name="so-now-what-is-load-and-what-is-save-3" class="anchor" href="https://forum.rebol.info#so-now-what-is-load-and-what-is-save-3"></a>So Now, What Is LOAD (and What Is SAVE)?</h2>
<p>I don't really know.</p>
<p>It's clear you're supposed to give LOAD a file, and it gives you something back.  But if the file contains a script, it seems to me that all load can give you back is some kind of MODULE! that the only thing you can do with it is DO it (once?) or IMPORT it (possibly many times?)... in which case, why did you need the middle man of LOAD?</p>
<p>Right now that's kind of where things stand in Ren-C... that LOAD is an implementation artifact of DO and IMPORT, used nowhere else.</p>
<p>R3-Alpha had an example where it could do something like this:</p>
<pre><code>r3-alpha&gt;&gt; save/header %test.r "Hello World" [Title: "My Hello"]

r3-alpha&gt;&gt; read/string %test.r
== {REBOL [
    Title: "My Hello"
]
"Hello World"
}

r3-alpha&gt;&gt; load %test.r
== "Hello World"
</code></pre>
<p>If you try this with a BLOCK!, it will just be the block's contents... not the whole block:</p>
<pre><code>r3-alpha&gt;&gt; save/header %test.r [a [b c] d] [Title: "My Block"]

r3-alpha&gt;&gt; read/string %test.r
== {REBOL [
    Title: "My Block"
]
a [b c] d
}

r3-alpha&gt;&gt; load %test.r
== [a [b c] d]
</code></pre>
<p>There's no enclosing block saved, and yet it's interpreted as the contents of a block.  Hm, so what if the block had contained "Hello World"?  Well, the block is of course lost in that case:</p>
<pre><code>r3-alpha&gt;&gt; save/header %test.r ["Hello World"] [Title: "My Hello Block"]

r3-alpha&gt;&gt; load %test.r
== "Hello World"
</code></pre>
<p>We could arguably "fix" this using isotopes, e.g. SAVE could take a splice if you wanted the values to be spread in the script... otherwise it would preserve your value.  But in order for me to make decisions like "is this reasonable?" I have to know what the use case is.  And I don't know what it is.  Are LOAD and SAVE some kind of generic value-to-file service?  Or are they specifically for scripts?</p>
<h2>
<a name="practical-matter-bootstrap-rebmake-code-4" class="anchor" href="https://forum.rebol.info#practical-matter-bootstrap-rebmake-code-4"></a>Practical Matter: Bootstrap Rebmake Code</h2>
<p>There's code in the bootstrap which says:</p>
<pre><code>user-config: make object! load (join repo-dir %configs/default-config.r)
</code></pre>
<p>Then <code>%default-config.r</code> has lines in it like <strong>os-id: null</strong>.  It expects to be able to resolve NULL to a definition, e.g. the one in LIB.  But we don't want to bind into LIB directly (too easy to do dangerous modifications).  So does LOAD always create a new context?  Here we want an object, not a module... this is important to distinguish because the techniques used by modules don't scale.  So if someone is going to LOAD thousands of objects, they shouldn't be modules... :-/</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/what-is-load-anyway/2130">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/what-is-load-anyway/2130</link>
          <pubDate>Tue, 23 Jan 2024 15:02:01 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2130</guid>
          <source url="https://forum.rebol.info/t/what-is-load-anyway/2130.rss">What is LOAD, Anyway?</source>
        </item>
        <item>
          <title>The Return of ALIAS?</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>Rebol2 had a strange concept of the ability to create aliases for words:</p>
<pre><code>rebol2&gt;&gt; alias 'append "foo"
== foo

rebol2&gt;&gt; foo [a b c] &lt;d&gt;
== [a b c &lt;d&gt;]

rebol2&gt;&gt; foo: 10
== 10

rebol2&gt;&gt; append
== 10
</code></pre>
<p><em>(You might wonder why it takes a string, vs. being <strong>alias 'append 'foo</strong>.  The problem is that if you tried that, the fact that merely mentioning words creates variables for them in historical Rebol would mean that FOO appeared to already exist as an unset variable.  The alias wouldn't override it.)</em></p>
<p>So I've actually been wondering about a more modern version of ALIAS.  Because right now we have a sort of pain point on the idea that you can only create bound references to something when the names match up exactly.  If you have the thing under a different name, then you have to create a proxy variable to hold the value with the right name... but then you disconnect seeing updates of the original thing.</p>
<p>This could be particularly useful in module imports, where currently you don't see updates if something you import changes in the module you imported from.  EXPORT should likely default to providing declarations as read-only, and you should have to do something special if the importers can write a variable.  But it's come up frequently (both the desire to see updates, and to be able to write and have the changes seen by the module and other importers, without going through a level of indirection like an object)</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/the-return-of-alias/2129">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/the-return-of-alias/2129</link>
          <pubDate>Mon, 22 Jan 2024 15:07:13 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2129</guid>
          <source url="https://forum.rebol.info/t/the-return-of-alias/2129.rss">The Return of ALIAS?</source>
        </item>
        <item>
          <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>I've written about Rebol's historical idea of walking the source deeply at the beginning, and the <a href="https://forum.rebol.info/t/the-real-story-about-user-and-lib-contexts/764">mere mention of an ANY-WORD!</a> would lead to a variable being created for it in the user context.  This chewed through memory making unnecessary variables, and gave you a situation ripe for typos:</p>
<pre><code> rebol2&gt;&gt; add-ten: func [argument] [
              argment: argument + 10
              return argument
           ]

 rebol2&gt;&gt; add-ten 20
 == 20

 rebol2&gt;&gt; argment
 == 30
</code></pre>
<p>This behavior resembles <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">pre-strict-mode JavaScript</a>, and makes it easy to get bugs</p>
<p>But it's a semantic that some code uses intentionally.  And if Rebol2 emulation is to be possible, there has to be some way to do this.</p>
<p>It's also a useful way to work in the console.  Browsers still run JavaScript in non-strict-mode by default:</p>
<pre><code>&gt;&gt; function foo() { jkl = 10 }
&lt;- undefined

&gt;&gt; foo()
undefined

&gt;&gt; jkl
&lt;- 10
</code></pre>
<h2>
<a name="simulating-non-strictness-with-attachment-binding-1" class="anchor" href="https://forum.rebol.info#simulating-non-strictness-with-attachment-binding-1"></a>Simulating Non-Strictness With "Attachment" Binding</h2>
<p>In order to overcome the idea of creating variables for every ANY-WORD! to be mentioned, the "Sea of Words" concept was first implemented by making code loaded for a module bind non-specifically to that module.  Words held a pointer to the module with no further information about the address of a variable in that module.  This was called the "attached" state.</p>
<p>If you tried to read from an attached word, it would fail.  But if you wrote to an attached word, it would create a variable.  This gave the experience of non-strict mode, without a-priori creating tons of variables.</p>
<p>But this creates weird words that are neither fully bound nor fully unbound.  And you can't take being in the "attached" state to mean the variable does not exist in the module... because more than one attached reference to the word could have been created, and one of them might have been used to create it... not knowing about the other word's attached state to fix it up.  Or perhaps the variable was created explicitly in the module--not via any particular assignment.</p>
<h2>
<a name="should-words-be-storing-environments-2" class="anchor" href="https://forum.rebol.info#should-words-be-storing-environments-2"></a>Should Words Be Storing "Environments"?</h2>
<p>Historically, bound words would store the specific "address" of variables (most of the time object plus index), while unbound words would store nothing.</p>
<p>Attachment introduced a new situation where an "unbound" word could hold a pointer to a module, where the word would be created if a SET or SET-WORD! operation were performed.</p>
<p>But if objects and environments can expand, is there a good reason why the "attachment" should have been to a particular module... or should it be attached to an environment?  If the specifier for a piece of code has an OBJECT! to look in first, and then a MODULE!... and a lookup doesn't find it in either, why should it become "attached" only to the module?  What if it shows up in the object before you write it?</p>
<p>Taking this to the extreme: Why should only "unbound"/"attached" things be able to see overrides that come along later on?  Why don't words store environments always, and look up every time...to be able to find new things?</p>
<h2>
<a name="ok-back-up-3" class="anchor" href="https://forum.rebol.info#ok-back-up-3"></a>Ok, Back Up.</h2>
<p>It seems that once a word has been bound, it needs to stay bound to where it is.  e.g. the following seems bad:</p>
<pre><code>&gt;&gt; word: in [] 'foo
== foo

&gt;&gt; protect word  ; make sure no one changes FOO's value

&gt;&gt; set word 10
== 10

&gt;&gt; some-arbitrary-routine
== &lt;whatever&gt;  ; didn't error, so didn't try to write foo

&gt;&gt; get word
== 20  ; !!! it wasn't written, so how?
</code></pre>
<p>We'd lose some grounding if bound words weren't stable.  It also would hurt performance, because words would have to be looked up in the environment chain every time.</p>
<p>BUT we're saying that the <strong>IN</strong> operation does this lookup, and may get different results if the environment changes.  That's pretty much a given: the evaluator runs an equivalent to IN, and this is why when you run a function several times you get different bindings to different frames from the same unbound words as input.</p>
<h2>
<a name="contain-the-weirdness-to-attachment-4" class="anchor" href="https://forum.rebol.info#contain-the-weirdness-to-attachment-4"></a>Contain The Weirdness To "Attachment"</h2>
<p>This points the finger at "attachment" binding being a narrow, weird thing... whose job is solely to simulate the idea that a variable exists that doesn't.</p>
<p>Sea of Words made it a shallow illusion, e.g. it didn't let you GET/ANY the variable and get it back as being trash--you'd get an error instead.  There's risks to deepening the illusion, because you'd have to make module enumeration give back every possible word as a variable.  :-/</p>
<p>So I think attachment should be to a module (not an environment) and it should be considered as bound for most practical purposes (it would need to be, for Rebol2 compatibility).</p>
            <p><small>5 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128</link>
          <pubDate>Mon, 22 Jan 2024 14:47:39 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2128</guid>
          <source url="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss">Caching Binding Lookup, and &quot;Attachment Binding&quot;</source>
        </item>
        <item>
          <title>Sticky SET-WORD! Binding Problem In MAKE OBJECT!</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <p>Trying to use the policy that bindings don't override, I ran into a bug with MAKE OBJECT! when a SET-WORD! is carrying a pre-existing binding.</p>
<p>What happens is that a new field is made (cued by seeing a top-level SET-WORD!) but then when the body is executed it uses the old binding... so the newly created field remains unassigned, and the old value is updated.</p>
<pre><code>&gt;&gt; obj: make object! [x: 10]
== make object! [
    x: 10
]

&gt;&gt; block: compose [(bind 'x: obj) &lt;new&gt;]
== [x: &lt;new&gt;]

&gt;&gt; obj2: make object! block
== make object! [
    x: ~
]

&gt;&gt; obj
== make object! [
    x: &lt;new&gt;
]
</code></pre>
<p>This hints at a class of hard-to-reason-about cases.  The more you use material with hardened bindings, the more you'll see them come up.</p>
<p>(I hit the problem in the whitespace dialect code, which is still using mutable binding when it probably should not... but, it gives a good example of a problem that happens if you do... and if we're living in the non-binding-overriding world.)</p>
<p>For the moment, I think I'm going to say that MAKE OBJECT! will error if any of the SET-WORD!s in the top level already have a binding.</p>
<ul>
<li>
<p>Binding can't serve two masters.  If the code were more complex than the above, it's not clear to say that the original binding didn't mean what it said in terms of intending a specific assignment... vs wanting to be overridden.</p>
</li>
<li>
<p>I don't want fundamentals like this to use mutable binding, and to get this to work virtually at one-level of depth would require a tricky bind instruction that I don't want to deal with right now.</p>
</li>
</ul>
<p>I'd say it's the first "major" problem I've seen in practice from a policy of not overriding binding (in the sense that it's fairly hard to argue "well, maybe you wanted that").</p>
            <p><small>4 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/sticky-set-word-binding-problem-in-make-object/2127">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/sticky-set-word-binding-problem-in-make-object/2127</link>
          <pubDate>Sat, 20 Jan 2024 00:21:21 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2127</guid>
          <source url="https://forum.rebol.info/t/sticky-set-word-binding-problem-in-make-object/2127.rss">Sticky SET-WORD! Binding Problem In MAKE OBJECT!</source>
        </item>
        <item>
          <title>DO of TEXT! As Synonym of DO of FILE! Containing String</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Modules</category>
          <description><![CDATA[
            <p>So DO in Rebol and Red of a string has classically been what we might think of today as:</p>
<pre><code>do in system.contexts.user transcode string
</code></pre>
<p>Sample behavior:</p>
<pre><code>rebol2&gt;&gt; var: 10
== 10

rebol2&gt;&gt; do "var: var + 20 print [var]"
30

rebol2&gt;&gt; var
== 30
</code></pre>
<p>So not only could it see VAR, it could change it.</p>
<p>This seems obviously bad in a modularized world, in the sense that if you DO a string somewhere besides the console (e.g. in a module) you're getting no effects where you likely intend them, and causing effects somewhere else.</p>
<p>Ren-C addresses this by isolating the DO (as it would a module), which seems like the only sane idea.  If you have a string representing code and want to run it in the current context, you need a binding operation, e.g.:</p>
<pre><code>do in [] transcode string
</code></pre>
<h2>
<a name="quirks-with-header-handling-in-string-input-1" class="anchor" href="https://forum.rebol.info#quirks-with-header-handling-in-string-input-1"></a>Quirks With Header Handling In String Input</h2>
<p>If you DO a string with a header, it appears to be handled:</p>
<pre><code>rebol2&gt;&gt; do "Rebol [] print {Hello}"
Hello
</code></pre>
<p>BUT it's actually not being handled in Rebol2.  It's just that historically, Rebol has been the system object:</p>
<pre><code>rebol2&gt;&gt; words-of rebol
== [version build product core components words...]
</code></pre>
<p>So the DO was actually evaluating Rebol to an OBJECT!, ignoring it, then evaluating a block, and ignoring that.  To see that this is what's happening:</p>
<pre><code>rebol2&gt;&gt; unprotect 'Rebol

rebol2&gt;&gt; Rebol: does [print "Boo"]

rebol2&gt;&gt; do "Rebol [] print {Hello}"
Boo!
Hello
</code></pre>
<p>R3-Alpha changed this, so that if you do a string starting with the word "Rebol" then it will interpret the subsequent block as a header, and use that to guide the loading process of the string... which might mean interpreting it into something besides a block (e.g. a module):</p>
<pre><code>r3-alpha&gt;&gt; do {REBOL [Type: Module Options: [isolate]] xyz: &lt;hi&gt;}  
Module: "Untitled" Version: none Date: none

r3-alpha&gt;&gt; xyz
** Script error: xyz has no value
</code></pre>
<p>There's a quirk in that if you do a BLOCK! directly instead of a string, you get the old REBOL-evaluates-as-an-OBJECT! ignoring the block behavior (<a href="https://github.com/metaeducation/rebol-issues/issues/2372">issue 2372</a>)</p>
<pre><code>r3-alpha&gt;&gt; do [REBOL [Type: Module Options: [isolate]] xyz: &lt;hi&gt;] 
== &lt;hi&gt;

r3-alpha&gt;&gt; xyz
== &lt;hi&gt;
</code></pre>
<p>To help mitigate this, the word "Rebol" is defined to generate an error by default under evaluation in Ren-C (the system object is SYSTEM or alias as SYS)</p>
<p>In any case, the idea here is that since headers are used to dictate how code is loaded and bound, if you have a BLOCK! it has already gone through that process.</p>
<h2>
<a name="do-of-a-text-should-require-a-header-2" class="anchor" href="https://forum.rebol.info#do-of-a-text-should-require-a-header-2"></a>DO of a TEXT! Should Require A Header</h2>
<p>All Rebol2 files processed by LOAD and DO of a FILE! (or URL!) are supposed to have a header:</p>
<pre><code>rebol2&gt;&gt; write %code.r "print {Hello World}"

rebol2&gt;&gt; do %code.r
** Syntax Error: Script is missing a REBOL header
</code></pre>
<p>R3-Alpha doesn't enforce that, which was a step backwards in many people's opinions (including mine).</p>
<pre><code>r3-alpha&gt;&gt; write %code.r "print {Hello World}"

r3-alpha&gt;&gt; do %code.r
Script: none Version: none Date: none
Hello World
</code></pre>
<p>If you have code without a header in a file, then it's your job to TRANSCODE that yourself into a block and do whatever binding or processing you need to do to get it to run.</p>
<p>But considering that, it seems to me that DO of a TEXT! should need a header, and be a synonym for DO LOAD of the text.  Having a header would help reinforce that you really are running this code like a script in its isolated environment.  And it means that if you got your script data from some random place, you don't have to write it to a file just to get DO to process the header.</p>
<h2>
<a name="splitting-do-and-eval-is-likely-important-3" class="anchor" href="https://forum.rebol.info#splitting-do-and-eval-is-likely-important-3"></a>Splitting DO and EVAL Is Likely Important</h2>
<p>When you add all this up, it may suggest we should separate DO and EVAL completely (which was a long-running opinion of <span class="mention">@earl</span> from back in the day).</p>
<p><strong>eval block</strong> is a little bit longer than <strong>do block</strong> but not by much.</p>
<p>One benefit could be that if we shift away from assuming that DO is something that runs just Rebol code, we can say that it gets its knowledge from the file itself.  This could come from the extension (e.g. <strong>do %some-file.js</strong> could run javascript code, <strong>do %some-file.css</strong> could incorporate CSS).</p>
<p>Another potentially good argument is that the amount of parameterization for DO could roughly wind up matching <a href="https://forum.rebol.info/t/design-for-import/1570">the amount of parameterization for IMPORT</a>.  This might suggest even that DO be arity-2 in all cases instead of having a refinement form of DO/ARGS.  That would allow for a content type override if you were DO-ing a string:</p>
<pre><code>do css-source-text [Type: 'css]
</code></pre>
<p>Though single-arity DO is pretty entrenched.  Maybe DO of a BLOCK! does expect that block to have a header structure, so you could add that header:</p>
<pre><code>do compose [Rebol [Type: 'css] (css-source-text)]
; -or-
do compose [CSS [&lt;options for merging CSS in ReplPad&gt;] (css-source-text)]

do compose [Rebol [] (spread transcode rebol-source-text)]
</code></pre>
<h2>
<a name="regardless-do-of-a-text-needs-a-header-4" class="anchor" href="https://forum.rebol.info#regardless-do-of-a-text-needs-a-header-4"></a>Regardless, DO of a TEXT! Needs a Header</h2>
<p>This strikes me as non-negotiable, so I went ahead to with this, and hit a few issues.</p>
<p>DO-ing text directly with no intermediate processing step is a rarely needed operation, so it doesn't come up much.  But I did trip over two issues:</p>
<h3>
<a name="issue-do-on-the-command-line-5" class="anchor" href="https://forum.rebol.info#issue-do-on-the-command-line-5"></a>Issue: --do On The Command Line</h3>
<p>First thing I hit was the question of the <strong><code>--do "your code here"</code></strong> command line option.  This is a little annoying, because you don't have the option of saying <strong><code>--do [your code here]</code></strong> at that particular place.</p>
<p>I can attest to the fact that I'd be annoyed if I had to put a header there.  But then... what if I wanted a header's influence... settings to direct the execution of that code?</p>
<p>This again seems to suggest a split of --eval and --do.  Use --do if you have a header, and --eval if you don't.  Since EVAL wouldn't take strings, the idea that the command line presumes you want the string bound in the "default sense" (e.g. what would happen if you typed in the console) seems fine.</p>
<p>It may be that DO of a BLOCK! running Rebol code is just so ingrained that it isn't changeable.  If that's the case, then saying <code>--do</code> takes the block interpretation of the string you pass it is probably not a big issue, and then <code>--do {do {Rebol [] ...}}</code> can be how you inject a header on the command line.</p>
<h3>
<a name="issue-does-for-doing-code-6" class="anchor" href="https://forum.rebol.info#issue-does-for-doing-code-6"></a>Issue: DOES for doing code</h3>
<p>This isn't really about the DO-needs-a-header-on-string, but another thing I noticed pertaining to a potential DO/EVAL split.</p>
<p>DOES is a shorthand for defining a LAMBDA with no arguments.</p>
<pre><code>&gt;&gt; foo: does [1 + 2]

&gt;&gt; foo
== 3
</code></pre>
<p>For reasons of consistency, Ren-C extended it so it would run anything DO would process:</p>
<pre><code>&gt;&gt; foo: does %your-script.r

&gt;&gt; foo
Running your script...
</code></pre>
<p>That's hardly an important feature <em>(<code>foo: does [do %your-script.r]</code> is easy enough to say if it ever actually comes up, which it has not.)</em>  But it raises a question about using the word DOES in light of a DO and EVAL split.  DOES contains the word DO and might suggest a connection with DO's behavior and not EVAL's.</p>
<p>Perhaps RUN could be the script-oriented runner, with DO keeping the role of EVAL... though right now I'm using RUN for executing frames and gathering arguments at the callsite (a kind of inline APPLY).  That would need another name.</p>
<p>Perhaps EVALS is not so bad as an alternative to DOES?  :-/</p>
<pre><code>&gt;&gt; foo: evals [print "hi"]

&gt;&gt; foo
hi
</code></pre>
<p>No, it's bad.  I'm not a fan.</p>
<p>Or maybe the inconsistency that DOES has little relation to DO is not a big deal.  But inconsistency bothers me (which is why I made <strong>does x</strong> a synonym for <strong>lambda [] [do x]</strong> for all X, despite likely uselessness for non-block X.)</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/do-of-text-as-synonym-of-do-of-file-containing-string/2125">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/do-of-text-as-synonym-of-do-of-file-containing-string/2125</link>
          <pubDate>Fri, 19 Jan 2024 12:38:09 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2125</guid>
          <source url="https://forum.rebol.info/t/do-of-text-as-synonym-of-do-of-file-containing-string/2125.rss">DO of TEXT! As Synonym of DO of FILE! Containing String</source>
        </item>
        <item>
          <title>Making FUNC Variant That Auto-Returns Last Result</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Functions</category>
          <description><![CDATA[
            <p>I had offered that people could use this simple wrapper to get the old behavior of FUNC, to drop out its last result (instead of returning trash):</p>
<pre><code>func: adapt :lib.func [body: compose [return (as group! body)]]
</code></pre>
<p>The concept is that if you write:</p>
<pre><code> foo: func [x] [
     if x &lt; 0 [return x + 10]
     x - 10
 ]
</code></pre>
<p>What you'd actually get would be:</p>
<pre><code> foo: lib.func [x] [
     return (
         if x &lt; 0 [return x + 10]
         x - 10
     )
 ]
</code></pre>
<h2>
<a name="broken-under-new-binding-model-1" class="anchor" href="https://forum.rebol.info#broken-under-new-binding-model-1"></a>Broken Under New Binding Model</h2>
<p>Under the new binding model, an array which is bound will by default hold onto its binding.</p>
<ul>
<li>
<p>The BODY was a BLOCK! that evaluated at the callsite and captured its environment (e.g. to the user context, module context, outer function context, etc.)</p>
</li>
<li>
<p>When you convert it to a GROUP! it will still have that binding.</p>
</li>
<li>
<p>The surgery which is done to inject the frame containing X into the environment will thus apply only at the outermost level.  So the outer block where the return lives would see it, but never make it to the inner group.</p>
<pre><code>func: adapt :lib.func [
    body: compose [
        print ["Here would see the X:" x]
        return (as group! body)  ; &lt;-- inside group will not
    ]
]
</code></pre>
</li>
</ul>
<h2>
<a name="mimicking-funcs-surgery-2" class="anchor" href="https://forum.rebol.info#mimicking-funcs-surgery-2"></a>Mimicking FUNC's Surgery</h2>
<p>One idea would be to use a utility that can do something like what LIB.FUNC did to put the frame onto the proxy body, on the original body.</p>
<p>But awkwardly, you can't do this surgery inside the COMPOSE, because it has to be done once the function is running.  If we call that surgery OVERBIND, one answer would look something like this:</p>
<pre><code>func: adapt :lib.func [
    body: compose [
        return do overbind binding of in [] 'return (body)
    ]
]
</code></pre>
<p><em>(I'll mention that this OVERBIND is not as efficient as what FUNC does, because the frame itself has a pointer to the inherited environment when it's made.  But it only has one slot for that pointer.  So if you try to build a specifier chain with the frame that points to another environment, it has to fabricate a "frame holder" which has its own pointer to put in the chain.)</em></p>
<p>Notice that we only want the frame, here... which we get from the binding of the RETURN.  We don't want to inject awareness of everything in this FUNC adaptation's scope.  So not <strong><code>overbind [] (body)</code></strong>.  If such a thing were even legal to do... body probably has its own copy of lib inherited from another module, and then you've got another module and its lib... we're trying to avoid that kind of conundrum with conservative binding preservation.</p>
<h2>
<a name="another-approach-steal-the-binding-and-unbind-3" class="anchor" href="https://forum.rebol.info#another-approach-steal-the-binding-and-unbind-3"></a>Another Approach: Steal The Binding And Unbind</h2>
<p>Another approach would be to steal the binding off of the body and put it on the composition, then remove the binding from the body:</p>
<pre><code>func: adapt :lib.func [
    body: in body bindable compose [
        return (bindable as group! body)
    ]
]
</code></pre>
<p>You can put the BINDABLE before or after the AS GROUP!.</p>
<p>I actually think this reads less insanely if we just go with UNBIND as being a "tip-unbinding" operation by default, and then have UNBIND/DEEP.  <em>(Maybe UNBIND/SHALLOW for one level of depth?)</em>:</p>
<pre><code>func: adapt :lib.func [
    body: in body unbind compose [
        return (as group! unbind body)
    ]
]
</code></pre>
<p>It's much better to do it this way.  You're doing cheaper operations and doing them at FUNC creation time.</p>
<h2>
<a name="note-that-i-still-hate-implicit-return-4" class="anchor" href="https://forum.rebol.info#note-that-i-still-hate-implicit-return-4"></a>Note That I Still Hate Implicit RETURN</h2>
<p>There's a reason the default FUNC doesn't do it.  If you start doing cool things with RETURN you'll break things in a way that lurks.</p>
<p>Sample cool thing that works today:</p>
<pre><code> foo: func [x y] [
     return: adapt augment :return [arg2] [
         value: meta ((unmeta value) + arg2)  ; return ^VALUE is meta
     ]
     if x &gt; 10 [
         return x y  ; arity 2 return, adds args and returns sum!
    ]
]

&gt;&gt; foo 20 30
== 50

&gt;&gt; foo 5 5
== ~  ; anti
</code></pre>
<p>If anything, I feel like the trash result isn't going far enough--and it should actually error if you skip out on a return.  Maybe there was some important finalization work to do.</p>
<p>But my example shows that putting it in implicitly means it doesn't necessarily roll with whatever updated definition you give to return.  You'll just get a confusing error in a bit of hidden code.  Not good for a fundamental part.</p>
            <p><small>3 posts - 2 participants</small></p>
            <p><a href="https://forum.rebol.info/t/making-func-variant-that-auto-returns-last-result/2124">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/making-func-variant-that-auto-returns-last-result/2124</link>
          <pubDate>Thu, 18 Jan 2024 19:23:59 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2124</guid>
          <source url="https://forum.rebol.info/t/making-func-variant-that-auto-returns-last-result/2124.rss">Making FUNC Variant That Auto-Returns Last Result</source>
        </item>
        <item>
          <title>Case-Insensitivity And Dialecting</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Dialects/DSLs</category>
          <description><![CDATA[
            <p>Today's Ren-C uses case-sensitive binding.  The topic has been discussed a lot:</p>
<p><a href="https://forum.rebol.info/t/case-insensitivity-vs-case-preservation-cant-have-both/1439" class="inline-onebox">Case Insensitivity vs. Case-Preservation (can't have both?)</a></p>
<p>As a discipline, we still are trying to keep the language lowercase, in the standard library at least.</p>
<p>But one thing that hasn't been discussed much is how case could be used creatively in dialects, when you know the case doesn't matter.  I think that in certain domains, use of case in dialects could be an interesting tool.</p>
<h2>
<a name="using-casing-to-imply-uppercase-lowercase-as-is-case-1" class="anchor" href="https://forum.rebol.info#using-casing-to-imply-uppercase-lowercase-as-is-case-1"></a>Using Casing To Imply Uppercase, Lowercase, As-Is Case</h2>
<p>I've written a little about how the <a href="https://forum.rebol.info/t/usefulness-of-string-interpolation/2114">CScape interpolation tool</a> does casing.  That's strings and not ordinary code.</p>
<p>The case logic would work in ordinary code something like this:</p>
<pre><code>&gt;&gt; strings: ["aBc" "dEf" "gHi]

&gt;&gt; cased-print ["For instance:" STRINGS.1 strings.2 Strings.3]
For instance: ABC def gHi
</code></pre>
<p>It might seem silly, but in CScape it turns out to be pretty useful to do that.</p>
<h2>
<a name="non-case-related-example-hardening-bindings-2" class="anchor" href="https://forum.rebol.info#non-case-related-example-hardening-bindings-2"></a>Non-Case-Related Example: "Hardening" Bindings</h2>
<p>We have an issue now that sometimes when you are composing material you want bindings to "stick".  Here we want LET and PASSTHRU to be bound to the same environment as the block given to the COMPOSE (which propagates to the GROUP!s, and then to the blocks evaluated in the groups).  But we want RETURN to be unbound, and pick up its binding from the site where it is composed:</p>
<pre><code> compose [
     (in [] 'let) (name): (in [] 'passthru) :return
 ]
</code></pre>
<p>There could be some dialect options for this... a special signal, maybe something you pass:</p>
<pre><code>compose/harden [
    &lt;hard&gt; let (name): &lt;hard&gt; passthru :return
] &lt;hard&gt;

compose/harden [
    %h let (name): %h passthru :return
] %h

compose/harden [
    $ let (name): $ passthru :return
] $
</code></pre>
<p>Since you have groups available, you could get the literal of the thing you're hardening with, e.g. with <code>(&lt;hard&gt;)</code> or <code>(%h)</code> or <code>($)</code></p>
<p>And of course, you could have an operation that reverses this...so that things were hardened by default but you escaped to leave them unbound.</p>
<p>But... a weirder idea... what if you used something like the case?</p>
<pre><code> weird-compose [
     LET (unbind name): PASSTHRU :return
 ]
</code></pre>
<p>Important to remember is that symbols don't have case.  So you can't use the trick for everything.</p>
<p>But I present this in juxtaposition to using even the most minimal signal (like $) just to show how much the comprehensibility can benefit.</p>
            <p><small>1 post - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/case-insensitivity-and-dialecting/2123">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/case-insensitivity-and-dialecting/2123</link>
          <pubDate>Wed, 17 Jan 2024 22:33:15 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2123</guid>
          <source url="https://forum.rebol.info/t/case-insensitivity-and-dialecting/2123.rss">Case-Insensitivity And Dialecting</source>
        </item>
        <item>
          <title>Functions That Capture the Current &quot;Evaluation Environment&quot;</title>
          <dc:creator><![CDATA[hostilefork]]></dc:creator>
          <category>Binding</category>
          <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="bradrn" data-post="11" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/40/365_2.png" class="avatar"><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/11">Custom Function Generator Pitfalls</a>
</div>
<blockquote>
<p>Indeed, there would have to be a notion of the ‘currently active environment’ from which unbound words lookup their names. (...)  Surely <a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">specifiers</a> require the same kind of concept already?</p>
</blockquote>
</aside>
<p>This sounds very <a href="https://forum.rebol.info/t/lisps-kernel-clojure-limits-of-code-is-data-and-data-is-code/2060">Kernel-like</a>, e.g.</p>
<pre><code>foo: func [block &lt;environment&gt; env] [
    print mold block
    print [env.x env.y]
]

bar: func [x] [
   let y: 20
   foo [x + y]
]

&gt;&gt; bar 10
[x + y]
10 20
</code></pre>
<p>It's true that specifiers have been creeping toward being able to offer something like this functionality.  But they were originally made with a particular mix of correctness and optimization in mind for combining FRAME! instances with "relativized" function bodies, so that simple index numbers could be used to find instance variables.  Extending them has been experimental to permit things like LET but they're fairly brittle at present.</p>
<p>Today's specifiers narrow the fiddling to literals.  e.g. <strong>if foo [x + y]</strong> would have the specifier influence [x + y], but if you'd written <strong>if foo (block)</strong> the specifier wouldn't affect the passed-in block...so it's different from a situation where IF was receiving an environment.</p>
<hr>
<p><strong>I'm worried about a generalized <code>&lt;environment&gt;</code> becoming available... and especially if such an out-of-band parameter sneaks in and affecting the behavior of fundamentals like COMPOSE or EITHER etc.</strong></p>
<p>Once you have this out of band parameter, you have the problem of what happens when things get a step removed and you need to start making it passed in-band.  (e.g. the difference between a function that calls COMPOSE directly vs. a function that calls a function that calls COMPOSE, where the intended environment of influence comes from the outermost call).</p>
<p>You also start getting some strange combinatorics of how much influence the environment is supposed to have in an operation vs. any existing binding on the passed in items.  So I'd generally been going with the idea that the evolution of binding from being "just on words" to being "on words and arrays" would keep with the spirit that the way to tunnel "environments" through is to use mechanisms that put them granularly on your arguments vs. relying on this parameter.</p>
<p>For the vast majority of code, I like the idea that whatever is done with environments gets those environments pasted onto the values themselves, so that things like GET and COMPOSE remain single-arity in an abstractable way, so that they can also be abstracted as single-arity functions without introducing quandaries from sometimes-implicit environment parameters.</p>
            <p><small>2 posts - 1 participant</small></p>
            <p><a href="https://forum.rebol.info/t/functions-that-capture-the-current-evaluation-environment/2122">Read full topic</a></p>
          ]]></description>
          <link>https://forum.rebol.info/t/functions-that-capture-the-current-evaluation-environment/2122</link>
          <pubDate>Tue, 16 Jan 2024 10:31:44 +0000</pubDate>
          <discourse:topicPinned>No</discourse:topicPinned>
          <discourse:topicClosed>No</discourse:topicClosed>
          <discourse:topicArchived>No</discourse:topicArchived>
          <guid isPermaLink="false">forum.rebol.info-topic-2122</guid>
          <source url="https://forum.rebol.info/t/functions-that-capture-the-current-evaluation-environment/2122.rss">Functions That Capture the Current &quot;Evaluation Environment&quot;</source>
        </item>
  </channel>
</rss>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Default Values And MAKE FRAME!</title>
    <link>https://forum.rebol.info/t/default-values-and-make-frame/1412</link>
    <description>Something you may notice when you MAKE FRAME! is that all the fields start out VOID (hence we say the variables are &quot;unset&quot;):

    ; Remember that the QUASI! of NULL would be QUOTED!
    ; e.g. [series: &#39;~] --  But since these tildes are not quoted they imply
    ; evaluation, which would set the variables to void (e.g.)

    &gt;&gt; f: make frame! :append
    == make frame! [
        series: ~
        value: ~
        part: ~
        only: ~
        dup: ~
        line: ~
    ]

## It&#39;s Critical These Are Isotopes And Not NULL

**The most important reason is that when a function is invoked, its frame cannot actually contain any isotopes.**  So they can be out-of-band, and safely represent the intent of an unspecialized parameter.

Isotopes can only be passed as arguments is if they are ^META parameters...and this means their value in the frame will have been pre-processed into a plain BAD-WORD!.

Why is it plain?  Well, remember the META behaviors:

    &gt;&gt; meta null  ; META of pure NULL gives BLANK!
    _

    &gt;&gt; ~whatever~  ; evaluation of a plain QUASI! WORD! produces an isotope
    == ~whatever~  ; isotope

    &gt;&gt; meta ~whatever~  ; META of an isotope gives you the QUASI! WORD! back
    == ~whatever~

    &gt;&gt; meta 1020  ; META of any other value will just quote it one more level
    == &#39;1020

    &gt;&gt; meta the &#39;&#39;&#39;(a + b)
    == &#39;&#39;&#39;&#39;(a + b)

So the evaluator is armed with the knowledge that the frame cannot legitimately have isotopes to be passed as arguments.  It can draw the conclusion that if it *does* see **`~`** isotopes in a frame, that means the parameter was not specified.

For refinements it&#39;s fine if the parameter was unspecified; they can just be defaulted to NULL.  For a required parameter, it means raising an error...just as if you had the parameter missing at a callsite.

## You Can Specialize-Out Optional Arguments With NULL

Another perk of starting out the frame with voids is that you can remove parameters while leaving other parameters unspecified.  This permits partial specialization:

    &gt;&gt; foo: func [x [integer!] /y [integer!]] [if y [x + y] else [x + 1000]]

    &gt;&gt; f: make frame! :foo
    == make frame! [
        x: ~
        y: ~
    ]

    &gt;&gt; f.y: null

    &gt;&gt; bar: make action! f

    &gt;&gt; parameters of :foo
    == [x /y]

    &gt;&gt; parameters of :bar
    == [x]

    &gt;&gt; bar 20
    == 1020

This shows pretty clearly why we don&#39;t want NULL to denote unspecialized fields--because it&#39;s desirable to be able to specialize them to NULL!  The distinction from void lets the evaluator notice when that&#39;s happened.

## You&#39;re Guarded By Errors When Using Unset Fields

While you&#39;re filling up the frame, it&#39;s nice to have a heads-up if you access frame fields that haven&#39;t been assigned yet:

    &gt;&gt; if f.series [print &quot;An error here makes sense, right?&quot;]
    ** Script Error: f.series is unset (~ isotope) (see ^(...) and GET/ANY)

## The Locals Are Initialized to the Unset Isotope, Too

This is something a bit hidden, because you don&#39;t see the locals when you are viewing the frame from the &quot;outside&quot; (as you are here).

But from an implementation standpoint, it&#39;s nice to have all the locals start out as unset, which is what you want them to be when the function runs.</description>
    
    <lastBuildDate>Sat, 27 Aug 2022 11:48:26 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://forum.rebol.info/t/default-values-and-make-frame/1412.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Default Values And MAKE FRAME!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1412">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>That Seems So Elegant... What's The Catch?</strong></p>
<ul>
<li>
<p>When doing a low-level build of a FRAME! for a function, you are on the hook for knowing the callsite parameter convention and doing what it takes to meet the expectation.</p>
<ul>
<li>So for a quoted (literal) parameter, you have to take that into account...since no callsite quoting is going on, you must do your own quoting in the assignment.</li>
</ul>
</li>
</ul>
</blockquote>
</aside>
<p>Okay... in practice this catch turns out to be <em>really annoying</em>.</p>
<p>Enough so that I think the frames should speak an "as-is" language.  Then the mechanics that turn parameters into ^META should be done by the function when it's called.</p>
<p>So let's revisit:</p>
<pre><code>greater-than-10: func [^x [integer!]] [
    if quasi? x [
        print ["Doing special thing for" mold x]
    ] else [
        x &gt; 10
    ]
]
</code></pre>
<p>I think what should happen in practice is that FUNC turns that into something like this, where you can annotate a lower-level FUNC* to say that isotopes are okay...and the body ^METAs the variables:</p>
<pre><code>greater-than-10: func* [x [integer! ~any-value~]] [
    x: ^x  ; This would be added by the higher level FUNC generator

    if quasi? x [
        print ["Doing special thing for" mold x]
    ] else [
        x &gt; 10
    ]
]
</code></pre>
<p>Here you'd get the behavior you'd expect for normal values:</p>
<pre><code>&gt;&gt; f: make frame! :greater-than-10
&gt;&gt; f.x: 20
== 20

&gt;&gt; do f
== #[true]
</code></pre>
<p>And if you wanted to pass an isotope, you'd assign isotopic values in the frame:</p>
<pre><code>&gt;&gt; f: make frame! :greater-than-10
&gt;&gt; [~f.x~]: ~asdf~
== ~asdf~  ; isotope

&gt;&gt; do f
Doing special thing for ~asdf~
</code></pre>
<h2>But What If Actually Want To Specialize To Void?</h2>
<p>You wouldn't be able to specialize voids by way of just a FRAME!.</p>
<pre><code>&gt;&gt; f: make frame! :set

&gt;&gt; f.value: ~
; void  (...meaningless, as it was already void...)

&gt;&gt; unset: make action! :f  ; not going to give you what you want

&gt;&gt; unset 'foo
; UNSET is missing its value argument
</code></pre>
<p>I'm not all that bummed out about this.  It was much more of a problem when you couldn't set things to NULL, because that inhibited removing refinements from the interface of functions.  This is a really narrow case...and I think some operation that just says "remove the parameter from the interface would probably do it.</p>
<pre><code>&gt;&gt; f: make frame! :set
&gt;&gt; protect/hide 'f.value  ; commit to the unset state
&gt;&gt; unset: make action! f
</code></pre>
<p>And SPECIALIZE could still do it, using the trick of assigning a special identity to each frame variable that it recognizes:</p>
<pre><code>unset: redescribe [
    {Clear the value of a word to an unset isotope (in its current context)}
](
    specialize :set [value: ~]  ; tricky case, but supported!
)
</code></pre>
<h2>What About Signaling END of Frame Input?</h2>
<p>I mentioned that the end of input could be NULL if the ^META parameters were always QUASI! / QUOTED! / BLANK!.</p>
<p>But at the frame currency level, this doesn't work if it's using plain values and not meta ones.  You have conflation of void, and then if you use NULL you're getting conflation with END.</p>
<p>Something that could solve these cases would be if there were "meta frames" where every value was interpreted as being meta.  <em>Could this be an application for isotopic frames??</em></p>
<p>Or a behavior for QUOTED! frames?</p>
<pre><code>&gt;&gt; f: make frame! :set
&gt;&gt; f.value: '~   ; meta void
&gt;&gt; make action! isotopic f  ; isotope status means unquote everything
</code></pre>
<p>I don't know about that, because I was thinking isotopic frames would auto-run from WORD!, and save you from having to make ACTION!s out of frames just to get that behavior.</p>
<p><strong>Anyway, long story short, I think the baseline mechanics of FRAME! has to be as-is.</strong>  Whatever else is an exception and should be handled specially.  If you want a ^META parameter, that should be something that happens after the function starts running.  This improves matters greatly.</p>
          <p><a href="https://forum.rebol.info/t/default-values-and-make-frame/1412/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame/1412/6</link>
        <pubDate>Sat, 27 Aug 2022 11:48:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1412-6</guid>
        <source url="https://forum.rebol.info/t/default-values-and-make-frame/1412.rss">Default Values And MAKE FRAME!</source>
      </item>
      <item>
        <title>Default Values And MAKE FRAME!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="4" data-topic="1412">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><em>But it doesn't mean that higher level functions can't try to help you out...</em></p>
</blockquote>
</aside>
<p>So now, this works!</p>
<pre><code>unset: redescribe [
    {Clear the value of a word to an unset isotope (in its current context)}
](
    specialize :set [value: ~]  ; tricky case, but supported!
)
</code></pre>
<p>It's been a long path to this but I think it's a good one.  We realize that what a higher-level construct like SPECIALIZE or APPLY can do is different from the raw FRAME! mechanic.</p>
<p>There will be some people out there who use FRAME! and then are bitten by the fact that a function they think is "ordinary" (like SET or RETURN) turn out to take ^meta arguments.  But it just means you have to match the parameter convention.</p>
<p>As I've said before, this is true of quoting as well.  Even if you're used to writing <code>for-each x ...</code> you can't do:</p>
<pre><code> for-each-x-frame: make frame! :for-each
 for-each-x-frame.vars: x
</code></pre>
<p>The quoting from the parameter convention doesn't apply to the assignment inside the frame.  You have to say:</p>
<pre><code> for-each-x-frame: make frame! :for-each
 for-each-x-frame.vars: 'x
</code></pre>
<p>And similarly for a meta parameter.  You need the ^.</p>
<pre><code> return-unset-frame: make frame! :return
 return-unset-frame.value: ^ void
</code></pre>
<p>Makes pretty good sense, and here SPECIALIZE is showing that higher levels can smooth over it.</p>
          <p><a href="https://forum.rebol.info/t/default-values-and-make-frame/1412/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame/1412/5</link>
        <pubDate>Thu, 08 Jul 2021 17:14:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1412-5</guid>
        <source url="https://forum.rebol.info/t/default-values-and-make-frame/1412.rss">Default Values And MAKE FRAME!</source>
      </item>
      <item>
        <title>Default Values And MAKE FRAME!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2>Higher-Level Functions than DO FRAME! Can Lend A Hand</h2>
<p>Let's imagine you want to specialize RETURN.  It's one of those functions that takes a ^meta parameter, so that you can say things like <strong><code>return ~none~</code></strong> and hand back an isotope to the caller.</p>
<p>But specialize can be creative in terms of how it builds the frame.  So let's say you don't want to care if it's a meta parameter or not, and want to write:</p>
<pre><code>r5: specialize :return [value: 5]  ; you don't want to have to quote 5
rU: specialize :return [value: ~]  ; e.g. return void
</code></pre>
<p><em>So imagine specialize isn't using voids as its initial condition for variables in the frame.</em></p>
<p>Just for starters, let's have it use some kind of one-off series identity for the initial state of <code>value</code>.  A primordial example could just use a string like <strong>"!!!unspecialized!!!"</strong>.  If that were owned by SPECIALIZE then that could uniquely identify unspecialized fields...and assigning an identical string with a different identity wouldn't be mistaken for the identity that specialize knows.</p>
<p>So then, anything it saw that it didn't recognize as that exact identity, it would assume had been specialized.  And if the parameter class was ^META, it would do the appropriate adjustment...turning isotopes into QUASI! WORD!s, and quoting other values.</p>
<p>What you lose in this "specialized identity" approach being a string is the idea of getting errors on unassigned variables...or having an easy test of whether you've specialized things or not.  This might be a good argument for having something that carries a cheap notion of identity but can be recognized as unspecialized.  Maybe UNSPECIALIZED! should be its own datatype for the purpose?</p>
<p><strong>But the point is...</strong> higher-level tools can come into play that are aware of the parameter conventions and do adjustments for you.  But if you work at the FRAME! level, you're at the metal...and you have to fill the slots with their <em>final</em> values; no parameter conventions will be applied to adjust them for you.</p>
<p><strong>The only adjustment that happens in frame execution is that voids will be converted to NULLs.</strong></p>
<p>And I will say again that as weird as it all may sound, it's quite elegant!</p>
          <p><a href="https://forum.rebol.info/t/default-values-and-make-frame/1412/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame/1412/4</link>
        <pubDate>Mon, 21 Jun 2021 07:03:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1412-4</guid>
        <source url="https://forum.rebol.info/t/default-values-and-make-frame/1412.rss">Default Values And MAKE FRAME!</source>
      </item>
      <item>
        <title>Default Values And MAKE FRAME!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2>That Seems So Elegant... What's The Catch?</h2>
<ul>
<li>
<p>When doing a low-level build of a FRAME! for a function, you are on the hook for knowing the callsite parameter convention and doing what it takes to meet the expectation.</p>
<ul>
<li>
<p>So for a quoted (literal) parameter, you have to take that into account...since no callsite quoting is going on, you must do your own quoting in the assignment.</p>
<ul>
<li>This isn't particularly new--you had to do your own quoting when using Rebol2 APPLY, also.  The quoting convention in the function spec wouldn't be heeded inside the apply block.</li>
</ul>
</li>
<li>
<p>Same for a meta parameter...there's no callsite that's converitng things from isotopes into a non-isotope, or adding quote levels.  When you are assigning fields in the frame you have to remember to META them.</p>
</li>
</ul>
</li>
</ul>
<p>It means that if the parameter convention changes, what you might have written for a MAKE FRAME! previously won't work.</p>
<p>Let's say someone writes a function that returns if something is greater than 10:</p>
<pre><code>greater-than-10: func [x [integer!]] [
    return x &gt; 10
]
</code></pre>
<p>Then you write code that builds a frame for it:</p>
<pre><code>f: make frame! :greater-than-10
f.x: 20
assert [true = do f]
</code></pre>
<p>It works.  Yet later the person who wrote the function decides they want to do something special if it's passed an isotope, while keeping the behavior for integers the same:</p>
<pre><code>greater-than-10: func [^x [integer!]] [
    if quasi? x [
        print ["Doing special thing for" mold x]
    ] else [
        x &gt; 10
    ]
]

&gt;&gt; greater-than-10 20
== #[true]

&gt;&gt; greater-than-10 ~asdf~
Doing special thing for ~asdf~
</code></pre>
<p>Why did the person who switched the parameter to ^META add this feature?  Who knows.  But let's say they thought it was okay because existing callsites would remain the same.</p>
<p>But it breaks our invocation via FRAME!...the code won't work any more.</p>
<pre><code>&gt;&gt; f: make frame! :greater-than-10
&gt;&gt; f.x: 20
== 20

&gt;&gt; do f
** Error: ^META arguments must be quoted!, bad-word!, or null
</code></pre>
<p>That message should be better, and tell you that it's x that's the problem.  But the key is you have to now adjust how you fill the frame to meet the meta requirements:</p>
<pre><code>&gt;&gt; f: make frame! :greater-than-10
&gt;&gt; f.x: quote 20
== '20

&gt;&gt; do f
== #[true]</code></pre>
          <p><a href="https://forum.rebol.info/t/default-values-and-make-frame/1412/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame/1412/3</link>
        <pubDate>Mon, 21 Jun 2021 02:44:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1412-3</guid>
        <source url="https://forum.rebol.info/t/default-values-and-make-frame/1412.rss">Default Values And MAKE FRAME!</source>
      </item>
      <item>
        <title>Default Values And MAKE FRAME!</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Something you may notice when you MAKE FRAME! is that all the fields start out VOID (hence we say the variables are "unset"):</p>
<pre><code>; Remember that the QUASI! of NULL would be QUOTED!
; e.g. [series: '~] --  But since these tildes are not quoted they imply
; evaluation, which would set the variables to void (e.g.)

&gt;&gt; f: make frame! :append
== make frame! [
    series: ~
    value: ~
    part: ~
    only: ~
    dup: ~
    line: ~
]
</code></pre>
<h2>It's Critical These Are Isotopes And Not NULL</h2>
<p><strong>The most important reason is that when a function is invoked, its frame cannot actually contain any isotopes.</strong>  So they can be out-of-band, and safely represent the intent of an unspecialized parameter.</p>
<p>Isotopes can only be passed as arguments is if they are ^META parameters...and this means their value in the frame will have been pre-processed into a plain BAD-WORD!.</p>
<p>Why is it plain?  Well, remember the META behaviors:</p>
<pre><code>&gt;&gt; meta null  ; META of pure NULL gives BLANK!
_

&gt;&gt; ~whatever~  ; evaluation of a plain QUASI! WORD! produces an isotope
== ~whatever~  ; isotope

&gt;&gt; meta ~whatever~  ; META of an isotope gives you the QUASI! WORD! back
== ~whatever~

&gt;&gt; meta 1020  ; META of any other value will just quote it one more level
== '1020

&gt;&gt; meta the '''(a + b)
== ''''(a + b)
</code></pre>
<p>So the evaluator is armed with the knowledge that the frame cannot legitimately have isotopes to be passed as arguments.  It can draw the conclusion that if it <em>does</em> see <strong><code>~</code></strong> isotopes in a frame, that means the parameter was not specified.</p>
<p>For refinements it's fine if the parameter was unspecified; they can just be defaulted to NULL.  For a required parameter, it means raising an error...just as if you had the parameter missing at a callsite.</p>
<h2>You Can Specialize-Out Optional Arguments With NULL</h2>
<p>Another perk of starting out the frame with voids is that you can remove parameters while leaving other parameters unspecified.  This permits partial specialization:</p>
<pre><code>&gt;&gt; foo: func [x [integer!] /y [integer!]] [if y [x + y] else [x + 1000]]

&gt;&gt; f: make frame! :foo
== make frame! [
    x: ~
    y: ~
]

&gt;&gt; f.y: null

&gt;&gt; bar: make action! f

&gt;&gt; parameters of :foo
== [x /y]

&gt;&gt; parameters of :bar
== [x]

&gt;&gt; bar 20
== 1020
</code></pre>
<p>This shows pretty clearly why we don't want NULL to denote unspecialized fields--because it's desirable to be able to specialize them to NULL!  The distinction from void lets the evaluator notice when that's happened.</p>
<h2>You're Guarded By Errors When Using Unset Fields</h2>
<p>While you're filling up the frame, it's nice to have a heads-up if you access frame fields that haven't been assigned yet:</p>
<pre><code>&gt;&gt; if f.series [print "An error here makes sense, right?"]
** Script Error: f.series is unset (~ isotope) (see ^(...) and GET/ANY)
</code></pre>
<h2>The Locals Are Initialized to the Unset Isotope, Too</h2>
<p>This is something a bit hidden, because you don't see the locals when you are viewing the frame from the "outside" (as you are here).</p>
<p>But from an implementation standpoint, it's nice to have all the locals start out as unset, which is what you want them to be when the function runs.</p>
          <p><a href="https://forum.rebol.info/t/default-values-and-make-frame/1412/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/default-values-and-make-frame/1412/1</link>
        <pubDate>Sun, 22 Nov 2020 13:24:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1412-1</guid>
        <source url="https://forum.rebol.info/t/default-values-and-make-frame/1412.rss">Default Values And MAKE FRAME!</source>
      </item>
  </channel>
</rss>

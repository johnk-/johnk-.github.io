<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Intentionally Specializing With NONE</title>
    <link>https://forum.rebol.info/t/intentionally-specializing-with-none/1168</link>
    <description>When you make a new FRAME! for a function, it has all of its fields unset (e.g. set to &quot;none&quot; **~**)

     foo: function [x [integer!] /y [integer!] /z] [...]

     &gt;&gt; f: make frame! :foo
     == make frame! [
          x: ~
          y: ~
          z: ~
     ]

If you were to try and **do f** on that frame without setting x to something, you would get an error.  You would also get an error if you said **f.x: &quot;not an integer&quot;** and tried **do f**.

You can just leave y and z alone.  If you DO F it will just mean they&#39;re taken as unused, and will be received by FOO as nulls.

But what if you want to actually SPECIALIZE a function with NONE, e.g.:

    unset: specialize :set [value: ~]

## Custom Escape Value?

A first thought I had was we could do something along the lines of just telling SPECIALIZE a value you want to use as the escape:

     foo-no-y: specialize/none :foo [y: &lt;noneescape&gt;] &lt;noneescape&gt;

It sounds plausible, until you think about scenarios where some of your data is being passed in from outside:

     make-specialfoo: function [data-from-elsewhere] [
         return specialize :foo [
             x: data-from-elsewhere
             y: &lt;noneescape&gt;
         ]
     ]

What if the passed in `data-from-elsewhere` just coincidentally used the same magic escape value you did?  :-(  I&#39;m not saying such a construct shouldn&#39;t or couldn&#39;t exist and be useful somewhere.  But it&#39;s a pretty big weakness for &quot;the&quot; SPECIALIZE to have.

## Assume only user-assigned nones are specialized

The current implementation of SPECIALIZE doesn&#39;t keep track of whether you assigned a field or not.   
 It just starts with frame fields as none, runs your code bound into the frame, and when the code is done it assumes anything that&#39;s still none is unspecialized.  So these act the same:

     specialize &#39;foo [x: 10 y: ~]
     specialize &#39;foo [x: 10]

Technically speaking, it&#39;s actually possible for the system to write a bit on the value cell in the frame... and notice whether that bit is still set at the end.  So it could tell a &quot;stale&quot; null from a user-written null.

Leveraging such internals makes me a bit uncomfortable, in the sense of being something the user can&#39;t do.  **I&#39;d like to see basic mechanics exported so that users could write their own variations of SPECIALIZE.**

## Make removing args a separate refinement

In the lazy/obvious department, just have a list of the arguments you want to remove, passed as a block or something:

    specialize/remove &#39;foo [x: 10] [y]
 
Not very imaginative.

## Likely Winner: Expose A New Meta Bit

A more imaginative concept might actually let the user programmatically request the field be removed from the frame&#39;s interface.  It might even reuse the mechanics for PROTECT/HIDE:

    specialize &#39;foo [
        x: 10
        protect/hide &#39;y:
    ]

A backwards-quoting operator might even do that with a nicer syntax...perhaps a function that is bound to work in concert with SPECIALIZE (the way KEEP works with COLLECT):

    specialize &#39;foo [
        x: 10
        y: hidden  ; or SPECIALIZED-OUT/etc...it would quote left and fiddle bit
    ]

It may be able to just build on the PROTECT/HIDE feature, and if so it might bring more justification to its existence.  Or maybe just the plain old PROTECT bit...if you&#39;re saying the field is protected, it&#39;s NULL and can&#39;t be changed, what else could you mean by that than &quot;it&#39;s in its final form, so remove it from the interface&quot;?

The idea is that I want to be able to flip back and forth between MAKE ACTION! from a FRAME! and MAKE FRAME! from an ACTION!.  This is the long game of writing your own specialization operators.  It can&#39;t be done completely in-band with values and nulls...since they represent valid states for a function&#39;s arguments.  So as long as the function call itself can&#39;t read this hidden bit controlling frame creation and derive meaning from it, it should work.</description>
    
    <lastBuildDate>Mon, 26 Jun 2023 03:10:27 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://forum.rebol.info/t/intentionally-specializing-with-none/1168.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Intentionally Specializing With NONE</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>When you make a new FRAME! for a function, it has all of its fields unset (e.g. set to "none" <strong>~</strong>)</p>
<pre><code> foo: function [x [integer!] /y [integer!] /z] [...]

 &gt;&gt; f: make frame! :foo
 == make frame! [
      x: ~
      y: ~
      z: ~
 ]
</code></pre>
<p>If you were to try and <strong>do f</strong> on that frame without setting x to something, you would get an error.  You would also get an error if you said <strong>f.x: "not an integer"</strong> and tried <strong>do f</strong>.</p>
<p>You can just leave y and z alone.  If you DO F it will just mean they're taken as unused, and will be received by FOO as nulls.</p>
<p>But what if you want to actually SPECIALIZE a function with NONE, e.g.:</p>
<pre><code>unset: specialize :set [value: ~]
</code></pre>
<h2>
<a name="custom-escape-value-1" class="anchor" href="https://forum.rebol.info#custom-escape-value-1"></a>Custom Escape Value?</h2>
<p>A first thought I had was we could do something along the lines of just telling SPECIALIZE a value you want to use as the escape:</p>
<pre><code> foo-no-y: specialize/none :foo [y: &lt;noneescape&gt;] &lt;noneescape&gt;
</code></pre>
<p>It sounds plausible, until you think about scenarios where some of your data is being passed in from outside:</p>
<pre><code> make-specialfoo: function [data-from-elsewhere] [
     return specialize :foo [
         x: data-from-elsewhere
         y: &lt;noneescape&gt;
     ]
 ]
</code></pre>
<p>What if the passed in <code>data-from-elsewhere</code> just coincidentally used the same magic escape value you did?  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20">  I'm not saying such a construct shouldn't or couldn't exist and be useful somewhere.  But it's a pretty big weakness for "the" SPECIALIZE to have.</p>
<h2>
<a name="assume-only-user-assigned-nones-are-specialized-2" class="anchor" href="https://forum.rebol.info#assume-only-user-assigned-nones-are-specialized-2"></a>Assume only user-assigned nones are specialized</h2>
<p>The current implementation of SPECIALIZE doesn't keep track of whether you assigned a field or not.<br>
It just starts with frame fields as none, runs your code bound into the frame, and when the code is done it assumes anything that's still none is unspecialized.  So these act the same:</p>
<pre><code> specialize 'foo [x: 10 y: ~]
 specialize 'foo [x: 10]
</code></pre>
<p>Technically speaking, it's actually possible for the system to write a bit on the value cell in the frame... and notice whether that bit is still set at the end.  So it could tell a "stale" null from a user-written null.</p>
<p>Leveraging such internals makes me a bit uncomfortable, in the sense of being something the user can't do.  <strong>I'd like to see basic mechanics exported so that users could write their own variations of SPECIALIZE.</strong></p>
<h2>
<a name="make-removing-args-a-separate-refinement-3" class="anchor" href="https://forum.rebol.info#make-removing-args-a-separate-refinement-3"></a>Make removing args a separate refinement</h2>
<p>In the lazy/obvious department, just have a list of the arguments you want to remove, passed as a block or something:</p>
<pre><code>specialize/remove 'foo [x: 10] [y]
</code></pre>
<p>Not very imaginative.</p>
<h2>
<a name="likely-winner-expose-a-new-meta-bit-4" class="anchor" href="https://forum.rebol.info#likely-winner-expose-a-new-meta-bit-4"></a>Likely Winner: Expose A New Meta Bit</h2>
<p>A more imaginative concept might actually let the user programmatically request the field be removed from the frame's interface.  It might even reuse the mechanics for PROTECT/HIDE:</p>
<pre><code>specialize 'foo [
    x: 10
    protect/hide 'y:
]
</code></pre>
<p>A backwards-quoting operator might even do that with a nicer syntax...perhaps a function that is bound to work in concert with SPECIALIZE (the way KEEP works with COLLECT):</p>
<pre><code>specialize 'foo [
    x: 10
    y: hidden  ; or SPECIALIZED-OUT/etc...it would quote left and fiddle bit
]
</code></pre>
<p>It may be able to just build on the PROTECT/HIDE feature, and if so it might bring more justification to its existence.  Or maybe just the plain old PROTECT bit...if you're saying the field is protected, it's NULL and can't be changed, what else could you mean by that than "it's in its final form, so remove it from the interface"?</p>
<p>The idea is that I want to be able to flip back and forth between MAKE ACTION! from a FRAME! and MAKE FRAME! from an ACTION!.  This is the long game of writing your own specialization operators.  It can't be done completely in-band with values and nulls...since they represent valid states for a function's arguments.  So as long as the function call itself can't read this hidden bit controlling frame creation and derive meaning from it, it should work.</p>
          <p><a href="https://forum.rebol.info/t/intentionally-specializing-with-none/1168/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/intentionally-specializing-with-none/1168/1</link>
        <pubDate>Thu, 23 May 2019 23:23:01 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1168-1</guid>
        <source url="https://forum.rebol.info/t/intentionally-specializing-with-none/1168.rss">Intentionally Specializing With NONE</source>
      </item>
  </channel>
</rss>

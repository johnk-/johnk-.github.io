<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>BLANK! 2022: Revisiting The Datatype</title>
    <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942</link>
    <description>In historical Redbol&#39;s meaning of the datatype NONE!, it had the bad habit of looking like a WORD!:

    rebol2&gt;&gt; &#39;none
    == none

    rebol2&gt;&gt; none
    == none  ; same in R3-Alpha and Red

But it wasn&#39;t a word:

    rebol2&gt;&gt; type? &#39;none
    == word!

    rebol2&gt;&gt; type? none
    == none!

It was a distinct type, which also happened to be falsey (while WORD!s are truthy):

    rebol2&gt;&gt; if &#39;none [print &quot;Truthy word!&quot;]
    Truthy word!

    rebol2&gt;&gt; if none [print &quot;Falsey none!&quot;]
    == none

And as we can see, NONE!s served purposes of signaling &quot;soft failures&quot;: branches that didn&#39;t run, or FINDs that didn&#39;t find, or SELECTs that didn&#39;t select... etc.

    rebol2&gt;&gt; find &quot;abcd&quot; &quot;z&quot;
    == none

    rebol2&gt;&gt; select [a 10 b 20] &#39;c
    == none

## Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!

* **NULL** - an &quot;isotopic&quot; state of WORD! that couldn&#39;t be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use ~null~.

      &gt;&gt; null
      == ~null~  ; isotope

      &gt;&gt; find &quot;abcd&quot; &quot;z&quot;
      == ~null~  ; isotope

      &gt;&gt; select [a 10 b 20] &#39;c
      == ~null~  ; isotope

      &gt;&gt; append [a b c] null
      ** Error: APPEND doesn&#39;t allow ~null~ isotope

* **VOID** - the result of things that are effectively &quot;no ops&quot;.  Some contexts choose to make them vanish, and when functions like APPEND get them as an argument they are treated as no-ops:

      &gt;&gt; void  ; void results don&#39;t show anything in the console

      &gt;&gt; if null [print &quot;Doesn&#39;t print as NULL is falsey&quot;]

      &gt;&gt; 1 + 2 if null [print &quot;Voids disappear...&quot;]
      == 3

      &gt;&gt; append [a b c] void
      == [a b c]

    (At one time void was also the state of unset variables, but that is now isotopic void...which has reclaimed the name &quot;none&quot;)

 * **BLANK!** was represented by a lone underscore ( **`_`** ) and could be put into blocks:

       &gt;&gt; append [a b c] _
       == [a b c _]

     It retained the choice to be falsey:

       &gt;&gt; if _ [print &quot;Won&#39;t print because blanks are falsey&quot;]

## Question One: Should BLANK! Just Be A WORD! ?

Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word.

Outside of historically being hardcoded as falsey, what makes BLANK! fairly &quot;built in&quot; is that in the path mechanics, it fills in the empty slots:

    &gt;&gt; to path! [_ a]
    == /a

    &gt;&gt; as block! &#39;a//b//c
    == [a _ b _ c]

Alternately, we could accomplish a &quot;reified nothing&quot; with a quoted void:

    &gt;&gt; to path! [&#39; a]
    == /a

    &gt;&gt; as block! &#39;a//b//c
    == [a &#39; b &#39; c]

But there&#39;s other places the blank is used, such as to opt-out of multi-returns.

    &gt;&gt; [_ pos]: transcode &quot;abc def&quot;

    &gt;&gt; pos
    == &quot; def&quot;

Once again, quoted void could be used here...though it looks a bit slight to my eyes, I can also see the point of view that it&#39;s better:

    &gt;&gt; [&#39; pos]: transcode &quot;abc def&quot;

Broadening the question, we could ask if blank is really the best choice for opting out of things like loop variables in FOR-EACH? Since VOID is used to opt-out, might a lone apostrophe be more coherent?

    &gt;&gt; for-each &#39; [1 2 3] [print &quot;no variable&quot;]
    no variable
    no variable
    no variable

It&#39;s more visually slight than **`for-each _ [1 2 3]`**, but not awful. And since voids are used to opt-out in slots it actually dovetails nicely with if the evaluated forms were allowed to opt out via void:

    for-each (if false [&#39;x]) [1 2 3] [print &quot;no variable&quot;]

If your expression produces no iterative variables to bind in the body assume that you didn&#39;t need them. The alternative of **`(if false [&#39;x] else [_])`** or even **`(if false &#39;x else &#39;_)`** seems like busywork.

This even would mean you could use **`()`** as a less slight alternative, if you didn&#39;t like the **`&#39;`** syntax:

    for-each () [1 2 3] [print &quot;no variable&quot;]  ; actually pretty nice!

The premise may hold for multi-returns also:

    &gt;&gt; [a &#39; c]: pack [1 2 3]
    == 1

    &gt;&gt; c
    == 3

    &gt;&gt; [a () c]: pack [4 5 6]
    == 4

    &gt;&gt; c
    == 6

I&#39;m not sure it looks worse than **`[a _ c]: pack [...]`**, and would open up:

    &gt;&gt; [a _ c]: pack [8 9 10]
    == 8

    &gt;&gt; _
    == 9

    &gt;&gt; c
    == 10

So can lone apostrophe paper over some of the system-level needs for reified nothingness... at least in enough cases that it&#39;s a good tradeoff to give underscore back to wordspace?

## Question Two: Does BLANK! Still Need To Be Falsey?

*My feeling is that having blank be falsey doesn&#39;t have all that much benefit.*  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:

    &gt;&gt; append [a b c] all [1 &lt; 2, 3 &lt; 4, _]
    == [a b c _]  ; would seem nice, but gives error today since ALL is NULL

Thinking of BLANK! as being &quot;null-like&quot; in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:

    &gt;&gt; item: _

    &gt;&gt; item: default [1 + 2]
    == ???

In practice, I prefer the truly non-valued NULL being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as &quot;not being assigned&quot;... as you&#39;ll get errors when you try to use it places (e.g. in APPEND).  Trying to use it to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)

This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I&#39;ve said &quot;blanks are to blocks what space is to strings&quot;.  And space is truthy:

    &gt;&gt; if second &quot;a b&quot; [print &quot;Space is truthy&quot;]
    Space is truthy

    &gt;&gt; if second [a _ b] [print &quot;So why shouldn&#39;t blank be truthy?&quot;]
    ???

**So Either Way, I Suggest The Removal of BLANK! From Being Falsey**.  This creates some incompatibility in Redbol (which has been using NONE! as a blank substitute).  But it&#39;s something that can be worked around.</description>
    
    <lastBuildDate>Mon, 26 Jun 2023 06:24:29 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>&gt;&gt; for-each ' [1 2 3] [print "no variable"]
no variable
no variable
no variable
</code></pre>
<p>It's more visually slight than <strong><code>for-each _ [1 2 3]</code></strong>, but not awful.</p>
</blockquote>
</aside>
<p><em>One potential qualm:</em> a quoted word vs. a regular word is seen as a different instruction by both FOR-EACH and multi-return.  So from a type system perspective it's like you're conflating some meanings of what QUOTED! is supposed to signal when you use an apostrophe vs. a distinct BLANK! type.  e.g. there's no "unquoted void literal", only a quoted one.</p>
<p>In the case of how the mechanics of LET works, this is actually a problem, because the apostrophes escape things it's not supposed to consider part of the LET :-/</p>
<pre><code> let [a 'b]: multi-returner ...
 =&gt;
 let a, [a b]: multi-returner ...  ; just drops the quote level from quoted things

 let [a ' c]: multi-returner ...
 =&gt;
 let [a c], [a ??? c]: multi-returner ...  ; can't drop quote level from lone quote
</code></pre>
<p>Yes, it could say that there's an exception for lone quotes and they stay as is, but it sort of points to the general unease and "weird exceptions" you have to make when the quoted state of void is used to represent something that is only quoted at all because it's "probably not meaningful otherwise".  Just seems to lead to snakey rules that the more-visible blank doesn't require.</p>
<p>Or maybe we just say <strong><code>()</code></strong> is what you use, I don't know.</p>
<pre><code>let [a () c]: multi-returner ...
</code></pre>
<p>Thinking further... today BLANK! is the default used by things like ARRAY but that could have different choices too:</p>
<pre><code>&gt;&gt; array 3
== [' ' ']  ; quoted voids

&gt;&gt; array 3
== [~ ~ ~]  ; isotopic voids

&gt;&gt; array 3
== [# # #]  ; empty tokens
</code></pre>
<p>Of those choices, I'd probably say I like the isotopic voids, just because of how ornery they become when evaluated....and orneryness seems like a good characteristic for when you didn't specify an /INITIAL value to be used.</p>
<p>But just because we would return <strong>_</strong> to the WORD! pool... would making it defined to evaluate to a null isotope or space (or some other default) be a good thing?  People might want it for other purposes (consider things like the <a href="https://underscorejs.org/">underscore.js library</a>, where it's the name of a utility module that tries to disappear).</p>
<pre><code>&gt;&gt; _: import %my-utility-lib.r

&gt;&gt; _.sum [1020 304]
== 1234
</code></pre>
<p>If you're going to open <strong>_</strong> up for potentially interesting purposes, but then turn around and say everyone assumes it evaluates to null (or space), then I'm not clear that the ability to redefine it is as much a benefit as a potential nuisance.  <img src="https://forum.rebol.info/images/emoji/twitter/angry.png?v=12" title=":angry:" class="emoji" alt=":angry:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/8</link>
        <pubDate>Sun, 27 Nov 2022 13:01:57 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1942-8</guid>
        <source url="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>Specifically BLANK! and its underscore literal is a huge win (this is from me, the ultra-conservative sceptic) in representing positive nothingness</p>
</blockquote>
</aside>
<p>Well, that's something.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<p>Hence you are on the side of <em>"Taking underscore away from the word pool does more good than harm."</em>  I guess that means you're less comfortable with lone apostrophe serving the  purpose.</p>
<p>But also...it is now allowed to <a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560">enclose weird words in vertical bars</a> as in Lisp, so you can have a WORD! whose spelling is underscore:</p>
<pre><code>&gt;&gt; w: |_|
== |_|

&gt;&gt; type of w
== #[datatype! word!]

&gt;&gt; to text! w
== "_"
</code></pre>
<p><em>(An important design deviation from Lisp is that leading and trailing spaces must be escaped... which biases <code>|</code> and <code>||</code> and <code>|||</code> etc. to being WORD!s of length 1, 2, and 3 respectively...and prohibits absolutely empty WORD!s, though we might have some escaping for that if it turns out to be some critical compatibility point with JSON or something.)</em></p>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I do think that as it represents the known absence of a value in data, it should be falsey in the general flow that data primarily should determine that flow.</p>
</blockquote>
</aside>
<p>I'm trying to make a general engine... so it will be possible to do Redbol compatibility, and if you want different rules you should be able to have them.  But the core as I see it is the "default" distribution which should be based on what is reasonably determined the "best" and most coherent.</p>
<p>The way I see it, the substrate simply isn't set up to do this effectively</p>
<pre><code>&gt;&gt; if select [alpha: true beta: false] 'beta [
       print "This will print, because FALSE is a WORD!"
   ]
   This will print, because FALSE is a WORD!
</code></pre>
<p>I've wondered if whatever peace is made with the above could be made with BLANK! more easily if it evaluated to NULL (and presumably would give NULL back from GET as well?), e.g.</p>
<pre><code>&gt;&gt; x: _
; null

&gt;&gt; get '_
; null

&gt;&gt; if get select [alpha: true beta: _] 'beta [
       print "GET of BLANK! could return null"
   ]
; void
</code></pre>
<p>(Note: This <a href="https://forum.rebol.info/t/get-block-get-and-reduce/1183/8">turns out to be complicated in a general sense</a>, but I think it's on the right track.  Consider GET as a placeholder for "the test that makes sense in your usage context".)</p>
<p>Then you have coverage for FALSE and anything you assign false to.  And I think the <a href="https://forum.rebol.info/t/thinking-about-isotopes-logically-true-and-false/1944">isotopic ~true~ and ~false~ story</a> looks like it may have the right stuff.  (Note that GET does not do evaluations by default...GROUP!s or groups in tuples...so you need to ask it to, hence this is somewhat safe.)</p>
<p>So lone IF comes down to <em>is an ANY-VALUE! available to answer whatever question I asked</em>.  A ~false~ isotope walks the line of being able to say "no" and a ~true~ isotope says "yes" but they sit in the netherspace of not being reified values...where all other isotopic WORD! cause an error.  It shapes the space to make tests when you have either a full ANY-VALUE! or a NULL actually useful.</p>
<p>Sidenote: If you want to not error on a failed select, <a href="https://forum.rebol.info/t/definitional-errors-as-blank-in-null-out-alternative/1880/7">there's now a more elegant answer</a>...and it depends on VOID.</p>
<pre><code>&gt;&gt; get select [alpha: true beta: _] 'gamma
** Error: GET doesn't accept NULL for its VAR argument (use MAYBE if intended)

&gt;&gt; maybe select [alpha: true beta: _] 'gamma
; void

&gt;&gt; get maybe select [alpha: true beta: _] 'gamma
; null
</code></pre>
<aside class="quote no-group" data-username="rgchris" data-post="4" data-topic="1942">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>I have this sense that the BLANK-NULL-VOID-ERROR story has too many actors with overlapping roles.</p>
</blockquote>
</aside>
<p>It is a work in progress...but...I believe there's plenty of evidence that things are pointing toward a solid outcome.</p>
<p>The proof comes from the code: the contrast between what the approaches without it can't do (and how catastrophically they regularly fall down) vs. what the approaches with them can do cleanly and correctly.</p>
<p>UPARSE is a giant piece of evidence, but I think there's quite a lot more.</p>
<p><a href="https://www.youtube.com/watch?v=H6_eqxh-Qok">Too Many Notes</a></p>

          <p><a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/5</link>
        <pubDate>Fri, 26 Aug 2022 06:36:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1942-5</guid>
        <source url="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <p>There's a lot to ponder here. I think on the one hand it's important to explore all of the possibilities, on the other it seems to be getting awfully convoluted and lacking a comprehensive narrative.</p>
<p>I'm not up to speed with much of what has changed in this realm for some time, so I apologise if this glosses over some since settled items, though judging by this post, there's much still unsettled.</p>
<p>For me (using the family name) Rebol's first obligation is to represent data—both in language and the way the language is interpreted in memory. Specifically BLANK! and its underscore literal is a huge win (this is from me, the ultra-conservative sceptic) in representing positive nothingness—that a thing exists but lacks assignation: <code>[name: "Thing" link: _]</code>. Despite that positivity, I do think that as it represents the known absence of a value in data, it should be falsey in the general flow that data primarily should determine that flow.</p>
<p>What it becomes in a dialect or within the general flow as distinct from NULL is of lesser importance as I see it. If NULL is the evaluator's ultimate representation of nothingness, then there should be a way to access that in internal dialects, such as SET-BLOCK! or PATH! and the like or it is not really fulfilling its role.</p>
<p>I have this sense that the BLANK-NULL-VOID-ERROR story has too many actors with overlapping roles. I don't have anything tangible to back that up with at this time.</p>
          <p><a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/4</link>
        <pubDate>Fri, 26 Aug 2022 01:55:19 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1942-4</guid>
        <source url="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
      <item>
        <title>BLANK! 2022: Revisiting The Datatype</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>In historical Redbol's meaning of the datatype NONE!, it had the bad habit of looking like a WORD!:</p>
<pre><code>rebol2&gt;&gt; 'none
== none

rebol2&gt;&gt; none
== none  ; same in R3-Alpha and Red
</code></pre>
<p>But it wasn't a word:</p>
<pre><code>rebol2&gt;&gt; type? 'none
== word!

rebol2&gt;&gt; type? none
== none!
</code></pre>
<p>It was a distinct type, which also happened to be falsey (while WORD!s are truthy):</p>
<pre><code>rebol2&gt;&gt; if 'none [print "Truthy word!"]
Truthy word!

rebol2&gt;&gt; if none [print "Falsey none!"]
== none
</code></pre>
<p>And as we can see, NONE!s served purposes of signaling "soft failures": branches that didn't run, or FINDs that didn't find, or SELECTs that didn't select... etc.</p>
<pre><code>rebol2&gt;&gt; find "abcd" "z"
== none

rebol2&gt;&gt; select [a 10 b 20] 'c
== none
</code></pre>
<h2>
<a name="ren-c-divided-nones-roles-across-null-void-and-blank-1" class="anchor" href="https://forum.rebol.info#ren-c-divided-nones-roles-across-null-void-and-blank-1"></a>Ren-C Divided NONE!s roles across NULL, VOID, and BLANK!</h2>
<ul>
<li>
<p><strong>NULL</strong> - an "isotopic" state of WORD! that couldn't be put in BLOCK!s.  Anywhere that NONE! would be used to signal a soft failure operation--like FIND or SELECT--would use ~null~.</p>
<pre><code>&gt;&gt; null
== ~null~  ; isotope

&gt;&gt; find "abcd" "z"
== ~null~  ; isotope

&gt;&gt; select [a 10 b 20] 'c
== ~null~  ; isotope

&gt;&gt; append [a b c] null
** Error: APPEND doesn't allow ~null~ isotope
</code></pre>
</li>
<li>
<p><strong>VOID</strong> - the result of things that are effectively "no ops".  Some contexts choose to make them vanish, and when functions like APPEND get them as an argument they are treated as no-ops:</p>
<pre><code>&gt;&gt; void  ; void results don't show anything in the console

&gt;&gt; if null [print "Doesn't print as NULL is falsey"]

&gt;&gt; 1 + 2 if null [print "Voids disappear..."]
== 3

&gt;&gt; append [a b c] void
== [a b c]
</code></pre>
<p>(At one time void was also the state of unset variables, but that is now isotopic void...which has reclaimed the name "none")</p>
</li>
<li>
<p><strong>BLANK!</strong> was represented by a lone underscore ( <strong><code>_</code></strong> ) and could be put into blocks:</p>
<pre><code>&gt;&gt; append [a b c] _
== [a b c _]
</code></pre>
<p>It retained the choice to be falsey:</p>
<pre><code>&gt;&gt; if _ [print "Won't print because blanks are falsey"]
</code></pre>
</li>
</ul>
<h2>
<a name="question-one-should-blank-just-be-a-word-2" class="anchor" href="https://forum.rebol.info#question-one-should-blank-just-be-a-word-2"></a>Question One: Should BLANK! Just Be A WORD! ?</h2>
<p>Ren-C allows you to use underscores internally to words, so it feels a little bad to take away one word.</p>
<p>Outside of historically being hardcoded as falsey, what makes BLANK! fairly "built in" is that in the path mechanics, it fills in the empty slots:</p>
<pre><code>&gt;&gt; to path! [_ a]
== /a

&gt;&gt; as block! 'a//b//c
== [a _ b _ c]
</code></pre>
<p>Alternately, we could accomplish a "reified nothing" with a quoted void:</p>
<pre><code>&gt;&gt; to path! [' a]
== /a

&gt;&gt; as block! 'a//b//c
== [a ' b ' c]
</code></pre>
<p>But there's other places the blank is used, such as to opt-out of multi-returns.</p>
<pre><code>&gt;&gt; [_ pos]: transcode "abc def"

&gt;&gt; pos
== " def"
</code></pre>
<p>Once again, quoted void could be used here...though it looks a bit slight to my eyes, I can also see the point of view that it's better:</p>
<pre><code>&gt;&gt; [' pos]: transcode "abc def"
</code></pre>
<p>Broadening the question, we could ask if blank is really the best choice for opting out of things like loop variables in FOR-EACH? Since VOID is used to opt-out, might a lone apostrophe be more coherent?</p>
<pre><code>&gt;&gt; for-each ' [1 2 3] [print "no variable"]
no variable
no variable
no variable
</code></pre>
<p>It's more visually slight than <strong><code>for-each _ [1 2 3]</code></strong>, but not awful. And since voids are used to opt-out in slots it actually dovetails nicely with if the evaluated forms were allowed to opt out via void:</p>
<pre><code>for-each (if false ['x]) [1 2 3] [print "no variable"]
</code></pre>
<p>If your expression produces no iterative variables to bind in the body assume that you didn't need them. The alternative of <strong><code>(if false ['x] else [_])</code></strong> or even <strong><code>(if false 'x else '_)</code></strong> seems like busywork.</p>
<p>This even would mean you could use <strong><code>()</code></strong> as a less slight alternative, if you didn't like the <strong><code>'</code></strong> syntax:</p>
<pre><code>for-each () [1 2 3] [print "no variable"]  ; actually pretty nice!
</code></pre>
<p>The premise may hold for multi-returns also:</p>
<pre><code>&gt;&gt; [a ' c]: pack [1 2 3]
== 1

&gt;&gt; c
== 3

&gt;&gt; [a () c]: pack [4 5 6]
== 4

&gt;&gt; c
== 6
</code></pre>
<p>I'm not sure it looks worse than <strong><code>[a _ c]: pack [...]</code></strong>, and would open up:</p>
<pre><code>&gt;&gt; [a _ c]: pack [8 9 10]
== 8

&gt;&gt; _
== 9

&gt;&gt; c
== 10
</code></pre>
<p>So can lone apostrophe paper over some of the system-level needs for reified nothingness... at least in enough cases that it's a good tradeoff to give underscore back to wordspace?</p>
<h2>
<a name="question-two-does-blank-still-need-to-be-falsey-3" class="anchor" href="https://forum.rebol.info#question-two-does-blank-still-need-to-be-falsey-3"></a>Question Two: Does BLANK! Still Need To Be Falsey?</h2>
<p><em>My feeling is that having blank be falsey doesn't have all that much benefit.</em>  NULL does a better job of it, and really what it does is mess with its usefulness as a placeholder:</p>
<pre><code>&gt;&gt; append [a b c] all [1 &lt; 2, 3 &lt; 4, _]
== [a b c _]  ; would seem nice, but gives error today since ALL is NULL
</code></pre>
<p>Thinking of BLANK! as being "null-like" in terms of non-valuedness is generally a hassle.  It makes you wonder about whether something like DEFAULT should think of it as being assigned or not:</p>
<pre><code>&gt;&gt; item: _

&gt;&gt; item: default [1 + 2]
== ???
</code></pre>
<p>In practice, I prefer the truly non-valued NULL being the only cases that DEFAULT overwrites.  This is because NULL is far more useful than BLANK! when it comes to representing something that you think of as "not being assigned"... as you'll get errors when you try to use it places (e.g. in APPEND).  Trying to use it to represent nothingness invariably leads to stray appearances in blocks (Shixin wrote a lot of code to try to filter them out in Rebmake, prior to it being switched to NULLs)</p>
<p>This makes more sense, and I think it bolsters the argument that BLANK! is less of a falsey-NULL relative...but more of a placeholder value.  I've said "blanks are to blocks what space is to strings".  And space is truthy:</p>
<pre><code>&gt;&gt; if second "a b" [print "Space is truthy"]
Space is truthy

&gt;&gt; if second [a _ b] [print "So why shouldn't blank be truthy?"]
???
</code></pre>
<p><strong>So Either Way, I Suggest The Removal of BLANK! From Being Falsey</strong>.  This creates some incompatibility in Redbol (which has been using NONE! as a blank substitute).  But it's something that can be worked around.</p>
          <p><a href="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942/1</link>
        <pubDate>Thu, 25 Aug 2022 13:50:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1942-1</guid>
        <source url="https://forum.rebol.info/t/blank-2022-revisiting-the-datatype/1942.rss">BLANK! 2022: Revisiting The Datatype</source>
      </item>
  </channel>
</rss>

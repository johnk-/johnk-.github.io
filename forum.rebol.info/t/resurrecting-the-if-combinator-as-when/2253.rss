<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
    <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253</link>
    <description>R3-Alpha had an idea--carried forward by Red--of an **arity-1** IF combinator.

    red&gt;&gt; num: 1020

    red&gt;&gt; parse [a a a] [if (even? num) some &#39;a]
    == true

    red&gt;&gt; parse [a a a] [if (odd? num) some &#39;a]
    == false

As you see, if the expression you give it turns out to be &quot;falsey&quot; then it doesn&#39;t continue matching.  It skips to the next alternate--if there is one.

    red&gt;&gt; parse [a a a] [if (odd? num) some &#39;b | some &#39;a]
    == true

But I always thought the arity-1 IF was a pretty alien thing that would confuse people.  You might think there&#39;s a branch, but there&#39;s no &quot;branch&quot;... just continuing along with the variadic list of everything that follows until the next **|** or end of BLOCK!.

I also wondered &quot;where does it end?&quot;  With an IF combinator, why not a CASE combinator, or SWITCH combinator?

So when I came up with GET-GROUP! doing arbitrary substitutions of the rule it evaluates to, I thought &quot;hey, that&#39;s a lot more general!&quot;  We could just say that ~true~ and ~void~ antiforms would continue the parse, ~false~ would stop it, and ~null~ antiforms would trigger an error in case you didn&#39;t mean to do that.

### What That `:(GET-GROUP!)` Concept Looked Like

*(Note that **if condition &#39;[...]** is equivalent to **if condition [[...]]**.  This is called [&quot;soft-quoted branching&quot;](https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020))*

    &gt;&gt; num: 1020, rule: null

    ; generated [some &#39;b] rule is treated as if it had been written there
    &gt;&gt; parse [a a a b b b] [some &#39;a :(if even? num &#39;[some &#39;b])]
    == b 

    ; generated ~void~ from non-taken IF gets ignored, and it kept parsing
    &gt;&gt; parse [a a a b b b] [some &#39;a :(if odd? num &#39;[some &#39;c]) some &#39;b]
    == b

    ; generated ~true~ signal continues parse, just as ~void~ did
    &gt;&gt; parse [a a a b b b] [some &#39;a :(even? num) some &#39;b]
    == b

    ; generated ~false~ skips to next alternate (isn&#39;t one, so parse fails)
    &gt;&gt; parse [a a a b b b] [some &#39;a :(odd? num) some &#39;b]
    ** Error: PARSE BLOCK! combinator did not match input

    ; treat ~null~ conservatively, use :(maybe rule) for ~void~ to keep going 
    &gt;&gt; parse [a a a b b b] [some &#39;a :(rule) some &#39;b]
    ** Error: ~null~ antiform generated by GET-GROUP! in PARSE

## [Flexible Logic](https://forum.rebol.info/t/flexible-logic-system-terminology/2252) Kills `[~true~ ~false~]`... Breaks That Idea

In the flexible logic model, `[TRUE FALSE ON OFF YES NO]` are WORD!s, and hence indiscriminately trigger taking the branch in something like an IF when used directly.  The ~null~ antiform is the &quot;branch inhibitor&quot;, and it&#39;s what conditional expressions return when they don&#39;t match the condition.

    &gt;&gt; 10 &gt; 20
    == ~null~  ; anti

I don&#39;t think it&#39;s a good idea to make substitions via GET-GROUP! (or whatever comes to replace it) silently continue on NULL.  If you forgot to set a variable that was supposed to hold something (as in **rule** above), that should give you an error.  But I don&#39;t think you should have to write **:(maybe even? num)** :nauseated_face: 

## So Having A Conditional Logic Combinator Makes Sense

I just think that IF is a rather lousy name for it.

So I&#39;ll suggest **WHEN**.

    &gt;&gt; parse [a a a b b b] [some &#39;a, when (even? num), some &#39;b]
    == b 

It would be against the premise of flexible logic to have WHEN be biased and assume things like TRUE, YES, or NO should mean it continues or not.  I like the idea that you could hold a completely arbitrary word in a variable and say **`when (word)`**, that means *&quot;continue matching when word is set to a non-null value&quot;*.

Hence you&#39;d have to say **`when (true? flag)`** or **`when (off? toggle)`** etc.  I&#39;m not merely *comfortable* with this... I am gung-ho about it! :comet:

(Of course people can make their own combinators and build in biases of their choosing, the core just doesn&#39;t pick sides.)

## BYPASS Can Be A Synonym For `[when (null)]`

I didn&#39;t like using FAIL for saying when to stop a rule chain and go to the next alternate, because that is used for causing &quot;abrupt failures&quot; in the system.

So I&#39;d been using quasiform `~false~` the state in source (and the antiform if in a variable).

    &gt;&gt; parse [a a a b b b] [some &#39;a, :(if even? num [false]), some &#39;b]
    ** Error: PARSE BLOCK! combinator did not match input

    &gt;&gt; parse [a a a b b b] [some &#39;a, ~false~, some &#39;b]
    ** Error: PARSE BLOCK! combinator did not match input

But that isn&#39;t the model anymore.  There is no ~false~ or ~true~ antiform.  And honestly it wasn&#39;t that literate anyway. **when (...)** makes it clearer when you&#39;re using a variable.  And the quasiform just looks confusing.

Searching for a good word that doesn&#39;t run into something serving other purposes (e.g. BREAK), I asked Claude.ai for suggestions, and one of those was BYPASS.

I like it.  So for example you could write:

    &gt;&gt; parse [a a a b b b] [some &#39;a [:(if even? num [&#39;bypass]) some &#39;c] | some &#39;b]]
    == b

Although that particular case is clearer as **`[when (odd? num) ...]`**, but sometimes you have to throw in a bypass rule.

*(Amusingly, in Rebol2 the idiom for BYPASS was **`[end skip]`**, which was a rule guaranteed to mismatch at any position: either you weren&#39;t at the tail and the END wouldn&#39;t match, or you were at the tail and the END would match but then you couldn&#39;t SKIP.)*

## Where Does It Stop?

&gt; I also wondered &quot;where does it end?&quot;  With an IF combinator, why not a CASE combinator, or SWITCH combinator?

So I think it&#39;s good to just say WHEN.

You don&#39;t *technically* need WHEN if you have BYPASS to skip to next alternate, and ~void~ to keep going (or empty block, if you like... `[]` will keep going too).

     when (cond) =&gt; :(if not cond [&#39;bypass])  ; or :(if not cond &#39;bypass)

But that forces you to reverse the sense of your logic and write out something longer (and slower).  I think if you&#39;ve got logic that&#39;s complex like a case or switch, then writing it out as a splicing rule would have negligible benefit to try and shoehorn as a combinator.

## A Potential Weak Spot In **`#`** for Canon Branch Trigger

It&#39;s a given that the ~null~ antiform is the canon &quot;Branch Inhibitor&quot;.  It may well be the *only* branch inhibitor (though I&#39;m considering [~NaN~ antiforms](https://forum.rebol.info/t/isotopes-and-nan-not-a-number/2245) might also not trigger branches).

What&#39;s more up in the air is what the *canon branch trigger* is.

[quote=&quot;hostilefork, post:5, topic:2250&quot;]
I think this all just points to **`#`** being the most sensible choice, even though it&#39;s not an antiform. You can&#39;t have everything.
[/quote]

Before considering WHEN--I was looking at the impacts of using **#** on the GET-GROUP! substitution rules that had been in place.

Previously you could do this:

    &gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(odd? zeros) some #{FF}]
    == #{FF}

    &gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(even? zeros) some #{FF}]
    ** Error: PARSE BLOCK! combinator did not match input

But this becomes *fully broken* with things like EVEN? and ODD? returning either **`~null~`** or **`#`**.

    &gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(odd? zeros) some #{FF}]
    ** Error: ~null~ antiform generated by GET-GROUP! in PARSE

    &gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(even? zeros) some #{FF}]
    ** Error: PARSE BLOCK! combinator did not match input

The second case didn&#39;t match because since things like **`#a`** are character literals, **`#`** has been used to represent the 0 codepoint.  So in BINARY! it matches that.

    &gt;&gt; append #{DECAFBAD} #
    == #{DECAFBAD00}

    &gt;&gt; parse #{000000} [some #]
    == #

*(Having the # combinator synthesize # vs 0 is debatable.  But it wouldn&#39;t be #{00}.  We don&#39;t want matching combinators to make new series--they only return their own series argument which is already allocated.)*

And if you had a BLOCK! it would match **#**

    &gt;&gt; data: [a a a # b b b]

    &gt;&gt; parse data [some &#39;a :(true? trailing-b) some &#39;b]
    == b  ; great!  we know the block is all As and Bs!  (oh, WHOOPS!)

This is part of why I was saying the canon branch trigger should be an antiform--because it gets pushed out of band for things like this.

But the inconvenient truth is that tradeoffs are inevitable.  Here (and elsewhere) the problem can be addressed by not trying to mix conditional logic with substitution.  Substitution needs to be either a legal array element, or a ~void~ antiform to consciously opt out.  Conditional logic is now fully driven by non-nullity, meaning you need different instructions to contrast it with full-band substitution.

It still makes me a uneasy that the canon branch trigger isn&#39;t an antiform.  That will inevitably cause confusion... be accepted where it shouldn&#39;t, or have unintended meanings.

    &gt;&gt; num: 304

    &gt;&gt; compose [flag: (odd? num)]
    ** Error: Cannot compose ~null~ antiform into array slot

    &gt;&gt; compose [flag: (even? num)]
    == [flag: #]  ; we allowed something that is likely not what you meant

**So perhaps people can be empathetic to why I thought NOTHING would be a better choice for the canon branch trigger!**

But this might be an unwinnable fight, and the consequences of reusing the NOTHING antiform are greater than that of getting the occasional # substituted where it should not be...with the burden of inventing a whole new antiform not giving the payoff that putting another part in the mix needs to have.</description>
    
    <lastBuildDate>Fri, 13 Sep 2024 04:50:09 +0000</lastBuildDate>
    <category>Parsing</category>
    <atom:link href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I don't think it's a good idea to make substitions via GET-GROUP! (or whatever comes to replace it) silently continue on NULL. If you forgot to set a variable that was supposed to hold something (as in <strong>rule</strong> above), that should give you an error. But I don't think you should have to write <strong>:(maybe even? num)</strong> <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=12" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
</blockquote>
</aside>
<p>Having spent some time with this in practice, I'm wondering if it's doing more harm than good to not allowing NULL in GET-GROUP! substitutions to mean <em>"rule doesn't match"</em>.</p>
<p>It's particularly painful with WHILE:</p>
<pre><code>while :(mode = 'read) [some chunk]

; vs.

while when (mode = 'read) [some chunk]
</code></pre>
<p><strong>I am uncertain that the safety advantage is really worth it.</strong>  NULL variables aren't unset variables.  Having the state mean "don't keep going" seems useful enough to outweigh the occasional accident of "I meant to have a rule here but forgot it" case.</p>
<p>So I'm changing splicing to be null tolerant (well, tolerant in the sense that it won't abruptly fail, but triggers a rule mismatch).</p>
<p>The bigger issue is that leading colon for this is likely not going to be what it is, given the new general semantics of "optionality" that leading colon implies.  <a href="https://forum.rebol.info/t/get-group-s-in-parse-mean-execute-and-splice-as-rule/968/18">So I'm thinking that's going to be doubled groups again.</a></p>
<pre><code>while ((mode = 'read)) [some chunk]
</code></pre>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/13</link>
        <pubDate>Fri, 13 Sep 2024 04:50:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-13</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>You'll have to use an example then.</p>
<p>In the ordinary evaluator, IF does nothing if the condition is false...so you'll have to illustrate what you mean.</p>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/12</link>
        <pubDate>Fri, 06 Sep 2024 04:15:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-12</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Oh, looks like there’s been more confusion, sorry… I meant, outside PARSE altogether! That is, at the ‘top level’ of the program.</p>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/11</link>
        <pubDate>Fri, 06 Sep 2024 04:14:32 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-11</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Ah, so the "actual" IF combinator.</p>
<p>We can accomplish the most typical desire with <strong><code>:(if condition block)</code></strong></p>
<ul>
<li>
<p>When the condition is not null, the block is evaluated and its product used as a rule.</p>
</li>
<li>
<p>When the condition is null, a ~void~ antiform is returned from the IF, and the evaluator skips it and keeps going.</p>
</li>
</ul>
<p>If we made an IF combinator, you'd have to put your conditional code in a GROUP!.  Unless you meant to actually match content with a rule as your condition, like this:</p>
<pre><code>&gt;&gt; parse [hello world 304] [if opt 'hello [word! integer!]]
== 304
</code></pre>
<p>So what you used as a condition was what was synthesized by <code>[opt 'hello]</code> ... in this case the WORD! <code>hello</code> that matched (had it not matched it would be null).  Then since it was non-null, it matched the next block vs. skipping it.</p>
<p>That's something you can't do with putting the code in a GET-GROUP!.  I don't know how frequent that desire is, since most of the desire has been to control a rule based on a guard flag of some kind.</p>
<pre><code>&gt;&gt; worldnumber: 'true

&gt;&gt; parse [world 304] [if (true? worldnumber) [word! integer!]]
== 304
</code></pre>
<p>If that's the case, then your advantage can be small...as small as two characters for having the combinator.</p>
<pre><code>:(if true? worldnumber '[word! integer!])
if (true? worldnumber) [word! integer!]
</code></pre>
<p>But...I mean, I guess an IF combinator of that sort would be all right to have.  Trivial to write.  Just perhaps a little leery of the slippery slope of recreating every control construct as a combinator.</p>
<p>Were it to exist, I'd probably find uses for it.</p>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/10</link>
        <pubDate>Fri, 06 Sep 2024 04:09:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-10</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Basically, <code>when condition block ≡ if condition block []</code>. That is, it would run the given block if the condition is true, and do nothing otherwise.</p>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/9</link>
        <pubDate>Fri, 06 Sep 2024 03:54:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-9</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Well now I'm confused, what would a "top level" WHEN combinator be?</p>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/8</link>
        <pubDate>Fri, 06 Sep 2024 02:02:58 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-8</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Oh… whoops, OK, not sure how I missed that. For some reason I thought you were talking about WHEN as a top-level combinator. (Which is <em>also</em> a very useful thing to have!)</p>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/7</link>
        <pubDate>Fri, 06 Sep 2024 02:00:59 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-7</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>This is the example of using it in PARSE.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So Having A Conditional Logic Combinator Makes Sense</p>
<p>I just think that IF is a rather lousy name for it.</p>
<p>So I'll suggest <strong>WHEN</strong>.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; num: 1020

&gt;&gt; parse [a a a b b b] [some 'a, when (even? num), some 'b]
== b 
</code></pre>
</blockquote>
</aside>
<p>I didn't add the failing case, but:</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, when (odd? num), some 'b]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>I don't know how it would be applied in the main evaluator...</p>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/6</link>
        <pubDate>Fri, 06 Sep 2024 01:49:20 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-6</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Problem is when I go off and experiment I tend to tackle too many things at once, I tried to do Haskell on Arch Linux and got bored trying to figure it out.</p>
</blockquote>
</aside>
<p>Ah-ha. Do <em>not</em> use Haskell libraries from the Arch package repositories. They are famously broken, mostly because GHC doesn’t play well with dynamic linking. (I say this as someone using Arch myself.)</p>
<p>Instead, I strongly recommend using <a href="https://www.haskell.org/ghcup/">GHCup</a>.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="3" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Would you consider adding it to <code>parse</code> dialect too?</p>
</blockquote>
</aside>
<p>Hm? This is the PARSE dialect... what do you mean?</p>
</blockquote>
</aside>
<p>Hmm, maybe I’m just struggling to understand your PARSE examples. Where in that post did you show an example of WHEN in PARSE?</p>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/4</link>
        <pubDate>Fri, 06 Sep 2024 01:46:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-4</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>A good name — Haskell calls it this too.</p>
</blockquote>
</aside>
<p>I really should have clocked more time using Haskell to parse stuff.  <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=12" title=":frowning:" class="emoji" alt=":frowning:" loading="lazy" width="20" height="20"></p>
<p>Problem is when I go off and experiment I tend to tackle too many things at once, I tried to do Haskell on Arch Linux and got bored trying to figure it out.</p>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Would you consider adding it to <code>parse</code> dialect too?</p>
</blockquote>
</aside>
<p>Hm?  This is the PARSE dialect... what do you mean?</p>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/3</link>
        <pubDate>Fri, 06 Sep 2024 01:15:52 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-3</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2253">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So I'll suggest <strong>WHEN</strong>.</p>
</blockquote>
</aside>
<p>A good name — Haskell calls it this too. It’s a very useful combinator, so good to have.</p>
<p>Would you consider adding it to <code>parse</code> dialect too? It has a natural interpretation: parse the next thing only when the condition is true. (Again, this is something Haskell has.)</p>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/2</link>
        <pubDate>Fri, 06 Sep 2024 01:13:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-2</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
      <item>
        <title>Resurrecting the &quot;IF&quot; Combinator... as WHEN</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>R3-Alpha had an idea--carried forward by Red--of an <strong>arity-1</strong> IF combinator.</p>
<pre><code>red&gt;&gt; num: 1020

red&gt;&gt; parse [a a a] [if (even? num) some 'a]
== true

red&gt;&gt; parse [a a a] [if (odd? num) some 'a]
== false
</code></pre>
<p>As you see, if the expression you give it turns out to be "falsey" then it doesn't continue matching.  It skips to the next alternate--if there is one.</p>
<pre><code>red&gt;&gt; parse [a a a] [if (odd? num) some 'b | some 'a]
== true
</code></pre>
<p>But I always thought the arity-1 IF was a pretty alien thing that would confuse people.  You might think there's a branch, but there's no "branch"... just continuing along with the variadic list of everything that follows until the next <strong>|</strong> or end of BLOCK!.</p>
<p>I also wondered "where does it end?"  With an IF combinator, why not a CASE combinator, or SWITCH combinator?</p>
<p>So when I came up with GET-GROUP! doing arbitrary substitutions of the rule it evaluates to, I thought "hey, that's a lot more general!"  We could just say that ~true~ and ~void~ antiforms would continue the parse, ~false~ would stop it, and ~null~ antiforms would trigger an error in case you didn't mean to do that.</p>
<h3><a name="p-7569-what-that-get-group-concept-looked-like-1" class="anchor" href="https://forum.rebol.info#p-7569-what-that-get-group-concept-looked-like-1"></a>What That <code>:(GET-GROUP!)</code> Concept Looked Like</h3>
<p><em>(Note that <strong>if condition '[...]</strong> is equivalent to <strong>if condition [[...]]</strong>.  This is called <a href="https://forum.rebol.info/t/soft-quoted-branching-light-elegant-fast/1020">"soft-quoted branching"</a>)</em></p>
<pre><code>&gt;&gt; num: 1020, rule: null

; generated [some 'b] rule is treated as if it had been written there
&gt;&gt; parse [a a a b b b] [some 'a :(if even? num '[some 'b])]
== b 

; generated ~void~ from non-taken IF gets ignored, and it kept parsing
&gt;&gt; parse [a a a b b b] [some 'a :(if odd? num '[some 'c]) some 'b]
== b

; generated ~true~ signal continues parse, just as ~void~ did
&gt;&gt; parse [a a a b b b] [some 'a :(even? num) some 'b]
== b

; generated ~false~ skips to next alternate (isn't one, so parse fails)
&gt;&gt; parse [a a a b b b] [some 'a :(odd? num) some 'b]
** Error: PARSE BLOCK! combinator did not match input

; treat ~null~ conservatively, use :(maybe rule) for ~void~ to keep going 
&gt;&gt; parse [a a a b b b] [some 'a :(rule) some 'b]
** Error: ~null~ antiform generated by GET-GROUP! in PARSE
</code></pre>
<h2><a name="p-7569-flexible-logichttpsforumrebolinfotflexible-logic-system-terminology2252-kills-true-false-breaks-that-idea-2" class="anchor" href="https://forum.rebol.info#p-7569-flexible-logichttpsforumrebolinfotflexible-logic-system-terminology2252-kills-true-false-breaks-that-idea-2"></a><a href="https://forum.rebol.info/t/flexible-logic-system-terminology/2252">Flexible Logic</a> Kills <code>[~true~ ~false~]</code>... Breaks That Idea</h2>
<p>In the flexible logic model, <code>[TRUE FALSE ON OFF YES NO]</code> are WORD!s, and hence indiscriminately trigger taking the branch in something like an IF when used directly.  The ~null~ antiform is the "branch inhibitor", and it's what conditional expressions return when they don't match the condition.</p>
<pre><code>&gt;&gt; 10 &gt; 20
== ~null~  ; anti
</code></pre>
<p>I don't think it's a good idea to make substitions via GET-GROUP! (or whatever comes to replace it) silently continue on NULL.  If you forgot to set a variable that was supposed to hold something (as in <strong>rule</strong> above), that should give you an error.  But I don't think you should have to write <strong>:(maybe even? num)</strong> <img src="https://forum.rebol.info/images/emoji/twitter/nauseated_face.png?v=12" title=":nauseated_face:" class="emoji" alt=":nauseated_face:" loading="lazy" width="20" height="20"></p>
<h2><a name="p-7569-so-having-a-conditional-logic-combinator-makes-sense-3" class="anchor" href="https://forum.rebol.info#p-7569-so-having-a-conditional-logic-combinator-makes-sense-3"></a>So Having A Conditional Logic Combinator Makes Sense</h2>
<p>I just think that IF is a rather lousy name for it.</p>
<p>So I'll suggest <strong>WHEN</strong>.</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, when (even? num), some 'b]
== b 
</code></pre>
<p>It would be against the premise of flexible logic to have WHEN be biased and assume things like TRUE, YES, or NO should mean it continues or not.  I like the idea that you could hold a completely arbitrary word in a variable and say <strong><code>when (word)</code></strong>, that means <em>"continue matching when word is set to a non-null value"</em>.</p>
<p>Hence you'd have to say <strong><code>when (true? flag)</code></strong> or <strong><code>when (off? toggle)</code></strong> etc.  I'm not merely <em>comfortable</em> with this... I am gung-ho about it! <img src="https://forum.rebol.info/images/emoji/twitter/comet.png?v=12" title=":comet:" class="emoji" alt=":comet:" loading="lazy" width="20" height="20"></p>
<p>(Of course people can make their own combinators and build in biases of their choosing, the core just doesn't pick sides.)</p>
<h2><a name="p-7569-bypass-can-be-a-synonym-for-when-null-4" class="anchor" href="https://forum.rebol.info#p-7569-bypass-can-be-a-synonym-for-when-null-4"></a>BYPASS Can Be A Synonym For <code>[when (null)]</code></h2>
<p>I didn't like using FAIL for saying when to stop a rule chain and go to the next alternate, because that is used for causing "abrupt failures" in the system.</p>
<p>So I'd been using quasiform <code>~false~</code> the state in source (and the antiform if in a variable).</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a, :(if even? num [false]), some 'b]
** Error: PARSE BLOCK! combinator did not match input

&gt;&gt; parse [a a a b b b] [some 'a, ~false~, some 'b]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>But that isn't the model anymore.  There is no ~false~ or ~true~ antiform.  And honestly it wasn't that literate anyway. <strong>when (...)</strong> makes it clearer when you're using a variable.  And the quasiform just looks confusing.</p>
<p>Searching for a good word that doesn't run into something serving other purposes (e.g. BREAK), I asked Claude.ai for suggestions, and one of those was BYPASS.</p>
<p>I like it.  So for example you could write:</p>
<pre><code>&gt;&gt; parse [a a a b b b] [some 'a [:(if even? num ['bypass]) some 'c] | some 'b]]
== b
</code></pre>
<p>Although that particular case is clearer as <strong><code>[when (odd? num) ...]</code></strong>, but sometimes you have to throw in a bypass rule.</p>
<p><em>(Amusingly, in Rebol2 the idiom for BYPASS was <strong><code>[end skip]</code></strong>, which was a rule guaranteed to mismatch at any position: either you weren't at the tail and the END wouldn't match, or you were at the tail and the END would match but then you couldn't SKIP.)</em></p>
<h2><a name="p-7569-where-does-it-stop-5" class="anchor" href="https://forum.rebol.info#p-7569-where-does-it-stop-5"></a>Where Does It Stop?</h2>
<blockquote>
<p>I also wondered "where does it end?"  With an IF combinator, why not a CASE combinator, or SWITCH combinator?</p>
</blockquote>
<p>So I think it's good to just say WHEN.</p>
<p>You don't <em>technically</em> need WHEN if you have BYPASS to skip to next alternate, and ~void~ to keep going (or empty block, if you like... <code>[]</code> will keep going too).</p>
<pre><code> when (cond) =&gt; :(if not cond ['bypass])  ; or :(if not cond 'bypass)
</code></pre>
<p>But that forces you to reverse the sense of your logic and write out something longer (and slower).  I think if you've got logic that's complex like a case or switch, then writing it out as a splicing rule would have negligible benefit to try and shoehorn as a combinator.</p>
<h2><a name="p-7569-a-potential-weak-spot-in-for-canon-branch-trigger-6" class="anchor" href="https://forum.rebol.info#p-7569-a-potential-weak-spot-in-for-canon-branch-trigger-6"></a>A Potential Weak Spot In <strong><code>#</code></strong> for Canon Branch Trigger</h2>
<p>It's a given that the ~null~ antiform is the canon "Branch Inhibitor".  It may well be the <em>only</em> branch inhibitor (though I'm considering <a href="https://forum.rebol.info/t/isotopes-and-nan-not-a-number/2245">~NaN~ antiforms</a> might also not trigger branches).</p>
<p>What's more up in the air is what the <em>canon branch trigger</em> is.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2250">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="https://forum.rebol.info/t/true-false-on-off-yes-no/2250/5">True, False, On, Off, Yes, No...?</a></div>
<blockquote>
<p>I think this all just points to <strong><code>#</code></strong> being the most sensible choice, even though it's not an antiform. You can't have everything.</p>
</blockquote>
</aside>
<p>Before considering WHEN--I was looking at the impacts of using <strong>#</strong> on the GET-GROUP! substitution rules that had been in place.</p>
<p>Previously you could do this:</p>
<pre><code>&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(odd? zeros) some #{FF}]
== #{FF}

&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(even? zeros) some #{FF}]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>But this becomes <em>fully broken</em> with things like EVEN? and ODD? returning either <strong><code>~null~</code></strong> or <strong><code>#</code></strong>.</p>
<pre><code>&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(odd? zeros) some #{FF}]
** Error: ~null~ antiform generated by GET-GROUP! in PARSE

&gt;&gt; parse #{000000FFFFFF} [zeros: tally #{00} :(even? zeros) some #{FF}]
** Error: PARSE BLOCK! combinator did not match input
</code></pre>
<p>The second case didn't match because since things like <strong><code>#a</code></strong> are character literals, <strong><code>#</code></strong> has been used to represent the 0 codepoint.  So in BINARY! it matches that.</p>
<pre><code>&gt;&gt; append #{DECAFBAD} #
== #{DECAFBAD00}

&gt;&gt; parse #{000000} [some #]
== #
</code></pre>
<p><em>(Having the # combinator synthesize # vs 0 is debatable.  But it wouldn't be #{00}.  We don't want matching combinators to make new series--they only return their own series argument which is already allocated.)</em></p>
<p>And if you had a BLOCK! it would match <strong>#</strong></p>
<pre><code>&gt;&gt; data: [a a a # b b b]

&gt;&gt; parse data [some 'a :(true? trailing-b) some 'b]
== b  ; great!  we know the block is all As and Bs!  (oh, WHOOPS!)
</code></pre>
<p>This is part of why I was saying the canon branch trigger should be an antiform--because it gets pushed out of band for things like this.</p>
<p>But the inconvenient truth is that tradeoffs are inevitable.  Here (and elsewhere) the problem can be addressed by not trying to mix conditional logic with substitution.  Substitution needs to be either a legal array element, or a ~void~ antiform to consciously opt out.  Conditional logic is now fully driven by non-nullity, meaning you need different instructions to contrast it with full-band substitution.</p>
<p>It still makes me a uneasy that the canon branch trigger isn't an antiform.  That will inevitably cause confusion... be accepted where it shouldn't, or have unintended meanings.</p>
<pre><code>&gt;&gt; num: 304

&gt;&gt; compose [flag: (odd? num)]
** Error: Cannot compose ~null~ antiform into array slot

&gt;&gt; compose [flag: (even? num)]
== [flag: #]  ; we allowed something that is likely not what you meant
</code></pre>
<p><strong>So perhaps people can be empathetic to why I thought NOTHING would be a better choice for the canon branch trigger!</strong></p>
<p>But this might be an unwinnable fight, and the consequences of reusing the NOTHING antiform are greater than that of getting the occasional # substituted where it should not be...with the burden of inventing a whole new antiform not giving the payoff that putting another part in the mix needs to have.</p>
          <p><a href="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253/1</link>
        <pubDate>Thu, 05 Sep 2024 20:19:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2253-1</guid>
        <source url="https://forum.rebol.info/t/resurrecting-the-if-combinator-as-when/2253.rss">Resurrecting the &quot;IF&quot; Combinator... as WHEN</source>
      </item>
  </channel>
</rss>

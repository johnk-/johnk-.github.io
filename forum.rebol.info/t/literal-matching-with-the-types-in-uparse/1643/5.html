<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Literal Matching with the @ Types In UPARSE - #5 by hostilefork - Parsing - AltRebol</title>
    <meta name="description" content="I mentioned that the @ types were slated for use for literal matching.  The most frequent example I have given is: 
&amp;gt;&amp;gt; block: [some &amp;quot;a&amp;quot;]

&amp;gt;&amp;gt; uparse [[some &amp;quot;a&amp;quot;] [some &amp;quot;a&amp;quot;]] [some @block]
== [some &amp;quot;a&amp;quot;]  ; success gives res&amp;hellip;">
    <meta name="generator" content="Discourse 2.7.0.beta4 - https://github.com/discourse/discourse version 3fc72543de22c329cf2156f28b781821adc496ae">
<link rel="icon" type="image/png" href="../../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" content="#ffffff">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="../1643.html" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://forum.rebol.info","potentialAction":{"@type":"SearchAction","target":"https://forum.rebol.info/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../../opensearch.xml" title="AltRebol Search">

      <link href="https://forum.rebol.info/stylesheets/desktop_cdfbc200d3f5311dbee0f69ae668cfc42cfc8cb7.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop" data-theme-id="2"/>
      <link href="https://forum.rebol.info/stylesheets/desktop_theme_2_7b2b5b1bc734c2cc3b6ad5e0f49f467e8601ef2c.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2"/>
    
    
        <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;Literal Matching with the @ Types In UPARSE&#39;" href="../1643.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://forum.rebol.info/t/literal-matching-with-the-types-in-uparse/1643/5" />
<meta name="twitter:url" content="https://forum.rebol.info/t/literal-matching-with-the-types-in-uparse/1643/5" />
<meta property="og:title" content="Literal Matching with the @ Types In UPARSE" />
<meta name="twitter:title" content="Literal Matching with the @ Types In UPARSE" />
<meta property="og:description" content="We need an answer to matching literal content I&#39;ve been punting on this bug in SPLIT:  &gt;&gt; split [a &lt;t&gt; b c &lt;t&gt;] &lt;t&gt;  ; expecting [[a] [b c] []] ** Error: TAG! combinator must be &lt;here&gt; or &lt;end&gt; ATM ** Near: [to dlm ** | to &lt;end&gt;]  That error is coming from PARSE3, not PARSE (which is now what UPARSE is called, as it is decidedly superior semantics, and I don&#39;t want to teach any new users PARSE3/PARSE2).  Even though PARSE3 doesn&#39;t have much in the way of TAG! combinators (just &lt;here&gt; and &lt;end&gt;)..." />
<meta name="twitter:description" content="We need an answer to matching literal content I&#39;ve been punting on this bug in SPLIT:  &gt;&gt; split [a &lt;t&gt; b c &lt;t&gt;] &lt;t&gt;  ; expecting [[a] [b c] []] ** Error: TAG! combinator must be &lt;here&gt; or &lt;end&gt; ATM ** Near: [to dlm ** | to &lt;end&gt;]  That error is coming from PARSE3, not PARSE (which is now what UPARSE is called, as it is decidedly superior semantics, and I don&#39;t want to teach any new users PARSE3/PARSE2).  Even though PARSE3 doesn&#39;t have much in the way of TAG! combinators (just &lt;here&gt; and &lt;end&gt;)..." />
<meta property="article:published_time" content="2022-07-11T19:01:53+00:00" />
<meta property="og:ignore_canonical" content="true" />



    
  </head>
  <body class="crawler">
    
    <header>
      <a href="https://forum.rebol.info/">
          <img src="../../../uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" alt="AltRebol" id="site-logo" style="max-width: 150px;">
      </a>
    </header>
    <div id="main-outlet" class="wrap">
        <div id="topic-title">
    <h1>
      <a href="../1643.html">Literal Matching with the @ Types In UPARSE</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/domains/15" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #F1592A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Domains</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/domains/parsing/16" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #F1592A'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Parsing</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  


      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="../1643.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2021-08-02T18:58:15Z'>
              <time itemprop='dateModified' datetime='2021-08-02T19:41:13Z' class='post-time'>
                August 2, 2021,  7:41pm
              </time>
          <span itemprop='position'>#1</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <p>I mentioned that the @ types were slated for use for literal matching.  The most frequent example I have given is:</p>
<pre><code>&gt;&gt; block: [some "a"]

&gt;&gt; uparse [[some "a"] [some "a"]] [some @block]
== [some "a"]  ; success gives result of last matching rule
</code></pre>
<p>Works with all types:</p>
<pre><code>&gt;&gt; num: 1

&gt;&gt; uparse [1 1 1] [some @num]
== 1
</code></pre>
<p>I didn't mention things like @(gr o up) but those work too:</p>
<pre><code>&gt;&gt; uparse [1 1 1] [some @(3 - 2)]
== 1
</code></pre>
<p><strong>I realized I actually do not know how to write the above two cases in Red or Rebol2.</strong>  You can't use the number as a plain variable in Red, since it acts as a repeat rule <em>(UPARSE prohibits that, since it's a rule that takes an argument, you must use REPEAT for such behavior)</em></p>
<pre><code>red&gt;&gt; num: 1

red&gt;&gt; parse [1 1 1] [some num]
*** Script Error: PARSE - invalid rule or usage of rule: 1
</code></pre>
<p>Also in Red, I'm not clear on why the following isn't an error, since the GROUP! product is just discarded:</p>
<pre><code>red&gt;&gt; parse [1 1 1] [some (3 - 2)]
== false
</code></pre>
<p>This is something that would work in R3-Alpha, but doesn't in Red or Rebol2:</p>
<pre><code>red&gt;&gt; parse [1 1 1] [some quote (3 - 2)]
== false
</code></pre>
<p><strong>Your guess is as good as mine.</strong>  Whatever the answer in their world is, it's not obvious.  But I think the @ types give a clean answer in UPARSE.</p>
<h2>But What About @[bl o ck] ?</h2>
<p>In the past I suggested that one reason why <code>@[...]</code> might be taken for datatypes is because in cases like this, there'd be no difference between <code>@[bl o ck]</code> and <code>'[block]</code>.  I was imagining these being synonyms, because I couldn't think of anything else (since plain block was already "run rule"):</p>
<pre><code>&gt;&gt; uparse [[some "a"] [some "a"]] [some '[some "a"]]
== [some "a"]

&gt;&gt; uparse [[some "a"] [some "a"]] [some @[some "a"]]
== [some "a"]  ; "wasteful application of @[...], so why not datatype?"
</code></pre>
<p>But UPARSE has changed the game for why @[...] and [...] can mean different things...because <em>block rules synthesize values</em>.  And who's to say you might not want to match a rule and use its product as the literal thing to match against?</p>
<pre><code>&gt;&gt; uparse [1 1 1 2] [@[some '10, (10 + 10) | some '1 (1 + 1)]]
== 2
</code></pre>
<p>In other words your rule can match <em>and</em> provide an answer for the thing to match next.  We have zero experience with how often that might be useful.  But it does have meaning, which I guess is probably the death knell for using the @ types as DATATYPE!.</p>
<p>So this all looks pretty good.  But back to the drawing board for types.</p>
        </div>

        <meta itemprop='headline' content='Literal Matching with the @ Types In UPARSE'>
          <meta itemprop='keywords' content=''>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="2" />
           <span class='post-likes'>2 Likes</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="3" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="../1643.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2021-08-14T22:58:35Z'>
              <time itemprop='dateModified' datetime='2021-08-15T00:00:40Z' class='post-time'>
                August 15, 2021, 12:00am
              </time>
          <span itemprop='position'>#2</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1643">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I mentioned that the @ types were slated for use for literal matching.</p>
</blockquote>
</aside>
<p>Usage is making me wonder if this is the best use for @, or if it would be more helpful for literal non-matching... e.g. synthesizing values like a GROUP! would.</p>
<pre><code>&gt;&gt; uparse "a" [collect [keep @[keep some], keep &lt;any&gt;]]
== [keep some "a"]

&gt;&gt; uparse "a" [collect [keep @ 'keep, keep &lt;any&gt;]]
== [keep "a"]
</code></pre>
<p>Doing this kind of thing right now has several ugly alternatives:</p>
<pre><code>&gt;&gt; uparse "a" [collect [keep ^('keep), keep &lt;any&gt;]]
== [keep "a"]

&gt;&gt; uparse "a" [collect [keep ([keep]), keep &lt;any&gt;]]
== [keep "a"]
</code></pre>
<p><em>"What's so ugly about <strong>keep ([keep])</strong>"</em>, you might ask.  The problem isn't with it when it's written literally like that.  It's when you're trying to build a rule with COMPOSE and the contention over GROUP! and trying to nest inside of it becomes a bummer.</p>
<p>Let's say you're trying to build a KEEP parse rule inside a parse rule <em>(which I am actually at this moment trying to do in the whitespace interpreter project)</em>:</p>
<pre><code>name: "Binky"
uparse ... [... collect [
     keep (compose [keep (to word! name)])
] ...]
</code></pre>
<p>Okay so that gives you <strong>[keep Binky]</strong>.  Not what you wanted.  You can quote it...</p>
<pre><code>keep (compose [keep '(to word! name)])
</code></pre>
<p>Now you've got <strong>[keep 'Binky]</strong>.  But you're not trying to match Binky in the input, you're trying to synthesize it out of thin air.  Need it in a GROUP!... let's just go ahead and use the wacky engroup operator to do that:</p>
<pre><code>keep (compose [keep (engroup quote to word! name)])
</code></pre>
<p>So are we set, we've got <strong>[keep ('Binky)]</strong>?  Well, no... because KEEP demands evaluative values be quoted, and that quote is vaporized during the group evaluation so KEEP is getting a plain Binky word.  D'oh, so we need another quote on there somehow.  The ^ operator is one way, there are others that are more verbose:</p>
<pre><code>keep (compose [keep ^(engroup quote to word! name)])
</code></pre>
<blockquote>
<p><em>Notably you can't say <strong>keep '(engroup quote to word! name)</strong> because that becomes <strong>keep '('Binky)</strong>, which would look literally for a match in the input of a GROUP! like <strong>('Binky)</strong>.  <img src="../../../images/emoji/twitter/roll_eyes.png%3Fv=9" title=":roll_eyes:" class="emoji" alt=":roll_eyes:"></em></p>
</blockquote>
<h2>What A Freaking PITA... <img src="../../../images/emoji/twitter/cloud_with_rain.png%3Fv=9" title=":cloud_with_rain:" class="emoji" alt=":cloud_with_rain:"> ...We Can Do Better!</h2>
<p>If @ were used for literalization and synthesis of a non-match, we can make something less head-scratchy:</p>
<pre><code>keep (compose [keep @ '(to word! name)])
</code></pre>
<p>Poof.  If you wanted to quote inside the group you could do that too (effectively putting the "ONLY" on the value, as you would for keeping a block literally):</p>
<pre><code>keep (compose [keep @(quote to word! name)])
</code></pre>
<p><strong>The key to seeing why this breaks us out of the problem is that it lets us get at literal values without a GROUP!, which means we aren't trying to COMPOSE inside of COMPOSE groups.</strong></p>
<p>And there are lots of places we could benefit from this, I think.</p>
<pre><code>repeat ([2 3]) rule  =&gt;  repeat @[2 3] rule
</code></pre>
<p>Some situations might be a bit unsettling for people who don't see the @ as being quoting, e.g.:</p>
<pre><code>repeat (2) rule  =&gt;  repeat @ 2 rule
</code></pre>
<p>The 2 might look a bit too attached to the rule, if you don't realize the @ takes <em>one unit</em> of quoted parameterization to its right... not a full combinatorized parser like [2 rule]</p>
<p>But, I think it's just something you would have to get used to.  Like I say, it's actually this "let the @ stand off as a separate value" form that breaks the Gordian knot, when it comes to deeper forms of composition.</p>
<h2>What Would @(...) Mean In This Context?</h2>
<p>I guess it would just have to mean literally that GROUP, e.g. a synonym for <strong>@ (...)</strong>?</p>
<p>Because if it evaluated the group, what would it do to the result that would make it "more literal" than it already was?  You have ^(...) to add a quote level already--which wouldn't make sense for @.</p>
<p>It's an odd thing, but not useless.  After all, <strong>keep @[a b]</strong> is only one less character than <strong>keep ([a b])</strong>... though it would be more efficient due to knowing it doesn't need to run the evaluator on a GROUP!.  And <strong>keep @('foo)</strong> saves an additional character due to not needing to quote the group, as in <strong>keep ('('foo))</strong>.</p>
<p>Hm, so actually, I can see that being rather useful.</p>
<h2>How To Literal Match If Not With @ ?</h2>
<p>We were back to the drawing board on this when @ started acting like META, but then got it back when the ^XXX types came around...</p>
<p>And now we're back again.</p>
<p>You can splice the value in as a quoted rule, so at least there are options...  <strong>:(quote var)</strong> or <strong>:(^var)</strong></p>
<pre><code>&gt;&gt; block: [some "a"]
&gt;&gt; uparse [[some "a"] [some "a"]] [some :(quote block)]
== [some "a"]
</code></pre>
<p>Not my favorite, but by no means incoherent.</p>
<p>Though I'd already noticed one nagging missing point on literal matches, which was how to literally match a fetched block as a splice.</p>
<pre><code>block: [a b]
uparse [a b a b] [some ?operation? (block)]
</code></pre>
<p>When <code>@block</code> was a literal match, it had <strong>[[a b] [a b]]</strong> covered, but not this.  I don't know what that means, but it just pointed out to me there was something else afoot.</p>
<p>Still available at the moment are <strong>.foo</strong> and <strong>.(foo)</strong>, and <strong>/foo</strong> and <strong>/(foo)</strong> -- though I don't like those for this purpose.</p>
<p>I've been eyeing $foo $[foo] $(foo) etc for reasons like getting environment variables in shell dialects, and because I honestly think the potential here goes pretty far beyond MONEY!.  It would take some reckoning in the type system to get those available.</p>
<p>If $ becomes synonymous with "substitution", then might be that $(foo) makes more sense for "substitute this expansion as a rule" than GET-BLOCK! does, which might let the GET-XXX! variations mean "use this as a literal value".</p>
<h2>For Now I Need to Change @ So Code Gets Better... so...</h2>
        </div>

        <meta itemprop='headline' content='Literal Matching with the @ Types In UPARSE'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="2" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="../1643.html">


          <span class="crawler-post-infos">
              <time itemprop='datePublished' datetime='2021-08-15T02:05:07Z' class='post-time'>
                August 15, 2021,  2:05am
              </time>
              <meta itemprop='dateModified' content='2021-08-15T02:05:07Z'>
          <span itemprop='position'>#3</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1643">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>The key to seeing why this breaks us out of the problem is that it lets us get at literal values without a GROUP!, which means we aren't trying to COMPOSE inside of COMPOSE groups.</p>
</blockquote>
</aside>
<p>So trying this out, it does solve my problem, but it creates a disconnect I'm not totally comfortable with...</p>
<p>The @ operator itself has a parity.  In the normal evaluator:</p>
<pre><code>&gt;&gt; var: @ x
== x

&gt;&gt; var
== x
</code></pre>
<p>And in UPARSE:</p>
<pre><code>&gt;&gt; uparse "" [var: @ x]
== x

&gt;&gt; var
== x
</code></pre>
<p>All's good so far... this is the Gordian-knot slicer I talked about.  Synthesizing values out of thin air without a GROUP!, so it plays nicely with COMPOSE.</p>
<p>But I think this difference may be a mistake:</p>
<pre><code>&gt;&gt; var: @[a b]
== @[a b]

&gt;&gt; uparse "" [var: @[a b]]
== [a b]
</code></pre>
<p>While we accept that UPARSE and regular code act differently, I'm not clear on why @ would act the same but @[...] wouldn't.  The concept was maybe making it easier to do REPEAT ranges, but...well, if you wanted that, why not make REPEAT allow you to give it either BLOCK! or THE-BLOCK! ?</p>
<p>This also lets us maybe experiment with that trick I was suggesting, where even though evaluative types don't get added to blocks without a quote that maybe the @[...] types would.</p>
<pre><code>&gt;&gt; uparse "a" [collect [keep @keep, keep &lt;any&gt;]]]  ; no quote or ^ needed
== [keep #a]
</code></pre>
<p>This way you have both options for blocks:</p>
<pre><code>&gt;&gt; uparse "a" [collect [keep @[keep some], keep &lt;any&gt;]]
== [[keep some] #a]

&gt;&gt; uparse "a" [collect [keep @ [keep some], keep &lt;any&gt;]]
== [keep some #a]
</code></pre>
<p>I think I was trying to make those both do the same thing, but when you look at the broader picture, that doesn't seem all that useful.  If that inconsistency bothers you, then use THE instead:</p>
<pre><code>&gt;&gt; uparse "a" [collect [keep @[keep some], keep &lt;any&gt;]]
== [[keep some] #a]

&gt;&gt; uparse "a" [collect [keep the [keep some], keep &lt;any&gt;]]
== [keep some #a]
</code></pre>
<p>If we had infinite symbols on the keyboard I might propose the symbolic THE use something else besides @, but, we don't have infinite symbols and I think I can wrap my head around the rule:</p>
<pre><code>@ x =&gt; x
@x =&gt; @x
</code></pre>
<p>I haven't fully absorbed the implications here, but I do think this concept of having the <code>@xxx</code> types being a new "do whatever you want with it" argument type that plays along with combinators is pretty interesting.  The ANY rule could accept it, for example:</p>
<pre><code>uparse [10 &lt;twenty&gt; "hello" 20 304] [some any @[integer! tag! text!]]
</code></pre>
<p>Which to my eyes feels a little bit more comfortable than:</p>
<pre><code>uparse [10 &lt;twenty&gt; "hello" 20 304] [some any ([integer! tag! text!])]
</code></pre>
<p>I'll just have to see how it comes along.</p>
        </div>

        <meta itemprop='headline' content='Literal Matching with the @ Types In UPARSE'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="../1643.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2021-11-29T12:06:35Z'>
              <time itemprop='dateModified' datetime='2021-11-29T14:12:09Z' class='post-time'>
                November 29, 2021,  2:12pm
              </time>
          <span itemprop='position'>#4</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="2" data-topic="1643">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1643">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I mentioned that the @ types were slated for use for literal matching.</p>
</blockquote>
</aside>
<p>Usage is making me wonder if this is the best use for @, or if it would be more helpful for literal non-matching... e.g. synthesizing values like a GROUP! would.</p>
</blockquote>
</aside>
<p><strong>This has become a real sticking point, between two really good potential uses for the <code>@XXX</code> types in PARSE.</strong></p>
<ul>
<li>
<p>It's neat to have them be completely inert.  That lines up with their behavior in the normal evaluator, and by having them just passed through by the PARSE dialect you can make your combinators react to them in novel ways.</p>
</li>
<li>
<p>But without a way of saying <em>"I mean match this variable literally"</em>, you can't do things like <strong><code>num: 1, parse [1 1 1] [some @num]</code></strong></p>
</li>
</ul>
<p>One of the motivators to support the neutral interpretation was to allow things like PARSE's COLLECT+KEEP to build on this behavior:</p>
<pre><code>&gt;&gt; append [a b c] @d
== [a b c d]
</code></pre>
<p>You could do similar things with:</p>
<pre><code>&gt;&gt; uparse [1 2] [collect some [keep @hello, keep integer!]]
== [hello 1 hello 2]
</code></pre>
<p>It's messier without this, especially with the rules prohibiting raw evaluative values.  You have to quote the WORD! to keep it from evaluating, put it inside a group, and then either META it or ONLY it:</p>
<pre><code>&gt;&gt; uparse [1 2] [collect some [keep ^('hello), keep integer!]]
== [hello 1 hello 2]

&gt;&gt; uparse [1 2] [collect some [keep only ('hello), keep integer!]]
== [hello 1 hello 2]
</code></pre>
<p>Arguably you could do this with a combinator like THE, or if lone @ was allowed to do the behavior:</p>
<pre><code>&gt;&gt; uparse [1 2] [collect some [keep only the hello, keep integer!]]
== [hello 1 hello 2]

&gt;&gt; uparse [1 2] [collect some [keep only @ hello, keep integer!]]
== [hello 1 hello 2]
</code></pre>
<h2>Is The Inert-Only Rule Cure Worse Than The Disease?</h2>
<p>I'm not really ready to give up on the rules for block mechanics that have emerged, which make meta usage with variables very sensible:</p>
<pre><code>; if var is a BAD-WORD! isotope (like ~unset~ isotope) then ^var will
; be a plain BAD-WORD!, which APPEND won't accept unless you quote it
;
; if var is NULL then ^var will still be NULL, which append won't accept
; unless you TRY it to produce a BLANK!, where it will be a no-op
;
; if var is anything else, it will get quoted and appended as-is
;
append data ^var
</code></pre>
<p>There's nice properties there...something about that feels just <em>right</em>.  The problem we wind up with isn't when things are in variables, but how to work with literal content.  Blocks are certainly an option:</p>
<pre><code>append data [whatever]
</code></pre>
<p>Going back to PARSE, it winds up looking like this:</p>
<pre><code>&gt;&gt; uparse [1 2] [collect some [keep ([hello]), keep integer!]]
== [hello 1 hello 2]

&gt;&gt; uparse [1 2] [collect some [keep the [hello], keep integer!]]
== [hello 1 hello 2]
</code></pre>
<p><strong>This all feels close but it's not quite there.</strong>  If I squint long enough maybe I'll see it.</p>
<p>Maybe this really is just pointing to the fact that we need another part of speech, the <strong>$xxx</strong> ?</p>
<aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1643">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Though I'd already noticed one nagging missing point on literal matches, which was how to literally match a fetched block as a splice.</p>
<pre><code class="lang-auto">block: [a b]
uparse [a b a b] [some ?operation? (block)]
</code></pre>
</blockquote>
</aside>
<p>One idea here, would be: <strong>uparse [a b a b] [some $((block))]</strong></p>
<p>So <strong><code>$block</code></strong> would assume you meant as-is, and <strong><code>$(block)</code></strong> would similarly make the same assumption, but <strong><code>$((block))</code></strong> would think you wanted to match across the spliced elements.</p>
<p>It's an idea.</p>
<p>Things here need sorting out, but after all this time there's no point in making hasty bad decisions.  Keep working on it until it's right.</p>
        </div>

        <meta itemprop='headline' content='Literal Matching with the @ Types In UPARSE'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="2" />
           <span class='post-likes'>2 Likes</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="1" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="../1643.html">


          <span class="crawler-post-infos">
              <time itemprop='datePublished' datetime='2022-07-11T19:01:53Z' class='post-time'>
                July 11, 2022,  7:01pm
              </time>
              <meta itemprop='dateModified' content='2022-07-11T19:01:53Z'>
          <span itemprop='position'>#5</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1643">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I realized I actually do not know how to write the above two cases in Red or Rebol2.</p>
</blockquote>
</aside>
<h3>We need an answer to matching literal content</h3>
<p>I've been punting on this bug in SPLIT:</p>
<pre><code>&gt;&gt; split [a &lt;t&gt; b c &lt;t&gt;] &lt;t&gt;  ; expecting [[a] [b c] []]
** Error: TAG! combinator must be &lt;here&gt; or &lt;end&gt; ATM
** Near: [to dlm ** | to &lt;end&gt;]
</code></pre>
<p>That error is coming from PARSE3, not PARSE <em>(which is now what UPARSE is called, as it is decidedly superior semantics, and I don't want to teach any new users PARSE3/PARSE2)</em>.</p>
<p>Even though PARSE3 doesn't have much in the way of TAG! combinators (just <code>&lt;here&gt;</code> and <code>&lt;end&gt;</code>) it's aware of the PARSE state-of-the-art, and letting us know that using <code>&lt;t&gt;</code> as a rule will not match a literal <code>&lt;t&gt;</code> tag.  <em>(Unless you rewire your parse combinators and say that's what you want.)</em></p>
<p><strong>With @ for literal, this could be solved in SPLIT by saying <code>[to @dlm | to &lt;end&gt;]</code></strong></p>
<p>This doesn't solve the case of wanting to match spliced blocks:</p>
<pre><code>&gt;&gt; data: [a b]

&gt;&gt; parse [a b a b] [tally ???data???]  ; solve for ???
== 2
</code></pre>
<p>I suggested one possibility, as:</p>
<pre><code>&gt;&gt; parse [a b a b] [tally @((data))]
== 2
</code></pre>
<p>That's creative.  Anyway, this interpretation of @ is contentious with the other interpretation, which was "be inert"... so that combinators could decide what to do with the item.</p>
<p>However, some of the cases for that aren't really interesting anymore.  I had theorized that as being a way to pull blocks out of the "BLOCK! combinator interpretation"</p>
<pre><code>parse data [... any @[integer! text!] ...]
</code></pre>
<p>The idea that usually, <code>[integer! text!]</code> would mean <em>integer followed by text</em>...but the @ would tell us that the block was being passed literally to ANY, as if you'd said:</p>
<pre><code>parse data [... any ([integer! text!]) ...]
</code></pre>
<p><strong>But I ruled that ANY is perfectly allowed to decide its parameter will not be interpreted as a combinator, but taken as a literal BLOCK!</strong>  This is to say that combinators have parameter conventions just like ordinary functions do... which is why you don't have to write <strong><code>for-each 'var</code></strong> but can say <strong><code>for-each var</code></strong>.</p>
<p>This is just how the cookie bounces in this language, where context is everything.  I've had similar verdicts on the way <a href="../../plain-group-branching-only-run-if-branch-taken/1373/2.html">things like GROUP! work, in branching</a>:</p>
<pre><code>&gt;&gt; if true (print "in group" [print "in block"])
in group
in block

&gt;&gt; if false (print "in group" [print "in block"])
; void
</code></pre>
<p>So in the vein of "how I learned to stop worrying and love the BLOCK!", this feels fine:</p>
<pre><code>parse data [... any [integer! text!] ...]
</code></pre>
<h3>What About Keeping Literal Data?</h3>
<p>I'd argued that this was important:</p>
<pre><code>parse data [collect [... keep @word ...]]
; vs
parse data [collect [... keep ^('word) ...]]
; or
parse data [collect [... keep ([word]) ...]]
; etc.
</code></pre>
<p>I had a particularly irritating use case of synthesizing parse rules with COMPOSE, where the "simple" desire to synthesize a rule that kept literal content got annoyingly complex... and letting @ serve the purpose of a signal to KEEP to literalize seemed like the way out.</p>
<p><strong>But generally, I've soured on the @-word KEEP technique.</strong></p>
<pre><code>&gt;&gt; append [a b c] @d
== [a b c d]   ; I've developed no great love for this handling of @d
</code></pre>
<p>I know it's been a while since this has been at the forefront of discussion, but...I think I've decided this sucks.</p>
<p>We've dug the hole that APPEND and KEEP and all their friends splice by default.  That's the call that was made, and we should live with it.  Use a BLOCK!.</p>
<pre><code>&gt;&gt; append [a b c] [d]
== [a b c d] 
</code></pre>
<p>But this does put us in a bind with generative rules.  We're saying if you have a simple WORD! in a variable that you want to generate a KEEP for, you have to somehow get that word inside a block (to suppress evaluation and avoid splice warnings), and then get that inside a GROUP! (to avoid parse trying to interpret it as something matched).</p>
<p>There is a keyword which was proposed for this purpose, it was the proposal known as JUST.</p>
<pre><code> &gt;&gt; append [a b c] just d
 == [a b c d]
</code></pre>
<p>So JUST takes its argument literally, and then quotes it.  It's a shorthand for QUOTE THE</p>
<pre><code> &gt;&gt; append [a b c] quote the d
 == [a b c d]
</code></pre>
<p>If PARSE had JUST, it would be assumed that you were outside of the domain of matching by using it.</p>
<pre><code> &gt;&gt; parse [1 2] [collect some [keep just negate, keep integer!]]
 == [negate 1 negate 2]
</code></pre>
<p>What nags at me is that the "naked" negate...just in there inline like it's a keyword...feels more uncomfortable than the block-in-group.</p>
<p>When you say <strong>keep ([negate])</strong> you can conceptually break down why it works:</p>
<ul>
<li>
<p>It's in a GROUP!, so there's no matching going on</p>
<ul>
<li>Users have to know that all GROUP!s evaluate to synthesize a product, and don't advance the parse position in the process of doing so.</li>
</ul>
</li>
<li>
<p>Inside the group, it's in a BLOCK!, so you know it's not acting as a keyword or function.</p>
</li>
</ul>
<p>You can look at that and use your general knowledge to get it: <em>yes, I see why this works, in two clear steps</em>.</p>
<h2>But... it's time to JUST do it  <img src="../../../images/emoji/twitter/athletic_shoe.png%3Fv=9" title=":athletic_shoe:" class="emoji" alt=":athletic_shoe:"> ...and add JUST</h2>
<p><strong>The way to think about this is probably to say that the casual user goes with the BLOCK!-in-GROUP because it's clear and it's easy to make at source level...then JUST is targeted at the power users in generative code scenarios.</strong></p>
<p>Someone working with generated code will prioritize ease-of-generation vs. source-level-obviousness.  After all, the code is being generated, so you're not going to read it unless you're sophisticated enough to not be thrown off by JUST and a naked NEGATE.</p>
<p>And with this change, we can absorb the <span class="mention">@XXX</span> for the application of the missing functionality...the literal match.  (I'll retrofit PARSE3 so it works there as well.)</p>
        </div>

        <meta itemprop='headline' content='Literal Matching with the @ Types In UPARSE'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="2" />
           <span class='post-likes'>2 Likes</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

      </div>






    </div>
    <footer class="container wrap">
      <nav class='crawler-nav'>
        <ul>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/' itemprop="url">Home </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/categories' itemprop="url">Categories </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/guidelines' itemprop="url">FAQ/Guidelines </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
        </ul>
      </nav>
      <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
    
  </body>
  
</html>

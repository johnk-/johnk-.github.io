<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Syntax for Typechecked Values</title>
    <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260</link>
    <description>One of the things you can do with [Generalized Accessors](https://forum.rebol.info/t/a-dream-for-debugging-generalized-accessors/2259), is that assignments to any value can be typechecked.  You get this &quot;for free&quot; because accessors pair a function with a variable slot, and that function can use typechecking:

Writing the accessor boilerplate is laborious...

    checked: accessor lambda [^:value [your! types! here!] &lt;static&gt; actual] [
        either value [actual: value.] [actual.]  ; terminal dot allows unset vars
    ]

If you want to be truly generic and support storing actions in the variable, you need slashes:

    checked: accessor lambda [^:/value [your! types! here!] &lt;static&gt; actual] [
        either value [/actual: value.] [actual.]
    ]

Not only is that a nuisance to get typechecking, it&#39;s also not native code, so you&#39;re running that EITHER and its branches.

So we could make it a feature of ACCESSOR, maybe just when you give it a block...and it could do a particularly cheap and special form.  I think this is actually the right way to go about it... it would put a &quot;pairing&quot; cell in the variable&#39;s location, which would pair up the stored value with a PARAMETER! (which does preoptimized calculations on the typeset:

    checked: accessor [your! types! here!]
    checked: initial-value

That&#39;s all fine and good but seems we need a shorter way to say it...that doesn&#39;t repeat the variable name and doesn&#39;t have to say ACCESSOR.

We want whatever this is to still get collected as a SET-WORD! (if it is one), so this probably has to be something like:

    checked: typed [your! types! here!] initial-value

I don&#39;t hate it.  Alternate ideas?

## Interaction With Syntax For Locals

This would now be able to work:

    foo: func [x [text!] &lt;local&gt; y [integer!]] [...]

This would need to be lenient in terms of letting the Y be unset prior to its first assignment.  So it can contain nothing at the outset, but any future assignments have to assign integers.

But this would get a bit of a problem if we want to mix it with a form that lets you assign the local:

    foo: func [x [text!] &lt;local&gt; y: [integer!]] [...]

That would give you Y with the BLOCK! [integer!] in it.  You&#39;d have to say:

    foo: func [x [text!] &lt;local&gt; y: typed [integer!] 10] [...]

We could keep the historical &quot;groups to initialize&quot; idea

    foo: func [x [text!] &lt;local&gt; y (10)] [...]  ; not typechecked

    foo: func [x [text!] &lt;local&gt; y [integer!] (10)] [...]  ; typechecked

And maybe the idea of making a place to put the type constraints vindicates that syntax for this context.

**Typechecking will slow down the code.**  But it would be running through the same checking mechanisms that functions use.  As that code got better, so would this.

There could be some sort of &quot;enable typechecking only in debug mode&quot; property of functions where you could turn it on or off.</description>
    
    <lastBuildDate>Mon, 09 Sep 2024 19:08:53 +0000</lastBuildDate>
    <category>Datatypes</category>
    <atom:link href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Syntax for Typechecked Values</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>It looks like Red has looked into "typed contexts", and discussed some of the syntax issues there:</p>
<aside class="onebox githubissue" data-onebox-src="https://github.com/red/REP/issues/143#issuecomment-1518715432">
  <header class="source">

      <a href="https://github.com/red/REP/issues/143#issuecomment-1518715432" target="_blank" rel="noopener">github.com/red/REP</a>
  </header>

  <article class="onebox-body">
    <div class="github-row">
  <div class="github-icon-container" title="Issue">
	  <svg width="60" height="60" class="github-icon" viewBox="0 0 14 16" aria-hidden="true"><path fill-rule="evenodd" d="M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"></path></svg>
  </div>

  <div class="github-info-container">
    <h4>
      <a href="https://github.com/red/REP/issues/143#issuecomment-1518715432" target="_blank" rel="noopener">Typed contexts</a>
    </h4>

    <div class="github-info">
      <div class="date">
        opened <span class="discourse-local-date" data-format="ll" data-date="2023-04-21" data-time="21:38:17" data-timezone="UTC">09:38PM - 21 Apr 23 UTC</span>
      </div>


      <div class="user">
        <a href="https://github.com/dockimbel" target="_blank" rel="noopener">
          <img alt="dockimbel" src="https://avatars.githubusercontent.com/u/411393?v=4" class="onebox-avatar-inline" width="20" height="20">
          dockimbel
        </a>
      </div>
    </div>

    <div class="labels">
        <span style="display:inline-block;margin-top:2px;background-color: #B8B8B8;padding: 2px;border-radius: 4px;color: #fff;margin-left: 3px;">
          Discussion
        </span>
    </div>
  </div>
</div>

  <div class="github-row">
    <p class="github-body-container">After the changes made in the `apply` branch on red/red repo, it is now possible<span class="show-more-container"><a href="" rel="noopener" class="show-more">…</a></span><span class="excerpt hidden"> to add an array of typesets to Red contexts, so that additional type-checking can be enforced for datatypes relying on contexts. Such extra checks would help make Red code more robust when needed and ease debugging. Such extra typing is an optional feature, the current untyped versions are still allowed.

# Typed function contexts

* Arguments are type-checked at function call (no change on that).
* All function spec words could be type-checked on word setting (new feature).

Example:
```
foo: func [a [integer!] b /local c [string!] d [integer!]][
    a: none			; error!
    c: 'hi 			; error!
]
foo 1 27			; type-checking arguments
```
That strict type-checking for argument words is not back-compatible with words setting semantics in "non-typed" functions. So, we would need to explicitly specify when we want type-checking on each set-word inside the function's body (including when words are set using `set`, as long as they are bound to a typed function or typed object).

Proposal: use `typed` or `strict` attribute to force type-checking on word setting.
```
foo: func [[typed] a [integer!] b /local c [string!] d [integer!]][
    a: none			; error!
    c: 'hi 			; error!
]
foo 1 27			; type-check
```
So without such attribute, usual word setting semantics is preserved (local words type spec in such case would be ignored):
```
foo: func [a [integer!] b /local c [string!] d [integer!]][
    a: none			; allowed
    c: 'hi 			; allowed
]
foo 1 27			; type-check
```

The implementation cost for such feature is very low, as all word settings boil down to a call to `_context/set-in` function, which can be trivially extended to check the corresponding typeset.


### General questions

1. What is the default value of typed local words? We either need to allow `none` as a preset value, or provide a way to specify default values (can be tedious in practice)?


# Typed object contexts

The implementation cost is the same as for typed functions. Though, coming up with a clear, intuitive and minimal syntax is challenging. Here are several propositions:

In several of the propositions, we need a flag to mark the fact that the object needs to be processed for type information. Convention:
```
&lt;flag&gt;: @typed | [typed]
```

### 1. Prefixed inline type spec
```
make object! [
    &lt;flag&gt;
    [string!]  name: "John"
    [integer!] age: 25
    [string!]  city: "Boston"
]
```
Pros:
* Evaluation-transparent.
* Keeps set-words with their referred value together (good readability).

Cons:
* Reversed type/word order compared to function spec.
* Possible multiple conflicting type specs for same word.

### 2. Infixed inline type spec
```
make object! [
    &lt;flag&gt;
    name: [string!] "John"
    age:  [integer!] 25
    city: [string!] "Boston"
]
```
Pros:
* Consistent type definition order with function spec block.

Cons:
* Possible multiple conflicting type specs for same word.
* Body block needs to be modified to be able to evaluate it, which is costly (many values removal needed)
* Type spec blocks can be confused with valid data. (Though, risks can be reduced by adding an extra marker, like `#type` inside or outside each spec block.)
* Values are not directly following their assigned word. With long type definition, values can be pushed far away on the right. (bad readability)

### 3. Postfix inline type spec
```
make object! [
    &lt;flag&gt;
    name: "John"    [string!]
    age:  25	    [integer!]
    city: "Boston"  [string!] 
]
```
Pros:
* Evaluation-transparent.
* Loosely consistent type definition order with function spec block.
* Keeps set-words with their referred value together (good readability).

Cons:
* Type spec blocks cannot be reliably located! (e.g. `name: foo 123 [string!]`, is it a spec block or an argument to `foo`?). (Though, risks can be reduced by adding an extra marker, like `#type` inside or outside each spec block.)
* Possible multiple conflicting type specs for same word.
* With long or multi-line expressions, type spec block can be pushed far away right or down, beyond visibility (very bad readability).


### 4. Spec block as first value
```
make object! [
    [name: city: [string!] age: [integer!]]
    name: "John"
    age:  25
    city: "Boston"
]
```
Pros:
* Evaluation-transparent.
* Follows the attribute model in function spec block or in callbacks body blocks (e.g. filter block in event callbacks).
* Does not require a special flag/attribute value to notify the object constructor that fields can be typed.
* Multiple words can share the same type spec (enforces DRY principle).
* Up front list of object's words (can improve readability for big objects).

Cons:
* Double definition, problem for keeping in sync spec and body code (e.g. spec words not used in body block).

### 5. Prototype typed object

Let's add a new `declare` constructor function that takes a typed object spec and returns an object value with all fields preset to `none` (except for functions), ready to be used as a prototype for new typed objects. Internally, symbol and type arrays could be shared by default, as long as the context is not extended with new symbols.
```
obj: declare [name: city: [string!] age: [integer!] foo: func [...][...]]

make obj [
    name: "John"
    age:  25
    city: "Boston"
    foo: func [...][...]
]
```
Pros:
* Clean separation between specification and instantiation/evaluation.
* Same approach can be used for struct! values too.
* Could be evolved to implement a full class-based model.

Cons:
* Requires a new literal form for serialization round-trip! (Text serialization could drop typing info entirely, leaving it to Redbin for accurate serialization.)
* How to specify the type spec for new words for an object extending a typed proto? (The rule could be that extra words created that way are untyped.)
* Adds a new mezz/native to the core language.


### General questions
	
1. How to solve conflicting type definitions on multiple inheritance? (Should not happen in 5. as the proto object is the one providing the typing information.)

2. What is the default value of typed local words? We either need to allow `none` as a preset value, or provide a way to specify default values (can be tedious in practice)?

3. Allow changing typesets on a given word? (Personally, I think the stricter the rule in typing, the simpler it is for end users.)

4. `function!` values should not need to be typed, though, a typed object could protect such word of `function!` type from being modified to a different datatype.

5. How much the new typed object syntax needs to be back-compatible with untyped objects?

6. Should typed object also support a way to specify words protection from modification or should that be deferred to `protect/unprotect` functions?

7. Could the selected typed object syntax provide a clean way to support specifying object event handlers? (The current `on-change*/on-deep-change*` convention has always been temporary until a better solution is found.)


## References

* http://www.rebol.net/cgi-bin/r3blog.r?view=0016#comments</span></p>
  </div>

  </article>

  <div class="onebox-metadata">
    
    
  </div>

  <div style="clear: both"></div>
</aside>

<p>Seems that their lack of CHAIN! to unify the type with the declaration forces them to choose between various bad options.</p>
          <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260/11</link>
        <pubDate>Mon, 09 Sep 2024 19:08:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2260-11</guid>
        <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
      </item>
      <item>
        <title>Syntax for Typechecked Values</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="9" data-topic="2260">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Now that we'll be having the ability to do the checking after, this could be a notational way of distingiushing the two, saying you actually want modifications to keep the variables type.</p>
</blockquote>
</aside>
<p>Hmm… yeah, that seems reasonable to me.</p>
          <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260/10</link>
        <pubDate>Sun, 08 Sep 2024 02:47:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2260-10</guid>
        <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
      </item>
      <item>
        <title>Syntax for Typechecked Values</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="2260">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">foo: func [x:text! &lt;local&gt; y:integer!: 10] […]
</code></pre>
<p>I like the lightness of it.</p>
</blockquote>
</aside>
<p>So there are two senses of type checking, the checking of what you get into that function, and whether you want that to be applied to changes to the frame variable once you get it.</p>
<p>(The practice of using function arguments destructively is part of Rebol's pursuit-of-"efficiency" history, <a href="https://forum.rebol.info/t/reusing-function-argument-cells-vs-debugging/1047">although it makes debugging harder</a>.)</p>
<p>Rebol has only had the first form (checking arguments) with no checking after that.</p>
<p>Now that we'll be having the ability to do the checking after, this could be a notational way of distingiushing the two, saying you actually want modifications to keep the type of the argument in that set.   <img src="https://forum.rebol.info/images/emoji/twitter/man_shrugging.png?v=12" title=":man_shrugging:" class="emoji" alt=":man_shrugging:" loading="lazy" width="20" height="20"></p>
          <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260/9</link>
        <pubDate>Sun, 08 Sep 2024 02:45:51 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2260-9</guid>
        <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
      </item>
      <item>
        <title>Syntax for Typechecked Values</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2260">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But TYPED could also be available if one wanted it (or wanted to build some variation that was similar-to, but not exactly the same).</p>
</blockquote>
</aside>
<aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="2260">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><code>; should there be a syntax for retype, but keep value?</code></p>
</blockquote>
</aside>
<p>It may be that TYPED not take an initial value by default, but typecheck the value in its current state if not unset...</p>
<pre><code>var:integer!: 10
var: 20
; var: "hello" would be an error

var: typed [integer! text!]  ; == 20 ?
assert [var = 20]
var: 30
var: "goodbye"
</code></pre>
<p>Also better than a CHAIN! when you have line breaks and want to explain things:</p>
<pre><code> state: typed [
     integer!    ; if state is integer, we are exiting (UNIX exit status)
     tag!        ; a TAG! is used for non-terminal states
     issue!      ; issue is used for terminal states
     ...
 ]
</code></pre>
<p>If that goes on for a while, you might be better to not have a dangling thing to assign at the end bracket, but do a separate assignment.</p>
          <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260/8</link>
        <pubDate>Sun, 08 Sep 2024 02:06:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2260-8</guid>
        <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
      </item>
      <item>
        <title>Syntax for Typechecked Values</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>In terms of "Object Field Gathering Rules", this means taking the old rule:</p>
<pre><code>"look for length 2 CHAIN! with WORD! at head and terminal BLANK!"  ("SET-WORD?")
</code></pre>
<p>And turns it into:</p>
<pre><code>"look for any length CHAIN! with WORD! at head and BLANK! at tail"
</code></pre>
<p>For this to be useful, the meaning of all WORD!-headed, BLANK!-tailed CHAIN!s (conceptually SET-CHAIN!, though that's not a fundamental type, could be a constraint e.g. SET-CHAIN?)...must have the contents of the chain pertain to some constraint or property of that WORD! at the head.</p>
<p>(As is always the case, these are evaluator rules.  In your dialect, means whatever you want.)</p>
<p>Curiously, you can change the typing of your variables midstream in code if you want.</p>
<pre><code> var:integer!: 10
 var: 20
 ; var: "hello" would be an error

 var:[integer! text!]: var  ; should there be a syntax for retype, but keep value?
 var: 30
 var: "goodbye"
</code></pre>
          <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260/7</link>
        <pubDate>Sun, 08 Sep 2024 01:46:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2260-7</guid>
        <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
      </item>
      <item>
        <title>Syntax for Typechecked Values</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2260">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Though it deviates from the argument spec which just uses space in the dialect, it's a different section.</p>
</blockquote>
</aside>
<p>Well, it could be made an option in the argument spec too, for those who like the syntax (or dislike square brackets):</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">foo: func [x:text! &lt;local&gt; y:integer!: 10] […]
</code></pre>
<p>I like the lightness of it.</p>
          <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260/6</link>
        <pubDate>Sun, 08 Sep 2024 01:38:40 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2260-6</guid>
        <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
      </item>
      <item>
        <title>Syntax for Typechecked Values</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2260">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>now that we have CHAIN!, why not co-opt the SET-WORD! itself?</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">checked:your!:types!:here!: initial-value
</code></pre>
<p>Or perhaps, if this is syntactically valid (which I hope it is):</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">checked:[your! types! here!]: initial-value
</code></pre>
</blockquote>
</aside>
<p>That would be possible.  It looks a bit like a function call notation being a CHAIN!, but by ending in <strong><code>:</code></strong> it is differentiated.</p>
<p>Syntax coloring could make it clear (through bolding the whole thing) that it was an assignment.</p>
<p>It would help with the locals problem...</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y:[integer!]: 10] [...]`
</code></pre>
<p>Though it deviates from the argument spec which just uses space in the dialect, it's a different section.</p>
<p>We can try it.  But TYPED could also be available if one wanted it (or wanted to build some variation that was similar-to, but not exactly the same).</p>
          <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260/5</link>
        <pubDate>Sun, 08 Sep 2024 01:37:11 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2260-5</guid>
        <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
      </item>
      <item>
        <title>Syntax for Typechecked Values</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Ah, I didn’t realise it had to be next to the SET-WORD!. I guess <code>checked: ~~ type! value</code> is acceptable, though I don’t love it.</p>
<p>But… I just had another idea: now that we have CHAIN!, why not co-opt the SET-WORD! itself?</p>
<pre><code class="lang-plaintext">checked:your!:types!:here!: initial-value
</code></pre>
<p>Or perhaps, if this is syntactically valid (which I hope it is):</p>
<pre><code class="lang-plaintext">checked:[your! types! here!]: initial-value
</code></pre>
<p>I actually really like this idea, for a couple of reasons:</p>
<ul>
<li>Within Ren-C, one could say that typechecking is to values as refinements are to functions  — a small modification to their behaviour. From this point of view, it makes sense to make their syntax consistent.</li>
<li>Outside Ren-C, colons are very widely used for type signatures. This is consistent with that too.</li>
</ul>
<p>On the other hand, this syntax could be used for something already. Or simply impossible to fit into current Ren-C. I don’t know.</p>
<p>EDIT: Another thought on this — it could be extended to GET-WORD!s too, if that syntax isn’t already taken. <code>:value:type!</code> could mean, ‘get <code>value</code> and assert it has type <code>type!</code>’. Could be useful to have for some tricky situations.</p>
          <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260/4</link>
        <pubDate>Sun, 08 Sep 2024 01:31:16 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2260-4</guid>
        <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
      </item>
      <item>
        <title>Syntax for Typechecked Values</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Mechanically whatever this is has to be in the position after the SET-WORD!</p>
<p>Setting things to the accessor is a special out-of-band operation, that by definition can't be done through the assignment of a normal value:</p>
<pre><code>set-accessor $checked func [...] [...]
</code></pre>
<p>So the trick in ACCESSOR is to get the left hand side literally and assign it:</p>
<pre><code>accessor: enfix func [
    return: [~]
    var [set-word! set-tuple!]  ; support SET-GROUP! at some point
    action [action?]
][
    set-accessor var get $action
]
</code></pre>
<p>Currently I'm having it return nothing.  But if it wanted to be "consistent" with what drops out of other SET-WORD!s it would run the accessor and give back whatever the accessor wants to say the value is now.</p>
<p>Actually, these situations that do "weird" things should probably be giving back antiform TAG!.  So you still get the ornery response, but with a clarifying message about the weird thing that happened.</p>
<pre><code>accessor: enfix func [
    return: [hole?]
    var [set-word! set-tuple!]
    action [action?]
][
    set-accessor var get $action
    return ~&lt;set-accessor succeeded&gt;~  ; mentioning SET-ACCESSOR is useful
]
</code></pre>
<p>Anyway... you only get that one unit of lookback to find the variable to bless with this property.  So we can't do:</p>
<aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2260">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p><code>checked: initial-value ~~ [your! types! here!]</code></p>
</blockquote>
</aside>
<p>Whatever happens needs the form:</p>
<pre><code>checked: xxx ...
</code></pre>
<p>xxx takes 3 arguments: one from the left, two from the right.</p>
<p>So we <em>could</em> put the types after the value.</p>
<pre><code>checked: xxx initial-value [your! types! here!]
</code></pre>
<p>And we <em>could</em> require a sigil of some kind with that...as a literal throwaway parameter to help you find the separation point:</p>
<pre><code>checked: xxx initial-value :: [your! types! here!]
</code></pre>
<p>But so long as the XXX is there, I don't see the value in it.</p>
<p>~~ and :: are still available, and we could do:</p>
<pre><code>checked: :: [your! types! here!] initial-value

checked: ~~ [your! types! here!] initial-value
</code></pre>
<p>But I don't particularly like the <strong>::</strong> after the <strong>:</strong></p>
<p>We do control the gathering, so could theoretically make it look for non-SET-WORD! patterns, and the :: sigil can't be reassigned, letting the :: imply assignment:</p>
<pre><code>checked :: [your! types! here!] initial-value
</code></pre>
<p>But that's one of those irregularities that doesn't really buy enough to make it worth it.</p>
<p>TYPED is a Rebol-y enough thing that you can abbreviate to T or something if you like.</p>
<pre><code>T: typed.

checked: T [your! types! here!] initial-value
</code></pre>
<p>But usually there's higher return factorings you can do if you're repeating yourself a lot.</p>
          <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260/3</link>
        <pubDate>Sun, 08 Sep 2024 01:26:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2260-3</guid>
        <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
      </item>
      <item>
        <title>Syntax for Typechecked Values</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2260">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">checked: typed [your! types! here!] initial-value
</code></pre>
<p>I don't hate it. Alternate ideas?</p>
</blockquote>
</aside>
<p>I don’t hate it either. But I <em>do</em> have an alternate thought: why not use a sigil? You were wondering what to do with <code>~~</code>, and this looks like a good opportunity to use it:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">checked: initial-value ~~ [your! types! here!]
</code></pre>
<p>It doesn’t look that bad to me. Or it could be reversed:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">checked: [your! types! here!] ~~ initial-value
</code></pre>
<p>(Even better would be <code>::</code>, which has already been used for the purpose in Haskell. But sadly that’s no longer available.)</p>
          <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260/2</link>
        <pubDate>Sun, 08 Sep 2024 01:03:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2260-2</guid>
        <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
      </item>
      <item>
        <title>Syntax for Typechecked Values</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>One of the things you can do with <a href="https://forum.rebol.info/t/a-dream-for-debugging-generalized-accessors/2259">Generalized Accessors</a>, is that assignments to any value can be typechecked.  You get this "for free" because accessors pair a function with a variable slot, and that function can use typechecking:</p>
<p>Writing the accessor boilerplate is laborious...</p>
<pre><code>checked: accessor lambda [^:value [your! types! here!] &lt;static&gt; actual] [
    either value [actual: value.] [actual.]  ; terminal dot allows unset vars
]
</code></pre>
<p>If you want to be truly generic and support storing actions in the variable, you need slashes:</p>
<pre><code>checked: accessor lambda [^:/value [your! types! here!] &lt;static&gt; actual] [
    either value [/actual: value.] [actual.]
]
</code></pre>
<p>Not only is that a nuisance to get typechecking, it's also not native code, so you're running that EITHER and its branches.</p>
<p>So we could make it a feature of ACCESSOR, maybe just when you give it a block...and it could do a particularly cheap and special form.  I think this is actually the right way to go about it... it would put a "pairing" cell in the variable's location, which would pair up the stored value with a PARAMETER! (which does preoptimized calculations on the typeset:</p>
<pre><code>checked: accessor [your! types! here!]
checked: initial-value
</code></pre>
<p>That's all fine and good but seems we need a shorter way to say it...that doesn't repeat the variable name and doesn't have to say ACCESSOR.</p>
<p>We want whatever this is to still get collected as a SET-WORD! (if it is one), so this probably has to be something like:</p>
<pre><code>checked: typed [your! types! here!] initial-value
</code></pre>
<p>I don't hate it.  Alternate ideas?</p>
<h2>
<a name="interaction-with-syntax-for-locals-1" class="anchor" href="https://forum.rebol.info#interaction-with-syntax-for-locals-1"></a>Interaction With Syntax For Locals</h2>
<p>This would now be able to work:</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y [integer!]] [...]
</code></pre>
<p>This would need to be lenient in terms of letting the Y be unset prior to its first assignment.  So it can contain nothing at the outset, but any future assignments have to assign integers.</p>
<p>But this would get a bit of a problem if we want to mix it with a form that lets you assign the local:</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y: [integer!]] [...]
</code></pre>
<p>That would give you Y with the BLOCK! [integer!] in it.  You'd have to say:</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y: typed [integer!] 10] [...]
</code></pre>
<p>We could keep the historical "groups to initialize" idea</p>
<pre><code>foo: func [x [text!] &lt;local&gt; y (10)] [...]  ; not typechecked

foo: func [x [text!] &lt;local&gt; y [integer!] (10)] [...]  ; typechecked
</code></pre>
<p>And maybe the idea of making a place to put the type constraints vindicates that syntax for this context.</p>
<p><strong>Typechecking will slow down the code.</strong>  But it would be running through the same checking mechanisms that functions use.  As that code got better, so would this.</p>
<p>There could be some sort of "enable typechecking only in debug mode" property of functions where you could turn it on or off.</p>
          <p><a href="https://forum.rebol.info/t/syntax-for-typechecked-values/2260/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/syntax-for-typechecked-values/2260/1</link>
        <pubDate>Sun, 08 Sep 2024 00:45:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2260-1</guid>
        <source url="https://forum.rebol.info/t/syntax-for-typechecked-values/2260.rss">Syntax for Typechecked Values</source>
      </item>
  </channel>
</rss>

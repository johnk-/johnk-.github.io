<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
    <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128</link>
    <description>I&#39;ve written about Rebol&#39;s historical idea of walking the source deeply at the beginning, and the [mere mention of an ANY-WORD!](https://forum.rebol.info/t/the-real-story-about-user-and-lib-contexts/764) would lead to a variable being created for it in the user context.  This chewed through memory making unnecessary variables, and gave you a situation ripe for typos:

     rebol2&gt;&gt; add-ten: func [argument] [
                  argment: argument + 10
                  return argument
               ]

     rebol2&gt;&gt; add-ten 20
     == 20

     rebol2&gt;&gt; argment
     == 30

This behavior resembles [pre-strict-mode JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode), and makes it easy to get bugs

But it&#39;s a semantic that some code uses intentionally.  And if Rebol2 emulation is to be possible, there has to be some way to do this.

It&#39;s also a useful way to work in the console.  Browsers still run JavaScript in non-strict-mode by default:

    &gt;&gt; function foo() { jkl = 10 }
    &lt;- undefined

    &gt;&gt; foo()
    undefined

    &gt;&gt; jkl
    &lt;- 10

## Simulating Non-Strictness With &quot;Attachment&quot; Binding

In order to overcome the idea of creating variables for every ANY-WORD! to be mentioned, the &quot;Sea of Words&quot; concept was first implemented by making code loaded for a module bind non-specifically to that module.  Words held a pointer to the module with no further information about the address of a variable in that module.  This was called the &quot;attached&quot; state.

If you tried to read from an attached word, it would fail.  But if you wrote to an attached word, it would create a variable.  This gave the experience of non-strict mode, without a-priori creating tons of variables.

But this creates weird words that are neither fully bound nor fully unbound.  And you can&#39;t take being in the &quot;attached&quot; state to mean the variable does not exist in the module... because more than one attached reference to the word could have been created, and one of them might have been used to create it... not knowing about the other word&#39;s attached state to fix it up.  Or perhaps the variable was created explicitly in the module--not via any particular assignment.

## Should Words Be Storing &quot;Environments&quot;?

Historically, bound words would store the specific &quot;address&quot; of variables (most of the time object plus index), while unbound words would store nothing.

Attachment introduced a new situation where an &quot;unbound&quot; word could hold a pointer to a module, where the word would be created if a SET or SET-WORD! operation were performed.

But if objects and environments can expand, is there a good reason why the &quot;attachment&quot; should have been to a particular module... or should it be attached to an environment?  If the specifier for a piece of code has an OBJECT! to look in first, and then a MODULE!... and a lookup doesn&#39;t find it in either, why should it become &quot;attached&quot; only to the module?  What if it shows up in the object before you write it?

Taking this to the extreme: Why should only &quot;unbound&quot;/&quot;attached&quot; things be able to see overrides that come along later on?  Why don&#39;t words store environments always, and look up every time...to be able to find new things?

## Ok, Back Up.

It seems that once a word has been bound, it needs to stay bound to where it is.  e.g. the following seems bad:

    &gt;&gt; word: in [] &#39;foo
    == foo

    &gt;&gt; protect word  ; make sure no one changes FOO&#39;s value

    &gt;&gt; set word 10
    == 10

    &gt;&gt; some-arbitrary-routine
    == &lt;whatever&gt;  ; didn&#39;t error, so didn&#39;t try to write foo

    &gt;&gt; get word
    == 20  ; !!! it wasn&#39;t written, so how?

We&#39;d lose some grounding if bound words weren&#39;t stable.  It also would hurt performance, because words would have to be looked up in the environment chain every time.

BUT we&#39;re saying that the **IN** operation does this lookup, and may get different results if the environment changes.  That&#39;s pretty much a given: the evaluator runs an equivalent to IN, and this is why when you run a function several times you get different bindings to different frames from the same unbound words as input.

## Contain The Weirdness To &quot;Attachment&quot;

This points the finger at &quot;attachment&quot; binding being a narrow, weird thing... whose job is solely to simulate the idea that a variable exists that doesn&#39;t.

Sea of Words made it a shallow illusion, e.g. it didn&#39;t let you GET/ANY the variable and get it back as being trash--you&#39;d get an error instead.  There&#39;s risks to deepening the illusion, because you&#39;d have to make module enumeration give back every possible word as a variable.  :-/

So I think attachment should be to a module (not an environment) and it should be considered as bound for most practical purposes (it would need to be, for Rebol2 compatibility).</description>
    
    <lastBuildDate>Tue, 01 Oct 2024 12:47:03 +0000</lastBuildDate>
    <category>Binding</category>
    <atom:link href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="9" data-topic="2128">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I feel that it should be sufficient to put LET before SET-WORD!s as desired.</p>
</blockquote>
</aside>
<p>In the case of the console interactivity, a LET would not be seen past one evaluation (and isn't supposed to), so that explains at least why what I've called <strong><code>WRAP*</code></strong> is needed, to gather the set-things and inject them into the user context:</p>
<pre><code>&gt;&gt; let x: 10
== 10

&gt;&gt; x
** Error: X is not bound
</code></pre>
<p>And I believe it would be painful for scripts and modules to have to put LETs on all their top-level declarations, in addition to the fact that LET "does something different" mechanically.  It would have to be changed to where a module-level LET "injected", and I don't think we want LET to change what it does in that way.  But again, that's in contrast to <strong><code>WRAP*</code></strong> being used by the module machinery.</p>
<p>As for the cases of higher-level WRAP on a BLOCK! creating one object vs. lots of little LETs, there's not a huge difference.  But there <em>may</em> be some advantage to gathering all the declarations in one function call vs. having several--it <em>may</em> create fewer GC'able entities and it <em>may</em> be able to run faster.</p>
<p>But mostly it's just less visual noise of lots of LETs, and letting people work in a way that seems more familiar.  It does mean that you don't have to worry about touching up code when you move or delete the "declaring instance":</p>
<pre><code>... [
    let [pos value]: transcode/next ...  ; say I delete this line
    let x: ...
    let y: ...
    [pos value]: transcode/next ...
    if x = value [...]
    [pos value]: transcode/next ...
    if y = value  ...]
]
</code></pre>
<p>I think if you are writing code with one definition in it you are likely to favor the LET, but if you have a lot then the WRAP may win.</p>
<p>There's also a bit about how people might feel about LETs in mid-expression, e.g. on the right hand sides of comparisons/etc.</p>
<pre><code> all [
     1 = let x: something ...
     ...
 ]
</code></pre>
<p>LET does work in these cases, but might seem awkward--even to people who have fully embraced putting <em>assignments</em> in such slots.  I can at least vouch for the fact that putting LET there stresses <em>me</em> out (maybe because I'm just sensitive to the idea of "that might not work!", but it does work...the definition outlives the subexpression...although I predict trouble with variadics).</p>
<p>I suppose we can debate whether that should actually work or not.  It seems to me there's more value from it working.  It's strictly more powerful--if you don't want it to outlive the subexpression you can put it in a group.</p>
          <p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/10</link>
        <pubDate>Tue, 01 Oct 2024 11:54:26 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2128-10</guid>
        <source url="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss">Caching Binding Lookup, and &quot;Attachment Binding&quot;</source>
      </item>
      <item>
        <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Just had a thought: why do we need a special function WRAP? I feel that it should be sufficient to put LET before SET-WORD!s as desired.</p>
          <p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/9</link>
        <pubDate>Tue, 01 Oct 2024 02:24:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2128-9</guid>
        <source url="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss">Caching Binding Lookup, and &quot;Attachment Binding&quot;</source>
      </item>
      <item>
        <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="2128">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Everything in actual code that this is tripping on was a bug.</p>
</blockquote>
</aside>
<p>One problem, SET-BLOCK!s have not traditionally been considered in top level gathers.  (Not because they were never intended to be, but because <a href="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134">they are "new" <img src="https://forum.rebol.info/images/emoji/twitter/roll_eyes.png?v=12" title=":roll_eyes:" class="emoji" alt=":roll_eyes:" loading="lazy" width="20" height="20"> </a> and have had their semantics sort of hammering out over time.)</p>
<p>But if you can write:</p>
<pre><code>wrap [
    x: ...
]
</code></pre>
<p>It seems that you should be able to say:</p>
<pre><code>wrap [
    [x y]: ...
]
</code></pre>
<p>But SET-BLOCK! is dialected, so it gets a little complex.  You don't want to make a variable for Z when you see <strong><code>[x (z)]:</code></strong>, and you do want to make a variable for N when you see <strong><code>[^n (z)]:</code></strong></p>
<p>Which reminds me, with CHAIN we're about to get META-CHAIN-WORDs, like <strong><code>^foo:</code></strong> ... so you won't have to make a block to get a meta assignment.  And we'd expect that to wrap too.</p>
<pre><code>wrap [
    ^foo: ...
]
</code></pre>
<p>Brave new world.  But <strong><code>@foo:</code></strong> (evals to <code>@foo:</code>, bound) shouldn't be collected, nor should <strong><code>$foo:</code></strong> (evals to <code>foo:</code> bound), and obviously not <strong><code>'foo:</code></strong> (evals to <code>foo:</code>, unbound)</p>
<p>I'm also reminded that SET-BLOCK! needs to recurse for unpacking.</p>
<pre><code>wrap [
     [[a b] [c d]]: pack [pack [1 2] pack [3 4]]
]
</code></pre>
<p>I would expect <strong>a</strong>, <strong>b</strong>, <strong>c</strong>, and <strong>d</strong> to be collected by that wrap.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="7" data-topic="2128">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It is a little disappointing that things break when you say <strong><code>all wrap [(x: ...) ...]</code></strong></p>
</blockquote>
</aside>
<p>Well, there we see it's a blessing as well as a curse... if you didn't want the wrap semantics, you can escape them.</p>
<p><em>Given that I seem to be meandering about here, it may not be obvious...but things are really starting to tighten up.  Things are coming into alignment, and the code is written in such a way that I can morph it around pretty comfortably despite the drastic upheavals.  I will reiterate that without being able to build as C++, a lot of the reorganizations I do would be nigh impossible... so frontloading the R3-Alpha redesign effort with bringing C++ into it was not just worthwhile... it's the only reason the project can exist.</em></p>
          <p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/8</link>
        <pubDate>Mon, 30 Sep 2024 11:24:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2128-8</guid>
        <source url="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss">Caching Binding Lookup, and &quot;Attachment Binding&quot;</source>
      </item>
      <item>
        <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2128">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If you need to make a bunch of variables in a context, the <strong>wrap</strong> command could help you:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; wrap [x: 10 y: 20 z: 30, x + y + z]
== 60
</code></pre>
</blockquote>
</aside>
<p>I hinted at the need to <a href="https://forum.rebol.info/t/breaking-make-object-into-component-operations/1442">break MAKE OBJECT! into component operations</a>, and I think WRAP is one of those components... where it shouldn't run the code.</p>
<p>Because you might want to write something like:</p>
<pre><code>all wrap [
    x: ...
    y: ...
    z: ...
]
</code></pre>
<p>So the evaluation should be separate, as <strong><code>eval wrap [...]</code></strong></p>
<h3><a name="p-7802-does-eval-wrap-deserve-a-special-name-1" class="anchor" href="https://forum.rebol.info#p-7802-does-eval-wrap-deserve-a-special-name-1"></a>Does EVAL WRAP deserve a special name?</h3>
<p>Maybe, but I can't think of a good one offhand.  I sort of feel like those two words together are "right-sized" for the intent.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="2128">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>(Okay, I posted that 30 minutes ago, and I just booted a system with no attachment binding, so... yeah. I think it's time to let it go. People will write better code this way, strict mode is good.)</p>
</blockquote>
</aside>
<p>Everything in actual code that this is tripping on was a bug.</p>
<p>The casualties are things that are intentionally scrappy, like the tests.</p>
<p>I don't think the answer is to do something like WRAP/DEEP on the tests for their convenience...we don't want tests to be different from what runs in the console... and we don't want what runs in the console to be that different from what you could put in a script.</p>
<p>Basically just have to bite the bullet, and turn tests like <strong><code>all [x: ...]</code></strong> into <strong><code>all wrap [x: ...]</code></strong> or <strong><code>all [let x: ...]</code></strong> or whatever.</p>
<p>It is a little disappointing that things break when you say <strong><code>all wrap [(x: ...) ...]</code></strong> but I think that's just life.  Binding is becoming more of a conscious effort and that has ramifications, that's one of them.</p>
          <p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/7</link>
        <pubDate>Mon, 30 Sep 2024 10:42:06 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2128-7</guid>
        <source url="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss">Caching Binding Lookup, and &quot;Attachment Binding&quot;</source>
      </item>
      <item>
        <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2128">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This behavior resembles <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">pre-strict-mode JavaScript</a>, and makes it easy to get bugs</p>
<p>But it's a semantic that some code uses intentionally. And if Rebol2 emulation is to be possible, there has to be some way to do this.</p>
</blockquote>
</aside>
<p>Okay, <a href="https://forum.rebol.info/t/the-fate-of-redbol-emulation-in-a-mostly-unbound-world/2131">that emulation is out the window</a>, so let's drop it from consideration.  <em>(Though building an emulator in Ren-C would likely be relatively easy given the infrastructure, but that emulation would be a whole different evaluator.)</em></p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2128">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>It's also a useful way to work in the console. Browsers still run JavaScript in non-strict-mode by default:</p>
</blockquote>
</aside>
<p>I wonder if people would be happy enough if it just did top-level declarations.</p>
<pre><code>&gt;&gt; x: 10
== 10

&gt;&gt; (y: 20)
** Error: Y is not bound

&gt;&gt; (let y: 20)
== 20

&gt;&gt; y
** Error: Y is not bound

&gt;&gt; y: ~

&gt;&gt; (y: 20)
== 20

&gt;&gt; y: ~&lt;used by some-func&gt;~  ; &lt;-- tripwires are so cool
== ~&lt;used by some-func&gt;~  ; anti

&gt;&gt; some-func: func [x] [y: x] 

&gt;&gt; some-func 20

&gt;&gt; y
== 20
</code></pre>
<p>If you need to make a bunch of variables in a context, the <strong>wrap</strong> command could help you:</p>
<pre><code>&gt;&gt; wrap [x: 10 y: 20 z: 30, x + y + z]
== 60

&gt;&gt; z
** Error: z is not bound
</code></pre>
<p>So the console and whatever else could perhaps use a variant of that, where instead of using a fresh context you inject the variables into another one:</p>
<pre><code>&gt;&gt; wrap* system.contexts.user [x: 10 y: 20 z: 30 x + y + z]
== 60

&gt;&gt; z
== 30
</code></pre>
<p>Could do it as a refinement to wrap, though it puts the argument at the tail which I find annoying.</p>
<pre><code>wrap:inside [x: 10 y: 20 z: 30 x + y + z] system.contexts.user 
</code></pre>
<p>I <em>think</em> that covers the bases for me, but I'll have to try propagating this stuff in the system to find out.</p>
<p><strong>If attachment binding disappeared, I'd shed no tears.</strong></p>
<hr>
<p><em>(Okay, I posted that 30 minutes ago, and I just booted a system with no attachment binding, so... yeah.  I think it's time to let it go.  People will write better code this way, strict mode is good.)</em></p>
          <p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/6</link>
        <pubDate>Sun, 29 Sep 2024 20:34:25 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2128-6</guid>
        <source url="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss">Caching Binding Lookup, and &quot;Attachment Binding&quot;</source>
      </item>
      <item>
        <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2128">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Surely <code>set</code> can just create <code>whatever</code> in the current environment when it runs?</p>
</blockquote>
</aside>
<p>SET's parameter is a WORD! that has no binding, or some binding, but... that word is all it has in its hand.</p>
<p>If you are speaking of an <a href="https://forum.rebol.info/t/functions-that-capture-the-current-evaluation-environment/2122">implicit environment parameter</a> which would be captured from the callsite of the SET--it would be unlikely that was the right place to be doing the emergence of the new variable.</p>
<p>Think of the implementation of something like PARSE--which lives in its own module.  It's traversing some code that you gave it:</p>
<pre><code>Rebol [
    Title: "My Module"
    Type: module
]

example: func [&lt;local&gt; i] [
    parse [a 10] [w: word! i: integer!]
]

example
</code></pre>
<p>The block of rules that PARSE is receiving is thus connected with the frame of EXAMPLE which points next in the chain to the module environment for "My Module".</p>
<p>But the SET-WORD! combinator--which is implemented in the parse module--is what is ultimately running the code that sets the variable.  It has logic which says to run and process the next parse rule, and if it matches then SET the word to the product of that rule.</p>
<p>PARSE has in its hand the input rule block, and the <strong><code>w:</code></strong> set-word! that it plucked out of that block.  It doesn't know offhand that the <strong><code>w:</code></strong> word wasn't bound to something (e.g. if it asked about <strong><code>i</code></strong> it would get a binding).</p>
<p>The attached state is to allow the <strong>in rules ('w:)</strong> to give back a product that's able to permit the SET to appropriately emerge the variable into My Module, not PARSE's module.</p>
          <p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/5</link>
        <pubDate>Wed, 24 Jan 2024 02:18:56 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2128-5</guid>
        <source url="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss">Caching Binding Lookup, and &quot;Attachment Binding&quot;</source>
      </item>
      <item>
        <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="2128">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext"> rebol2&gt;&gt; foo: func [] [set 'whatever 10]  ; whatever bound to user context

 rebol2&gt;&gt; foo
 == 10

 rebol2&gt;&gt; whatever
 == 10
</code></pre>
<p>To preserve this behavior without requiring an a-priori walk that creates a ton of spurious variables, I came up with the idea of "attachment". Variables could be attached to a module but not exist in that module... yet. If a SET came along to that attached word, the variable would be created at that moment.</p>
</blockquote>
</aside>
<p>I honestly am really confused why ‘attachment’ is necessary here. Surely <code>set</code> can just create <code>whatever</code> in the current environment when it runs? That’s what basically every other programming language does, and it seems to work fine for them.</p>
          <p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/4</link>
        <pubDate>Wed, 24 Jan 2024 02:05:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2128-4</guid>
        <source url="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss">Caching Binding Lookup, and &quot;Attachment Binding&quot;</source>
      </item>
      <item>
        <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="2" data-topic="2128">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>surely that means there’s no need for ‘attachment’ at all?</p>
</blockquote>
</aside>
<p>The problem is that a variable may not exist at all to bind to, and there's never a moment of explicit creation.  Yet it's expected to work.</p>
<p>Historical Rebol expected all <em>source</em> words to be bound to something--even it's an unset something.  This is because variables were created in advance for all words mentioned in source.</p>
<pre><code> rebol2&gt;&gt; foo: func [] [set 'whatever 10]  ; whatever bound to user context

 rebol2&gt;&gt; foo
 == 10

 rebol2&gt;&gt; whatever
 == 10
</code></pre>
<p>To preserve this behavior without requiring an a-priori walk that creates a ton of spurious variables, I came up with the idea of "attachment".  Variables could be attached to a module but not exist in that module... yet.  If a SET came along to that attached word, the variable would be created at that moment.</p>
<p>Now that we have to be more explicit about binding, there's still the problem of when that variable would be created:</p>
<pre><code>&gt;&gt; foo: func [] [set in [] 'whatever 10]

&gt;&gt; foo
; ... if we wanted whatever in user context to be 10, how to do that?
</code></pre>
<p>SET only receives a WORD!...not the argument to IN.  For this to work, either IN had to create the variable <em>(not knowing in advance whether it was going to be SET or not)</em> or it had to bind the word in a state to say "if you get a SET request, here's where you should put the variable."</p>
<p>I've already said that having modules work this "non-strict" way is questionable (it's also a bit of a puzzle to guess what kinds of non-strict module presence in the "environment" should permit emergence, and how that implies a single location--let's imagine there's a methodology to it).  But it gives rise to console behaviors that people have come to expect, historical code uses the style, and rightly or wrongly some current code depends on it.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2128">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So I think attachment should be to a module (not an environment) and it should be considered as bound for most practical purposes (it would need to be, for Rebol2 compatibility).</p>
</blockquote>
</aside>
<p>Urgh.  Considering attachment binding to be "bound" is kind of unworkable.  Because it makes <em>basically the entire body of a non-strict module bound</em>.  And we've seen for instance that really basic things will choke on the binding (e.g. <a href="https://forum.rebol.info/t/sticky-set-word-binding-problem-in-make-object/2127">MAKE OBJECT! when SET-WORD! is thought to be already bound</a>)</p>
<p>Blindly treating it as unbound isn't good, because as I said, it may have come into existence.  So an attached word has to be checked for if it has come into existence before you treat it as unbound.</p>
<p>So if you can't treat it as unconditionally bound or unbound, this means its state can change out from under you.</p>
<p>It's definitely frustrating... I'd like to be able to say "this isn't important, don't support it".  But that would be very consequential.  Explicit creation of all variables e.g. in the console, we could say it could happen for all top-level definitions e.g. how MAKE OBJECT! works, and wind up with something like this:</p>
<pre><code>&gt;&gt; x: 10 print [x]
10 ; works

&gt;&gt; (y: 10 print [y])
** Error: y is unbound  ; wouldn't work
</code></pre>
          <p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/3</link>
        <pubDate>Tue, 23 Jan 2024 14:01:09 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2128-3</guid>
        <source url="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss">Caching Binding Lookup, and &quot;Attachment Binding&quot;</source>
      </item>
      <item>
        <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>Maybe I’m missing something, but: if we’re moving to this new model of block-level bindings, then surely that means there’s no need for ‘attachment’ at all?</p>
          <p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/2</link>
        <pubDate>Tue, 23 Jan 2024 03:30:46 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2128-2</guid>
        <source url="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss">Caching Binding Lookup, and &quot;Attachment Binding&quot;</source>
      </item>
      <item>
        <title>Caching Binding Lookup, and &quot;Attachment Binding&quot;</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I've written about Rebol's historical idea of walking the source deeply at the beginning, and the <a href="https://forum.rebol.info/t/the-real-story-about-user-and-lib-contexts/764">mere mention of an ANY-WORD!</a> would lead to a variable being created for it in the user context.  This chewed through memory making unnecessary variables, and gave you a situation ripe for typos:</p>
<pre><code> rebol2&gt;&gt; add-ten: func [argument] [
              argment: argument + 10
              return argument
           ]

 rebol2&gt;&gt; add-ten 20
 == 20

 rebol2&gt;&gt; argment
 == 30
</code></pre>
<p>This behavior resembles <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode">pre-strict-mode JavaScript</a>, and makes it easy to get bugs</p>
<p>But it's a semantic that some code uses intentionally.  And if Rebol2 emulation is to be possible, there has to be some way to do this.</p>
<p>It's also a useful way to work in the console.  Browsers still run JavaScript in non-strict-mode by default:</p>
<pre><code>&gt;&gt; function foo() { jkl = 10 }
&lt;- undefined

&gt;&gt; foo()
undefined

&gt;&gt; jkl
&lt;- 10
</code></pre>
<h2>
<a name="simulating-non-strictness-with-attachment-binding-1" class="anchor" href="https://forum.rebol.info#simulating-non-strictness-with-attachment-binding-1"></a>Simulating Non-Strictness With "Attachment" Binding</h2>
<p>In order to overcome the idea of creating variables for every ANY-WORD! to be mentioned, the "Sea of Words" concept was first implemented by making code loaded for a module bind non-specifically to that module.  Words held a pointer to the module with no further information about the address of a variable in that module.  This was called the "attached" state.</p>
<p>If you tried to read from an attached word, it would fail.  But if you wrote to an attached word, it would create a variable.  This gave the experience of non-strict mode, without a-priori creating tons of variables.</p>
<p>But this creates weird words that are neither fully bound nor fully unbound.  And you can't take being in the "attached" state to mean the variable does not exist in the module... because more than one attached reference to the word could have been created, and one of them might have been used to create it... not knowing about the other word's attached state to fix it up.  Or perhaps the variable was created explicitly in the module--not via any particular assignment.</p>
<h2>
<a name="should-words-be-storing-environments-2" class="anchor" href="https://forum.rebol.info#should-words-be-storing-environments-2"></a>Should Words Be Storing "Environments"?</h2>
<p>Historically, bound words would store the specific "address" of variables (most of the time object plus index), while unbound words would store nothing.</p>
<p>Attachment introduced a new situation where an "unbound" word could hold a pointer to a module, where the word would be created if a SET or SET-WORD! operation were performed.</p>
<p>But if objects and environments can expand, is there a good reason why the "attachment" should have been to a particular module... or should it be attached to an environment?  If the specifier for a piece of code has an OBJECT! to look in first, and then a MODULE!... and a lookup doesn't find it in either, why should it become "attached" only to the module?  What if it shows up in the object before you write it?</p>
<p>Taking this to the extreme: Why should only "unbound"/"attached" things be able to see overrides that come along later on?  Why don't words store environments always, and look up every time...to be able to find new things?</p>
<h2>
<a name="ok-back-up-3" class="anchor" href="https://forum.rebol.info#ok-back-up-3"></a>Ok, Back Up.</h2>
<p>It seems that once a word has been bound, it needs to stay bound to where it is.  e.g. the following seems bad:</p>
<pre><code>&gt;&gt; word: in [] 'foo
== foo

&gt;&gt; protect word  ; make sure no one changes FOO's value

&gt;&gt; set word 10
== 10

&gt;&gt; some-arbitrary-routine
== &lt;whatever&gt;  ; didn't error, so didn't try to write foo

&gt;&gt; get word
== 20  ; !!! it wasn't written, so how?
</code></pre>
<p>We'd lose some grounding if bound words weren't stable.  It also would hurt performance, because words would have to be looked up in the environment chain every time.</p>
<p>BUT we're saying that the <strong>IN</strong> operation does this lookup, and may get different results if the environment changes.  That's pretty much a given: the evaluator runs an equivalent to IN, and this is why when you run a function several times you get different bindings to different frames from the same unbound words as input.</p>
<h2>
<a name="contain-the-weirdness-to-attachment-4" class="anchor" href="https://forum.rebol.info#contain-the-weirdness-to-attachment-4"></a>Contain The Weirdness To "Attachment"</h2>
<p>This points the finger at "attachment" binding being a narrow, weird thing... whose job is solely to simulate the idea that a variable exists that doesn't.</p>
<p>Sea of Words made it a shallow illusion, e.g. it didn't let you GET/ANY the variable and get it back as being trash--you'd get an error instead.  There's risks to deepening the illusion, because you'd have to make module enumeration give back every possible word as a variable.  :-/</p>
<p>So I think attachment should be to a module (not an environment) and it should be considered as bound for most practical purposes (it would need to be, for Rebol2 compatibility).</p>
          <p><a href="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128/1</link>
        <pubDate>Mon, 22 Jan 2024 14:47:39 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2128-1</guid>
        <source url="https://forum.rebol.info/t/caching-binding-lookup-and-attachment-binding/2128.rss">Caching Binding Lookup, and &quot;Attachment Binding&quot;</source>
      </item>
  </channel>
</rss>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Ladislav Mecir&#39;s &quot;Bindology&quot; - Binding - AltRebol</title>
    <meta name="description" content="This is an archive of Ladislav&amp;#39;s well-known &amp;quot;Bindology&amp;quot; article. It&amp;#39;s not as important to have a backup of it as some other things, since it&amp;#39;s on WikiBooks and will probably stay there. 
Ladislav put it on WikiBooks in &amp;hellip;">
    <meta name="generator" content="Discourse 3.1.0.beta4 - https://github.com/discourse/discourse version 25276f62f959eab4557049a655300a70835c5769">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#ffffff">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="2073.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

    <link href="https://forum.rebol.info/stylesheets/color_definitions_base__2_caa66e77e807fc270e5b21d201643962219b6a9a.css?__ws=forum.rebol.info" media="all" rel="stylesheet" class="light-scheme"/>

  <link href="https://forum.rebol.info/stylesheets/desktop_97f5da14b02e14a864d77b6d983a33a1b302f894.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop"  />



  <link href="https://forum.rebol.info/stylesheets/chat_97f5da14b02e14a864d77b6d983a33a1b302f894.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="chat"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-details_97f5da14b02e14a864d77b6d983a33a1b302f894.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-details"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-lazy-videos_97f5da14b02e14a864d77b6d983a33a1b302f894.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-local-dates_97f5da14b02e14a864d77b6d983a33a1b302f894.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-narrative-bot_97f5da14b02e14a864d77b6d983a33a1b302f894.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-presence_97f5da14b02e14a864d77b6d983a33a1b302f894.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-presence"  />
  <link href="https://forum.rebol.info/stylesheets/docker_manager_97f5da14b02e14a864d77b6d983a33a1b302f894.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="docker_manager"  />
  <link href="https://forum.rebol.info/stylesheets/poll_97f5da14b02e14a864d77b6d983a33a1b302f894.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="poll"  />
  <link href="https://forum.rebol.info/stylesheets/chat_desktop_97f5da14b02e14a864d77b6d983a33a1b302f894.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="chat_desktop"  />
  <link href="https://forum.rebol.info/stylesheets/poll_desktop_97f5da14b02e14a864d77b6d983a33a1b302f894.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://forum.rebol.info/stylesheets/desktop_theme_2_5e18a6fac02b6ab11e33445179f4a2961aadbfd8.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2" data-theme-name="default"/>

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;Ladislav Mecir&#39;s &quot;Bindology&quot;&#39;" href="2073.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.rebol.info/uploads/default/original/1X/9ee5657fb81d179b484e0637da55bd1c83fbeb08.png" />
<meta property="og:image" content="https://forum.rebol.info/uploads/default/original/1X/9ee5657fb81d179b484e0637da55bd1c83fbeb08.png" />
<meta property="og:url" content="https://forum.rebol.info/t/ladislav-mecirs-bindology/2073" />
<meta name="twitter:url" content="https://forum.rebol.info/t/ladislav-mecirs-bindology/2073" />
<meta property="og:title" content="Ladislav Mecir&#39;s &quot;Bindology&quot;" />
<meta name="twitter:title" content="Ladislav Mecir&#39;s &quot;Bindology&quot;" />
<meta property="og:description" content="This is an archive of Ladislav&#39;s well-known &quot;Bindology&quot; article. It&#39;s not as important to have a backup of it as some other things, since it&#39;s on WikiBooks and will probably stay there.  Ladislav put it on WikiBooks in 2016, but the article is more circa a decade earlier, as the code from the article was uploaded to rebol.org in 2006  It&#39;s too long for a single post, so I split it into two.     Acknowledgments I would like to thank the men that influenced this article in some way. Those are esp..." />
<meta name="twitter:description" content="This is an archive of Ladislav&#39;s well-known &quot;Bindology&quot; article. It&#39;s not as important to have a backup of it as some other things, since it&#39;s on WikiBooks and will probably stay there.  Ladislav put it on WikiBooks in 2016, but the article is more circa a decade earlier, as the code from the article was uploaded to rebol.org in 2006  It&#39;s too long for a single post, so I split it into two.     Acknowledgments I would like to thank the men that influenced this article in some way. Those are esp..." />
<meta property="og:article:section" content="Development" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="og:article:section" content="Binding" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="article:published_time" content="2006-05-12T04:00:00+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://forum.rebol.info/">
    AltRebol
  </a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="2073.html">Ladislav Mecir&#39;s &quot;Bindology&quot;</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/development/8" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/development/binding/49" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Binding</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='Ladislav Mecir&#39;s &quot;Bindology&quot;'>
        <meta itemprop='articleSection' content='Binding'>
      <meta itemprop='keywords' content=''>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>

          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

              <link itemprop="mainEntityOfPage" href="2073.html">

                <link itemprop="image" href="../../uploads/default/original/1X/9ee5657fb81d179b484e0637da55bd1c83fbeb08.png">

              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2006-05-12T04:00:00Z' class='post-time'>
                    May 12, 2006,  4:00am
                  </time>
                  <meta itemprop='dateModified' content='2023-12-10T02:17:00Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='articleBody'>
              <blockquote>
<p>This is an archive of <a href="https://en.wikibooks.org/wiki/Rebol_Programming/Advanced/Bindology">Ladislav's well-known "Bindology" article</a>. It's not as important to have a backup of it as some other things, since it's on WikiBooks and will probably stay there.</p>
<p>Ladislav put it on WikiBooks in 2016, but the article is more circa a decade earlier, as the code from the article was <a href="http://www.rebol.org/view-script.r?script=contexts.r">uploaded to rebol.org in 2006</a></p>
<p>It's too long for a single post, so I split it into two.</p>
</blockquote>
<hr>
<h2>
<a name="acknowledgments-1" class="anchor" href="2073.html#acknowledgments-1"></a>Acknowledgments</h2>
<p>I would like to thank the men that influenced this article in some way. Those are especially Galt Barber, Brian D., Mark Dickson, Elan Goldman, Brian Hawley, Gregg Irwin, Thomas Jensen, Pierre Johnson, Holger Kruse, Volker Nitsch, Larry Palmiter, Patrick Philipot, Gabriele Santilli, Carl Sassenrath, Frank Sievertsen and Romano Paolo Tenca. Any errors are my copyright.</p>
<h2>
<a name="references-2" class="anchor" href="2073.html#references-2"></a>References</h2>
<p>The code in this article was tested in Rebol/View 2.7.6.3.1. It is possible that other versions of the interpreter yield different results.</p>
<p>A reader who wants to check all the examples can run this code:</p>
<pre><code>do http://www.rebol.org/download-a-script.r?script-name=contexts.r
</code></pre>
<p>...which defines all functions from this article.</p>
<h2>
<a name="word-types-3" class="anchor" href="2073.html#word-types-3"></a>Word types</h2>
<p>Rebol words like all Rebol values have type. Let's have a look at all available word types:</p>
<pre><code>type? first [rebol] ; == word!
type? first [rebol:] ; == set-word!
type? first [:rebol] ; == get-word!
type? first ['rebol] ; == lit-word!
type? first [/rebol] ; == refinement!
</code></pre>
<p>Moreover, all Rebol words have a common pseudo-type ANY-WORD!:</p>
<pre><code>any-word? first [rebol] ; == true
any-word? first [rebol:] ; == true
any-word? first [:rebol] ; == true
any-word? first ['rebol] ; == true
any-word? first [/rebol] ; == true
</code></pre>
<h2>
<a name="spelling-4" class="anchor" href="2073.html#spelling-4"></a>Spelling</h2>
<p>Every word has got a spelling. The spelling of a word is a string and it is one of the properties the above example words have in common. We can obtain the spelling of a word using the TO-STRING function:</p>
<pre><code>to-string first [rebol] ; == "rebol"
to-string first [rebol:] ; == "rebol"
to-string first [:rebol] ; == "rebol"
to-string first ['rebol] ; == "rebol"
to-string first [/rebol] ; == "rebol"
</code></pre>
<p>Observation (Unusual spellings): Words normally don't have some spellings like spellings containing spaces, spellings starting with a colon, etc. On the other hand, it is possible to create a word having any spelling as follows:</p>
<pre><code>unusual: make word! ":unusual word:"
type? unusual ; == word!
to-string unusual ; == ":unusual word:"
</code></pre>
<p>Observation (Spelling and word equality): Words with strict equal spelling are equal.</p>
<p>Illustration:</p>
<pre><code>equal? first [rebol] first [rebol:] ; == true
</code></pre>
<p>The reverse implication does not hold (since Rebol supports aliases). Nevertheless, we can reverse the implication at least in some way.</p>
<p>Observation (SAME? and spelling): If two words are the same according to the SAME? function then they have got strict equal spelling.</p>
<h2>
<a name="variables-5" class="anchor" href="2073.html#variables-5"></a>Variables</h2>
<p>A very important property of words is the ability to serve as variables (refer to Rebol values). To set a variable 'rebolution to refer to a Rebol string "uprising" we can pick one of the following:</p>
<pre><code>rebolution: "uprising"
set 'rebolution "uprising"
set/any 'rebolution "uprising"
set first [rebolution:] "uprising"
</code></pre>
<p>etc.</p>
<p>To get the value a variable refers to we can pick one of the following:</p>
<pre><code>:rebolution
get 'rebolution
get/any 'rebolution
</code></pre>
<p>etc.</p>
<p>Observation (Variables): The ability of words to serve as variables is closely related to a word property called binding. A word is a variable if and only if it is bound to a context (has a context, is in a context).</p>
<p>Illustration:</p>
<pre><code>; a refinement
get/any /rebol
** Script Error: rebol word has no context
** Near: get/any /rebol
</code></pre>
<p>The easiest way how to find out if a word is a variable is to use the properties of the BIND? function, which returns NONE for words that aren't variables:</p>
<pre><code>variable?: func [
    {is the given WORD a variable?}
    word [any-word!]
] [
    found? bind? :word
]
</code></pre>
<p>Tests:</p>
<pre><code>variable? 'rebol ; == true
variable? /rebol ; == false
</code></pre>
<p>Observation (Context uniqueness): As the BIND? function helps us to find out, for every Rebol word there is at most one context the given word is bound to.</p>
<p>Corollary (Context hierarchy): From the above observation follows that in Rebol there is no context hierarchy, because a context hierarchy would require some word being bound to at least two distinct contexts, one being "smaller" than the other.</p>
<p>Observation (Word sameness): According to the SAME? function two words are the same if and only if they have strict equal spelling and equal binding.</p>
<p>Observation (The result of the BIND? function): When the BIND? function is used to obtain the context of a word in an object, the result of the BIND? function "is not considered identical" with the object.</p>
<p>Illustration:</p>
<pre><code>o: make object! [a: none]
o-context: bind? in o 'a
same? o o-context ; == false
</code></pre>
<p>Observation (Equal words need not have equal binding): In fact, the opposite is true. For any word we can create a word having strict equal spelling, equal type and different binding.</p>
<pre><code>different-binding: func [
    {
        for a given WORD yield a word having
        strict equal spelling, equal type and different binding
    }
    word [any-word!] {the given word}
] [
    bind :word use reduce [to word! :word] reduce [to lit-word! :word]
]
</code></pre>
<p>Let's test, whether the function does what we declared:</p>
<pre><code>word1: 'a ; == a
word2: different-binding word1 ; == a
strict-equal? to-string word1 to-string word2 ; == true
equal? type? word1 type? word2 ; == true
equal? bind? word1 bind? word2 ; == false
set word1 1
set word2 2
get word1 ; == 1
get word2 ; == 2
</code></pre>
<p>The test shows that WORD1 and WORD2 have strict equal spelling and equal type. Their bindings are different. They can refer to different values at the same time, so they are distinct variables. Another test:</p>
<pre><code>word1: /a ; == /a
word2: different-binding word1 ; == /a
same? word1 word2 ; == false
equal? bind? word1 bind? word2 ; == false
</code></pre>
<h2>
<a name="the-bind-function-6" class="anchor" href="2073.html#the-bind-function-6"></a>The BIND function</h2>
<p>When we need to get a word having the spelling and type a given WORDS word has and the context a given KNOWN-WORD has, we can use the BIND function.</p>
<p>This is how the BIND function works:</p>
<h3>
<a name="binding-to-no-context-7" class="anchor" href="2073.html#binding-to-no-context-7"></a>Binding to no context</h3>
<p>Observation (Binding to no context): If the KNOWN-WORD has no context, BIND causes an error.</p>
<p>Illustration:</p>
<pre><code>a-word: second first context [rebol: 1] ; == rebol
bind? a-word ; == none
bind 'a a-word
** Script Error: rebol word has no context
** Near: bind 'a a-word
</code></pre>
<h3>
<a name="binding-when-the-words-argument-is-a-word-8" class="anchor" href="2073.html#binding-when-the-words-argument-is-a-word-8"></a>Binding when the WORDS argument is a word</h3>
<p>Observation (Effective bind): If it is possible, the BIND function yields a word having the spelling and type of the WORDS argument and the context of the KNOWN-WORD argument.</p>
<p>Illustration:</p>
<pre><code>words: 'a ; == a
known-word: use [a b] ['b] ; == b
result: bind words known-word ; == a
equal? bind? known-word bind? result ; == true
same? words known-word ; == false
</code></pre>
<p>We observe that the result has got the spelling and the type of the WORDS word, but it isn't the WORDS word because it is bound to the same context as the KNOWN-WORD is.</p>
<p>Observation (Equal words and effective bind): If WORD1 is a variable having a context CONTEXT and WORD2 is equal to WORD1 then WORD2 can be bound to CONTEXT too.</p>
<p>Observation (Ineffective bind): In case the BIND function cannot yield a word having the spelling and type of the WORDS argument and the binding of the KNOWN-WORD argument, BIND returns the WORDS argument.</p>
<pre><code>words: 'c ; == c
known-word: use [a b] ['b] ; == b
result: bind words known-word ; == c
same? words result ; == true
</code></pre>
<p>In this case BIND simply returned the WORDS word.</p>
<h3>
<a name="binding-when-the-words-argument-is-a-block-9" class="anchor" href="2073.html#binding-when-the-words-argument-is-a-block-9"></a>Binding when the WORDS argument is a block</h3>
<p>Observation (Binding block without copying): If the /COPY refinement isn't used, BIND replaces the elements of the block by results of their binding. There is one exception to this rule: BIND doesn't bind refinements contained in the block.</p>
<h2>
<a name="aliases-10" class="anchor" href="2073.html#aliases-10"></a>Aliases</h2>
<p>Definition (Aliases): Equal words that do not have strict equal spelling we call aliases.</p>
<p>This is our definition translated to Rebol:</p>
<pre><code>aliases?: func [
    {find out, if WORD1 and WORD2 are aliases}
    word1 [any-word!]
    word2 [any-word!]
] [
    found? all [
        equal? :word1 :word2
        strict-not-equal? to-string :word1 to-string :word2
    ]
]
</code></pre>
<p>Corollary (Word equality): Two words are equal if and only if one of the following conditions holds:</p>
<ul>
<li>the words have strict equal spelling</li>
<li>the words are aliases</li>
</ul>
<p>Corollary (Aliases and SAME?): The SAME? function yields FALSE when comparing two aliases.</p>
<p>Proof: See the (SAME? and spelling) observation and our definition of aliases.</p>
<p>Observation (Automatic aliases): Since Rebol tries to be case-insensitive, the interpreter usually (except for inconsistencies) "considers" words with spellings differing only in case to be aliases.</p>
<p>Observation (ALIAS): Aliases can be defined explicitly using the ALIAS function.</p>
<pre><code>; let's create an alias 'revolutionary for the word 'rebol
alias 'rebol "revolutionary"
; 'rebol and 'revolutionary will be equal words with different spelling:
equal? 'rebol 'revolutionary ; == true
strict-equal? to-string 'rebol to-string 'revolutionary ; == false
aliases? 'rebol 'mean ; == false
aliases? 'rebol 'rebol ; == false
aliases? 'rebol 'revolutionary ; == true
aliases? 'system 'SYSTEM ; == true
</code></pre>
<p>Observation (ALIAS return value): The ALIAS function returns unbound words.</p>
<pre><code>y: alias 'x "xx" ; == xx
bind? y ; == none
</code></pre>
<p>Observation (Variable sameness): Two words are one variable if and only if they are equal and their bindings are equal too.</p>
<pre><code>same-variable?: func [
    {are WORD1 and WORD2 the same variable?}
    word1 [any-word!]
    word2 [any-word!]
] [
    found? all [
        equal? :word1 :word2
        equal? bind? :word1 bind? :word2
    ]
]
</code></pre>
<p>Observation (Alternative definition of ALIASES?): According to our previous observations this definition is equivalent to our original definition:</p>
<pre><code>aliases?: func [
    {find out, if WORD1 and WORD2 are aliases}
    word1 [any-word!]
    word2 [any-word!]
    /local context
] [
    found? all [
        equal? :word1 :word2
        (
            if context: any [bind? :word1 bind? :word2] [
                word1: in context :word1
                word2: in context :word2
            ]
            ; WORD1 and WORD2 have equal binding now
            not same? :word1 :word2
        )
    ]
]
</code></pre>
<p>The alternative definition looks more complicated, but it is faster due to the fact that it does not need to manipulate strings.</p>
<h2>
<a name="context-words-11" class="anchor" href="2073.html#context-words-11"></a>Context words</h2>
<p>The BIND? function allows us to find the context of a given word. The reverse task is a task to find all words that are in a given CONTEXT context. It can be done as follows:</p>
<pre><code>context-words?: func [
    {get the words in a given CONTEXT}
    context [object!]
] [
    bind first context context
]
</code></pre>
<p>Observation (Simplified set of context words): The block obtained as the result of the <code>first context</code> expression is a simplified set of context words. As opposed to the result of the above function it contains unbound words. Moreover, similarly as the result of the above function it doesn't contain aliases of its words and it contains only words of the WORD! datatype.</p>
<p>Illustration:</p>
<pre><code>alias 'rebol "rebellious"
o: make object! [rebellious: 1]
first o ; == [self rebellious]
bind? first first o ; == none
in o 'rebol ; == rebol
</code></pre>
<h2>
<a name="the-global-context-12" class="anchor" href="2073.html#the-global-context-12"></a>The global context</h2>
<p>Definition (Global context): The global context can be defined e.g. as follows:</p>
<p><code>global-context: bind? 'system</code></p>
<p>Note: This is not the only option, another one is to define it as the SYSTEM/WORDS object. The above definition gives us the simplest possible definition of global words.</p>
<p>Definition (Global words/global variables): The words that are bound to the global context we call global words (global variables):</p>
<pre><code>global?: func [
    {find out if a WORD is global}
    word [any-word! object!]
] [
    same? global-context bind? :word
]
</code></pre>
<p>Observation (MAKE, TO, LOAD, BIND and the global context): The words created by MAKE WORD!, MAKE SET-WORD!, MAKE GET-WORD!, MAKE LIT-WORD!, MAKE REFINEMENT!, TO WORD!, TO SET-WORD!, TO GET-WORD!, TO LIT-WORD!, TO REFINEMENT!, LOAD and BIND WORD 'SYSTEM are global.</p>
<p>Illustration:</p>
<pre><code>global? make word! first first rebol/words ; == true
global? to word! first first rebol/words ; == true
</code></pre>
<p>Observation (Automatic growth): The global context can be enlarged using the MAKE, TO, LOAD and BIND functions. On the other hand, the IN function doesn't enlarge the global context.</p>
<p>Observation (MAKE, TO and unbound words): All words contained in a result block of MAKE BLOCK!, TO BLOCK! and in its subblocks are unbound if the SPEC argument is a string.</p>
<p>Illustration:</p>
<pre><code>bind? first make block! "unbound" ; == none
bind? first first first make block! "[[unbound-too]]" ; == none
</code></pre>
<h2>
<a name="local-contexts-13" class="anchor" href="2073.html#local-contexts-13"></a>Local contexts</h2>
<p>Definition (Local words/local variables): The words that are neither unbound nor global we call local words (local variables):</p>
<pre><code>local?: func [
    {find out, if a WORD is local}
    word [any-word!]
] [
    not any [
        none? bind? :word
        global? :word
    ]
]
</code></pre>
<p>Definition (Local context): A context is called local context if its words are local words.</p>
<p>Observation (Local context types): User defined objects, function contexts and USE contexts are local contexts. In addition to these we can use the BIND? function to "convert" user defined objects and ports to contexts and using the DISARM function we can convert errors to objects. All the results are local contexts. The main distinction between the function- and USE- contexts and all other context types lies in the fact that the function- and USE- contexts don't need to contain a word equal to the word 'self.</p>
<p>Observation (Enlarging local contexts): Local contexts aren't enlargeable.</p>
<p>Observation (The result of the DIFFERENT-BINDING function): The result of the DIFFERENT-BINDING function as we defined it above is always a local word.</p>
<h2>
<a name="computed-binding-14" class="anchor" href="2073.html#computed-binding-14"></a>Computed binding</h2>
<p>Let's observe the behaviour of the Rebol interpreter when evaluating an example code string:</p>
<pre><code>code-string: {'f 'g 'h use [g h] [colorize "USE 1" 'f 'g 'h use [h] [colorize "USE 2" 'f 'g 'h]]}
</code></pre>
<p>The COLORIZE function will colorize the code listing as follows:</p>
<ul>
<li>the unbound words will be <span>brown</span>
</li>
<li>the global words will be <span>blue</span>
</li>
<li>the words bound by the first USE evaluation will be <span>red</span>
</li>
<li>the words bound by the second USE evaluation will be <span>magenta</span>
</li>
</ul>
<p>Here is the code:</p>
<pre><code>emit: func [text [char! string! block!]] [
    append result either block? text [rejoin text] [text]
]

colorize: func [
    {emit a table row containing text and the colorized code block}
    text [string!]
    /local space?
] [
    emit ["^/|-^/| " text "^/| "]
    space?: ""
    parse code-block rule: [
        (
            emit [space? #"["]
            space?: ""
        )
        any [
            [
                set word any-word! (
                    emit [
                        space?
                        {&lt;font color="}
                        case [
                            not bind? :word ["brown"]
                            global? :word ["blue"]
                            equal? bind? :word bind? code-block/6/4 ["red"]
                            equal? bind? :word bind? code-block/6/8/5 [
                                "magenta"
                            ]
                        ]
                        {"&gt;}
                        mold :word
                        &lt;/font&gt;
                    ]
                ) | into rule | set word skip (
                    emit [space? mold :word]
                )
            ]
            (space?: " ")
        ]
    ]
]
</code></pre>
<p>Let's watch how the code is being interpreted:</p>
<pre><code>; the result will be a wikitable
result: {^{| class="wikitable" border="1"
|-
! Text
! Code}

; first, the interpreter creates a code block
code-block: make block! code-string
colorize "String to block conversion"

; next, the code block is bound to the global context
bind code-block global-context
colorize "Code block bound to the global context"

; and then the code block is interpreted
do code-block

; now we close the table
emit "^/|}^/"

write clipboard:// result
</code></pre>
<p>The rendering result in a Wiki site is:</p>
<p><div class="lightbox-wrapper"><a class="lightbox" href="../../uploads/default/original/1X/9ee5657fb81d179b484e0637da55bd1c83fbeb08.png" data-download-href="https://forum.rebol.info/uploads/default/9ee5657fb81d179b484e0637da55bd1c83fbeb08" title="image"><img src="../../uploads/default/original/1X/9ee5657fb81d179b484e0637da55bd1c83fbeb08.png" alt="image" data-base62-sha1="mFEV2zcXBrq4yRjjfZ210vNygty" width="690" height="146" data-dominant-color="E7E6ED"><div class="meta">
<svg class="fa d-icon d-icon-far-image svg-icon" aria-hidden="true"><use href="#far-image"></use></svg><span class="filename">image</span><span class="informations">741×157 4 KB</span><svg class="fa d-icon d-icon-discourse-expand svg-icon" aria-hidden="true"><use href="#discourse-expand"></use></svg>
</div></a></div></p>
<p>The result proves that:</p>
<ul>
<li>
<p>After the string to block conversion all words in the CODE-BLOCK were unbound</p>
</li>
<li>
<p>After the CODE-BLOCK was bound to the global context all words in the CODE-BLOCK were global</p>
</li>
<li>
<p>The first USE call replaced all words 'g and 'h from its body block and its subblock with local USE 1 words</p>
</li>
<li>
<p>The second USE call replaced the 'h in the innermost block with the local USE 2 word</p>
</li>
</ul>
<p>Observation (Computed binding): During the interpretation the binding of Rebol words contained in the code is changed (i.e. the words are being replaced by words with different binding) until they are bound correctly and evaluated. That is why the creator of Rebol calls this behaviour "Computed binding".</p>
<h2>
<a name="scope-15" class="anchor" href="2073.html#scope-15"></a>Scope</h2>
<p>It looks like we observed a "scope hierarchy" during the execution of the above Rebol code. As we have demonstrated, it was only a side effect of the computed binding.</p>
<p>With a help of the computed binding we can easily create code samples, which do not exhibit any "scope" property:</p>
<pre><code>; create a block CODE-BLK containing a word 'a
code-blk: copy [a]
a: 12

; now append another word 'a to CODE-BLK
make object! [append code-blk 'a a: 13]

code-blk ; == [a a]

; test if CODE-BLK contains equal words
equal? first code-blk second code-blk ; == true

; prove that the CODE-BLK is not a "scope"
equal? bind? first code-blk bind? second code-blk ; == false
</code></pre>
<p>The CODE-BLK example demonstrates that for a code block there is no such thing as its "current context" in Rebol because in Rebol only individual words are associated with context.</p>
<h2>
<a name="the-use-function-16" class="anchor" href="2073.html#the-use-function-16"></a>The USE function</h2>
<p>To be as precise as possible we will write the description of the USE function behaviour in Rebol.</p>
<p>The following function creates a new context, in which all words are unset:</p>
<pre><code>make-context-model: func [
    {context creation simulation}
    words [block!] {context words, needs to be non-empty}
] [
    bind? first use words reduce [reduce [first words]]
]
</code></pre>
<p>The description of USE:</p>
<pre><code>use-model: function [
    {USE simulation, works for non-empty WORDS block}
    [throw]
    words [block!] "Local word(s) to the block"
    body [block!] "Block to evaluate"
] [new-context] [
    unless empty? words [
        ; create a new context
        new-context: make-context-model words
        ; bind the body to the new Context
        bind body new-context
    ]
    do body
]
</code></pre>
<p>Observation (USE-MODEL and BODY): USE-MODEL modifies its BODY argument when it binds it to the new context. If we wanted to leave the BODY argument unmodified, we should have used BIND/COPY instead of the present BIND.</p>
<p>Let's compare USE-MODEL's behaviour and the behaviour of USE:</p>
<pre><code>body: ['a]
body-copy: copy body
same? first body first body-copy ; == true
use [a] body
same? first body first body-copy ; == false
</code></pre>
<p>As we made sure, the same is true for both USE-MODEL and the original USE. The simulation is so accurate that it helped us to reveal a bug in the following code:</p>
<pre><code>f: func [x] [
    use [a] [
        either x = 1 [
            a: "OK"
            f 2
            a
        ] [
            a: "BUG!"
            "OK"
        ]
    ]
]
f 1 ; == "BUG!"
</code></pre>
<p>Explanation/correction:</p>
<p>The observed USE property caused that the body of the function F got modified during the second USE execution. After that modification it no longer contained the word 'a that was set to "OK" during the first invocation of F. Instead it contained only the word 'a set to the "BUG!" value during the second invocation of F.</p>
<p>If we preserve the body of the F somehow, we can get the correct behaviour:</p>
<pre><code>f: func [x] [
    use [a] copy/deep [
        either x = 1 [
            a: "OK"
            f 2
            a
        ] [
            a: "BUG!"
            "OK"
        ]
    ]
]
f 1 ; == "OK"
</code></pre>
<p>Another way how to correct the behaviour is to use our own version of USE that will not modify its body argument:</p>
<pre><code>nm-use: func [
    {
        Defines words local to a block.
        Does't modify the BODY argument.
    }
    [throw]
    words [block!] {Local words to the block}
    body [block!] {Block to evaluate}
] [
    use words copy/deep body
]
</code></pre>
<h2>
<a name="make-object-17" class="anchor" href="2073.html#make-object-17"></a>MAKE OBJECT!</h2>
<p>We need a function that evaluates the SPEC argument like MAKE OBJECT! does, which means that it has to catch  RETURN, THROW and BREAK:</p>
<pre><code>spec-eval: func [
    {evaluate the SPEC like MAKE OBJECT! does}
    spec [block!]
] [
    any-type? catch [loop 1 spec]
]
</code></pre>
<p>The MAKE OBJECT! simulation:</p>
<pre><code>make-object!-model: function [
    {MAKE OBJECT! simulation}
    spec [block!]
] [set-words object sw] [
    ; find all set-words in SPEC
    set-words: copy [self]
    parse spec [
        any [
                copy sw set-word! (append set-words sw)
            |
                skip
        ]
    ]
    ; create a context with the desired local words
    object: make-context-model set-words
    ; set 'self in object to refer to the object
    object/self: object
    ; bind the SPEC to the blank object
    bind spec in object 'self
    ; evaluate it
    spec-eval spec
    ; return the value of 'self as the result
    return get/any in object 'self
]
</code></pre>
<p>Observation (MAKE-OBJECT!-MODEL and SPEC): MAKE-OBJECT!-MODEL modifies its SPEC argument when it binds it to the new context. If we wanted to leave the SPEC argument unmodified, we should have used BIND/COPY instead of the present BIND.</p>
<p>The described behaviour leads to a bug similar to the bug described in the USE section:</p>
<pre><code>f: func [x] [
    get in make-object!-model [
        a: "OK"
        if x = 1 [
            a: "BUG!"
            f 2
            a: "OK"
        ]
    ] 'a
]
f 1 ; == "BUG!"
</code></pre>
<p>The explanation and the correction are similar as for the USE function. The word a: in the a: "OK" line positioned after the recursive call to F and bound to the object F created first was replaced by a word a: bound to the object F created during the recursive call. Consequently, the expression a: "OK" had no effect on the object F created first and therefore it retained the last value of 'a, which was "BUG!". If we preserve the body of F, we can get the correct behaviour:</p>
<pre><code>f: func [x] [
    get in make object! copy/deep [
        a: "OK"
        if x = 1 [
            a: "BUG!"
            f 2
            a: "OK"
        ]
    ] 'a
]
f 1 ; == "OK"
</code></pre>
<p>As you might have seen, the above code deep copies the BODY block before binding it to the context. Analogical bugs were discovered when the deep copying was not used when the FUNC function created Rebol functions.</p>
<h2>
<a name="make-proto-18" class="anchor" href="2073.html#make-proto-18"></a>MAKE PROTO</h2>
<p>This is a simulation of the situation when the MAKE function obtains a prototype of the object it has to create. First of all, we need a special BIND-like function:</p>
<pre><code>specbind: function [
    {bind only known-words}
    block [block!]
    known-words [block!]
] [p w bind-one kw] [
    bind-one: [
        p:
        [
            copy w any-word! (
                if kw: find known-words first w [
                    change p bind w first kw
                ]
            ) | copy w [path! | set-path! | lit-path!] (
                if kw: find known-words first first w [
                    change p bind w first kw
                ]
            ) | into [any bind-one] | skip
        ]
    ]
    parse block [any bind-one]
    block
]
</code></pre>
<p>And here is the simulation:</p>
<pre><code>make-proto: function [
    {MAKE PROTO simulation}
    proto [object!]
    spec [block!]
] [set-words object sw word value spc body pwords] [
    ; get local words from proto
    set-words: copy first proto

    ; append all set-words from SPEC
    parse spec [
        any [
            copy sw set-word! (append set-words sw) |
            skip
        ]
    ]

    ; create a blank object with the desired local words
    object: make-context-model set-words
    object/self: object

    ; copy the contents of the proto
    pwords: bind first proto object
    repeat i (length? first proto) - 1 [
        word: pick next first proto i
        any-type? set/any 'value pick next second proto i
        any [
            all [string? get/any 'value set in object word copy value]
            all [
                block? get/any 'value
                value: specbind copy/deep value pwords
                set in object word value
            ]
            all [
                function? get/any 'value
                spc: load mold third :value
                body: specbind copy/deep second :value pwords
                set in object word func spc body
            ]
            any-type? set/any in object word get/any 'value
        ]
    ]

    bind spec object
    spec-eval spec
    return get/any in object 'self
]
</code></pre>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
                <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
                <meta itemprop="userInteractionCount" content="0" />
              </div>

          </div>
          <div id='post_2' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

              <link itemprop="mainEntityOfPage" href="2073.html">


              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2006-05-12T04:02:55Z' class='post-time'>
                    May 12, 2006,  4:02am
                  </time>
                  <meta itemprop='dateModified' content='2006-05-12T04:02:55Z'>
              <span itemprop='position'>2</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <h2>
<a name="functions-with-make-object-like-handling-of-local-words-1" class="anchor" href="2073.html#functions-with-make-object-like-handling-of-local-words-1"></a>Functions with MAKE OBJECT!-like handling of local words</h2>
<p>Before we try to model the function evaluation, we can ask whether we can use the same method of the local words handling as the CONTEXT function uses.</p>
<p>The answer is positive and the function able to do this is defined below.</p>
<p>First of all a function that can extract all local words of a function from its SPEC:</p>
<pre><code>locals?: func [
    {Get all locals from a spec block.}
    spec [block!]
    /args {get only arguments}
    /local locals item item-rule
] [
    locals: make block! 16
    item-rule: either args [[
	refinement! to end (item-rule: [end skip]) |
	set item any-word! (insert tail locals to word! :item) | skip
    ]] [[
	set item any-word! (insert tail locals to word! :item) | skip
    ]]
    parse spec [any item-rule]
    locals
]

set-words: func [
    {Get all set-words from a block}
    block [block!]
    /deep {also search in subblocks/parens}
    /local elem words rule here
] [
    words: make block! length? block
    rule: either deep [[
        any [
            set elem set-word! (
                insert tail words to word! :elem
            ) | here: [block! | paren!] :here into rule | skip
        ]
    ]] [[
        any [
            set elem set-word! (
                insert tail words to word! :elem
            ) | skip
        ]
    ]]
    parse block rule
    words
]

funcs: func [
    {Define a function with auto local and static variables.}
    [throw]
    spec [block!] {Help string (opt) followed by arg words with opt type and string}
    init [block!] {Set-words become static variables, shallow scan}
    body [block!] {Set-words become local variables, deep scan}
    /local svars lvars
] [
    ; Preserve the original Spec, Init and Body
    spec: copy spec
    init: copy/deep init
    body: copy/deep body
    ; Collect static and local variables
    svars: set-words init
    lvars: set-words/deep body
    unless empty? svars [
        ; create the static context and bind Init and Body to it
        use svars reduce [reduce [init body]]
    ]
    unless empty? lvars: exclude exclude lvars locals? spec svars [
        ; declare local variables
        insert any [find spec /local insert tail spec /local] lvars
    ]
    do init
    make function! spec body
]
</code></pre>
<h2>
<a name="model-of-rebol-functions-2" class="anchor" href="2073.html#model-of-rebol-functions-2"></a>Model of Rebol functions</h2>
<p>Our model of Rebol functions will be a Rebol object FUNCTION!-MODEL having the appropriate attributes. The totally necessary attributes of Rebol functions are SPEC and BODY.</p>
<p>To model the current behaviour of Rebol functions accurately our FUNCTION!-MODEL needs CONTEXT, CONTEXT-WORDS and RECURSION-LEVEL attributes to model the behaviour of Rebol functions during recursive calls:</p>
<pre><code>function!-model: make object! [
    spec: none
    body: none
    context: none
    context-words: none
    recursion-level: none
]
</code></pre>
<h3>
<a name="model-of-the-func-function-3" class="anchor" href="2073.html#model-of-the-func-function-3"></a>Model of the FUNC function</h3>
<p>This function gets the SPEC and BODY attributes, creates a new FUNCTION!-MODEL and initializes it.</p>
<pre><code>func-model: function [
    {create a function!-model}
    spec [block!]
    body [block!]
] [result aw] [
    result: make function!-model []

    ; SPEC and BODY are deep copied
    result/spec: copy/deep spec
    result/body: copy/deep body

    result
]
</code></pre>
<h3>
<a name="model-of-the-function-call-stack-4" class="anchor" href="2073.html#model-of-the-function-call-stack-4"></a>Model of the function call stack</h3>
<p>The call stack is empty when the interpreter starts.</p>
<pre><code>call-stack-model: make block! []
</code></pre>
<h3>
<a name="model-of-function-evaluation-5" class="anchor" href="2073.html#model-of-function-evaluation-5"></a>Model of function evaluation</h3>
<p>Our simulation begins when the values of the function arguments are collected and their types checked.</p>
<p>The evaluation function obtains a FUNCTION!-MODEL together with a block of values it shall store to its local context words (i.e. all values of its arguments, optional arguments, refinements and local words).</p>
<p>We model only the morst frequent case of a function without the THROW/CATCH attributes.</p>
<p>The first part of our model executes the body:</p>
<pre><code>exec: func [body] [do body]
</code></pre>
<p>The simulation:</p>
<pre><code>evaluate-model: function [
    {evaluate a function!-model}
    f-model {the evaluated function!-model}
    values [block!] {the supplied values}
] [old-values result] [
    ; detect recursive call
    if (f-model/recursion-level: f-model/recursion-level + 1) &gt; 1 [
        ; push the old values of context words to the stack
        insert/only tail call-stack-model second f-model/context
    ]
    set/any f-model/context-words values

    ; execute the function body
    error? set/any 'result exec f-model/body

    ; restore the former values from the stack, if needed
    if (f-model/recursion-level: f-model/recursion-level - 1) &gt; 0 [
        ; pop the old values of the context words from the stack
        set/any f-model/context-words last call-stack-model
        remove back tail call-stack-model
    ]

    return get/any 'result
]
</code></pre>
<p>Our model uses just one context for the whole lifetime of the FUNCTION!-MODEL without need to change the binding of its BODY. I call this behaviour a Dynamic Recursion Patch.</p>
<p>Some tests:</p>
<pre><code>probeblk: func [] [
    prin mold blk
    prin ": "
    print mold reduce blk
]

recfun: func-model [x] [
    append blk 'x
    either x = 2 [
        probeblk
    ] [
        evaluate-model recfun [2]
    ]
]

blk: copy []
evaluate-model recfun [1] ; [x x]: [2 2]
probeblk ; [x x]: [1 1]
</code></pre>
<p>If we compare the simulated behaviour with the real Rebol functions, we get:</p>
<pre><code>recfun: func [x] [
    append blk 'x
    either x = 2 [
        probeblk
    ] [
        recfun 2
    ]
]

blk: copy []
recfun 1 ; [x x]: [2 2]
probeblk ; [x x]: [1 1]
</code></pre>
<p>This shows that the simulation is really accurate and that Rebol functions use the Dynamic Recursion Patch too.</p>
<p>Although the Dynamic Recursion Patch can speed up the evaluation under some circumstances it has got its drawbacks:</p>
<pre><code>f-returning-x: func [x] [
    func [] [x]
]

f-returning-ok: f-returning-x "OK"
f-returning-ok ; == "OK"
f-returning-bug: f-returning-x "BUG!"
; so far so good, but now:
f-returning-ok ; == "BUG!"
</code></pre>
<h2>
<a name="computed-binding-functions-closures-6" class="anchor" href="2073.html#computed-binding-functions-closures-6"></a>Computed binding functions (Closures)</h2>
<p>As we have seen above Computed binding has got its merits while the Dynamic recursion patch isn't ideal. The results inspired me to implement the Computed binding functions and compare their behaviour with the behaviour of the Dynamic recursion patch functions.</p>
<p>The Computed binding functions shall create a new context every time they are called and bind their bodies accordingly. We can even use a part of the above simulation to implement them.</p>
<pre><code>closure: func [
    [catch]
    spec [block!] {Help string (opt) followed by arg words (and opt type and string)}
    body [block!] {The body block of the closure}
    /local spc item result
] [
    spc: make block! 1 + (2 * length? spec)
    insert/only spc [throw]
    result: make block! 5 + length? spec
    insert result reduce [:do :make :function! spc body]
    parse spec [
        any [
            set item any-word! (
                insert tail result to word! :item
                insert tail spc to get-word! :item
                insert/only tail spc [any-type!]
            ) | skip
        ]
    ]
    throw-on-error [make function! spec result]
]
</code></pre>
<p>The first test:</p>
<pre><code>recfun: closure [x] [
    append blk 'x
    either x = 2 [
        probeblk
    ] [
        recfun 2
    ]
]

blk: copy []
recfun 1 ; [x x]: [1 2]
probeblk ; [x x]: [1 2]
</code></pre>
<p>This surely looks better than before. The second test:</p>
<pre><code>f-returning-x: closure [x] [
    func [] [x]
]

f-returning-ok: f-returning-x "OK"
f-returning-ok ; == "OK"
f-returning-bug: f-returning-x "BUG!"
; so far so good, but now:
f-returning-ok ; == "OK"
</code></pre>
<p>The end.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
                <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
                <meta itemprop="userInteractionCount" content="0" />
              </div>

          </div>
    </div>






    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://forum.rebol.info/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://forum.rebol.info/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://forum.rebol.info/guidelines' itemprop="url">FAQ/Guidelines </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://forum.rebol.info/tos' itemprop="url">Terms of Service </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://forum.rebol.info/privacy' itemprop="url">Privacy Policy </a>
        </span>
      </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

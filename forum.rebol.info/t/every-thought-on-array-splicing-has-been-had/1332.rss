<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
    <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332</link>
    <description>&gt; Important Updated Response to the topic of this 2020 Post:
&gt;
&gt; **Nope.  I was wrong.  [Quoting levels of -1](https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918) was a thought that hadn&#39;t been had in September 2020.**
&gt;
&gt; *(Because [isotopes in their most primitive form weren&#39;t proposed until November 2020](https://forum.rebol.info/t/multiple-returns-and-branching-could-it-unseat-voidification/1408), and it took some time before ^META conventions were laid out.)*
&gt;
&gt; Just goes to show you... there&#39;s always room for more insights.  You can ignore this post unless you want to go down some historical dead ends...

---
Here&#39;s what we &quot;know&quot;...

## BLOCK!s (and only plain BLOCK!s) Splice By Default

This is to say that BLOCK! is *The* universal container (**&quot;[o]&quot;**).  Splicing of the contents of a non-block is done by aliasing it as a block first...which can be done efficiently without copying memory.

It was always obvious to me that PATH!s should not splice.  But I didn&#39;t have any real guidance on GROUP!, or the new types like SET/GET-BLOCK!/GROUP! (and whatever **@[block]** or **@(group)** ultimately gets called).  It was a toss up between *&quot;anything that uses spaces to separate elements splice, and anything tighter--like tuples/paths--not&quot;* vs. *&quot;the logo is [o], so anything with brackets is special&quot;* (I was pretty sure *&quot;do whatever Rebol2 did&quot;* was not a good idea).

But I think there&#39;s a better narrative for justifying this solution.  Looking at other languages like Haskell/Rust/Elm, they all used parentheses for tuples...where their notion of a tuple is fixed-size with elements that aren&#39;t necessarily of the same type.  This led me to think about the question of if BLOCK!&#39;s universal containerness might make it something you don&#39;t just pick automatically...you&#39;d pick something else when splicing wasn&#39;t what you&#39;d *typically* want.

Here&#39;s a made-up example:

    add-new-products: func [product-list: [block!]] [
        product1: &#39;(#WID-0304 &quot;Super Widget&quot; $1.99)
        product2: &#39;(#WID-1020 &quot;Super Widget Plus&quot; $2.00)

        append product-list product1
        append product-list product2
        append product-list [
            (#WID-0421 &quot;Super Widget Premium&quot; $2.01)
            (#WID-9999 &quot;Super Widget Ultimate&quot; $102,003.04)
        ]
    ]

See how light the generic quoting made the GROUP! literals?  Now this makes the choice of BLOCK! vs. GROUP! something that you can reason about better.  You can take advantage of the difference so you&#39;re not fighting the behavior--but &quot;synergizing&quot; with it.

But also...with **@[...]**/etc that doesn&#39;t splice, you have more options for shifting your data&#39;s conception of itself as it is passed around.

I&#39;ll point out that since there&#39;s no @ or : in the logo, this does ultimately dovetail nicely with &quot;what&#39;s in the logo is special&quot;...it&#39;s not just any bracketed thing, it&#39;s plain BLOCK!.   :slight_smile:
 
## [&quot;Modal Parameters&quot;](https://forum.rebol.info/t/new-parameter-convention-concept-modal-arguments-or-the-arg/1187) are the Answer for Anti-Splicers

I&#39;ve been trying to embrace @rgchris&#39;s concept that the language bias should stick to making it so that &quot;common&quot; code does not lean too strongly on symbols to convey meaning.  While you can retrain yourself to comprehend pretty much any symbol soup, letting your mindset drift to that &quot;new normal&quot; isn&#39;t good for communicating code to others.  *(And it&#39;s probably not good for your own ability to see clearly, either...even if you -think- you understand what you&#39;re doing.)*

This has to be balanced against many other design factors; to which I&#39;m sensitive because I actually understand what it takes to make things *work* at a mechanical bits-and-bytes level.  So this pushes back and forth.

Modal parameters give an easy mechanism to library authors, or others who want a rigorous way to append values &quot;as is&quot; without typing /only at every callsite.

    &gt;&gt; append [a b c] @[d e]
    == [a b c [d e]]

    &gt;&gt; item: @[d e]
    &gt;&gt; append [a b c] item
    == [a b c @[d e]]  ; modality comes from parameter, not fetched value

    &gt;&gt; append [a b c] &#39;@[d e]
    == [a b c @[d e]]  ; quoting suppresses modality, then evaluates away

     &gt;&gt; do compose [append [a b c] &#39;(third [&lt;d&gt; #e @[f g]])]
     == [a b c @[f g]]  ; quoting in COMPOSE is there to help in cases like this

It&#39;s not something that has to be brought up in early tutorials.  But I like it.  And it&#39;s a generic mechanism that people can use when they want a parameter to indicate the mode of a refinement...so there&#39;s generic uses for it.

## Further changes to APPEND and such will be abandoned

I experimented with making APPEND only accept blocks, and then maybe blocks and strings, and other kinds of tweaks.  They weren&#39;t worth it.

What&#39;s changing the game here is making BLOCK! the only type that splices by default.

It used to be that when you had a moment of doing an append of some parameter--that wasn&#39;t a block before but suddenly is now--you groaned and said *&quot;why&#39;d I forget the /ONLY&quot;* or *&quot;why does this darn thing behave so randomly&quot;*.

Now a new thing you can ask in many of these moments is: ***&quot;Why was this value a plain block if I didn&#39;t want it to splice??&quot;***  It should feel less random, when you have more alternatives.  I&#39;m going to look at my array choices in this new light, and maybe need /ONLY less often as a result.

Modal parameters are good to have to point people to who aren&#39;t on board with splice-by-default.  And I&#39;m willing to accept the burden of using a modal parameter to enter an @ symbol when I want it.  It saves significant evaluation time over APPEND/ONLY, and doesn&#39;t require a series node allocation to hold the APPEND and ONLY words.

## BLOCK! Conversions Needed

Because the only way to get splicing is now to have a block, it raises the question of how to get blocks.

AS BLOCK! is cheap; it doesn&#39;t allocate any memory, it just aliases the series as a different cell class.  So it&#39;s a good choice if you know what you have is an array.

    &gt;&gt; group: &#39;(d e f)
    &gt;&gt; append [a b c] as block! group
    == [a b c d e f]

If you don&#39;t know if you have an array value or not, this is a little harder.  But we can actually turn items into a one-cell BLOCK! *without allocating any memory*.  This is a new trick which was called mirroring, but the mechanism is changed to where it needs a new name.  The new block is read only, but that is okay for the purposes of this append since it&#39;s gone after the splice.

The name for the operation I had in mind was BLOCKIFY (though it&#39;s not using the mirroring mechanism at the moment, only the PATH! trick is, which proves it does work).

    &gt;&gt; value: &#39;(d e f)
    &gt;&gt; append [a b c] blockify value  ; [d e f]
    == [a b c d e f]

    &gt;&gt; value: 1020
    &gt;&gt; append [a b c] blockify value  ; [1]
    == 1020

But that&#39;s a weird looking word, and I hate having to have lists of things like this (groupify?  set-groupify?)  The concept from the other day of FORCE might be interesting

    append [a b c] force block! value

That&#39;s at least generic, and it kind of conveys &quot;I want a block, if it&#39;s a block then great, if not then change it&quot;.  But that makes it sound like its *changing* the input value to be a block, vs. wrapping it.

But maybe AS can wing it, and say that if you give it a non-block it can just do the wrapping in a block anyway and give you something read-only?  :-/  I mean, the user doesn&#39;t know that every single-valued item doesn&#39;t secretly live in a 1-element array in the implementation...it might.  Hmmm.

Anyway, this name looks like the only missing piece.  What do you call something that doesn&#39;t do any memory allocation but just makes a light 1-element wrapper that can live in a cell, to keep us from having to add more crazy refinements?

It&#39;s not a super high priority as most cases are known to be AS (in the form known today)

## Speak Up or Hold Your Peace

Like I say, I think I&#39;ve probably had all the thoughts.  There aren&#39;t any more to be had.  If you want to prove me wrong, post it here...but do it soon.</description>
    
    <lastBuildDate>Sun, 10 Jan 2021 16:27:15 +0000</lastBuildDate>
    <category>Semantics</category>
    <atom:link href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/10</link>
        <pubDate>Sun, 17 Jul 2022 06:28:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-10</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[BlackATTR]]></dc:creator>
        <description><![CDATA[
            <p>Query (at this time) is at most a few hundred lines of unsophisticated script. I think you should make whatever changes are necessary for the language and I will incorporate them as needed. I welcome it. I already need to rework every parse expression for uparse.</p>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/14">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/14</link>
        <pubDate>Fri, 13 Aug 2021 17:46:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-14</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I'm actually satisfied with the idea that evaluative types must be quoted to do APPEND/INSERT/CHANGE mechanics.  But it seems the FIND still throws me, on account of it being too related to SELECT at this time, and needing to take plain WORD! for OBJECT!.</p>
<p>Because I want to go ahead and push forward on <a class="mention" href="https://forum.rebol.info/u/blackattr">@BlackATTR</a>'s QUERY without trashing all of his FIND calls, I've put back the ability to FIND a WORD!--specifically--in BLOCK!s for now.  Other evaluative types require to be put in blocks or quoted, etc.</p>
<p>This is all going to take some philosophical reckoning on what the language is and what it's actually trying to achieve... <strong>and I think UPARSE is becoming a really good lens for asking that question.</strong>  It's a pretty amazing piece of usermode code; I think it's probably the most epic language showcase there is so far in the Redbol universe.</p>
<p>Hopefully we can make QUERY be another one.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/13</link>
        <pubDate>Fri, 13 Aug 2021 04:08:00 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-13</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
        <description><![CDATA[
            <p>Looking at it in isolation, the splicing of paths and tuples into blocks looks wrong.</p>
<p>But if it is the right thing to do, then the @-forns look best for appending as-is.</p>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/12</link>
        <pubDate>Wed, 11 Aug 2021 21:34:53 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-12</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Though I understand anyone being skeptical given the amount of debate: <em>I do honestly think I am zeroing in on "an answer" regarding the core ergonomics for things like APPEND</em>.  But it doesn't feel quite there yet.</p>
<p>The biggest point of discomfort relates to what I mentioned about WORD!s, which is proving to be a bigger deal in practice than I first realized:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="1332">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong>The most obvious side-effect is that you won't be able to append WORD!s/PATH!s/etc. without making them quoted.</strong></p>
<pre><code>&gt;&gt; append [a b c] 'd
** Error: evaluative value must be QUOTED! to append
</code></pre>
</blockquote>
</aside>
<p><em>(Remember of course that APPEND is not receiving <strong>'d</strong> in this case.  The <strong>'</strong> suppresses the evaluation and "vaporizes" so that APPEND winds up receiving the <strong>d</strong>.  To get APPEND to receive a QUOTED! value you'd have to have said <strong>''d</strong> or <strong>the 'd</strong> or <strong>just d</strong> or some other such construction.)</em></p>
<p>Of course, we can just say "screw it" and allow it...and be no worse off than history (better, really).  But that's small comfort, as I think history was bad!</p>
<p>Quick refresher:</p>
<pre><code>rebol2&gt;&gt; value: first [d/e]
== d/e
rebol2&gt;&gt; append [a b c] value
== [a b c d e]
     ; ^-- not [a b c d/e]

rebol2&gt;&gt; value: first [(d e)]
== (d e)
rebol2&gt;&gt; append [a b c] value
== [a b c d e]
     ; ^-- not [a b c (d e)]

rebol2&gt;&gt; value: first ['d]
== 'd
rebol2&gt;&gt; append [a b c] value
== [a b c d]
    ; ^-- not for the Ren-C reason... LIT-WORD! decay on WORD!-fetch
rebol2&gt;&gt; append [a b c] first ['d]
== [a b c 'd]
    ; ^-- see what I mean?  yes this is all kinds of ridiculous
</code></pre>
<p><em>(Note: Red at least doesn't do that last one, there is no LIT-WORD! decay on word fetches.)</em></p>
<p>Point being: <strong>I want people to keep in mind just how crappy history was, in understanding why the search for better is worthwhile...especially if it kills off /ONLY.</strong></p>
<h2>Back To the WORD! Pain Point</h2>
<p>Among the places I'm finding it painful to not be able to just pass a WORD!, let's look at FIND.  You'll see code like:</p>
<pre><code>if not find data 'd [append data 'd]
</code></pre>
<p>The readability suffers a bit if you change this to BLOCK!.  In this example in particular, it gets harder to see the branch:</p>
<pre><code>if not find data [d] [append data [d]]
</code></pre>
<p>If you use double quotes it seems confusing:</p>
<pre><code>if not find data ''d [append data ''d]
</code></pre>
<p>It's likely similarly strange to most readers to wonder why you have to "quote twice" when you use the word QUOTE, but it's the generic substitute for /ONLY:</p>
<pre><code>if not find data quote 'd [append data quote 'd]
</code></pre>
<p>And then there's JUST, which reads well but hides a lot of mechanics (it's QUOTE THE):</p>
<pre><code>if not find data just d [append data just d]
</code></pre>
<p>I don't think this is any less learnable than /ONLY when you add it all up, and it has a mechanical rationale behind it.  But there's something else...</p>
<h2>Bigger Problem: What About OBJECT!</h2>
<p>If you take operations like FIND and SELECT they've historically been willing to operate on BLOCK! or OBJECT!.  Should the rules about not taking evaluative types apply to them, too?  :-/</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20]

&gt;&gt; select obj 'a
** Error: SELECT can't take evaluative types, use QUOTED!

&gt;&gt; select obj ''a
== 10

&gt;&gt; select obj [a]
== 10   ; ???
</code></pre>
<p>So that's not good.</p>
<p><strong>But again, on the whole: there are some things going right here with the QUOTED! behavior...and some things going wrong here with the WORD! behavior...so it's important to stop and think.</strong></p>
<h2>One Weird Thought: What About <code>@WORD</code> ?</h2>
<p>Today, the "evaluator inert doesn't need a quote" rule means that the <code>@xxx</code> types--which are inert--append as-is:</p>
<pre><code>&gt;&gt; append [a b c] @d
== [a b c @d]  ; today's behavior, whereas appending a `d` WORD! errors
</code></pre>
<p>But since there are some types like BLOCK! or BLANK! or QUOTED! that are called out as "special" in terms of behavior w.r.t. the likes of APPEND, what if the inert @ types were treated like QUOTED!?</p>
<pre><code>&gt;&gt; append [a b c] @d
== [a b c d]  ; since appending [d] and 'd are special, why not @d too?
</code></pre>
<p>This doesn't really help you if you're trying to append SET-WORD!s or other parts to the block, because there's no <strong><code>@foo:</code></strong> type (for instance).  But in the specific case of words, it helps...and that's the case where we have the issue with object keys.</p>
<p>How far would this go?  Would <code>@word</code> become the universal sign of the key?  Might it be what's offered as the key in FOR-EACH loops?</p>
<pre><code>&gt;&gt; obj: make object! [a: 10 b: 20]
&gt;&gt; for-each [key val] obj [print [mold key mold val]]
@a 10
@b 20
</code></pre>
<p>I'll point out that there are some benefits to these non-evaluative types taking on a bigger role.  When you COMPOSE or use them in the API, plain WORD! can be very inconvenient to handle...you're always having to throw in quotes to suppress their evaluation.  Remember that when you write <strong>'a</strong> you're getting a pass on that being inert for just that one evaluation...whoever receives it still has to treat it as a hot potato.</p>
<p><strong>I'm just throwing out an idea, here.</strong>  But really, I don't know.  I think making QUOTED! types append their quoted argument as-is is a winner, and I believe it's fundamental to Rebol's DNA that BLOCK! splice by default.  Yet I think the safety net of catching evaluative types is a way of saying <em>"oh, you're putting together something that could be CODE!"</em> where you can catch cases where values might be splicing blocks or throwing away their quotes on accident.</p>
<hr>
<p><strong>And of course we can wuss out and just say WORD! is special.</strong>  After all, QUOTED! is an evaluative type and it's given special meaning in APPEND.  (But that is sort of the point--since it has special meaning, we try to protect usages of the other evaluative types from being misinterpreted.)</p>
<p>I don't really think there's any particular value in saying that the <code>@xxx</code> types are uniquely able to be appended as-is since they are inert, so it kind of feels like a nice option to let them mean append themselves minus the <code>@</code>.  However that implies that ^[...] and @[...] would act the same for APPEND... via different mechanisms.</p>
<pre><code>&gt;&gt; append [a b c] @d
== [a b c d]

&gt;&gt; append [a b c] @d/e
== [a b c d/e]

&gt;&gt; append [a b c] @d.e
== [a b c d.e]

&gt;&gt; append [a b c] @(d e)
== [a b c (d e)]

&gt;&gt; append [a b c] @[d e]
== [a b c [d e]]  ; due to internal logic of APPEND with @

&gt;&gt; append [a b c] ^[d e]  ; -&gt; append [a b c] the '[d e]
== [a b c [d e]]  ; due to internal logic of APPEND with QUOTED!
</code></pre>
<h2>Or we can fully wuss out and say there's no protection</h2>
<pre><code>&gt;&gt; append [a b c] 'd
== [a b c d]

&gt;&gt; append [a b c] ''d
== [a b c d]

&gt;&gt; append [a b c] [d]
== [a b c d]

&gt;&gt; append [a b c] '[d]
== [a b c d]

&gt;&gt; append [a b c] ''[d]
== [a b c [d]]

&gt;&gt; append [a b c] quote [d]
== [a b c [d]]

&gt;&gt; append [a b c] ^[d]
== [a b c [d]]
</code></pre>
<p>But I think this should be considered carefully.</p>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/11</link>
        <pubDate>Tue, 10 Aug 2021 23:55:04 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-11</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="hostilefork" data-post="1" data-topic="1332">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>...so it's time to take what's known and tie it all up.</p>
</blockquote>
</aside>
<p>It took another 6 months, but I think this is now actually ready to be tied up.</p>
<ul>
<li>
<p>BLOCK! splices by default</p>
</li>
<li>
<p><a href="https://forum.rebol.info/t/should-append-null-fail-append-blank-add-nothing-unless-only/635/9">BLANK! appends nothing, and appending NULL errors</a></p>
</li>
<li>
<p>All other <em>inert</em> types append as-is</p>
</li>
<li>
<p>QUOTED! will remove a quote level and append</p>
</li>
<li>
<p>Evaluative types which are not quoted will error when you append them, telling you to quote them</p>
</li>
</ul>
<p>In the same vein as what I was suggesting before, ^ is the answer for "anti-splicers".  However it now fits in with a generalized quoting mechanic, and modal parameters are no longer a thing (in the core, at least).</p>
<p><strong>The most obvious side-effect is that you won't be able to append WORD!s/PATH!s/etc. without making them quoted.</strong></p>
<pre><code>&gt;&gt; append [a b c] 'd
** Error: evaluative value must be QUOTED! to append
</code></pre>
<p>You have your pick of how to deal with this.  If it's literal, you could always put it in a block:</p>
<pre><code>&gt;&gt; append [a b c] [d]
[a b c d]
</code></pre>
<p>If it's in a variable, you could quote it:</p>
<pre><code>&gt;&gt; var: first [d]

&gt;&gt; append [a b c] quote var
== [a b c d]
</code></pre>
<p>And of course, there's the ^ operator...which is like QUOTE, but has some more subtlety (e.g. NULL =&gt; NULL and not quoted null (just '), and special handling of BAD-WORD! in a similar vein)</p>
<pre><code>&gt;&gt; append [a b c] ^var
== [a b c d]
</code></pre>
<p>Using the standalone operator is also possible, but it's meant for expressions:</p>
<pre><code>&gt;&gt; append [a b c] ^ var
== [a b c d]

&gt;&gt; append [a b c] ^ first [d]
== [a b c d]
</code></pre>
<p><strong>I'm on the fence about what to do with GROUP!</strong>.  Since they are evaluative I'm thinking that converting them to a BLOCK! to append makes the most sense.</p>
<p>So a few details to hash out, I guess we can let experience guide.  But in terms of the big picture, I feel it in my bones that no better answer is coming.</p>
<blockquote>
<p>UPDATE July 2022:</p>
<p><em>"I feel it in my bones that no better answer is coming."</em></p>
<p>That was probably just gout.  Better answer has arrived.</p>
</blockquote>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/8</link>
        <pubDate>Thu, 13 May 2021 10:12:34 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-8</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>A while ago, <a href="https://forum.rebol.info/t/make-splicing-by-default-only-apply-when-appending-a-block/226/7">@IngoHohmann made a sensible-sounding suggestion</a>:</p>
<aside class="quote no-group" data-username="IngoHohmann" data-post="7" data-topic="226">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"><a href="https://forum.rebol.info/t/make-splicing-by-default-only-apply-when-appending-a-block/226/7">Make Splicing by default only apply when appending a BLOCK!</a>
</div>
<blockquote>
<p>Well these days to splice or not to splice could be controlled with quoted-, get-, set- variants.</p>
</blockquote>
</aside>
<p>I pointed out that unfortunately this wouldn't have the desired behavior at the callsites... because the evaluation of the parameter would strip the quote off before APPEND saw it:</p>
<pre><code>&gt;&gt; '[d e]
== [d e]

&gt;&gt; append [a b c] '[d e]
== [a b c d e]
</code></pre>
<p>For APPEND to "see the tick", it would have to change its parameter convention to take its argument literally...which is not desirable...or you have to use a function that adds it:</p>
<pre><code>&gt;&gt; quote [d e]
== '[d e]

&gt;&gt; append [a b c] quote [d e]
== [a b c [d e]]
</code></pre>
<h2>You Could Ask: "So What?"</h2>
<p>We've been expressing a willingness to use an ONLY operator to signal an intent to add things "as is":</p>
<pre><code>&gt;&gt; only [d e]
== [[d e]]

&gt;&gt; append [a b c] only [d e] 
== [a b c [d e]]
</code></pre>
<p>But optimizing that to an extreme would be hard, and weird.  The more I look at it, the more reluctant I am to push the optimizations to the point of not using a series node.  e.g. the "one series node" optimization is about as far as I may feel comfortable pushing ONLY.</p>
<p>On the other hand...generic quoting is already written, and systemically optimized, even to multiple levels (up to 3)...and does no allocations.  And QUOTE will be something users are already familiar with.</p>
<p>Plus, you at least have the option when writing expert-optimized code to use the learnable idiom of two ticks when you have a literal:</p>
<pre><code>&gt;&gt; append [a b c] ''[d e]
== [a b c [d e]]
</code></pre>
<h2>Ok, But, It Makes QUOTED! Another Interfered-With Type <img src="https://forum.rebol.info/images/emoji/twitter/frowning.png?v=9" title=":frowning:" class="emoji" alt=":frowning:">
</h2>
<p>Let's say you're running through a block of items that contains quoted things and want to append them somewhere...you've now got another type that APPEND chooses to muck with if you don't say /ONLY or QUOTE:</p>
<pre><code>data1: [1 2 &lt;skipme&gt; x y 'z]
data2: []

for-each item data1 [
    if not tag? item [
        append data2 item
    ]
]

&gt;&gt; data2
== [1 2 x y z]  ; oops, 'z got turned into plain z
</code></pre>
<p>Still.. <em>what happened to <strong>'z</strong> would have just as easily happened to <strong>[z]</strong>.</em>  So how much worse is losing of a level of quote than losing the containership of a block?</p>
<p>Rebol2 messed with your BLOCK!s, GROUP!s and ANY-PATH!s if you forgot to say /ONLY.  Now it would mess with your BLOCK!s and your QUOTED!s.</p>
<p><strong>I'm not in love with this aspect...but just pointing out that there's been no perfect answer to the problem, yet.</strong>  So having an imperfect property doesn't rule something out automatically.</p>
<h2>Main Point: Stepping Back From The Abyss of Optimization...</h2>
<p>Using the sunk cost of work on QUOTED! vs. making a "magic" kind of block came to me while thinking about something related.</p>
<p>Imagine you have a function that takes actions to run, and you want to pass that something that just returns a constant value.</p>
<p>One way to do this today is to make a specialization of the IDENTITY function:</p>
<pre><code>&gt;&gt; three: specialize :identity [value: 3]

&gt;&gt; type of :three
== #[action!]

&gt;&gt; three
== 3
</code></pre>
<p>But it feels a shame for such an action to take up more space and load the GC than just the simple number 3 would take.  So we can imagine an overlaying cell formats, and how to "lie" about being an ACTION! when the cell is really an INTEGER!.</p>
<p><em>But oh what a tangled web we weave...</em> trying to engineer this deception has so many problems it becomes hard to count them all.  You can set meta information on actions, but this integer-action has no place to put it.  If you convert it to a real ACTION! on demand, then each such conversion would get a new identity...putting the inefficiencies aside, that's a semantic problem because actions are expected to have individual identities, and these just don't.</p>
<p><strong>It would be much simpler if you had written the routine that was willing to take an action to also take a QUOTED!</strong>.</p>
<p>This makes a good argument for why QUOTED!s should answer to the same questions that an action might...just minus that one lie of "I am an action!"</p>
<pre><code>&gt;&gt; a: func [] [return just x]
&gt;&gt; q: just 'x

&gt;&gt; do :a
== x

&gt;&gt; do :q  ; colon not needed, but shows same flow as when using an action
== x

&gt;&gt; parameters of :a
== []

&gt;&gt; parameters of :q
== []
</code></pre>
<p>I guess the point I'm trying to make is that while it might seem a bit dissatisfying to have to handle a QUOTED! or an ACTION!, it seems that the places where you would have actual trouble with it is anywhere such methods don't make sense...and those points are exactly where a "fake" optimized action would break down.</p>
<p>This line of thinking took me to where I thought that making an optimized BLOCK! that doesn't have the implementation character of a BLOCK! (e.g. a series node) is a mistake in a similar vein.  If you demand this particular axis of efficiency, you should use the systemic mechanism of a QUOTED! to get it...or say it's not worth it.</p>
<h2>So Does Mucking Up QUOTED!s Beat the /ONLY Option?</h2>
<p>I'm not feeling convinced.</p>
<p>The only thing I think I've convinced myself of is that the fake no-node block trick I was considering is bad for the health of the system.  We are making 1-element blocks somewhat efficiently, but they're not free.  So I wanted to write up the thinking behind that...and share the rest in case it triggered any brainstorms.</p>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/15">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/15</link>
        <pubDate>Sun, 10 Jan 2021 16:27:15 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-15</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1332">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<h2>BLOCK!s (and only plain BLOCK!s) Splice By Default</h2>
<p>This is to say that BLOCK! is <em>The</em> universal container (<strong>"[o]"</strong>).</p>
</blockquote>
</aside>
<p>Let me mention another implication here, that wasn't explicitly stated, but follows naturally.</p>
<p>When we're trying to define what <strong>append string block</strong> means, it has to be the same as appending the elements one at a time.</p>
<pre><code>block: [&lt;&lt;items&gt;&gt;]
append "abc" block

=&gt;

append/only "abc" first block
append/only "abc" second block
....
append/only "abc" last block
</code></pre>
<p><strong>...but this doesn't say anything about what <em>APPEND/ONLY</em> of a BLOCK! to a string means.</strong></p>
<p>It just tells us that <strong>append "abc" ["d" "e"]</strong> should not be <strong>"abcd e"</strong> or similar.  Because we're never appending a block to a string, we're only invoking the containership.</p>
<p>Yet when we actually <em>do</em> append a block to a string, we could change the behavior:  Rebol2 did so, by FORM-ing:</p>
<pre><code>rebol2&gt;&gt; append "abc" ["d" "e"]
== "abcde"

rebol2&gt;&gt; append "abc" [["d" "e"]]
== "abcd e"
</code></pre>
<p>But if this is so, it should be what you get with /ONLY, which Rebol2 did <em>not</em> do:</p>
<pre><code>rebol2&gt;&gt; append/only "abc" ["d" "e"]
== "abcde"
</code></pre>
<h2>With Rules In Place, How Do We Get Actual Benefit?</h2>
<p>Now we know that <strong>blocks are the only splicing type</strong> and <strong>using /only is the same as if the input were in a block of length 1</strong>...</p>
<p>...this gives us guidance on our degrees of freedom, e.g. we might say GROUP!s are different and don't FORM:</p>
<pre><code>&gt;&gt; append "abc" [["d" "e"] ("f" "g")]
== "abcd efg"
</code></pre>
<p>We <em>can</em> say that.  <em>But what gives actual benefit?</em>  If blocks are divergent between top-level block behavior and how they act one at a time, it's confusing.</p>
<p>Brainstorming here for a moment...but what if we reversed that, so BLOCK! acted the same if it was splicing or not, but GROUP! would space things out?</p>
<pre><code>&gt;&gt; append "abc" '("d" "e")
== "abcd e"

&gt;&gt; append "abc" ["d" "e"]
== "abcde"

&gt;&gt; append "abc" [["d" "e"] ("f" "g")]
== "abcdef g" 
</code></pre>
<p>That doesn't seem quite as useful as if GROUP! appending gave you a leading space.  What would that look like?</p>
<pre><code>&gt;&gt; append "" '("x" "y")  ; base case, don't add leading space
== "x y"

&gt;&gt; append "abc" '("d" "e")  ; content already, so add leading space
== "abc d e"

&gt;&gt; append "abc" ["d" "e"]
== "abcde"

&gt;&gt; append "abc" [["d" "e"] ("f" "g")]
== "abcde f g" 
</code></pre>
<p>Now we're seeing something less confusing, that's shaping up to be more useful and consistent.</p>
<p>But GROUP! is probably the wrong type for this distinction.  PRINT uses GROUP! to calculate data and throw the intermediate results away.  Maybe a different type of BLOCK! would be better.  GET-BLOCK! perhaps?</p>
<pre><code>&gt;&gt; append "abc" [["d" "e"] :["f" "g"]]
== "abcde f g" 
</code></pre>
<p>Not everything has to have a behavior, and probably should not.  Maybe GROUP!s evaluative bias means it simply shouldn't be allowed to be added to strings...that it's likely a mistake.</p>
<p><strong>This seems to point in the direction of greater usefulness and explainability.</strong>  Thoughts welcome.</p>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/7</link>
        <pubDate>Wed, 11 Nov 2020 08:26:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-7</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[giuliolunati]]></dc:creator>
        <description><![CDATA[
            <p>It's  fine for me!<br>
(some more chars)</p>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/6">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/6</link>
        <pubDate>Thu, 24 Sep 2020 21:16:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-6</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="1" data-topic="1332">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Anyway, this name looks like the only missing piece. What do you call something that doesn't do any memory allocation but just makes a light 1-element wrapper that can live in a cell, to keep us from having to add more crazy refinements?</p>
</blockquote>
</aside>
<p>Following this all through in the code, I'm pleased with the very clear definition...that has a philosophical basis now:</p>
<pre><code>append block :value 
; ^-- appends 0 items if value is null, 1 item if not a block, or N if block
</code></pre>
<p>It's rigid, it's clear.  You have an easy test of <code>block? :value</code> for knowing if you're dealing with the universal container.  If you want to append it as-is, use <code>append/only</code> or <code>@value</code>.</p>
<h2>Clarity Disappears If You Use TO BLOCK!</h2>
<p>Let's put aside AS for a moment.  As pleasing as the above is, you're quickly into the danger zone once you write:</p>
<pre><code>either block? :value [
    append block value  ; add itemwise
][
    append block to block! :value
]
</code></pre>
<p>The spectrum of meanings for TO BLOCK! value is currently so variant that this is nigh-unknowable if you don't know what type value is.</p>
<p>But one thing is clear...it doesn't make a whole lot of sense to have your TO BLOCK! of a value just wrap that value in a block.  You can do that with <code>reduce [value]</code>...it's a poor use for TO (and if you want blocks left as is, you can use <code>blockify value</code>).</p>
<p>I'd go so far as to say that it's so bad that <strong>no data type should define its TO BLOCK! conversion as simply putting the item in a block</strong>.  That's just a way of saying <em>"I can't meaningfully be expressed as a BLOCK!"</em>.  If that's the case, the conversion should be an error.</p>
<pre><code>rebol2&gt;&gt; to block! [12-Dec-2012]
== [12-Dec-2012]  ; I think we can now say that this is "clearly bad"
</code></pre>
<p>There are likely some other good rules for what TO BLOCK! would do.  e.g. FOR-EACH on your item should give back individual things that match.  So this looks inconsistent to me:</p>
<pre><code>rebol2&gt;&gt; collect [foreach ch "ab cd" [keep ch]]
== [#"a" #"b" #" " #"c" #"d"]

rebol2&gt;&gt; to block! "ab cd"
== [ab cd]  ; e.g. it was transcoded
</code></pre>
<p>That TO BLOCK! is much more obvious if you just say <strong>transcode "ab cd"</strong>.  So I think the FOREACH result should be the TO BLOCK! result.   (This aligns with how I've been talking about how TO BLOCK! of a string giving back individual CHAR!s would be handy if you are dealing with some kind of string algorithm for which fixed-size codepoint manipulation would be useful.)</p>
<h2>My proposal for AS is an efficient alternative to TO</h2>
<p>The goal of AS is to produce something that doesn't <em>necessarily</em> have its own identity (if it can avoid it) but otherwise should act the same as TO.</p>
<p>This means you could do some kind of surgery to build a BLOCK! you don't need for anything else, and then <strong>as path!</strong> it.  Even though PATH! is no longer in the ANY-ARRAY! typeclass (not always guaranteed to have an array under the hood), the system would take advantage of it (since it can in this case) and the path would co-opt the series internally.</p>
<p>But...</p>
<aside class="quote no-group" data-post="1" data-topic="1332">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But maybe AS can wing it, and say that if you give it a non-block it can just do the wrapping in a block anyway and give you something read-only? :-/ I mean, the user doesn't know that every single-valued item doesn't secretly live in a 1-element array in the implementation...it might. Hmmm.</p>
</blockquote>
</aside>
<p>If AS is just a compatibility for TO, then I've suggested this behavior of falling back on blocks if you don't know what else to do is not cool.</p>
<p>Point is that we have to use a lot of imagination to know what the heck someone means if they write:</p>
<pre><code>append block as block! some-completely-random-value
</code></pre>
<p>The value might be a DATE! or an INTEGER! or a GROUP! or a PATH! or who-knows-what.  I'm not sure where in the code anyone should be writing this and expecting it to "just work".</p>
<p>So I think the example is just flawed by design.  You shouldn't see code like this.  Instead you should see things that look more like:</p>
<pre><code>append block switch type of value [
    path! [to block! value]  ; don't try to use internal sharing optimization 
    group! [as block! value]  ; do use internal sharing
    date! [compose [the-date: (value) {adds 3 items}]]
] else [
    value  ; append as-is
]
</code></pre>
<p>This gets rid of having to have a cheap way to put an item in a block, just to conform weird values to the "Promise me you're making a block" protocol.  I think that is just a red herring.</p>
<p>I'm really liking how this is laid out with the single unambiguous point of control on splicing.  BLOCK!-or-not.  Again...its simplicity makes it something you can leverage vs. fight against!</p>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/4</link>
        <pubDate>Sun, 20 Sep 2020 20:46:46 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-4</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="2" data-topic="1332">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>Imo all is open for improvement with the proper argumentation.</p>
</blockquote>
</aside>
<p>In some sense, all of life is "storytelling" in one form or another.  So a lot of this deep consideration is really about "having a story".</p>
<p>When people show up and ask why something is the way it is, it's important to be able to tell that story and have it be something that they can put in their mind and be comfortable with.  I think due diligence has been done here, and no one can say alternatives weren't given a shot.</p>
<aside class="quote no-group" data-post="2" data-topic="1332">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>I think I like where this is leading to</p>
</blockquote>
</aside>
<p>I'll point out that it's not just about the endgame.  While it may seem like nothing is accomplished by spinning one's wheels trying to change things like this back and forth over years, that overlooks all the enhancements that came in that process.</p>
<aside class="quote no-group" data-post="2" data-topic="1332">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/iarnold/40/226_2.png" class="avatar"> iArnold:</div>
<blockquote>
<p>Another name for BLOCKIFY could perhaps be BLOCKSET, ASBLOCK, TOBLOCK.</p>
</blockquote>
</aside>
<p>I want to avoid "TO" usages in contexts like this because I'm pretty sure all "TO" operations need to make a new series.</p>
<pre><code>&gt;&gt; input: '(a b c)  ; note: remember that Rebol2 INPUT is now `ASK TEXT!`

&gt;&gt; output: to block! input
== [a b c]

&gt;&gt; append input [d e f]
== [a b c d e f]

&gt;&gt; output
== [a b c]  ; not changed when original is changed
</code></pre>
<p>What we're looking for here would be more like what AS does; it's just a question of how much sense it makes to be able to say <code>as block! 1</code></p>
<p>I've been thinking about the techniques for AS BLOCK!  giving back [] as an immutable block that lives in a single cell...and it's a little bit tricky in the implementation because the cell has no room for an index.  So if you say something like <strong>foo-next: next as block! </strong> then there has to be some magic.</p>
<p>I think the magic is that it uses a single bit in the cell to indicate whether it's at the head or the tail, and if you try to step outside of that boundary then you wind up triggering an allocation of a read-only 1-element array that gets put into an actual cell.  This would mean you'd get a lot of those with:</p>
<pre><code>pos: as block! &lt;foo&gt;
pos2: skip pos 2
pos3: skip pos 3
pos4: skip pos 4
...</code></pre>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/3</link>
        <pubDate>Sun, 20 Sep 2020 12:54:07 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-3</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[iArnold]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-post="1" data-topic="1332">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>append [a b c] force block! value</p>
</blockquote>
</aside>
<p>It is a kind of CAST that you want to do here. Could call this FORGE. Other suggestions FABRICATE (too long) HATCH, CRAFT (I like that), FEIGN, FIDDLE.</p>
<aside class="quote no-group" data-post="1" data-topic="1332">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I was pretty sure <em>"do whatever Rebol2 did"</em> was not a good idea</p>
</blockquote>
</aside>
<p>Do as R2 did, is a good starting point. Many things have been looked at with a refreshing mindset. Though a lot of things have grown to become as they are, which is not always as consistent or well-thought out. Imo all is open for improvement with the proper argumentation.</p>
<p>I think I like where this is leading to and being able to do without the /ONLY to append a block! as a block! to another block! is pretty cool. I have had many occasions where I forgot the /ONLY and having the @ notation to signal the /ONLY purpose is fine for me.</p>
<p>Another name for BLOCKIFY could perhaps be BLOCKSET, ASBLOCK, TOBLOCK.</p>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/2</link>
        <pubDate>Sun, 20 Sep 2020 08:22:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-2</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
      <item>
        <title>Every Thought On Array Splicing Has Been Had :exploding_head:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <blockquote>
<p>Important Updated Response to the topic of this 2020 Post:</p>
<p><strong>Nope.  I was wrong.  <a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">Quoting levels of -1</a> was a thought that hadn't been had in September 2020.</strong></p>
<p><em>(Because <a href="https://forum.rebol.info/t/multiple-returns-and-branching-could-it-unseat-voidification/1408">isotopes in their most primitive form weren't proposed until November 2020</a>, and it took some time before ^META conventions were laid out.)</em></p>
<p>Just goes to show you... there's always room for more insights.  You can ignore this post unless you want to go down some historical dead ends...</p>
</blockquote>
<hr>
<p>Here's what we "know"...</p>
<h2>
<a name="blocks-and-only-plain-blocks-splice-by-default-1" class="anchor" href="https://forum.rebol.info#blocks-and-only-plain-blocks-splice-by-default-1"></a>BLOCK!s (and only plain BLOCK!s) Splice By Default</h2>
<p>This is to say that BLOCK! is <em>The</em> universal container (<strong>"[o]"</strong>).  Splicing of the contents of a non-block is done by aliasing it as a block first...which can be done efficiently without copying memory.</p>
<p>It was always obvious to me that PATH!s should not splice.  But I didn't have any real guidance on GROUP!, or the new types like SET/GET-BLOCK!/GROUP! (and whatever <strong>@[block]</strong> or <strong>@(group)</strong> ultimately gets called).  It was a toss up between <em>"anything that uses spaces to separate elements splice, and anything tighter--like tuples/paths--not"</em> vs. <em>"the logo is [o], so anything with brackets is special"</em> (I was pretty sure <em>"do whatever Rebol2 did"</em> was not a good idea).</p>
<p>But I think there's a better narrative for justifying this solution.  Looking at other languages like Haskell/Rust/Elm, they all used parentheses for tuples...where their notion of a tuple is fixed-size with elements that aren't necessarily of the same type.  This led me to think about the question of if BLOCK!'s universal containerness might make it something you don't just pick automatically...you'd pick something else when splicing wasn't what you'd <em>typically</em> want.</p>
<p>Here's a made-up example:</p>
<pre><code>add-new-products: func [product-list: [block!]] [
    product1: '(#WID-0304 "Super Widget" $1.99)
    product2: '(#WID-1020 "Super Widget Plus" $2.00)

    append product-list product1
    append product-list product2
    append product-list [
        (#WID-0421 "Super Widget Premium" $2.01)
        (#WID-9999 "Super Widget Ultimate" $102,003.04)
    ]
]
</code></pre>
<p>See how light the generic quoting made the GROUP! literals?  Now this makes the choice of BLOCK! vs. GROUP! something that you can reason about better.  You can take advantage of the difference so you're not fighting the behavior--but "synergizing" with it.</p>
<p>But also...with <strong>@[...]</strong>/etc that doesn't splice, you have more options for shifting your data's conception of itself as it is passed around.</p>
<p>I'll point out that since there's no @ or : in the logo, this does ultimately dovetail nicely with "what's in the logo is special"...it's not just any bracketed thing, it's plain BLOCK!.   <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=12" title=":slight_smile:" class="emoji" alt=":slight_smile:" loading="lazy" width="20" height="20"></p>
<h2>
<a name="modal-parametershttpsforumrebolinfotnew-parameter-convention-concept-modal-arguments-or-the-arg1187-are-the-answer-for-anti-splicers-2" class="anchor" href="https://forum.rebol.info#modal-parametershttpsforumrebolinfotnew-parameter-convention-concept-modal-arguments-or-the-arg1187-are-the-answer-for-anti-splicers-2"></a><a href="https://forum.rebol.info/t/new-parameter-convention-concept-modal-arguments-or-the-arg/1187">"Modal Parameters"</a> are the Answer for Anti-Splicers</h2>
<p>I've been trying to embrace <a class="mention" href="https://forum.rebol.info/u/rgchris">@rgchris</a>'s concept that the language bias should stick to making it so that "common" code does not lean too strongly on symbols to convey meaning.  While you can retrain yourself to comprehend pretty much any symbol soup, letting your mindset drift to that "new normal" isn't good for communicating code to others.  <em>(And it's probably not good for your own ability to see clearly, either...even if you -think- you understand what you're doing.)</em></p>
<p>This has to be balanced against many other design factors; to which I'm sensitive because I actually understand what it takes to make things <em>work</em> at a mechanical bits-and-bytes level.  So this pushes back and forth.</p>
<p>Modal parameters give an easy mechanism to library authors, or others who want a rigorous way to append values "as is" without typing /only at every callsite.</p>
<pre><code>&gt;&gt; append [a b c] @[d e]
== [a b c [d e]]

&gt;&gt; item: @[d e]
&gt;&gt; append [a b c] item
== [a b c @[d e]]  ; modality comes from parameter, not fetched value

&gt;&gt; append [a b c] '@[d e]
== [a b c @[d e]]  ; quoting suppresses modality, then evaluates away

 &gt;&gt; do compose [append [a b c] '(third [&lt;d&gt; #e @[f g]])]
 == [a b c @[f g]]  ; quoting in COMPOSE is there to help in cases like this
</code></pre>
<p>It's not something that has to be brought up in early tutorials.  But I like it.  And it's a generic mechanism that people can use when they want a parameter to indicate the mode of a refinement...so there's generic uses for it.</p>
<h2>
<a name="further-changes-to-append-and-such-will-be-abandoned-3" class="anchor" href="https://forum.rebol.info#further-changes-to-append-and-such-will-be-abandoned-3"></a>Further changes to APPEND and such will be abandoned</h2>
<p>I experimented with making APPEND only accept blocks, and then maybe blocks and strings, and other kinds of tweaks.  They weren't worth it.</p>
<p>What's changing the game here is making BLOCK! the only type that splices by default.</p>
<p>It used to be that when you had a moment of doing an append of some parameter--that wasn't a block before but suddenly is now--you groaned and said <em>"why'd I forget the /ONLY"</em> or <em>"why does this darn thing behave so randomly"</em>.</p>
<p>Now a new thing you can ask in many of these moments is: <em><strong>"Why was this value a plain block if I didn't want it to splice??"</strong></em>  It should feel less random, when you have more alternatives.  I'm going to look at my array choices in this new light, and maybe need /ONLY less often as a result.</p>
<p>Modal parameters are good to have to point people to who aren't on board with splice-by-default.  And I'm willing to accept the burden of using a modal parameter to enter an @ symbol when I want it.  It saves significant evaluation time over APPEND/ONLY, and doesn't require a series node allocation to hold the APPEND and ONLY words.</p>
<h2>
<a name="block-conversions-needed-4" class="anchor" href="https://forum.rebol.info#block-conversions-needed-4"></a>BLOCK! Conversions Needed</h2>
<p>Because the only way to get splicing is now to have a block, it raises the question of how to get blocks.</p>
<p>AS BLOCK! is cheap; it doesn't allocate any memory, it just aliases the series as a different cell class.  So it's a good choice if you know what you have is an array.</p>
<pre><code>&gt;&gt; group: '(d e f)
&gt;&gt; append [a b c] as block! group
== [a b c d e f]
</code></pre>
<p>If you don't know if you have an array value or not, this is a little harder.  But we can actually turn items into a one-cell BLOCK! <em>without allocating any memory</em>.  This is a new trick which was called mirroring, but the mechanism is changed to where it needs a new name.  The new block is read only, but that is okay for the purposes of this append since it's gone after the splice.</p>
<p>The name for the operation I had in mind was BLOCKIFY (though it's not using the mirroring mechanism at the moment, only the PATH! trick is, which proves it does work).</p>
<pre><code>&gt;&gt; value: '(d e f)
&gt;&gt; append [a b c] blockify value  ; [d e f]
== [a b c d e f]

&gt;&gt; value: 1020
&gt;&gt; append [a b c] blockify value  ; [1]
== 1020
</code></pre>
<p>But that's a weird looking word, and I hate having to have lists of things like this (groupify?  set-groupify?)  The concept from the other day of FORCE might be interesting</p>
<pre><code>append [a b c] force block! value
</code></pre>
<p>That's at least generic, and it kind of conveys "I want a block, if it's a block then great, if not then change it".  But that makes it sound like its <em>changing</em> the input value to be a block, vs. wrapping it.</p>
<p>But maybe AS can wing it, and say that if you give it a non-block it can just do the wrapping in a block anyway and give you something read-only?  :-/  I mean, the user doesn't know that every single-valued item doesn't secretly live in a 1-element array in the implementation...it might.  Hmmm.</p>
<p>Anyway, this name looks like the only missing piece.  What do you call something that doesn't do any memory allocation but just makes a light 1-element wrapper that can live in a cell, to keep us from having to add more crazy refinements?</p>
<p>It's not a super high priority as most cases are known to be AS (in the form known today)</p>
<h2>
<a name="speak-up-or-hold-your-peace-5" class="anchor" href="https://forum.rebol.info#speak-up-or-hold-your-peace-5"></a>Speak Up or Hold Your Peace</h2>
<p>Like I say, I think I've probably had all the thoughts.  There aren't any more to be had.  If you want to prove me wrong, post it here...but do it soon.</p>
          <p><a href="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332/1</link>
        <pubDate>Sat, 19 Sep 2020 21:02:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1332-1</guid>
        <source url="https://forum.rebol.info/t/every-thought-on-array-splicing-has-been-had/1332.rss">Every Thought On Array Splicing Has Been Had :exploding_head:</source>
      </item>
  </channel>
</rss>

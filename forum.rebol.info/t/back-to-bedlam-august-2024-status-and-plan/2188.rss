<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Back to Bedlam: August 2024 Status and...Plan? :confused:</title>
    <link>https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188</link>
    <description>&gt; So Ren-C had a pretty exciting first 3 months of 2024, and then started to drop off, until I wasn&#39;t working on it at all.
&gt;
&gt; I&#39;ll try and sum up what&#39;s gone on, and where things might realistically go from here.

---

# Rapid Development: January âž¡ March

### Binding Paradigm Shift

The [arrival of @bradrn](https://forum.rebol.info/t/bradrn-brad/2088) who had been investigating &quot;R&quot; directed attention back to the central language issue of how binding works at all (if it can be made to work).  This prioritized revisiting &quot;Pure Virtual Binding&quot; with fresh eyes: **[Pure Virtual Binding II](https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/9?u=hostilefork)**

I feel the premises are sound.  But if you buy into the methodology, then there are many consequences that will seem more alien than usual to historical Rebol programmers.  BLOCK!s are not inert in the evaluator, but rather evaluate to a version of the BLOCK! with binding applied... so **`(blk: [a b c])`** is distinct from **`(blk: &#39;[a b c])`** where the latter uses quoting to suppress the evaluation.  And since quoting suppresses any binding, **`(x: 10, y: get &#39;x)`** won&#39;t work because the **`&#39;x`** term drops the quote and stays unbound, meaning you have to use the new VAR-WORD! type and write **`(x: 10, y: get $x)`**.

*The epicycles of this new world touch every aspect of the design*--forcing &quot;binding awareness&quot; to the forefront of dialect authors and casual users.  I wish there were an easier answer, but &quot;implicitly paste unique binding pointers on words in waves&quot; is being proven to be non-composable sufficiently well by other Redbol implementations.  It doesn&#39;t work meaningfully, so they simply write anything non-trivial as C or Red/System.

I managed to get the system to run well enough to research the design.  It is very half-baked, and every few minutes I work with it triggers the need for a new meditation in the [Binding category](https://forum.rebol.info/c/development/binding/49).  But as a positive sign, the new model made it possible to add a LET combinator to UPARSE, and there are other longstanding problems that get solved.

### Isotopes Shape Up More Clearly

We now use a more consistent terminology where things like null are called [&quot;antiforms&quot; instead of &quot;isotopes&quot;](https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005/9?u=hostilefork) (e.g. the null antiform is one of the three isotopes of the WORD! **null**).

Some other shuffles were made, like saying that [void is the antiform word of **~void~**](https://forum.rebol.info/t/why-shouldnt-void-be-done-with-a-void-word-antiform/2160), and flipping [&quot;trash&quot; to the antiform of BLANK!](https://forum.rebol.info/t/why-trash-is-the-name-for-unset-state/2078).  This was based on the realization that there wasn&#39;t really all that much value in trying to make voids some special magic type that wasn&#39;t an antiform and couldn&#39;t be put in blocks, just so its quoted form could be a lone apostrophe.

### Breaking Through the 64 Fundamental Types Barrier

Since the dawn of Rebol, the use of a 64-bit bitflag for type checking has meant there can be only 64 types.  We need more, and fully generalized typechecking wants to be able to test not just for fundamental types but also for predicates (like if something is EVEN? vs. just if it&#39;s an INTEGER!).

To keep the system from slowing down to a glacial pace by type checking through function calls, [I hacked together an implementation of what I called &quot;intrinsics&quot;](https://forum.rebol.info/t/intrinsics-functions-without-frames/2050).  These functions are faster to call than ordinary natives, helping make type checking faster, but also other simple function calls.

### The New SIGIL! Type

For a while there was a concept of tolerating &quot;Weird Words&quot; (e.g. with spaces in them) by putting them in vertical bars, **`|like this|`**.  That allowed a few new interesting &quot;plain WORD!s&quot; like **`::`** to exist because you could accomplish their &quot;weird&quot; forms with vertical bars like a SET-WORD! form as **`|::|:`**.

This turned out to be a bad idea.  So I simplified with [a new type called the SIGIL!](https://github.com/metaeducation/ren-c/blob/master/tests/datatypes/sigil.test.reb)... with one for each decoration you could put on WORD!s and arrays.  These SIGIL!s only have a plain form, and have baked in evaluator behavior.  This also solves a problem elegantly, where you can write code like **`(x: &#39;$abc, if &#39;$ = sigil of x [...])`**

### API Antiform Splicing Solved

Having the `@` symbol be a SIGIL! with built-in evaluator behavior finessed another longstanding problem that having it be a WORD! bound to a reassignable function couldn&#39;t do, which was to reconstruct antiforms in API splices, e.g.:

    Value* val = rebValue(&quot;~true~&quot;);  // quasiform evaluates to antiform (logic)

    // rebElide(&quot;if&quot;, val, &quot;[print {Error: no antiforms in source code blocks}]&quot;);

    rebElide(&quot;if @&quot;, val, &quot;[print {Special loophole for @ makes this work}]&quot;);

The @ sigil can be given a special baked-in behavior--specific to the API--allowing it to preserve and reconstitute the antiform state.  This helps bridge the fact that `val` above isn&#39;t a Rebol WORD!, but a C variable, but still give the indirection that a word would have.  *(Note that splicing antiforms as quasiforms would be too permissive, because you can&#39;t be certain that your splices are in code that is evaluative... it would be like saying **`compose [1 (null) 2]`** gives you **`[1 ~null~ 2]`** instead of raising the intended error.)*

Resolving this major sticking point in the API was a big relief.

### String Interpolation Solved?

Whenever you are passing around a BLOCK! you may be passing along its environment, to which it holds a permanent reference (preventing that environment from GC&#39;ing).  But even more costly would be if every string had to carry around an environment...which also meant anyone you passed a string to gets access to environments that may have incidentally been put on that string.

The solution seems a bit obvious in retrospect: if you want to do interpolation on a string, [put it in something like a BLOCK!](https://forum.rebol.info/t/could-strings-have-context/587/27?u=hostilefork).  Like I say, *&quot;a lot better than starting to worry about having to quote your strings to suppress binding!&quot;*

---

# April : Things Start to Stall

### Coming to Terms with FENCE! and Brace Incompatibility

For the past few years I&#39;d been second-guessing the idea that plain braces should be used for strings, and that they should instead be another array type called FENCE!.  Comparing Rebol to the JSON it inspired made it seem like a thing that [once seen could not be unseen](https://forum.rebol.info/t/json-envy-serialization-dialect-in-rebol/2140/2?u=hostilefork).

Thinking through the natural alternatives for string representation made me think there could be an asymmetric pair of delimiters made by **`-{`** and **`}-`**.  Not only that, the pattern could be extended with more dashes.

     obj: {x: 10, y: &quot;obj would be an object now&quot;}

     print -{Hello new string &quot;World&quot;}-

     print -{Hello single } brace-containing string}-
     
     print --{Hello compound }- brace-containing double dash string}--

It might seem this would be a relatively simple-to-implement change compared to something like binding.  But it threw a wrench into things for many reasons:

* Historical binding was always complete garbage, whereas single-braced strings were actually touted as a pleasing aspect of the language (including by me).

* This would be the first truly non-backwards-compatible LOAD change to Ren-C, meaning that either some special way to signal which interpretation would be needed, or the work in the Rebol2 compatibility module would go to waste.

    * The idea of a single simple-switch covering this narrow issue always raises the question of whether you want a more generalized hook that you can give before loading.  Red offers such a thing as `system/lexer/pre-load` which is just a function that transform source UTF-8 before you load it, [though claims it should not be abused](https://www.red-lang.org/2019/11/editorial-brief-essay-on-lexical.html)

    * While I thought I could hack through a prototype with a kind of pre-load functionality using the existing bootstrap executable, trying to pre-empt the LOAD process exposed so many bugs in the R3-Alpha module implementation that it was basically impossible.

* Adding to the heaviness of the change, the concept that single-brace FENCE! creates an OBJECT! under evaluation just brings to attention the question of how binding works in such cases... e.g. does it make sense that **`{x: 10, y: y + 20}`** would try to make an object in which Y is adding 20 to the as-yet-to-be-defined Y field of the object being produced, necessitating you to write **`eval compose ${x: 10, y: (y) + 20}`** to capture an external Y?  Does that EVAL treat fences different than other array types, and if so should it treat groups different from blocks?

### I Went Down The Rabbit Hole Of Updating The Bootstrap Executable

The makefile generation and other &quot;prep&quot; code has been building using a version of Ren-C from December 2018.  It&#39;s been somewhat impressive that techniques in a `bootstrap-shim` file have been able to largely twist the language to modern conventions from within the language itself.  (This continues the tradition from `r2-forward` which made Rebol2 act more like R3-Alpha without having to change the EXE itself, though the adaptations were much less radical and done without Ren-C&#39;s high-leverage function composition tools.)

But hitting the bugs in pre-empting the LOAD process made me realize that it was time to make new bootstrap executables that fixed those bugs, and supported a mechanism for the new string format (and perhaps even add the FENCE! type).

So long as I was doing that, I could fold *most* of the bootstrap-shim features into the executable itself, for better and cleaner performance.  While doing so I could take that time to assess whether all the improvements had actually turned out to be improvements or not...reverting anything that had turned out to be bad.  I could also make the bootstrap EXE&#39;s PARSE compatible with modern UPARSE, meaning the only Rebol2-style parsing we&#39;d have would be in the Redbol emulation.

I also undertook modernizing the C code itself, where old names like `RELVAL` or `REBSER` could be replaced with newer stylization like `Cell` and `Series`.  This made it easier to read and compare older and newer code, and paste between them.

### New `&amp;` Sigil, but No Silver Bullet For Types

Opening up the number of fundamental types allowed bringing in a new sigil (**`&amp;[bl o ck]`**, **`&amp;word`**, **`&amp;(gr o up)`** etc.) which could be used for types.  While [some ideas were thrown around](https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151), no truly great coherent ideas for what Rebol&#39;s type system should be came up.

---

# May âž¡ July : Not Really Thinking About Rebol

I had a lot going on personally, and confronting Rebol&#39;s hard problems head-on was very wearying and not something I felt like doing (or even *able* to do).

Also wearying is that the world doesn&#39;t stand still.  The tools you use become deprecated and new versions have new flags and frustrations to deal with.  Every month (week?) you step away means you&#39;ll be coming back to something that broke, especially when you try to keep things running on as many platforms as Ren-C does.

So I found it easier to mess around with NixOS and discover more about what state it&#39;s in these days, watch YouTube math videos and [learn about Manim](https://github.com/ManimCommunity/manim), ask AI to turn my old [unfinished clips](http://metaeducation.com/media/music/harpsy.mp3) into [complete songs](http://metaeducation.com/media/music/paper-planes.mp3), go to improv... basically anything but worry about the design of an esoteric language.

*(I also have a &quot;part-time job&quot; as a product reviewer, that I was picked for on the basis of having written good reviews on Amazon for some years.  It doesn&#39;t pay directly, but I get free stuff to write reviews for: listening on [these $279-list-price earbuds right now](https://www.pcmag.com/reviews/jabra-elite-10-gen-2).)* 

---

# August : Now What?

I&#39;m back in Florida now, and settling into hermit mode...possibly for a couple of months, or maybe all winter.  More in the mood for doing some development.

I&#39;ve synchronized Ren-C with all the updates of the compilers and tools, and made a new Linux development VM based on Ubuntu 24.04 LTS (since the last Long-Term-Support release I&#39;d been using expired, long-term doesn&#39;t actually feel all that long).

And I&#39;m now taking the important step of sitting down to write a status update.  It&#39;s good to remember the nifty stuff that happened earlier in the year, and consciously reflect on what has been blocking the desire to work on it since then.

**I sure wish I could make some conservative choices and create a mimimum viable product, without needing to single-handedly try and solve everything up front with the Ren-C artifact.**

Yet the sad fact is that when it comes to just &quot;getting the idea out there&quot;, that ship sailed long ago with Rebol2.  From a design level, it found just enough that would stick to the wall.  But it was enough to inspire JSON, and then spawn a bunch of bus-factor-one derivative projects.

While Ren-C took R3-Alpha&#39;s [Second-System Effect](https://en.wikipedia.org/wiki/Second-system_effect) to new heights of pathology, it has the merit of being full of ideas I find interesting.  Meanwhile in over a decade, Red&#39;s &quot;getting the idea out there, part 2&quot; mission hasn&#39;t even accomplished an artifact that achieves Rebol2 parity for our modern faster-evolving ecology... *despite being relatively unambitious about changing the language*.  And I don&#39;t personally find much interesting about it &lt;sub&gt;(except for some of the stuff Boris does)&lt;/sub&gt;

Grafting one or two of the cool ideas onto R3-Alpha or Red, while leaving binding and the other big picture issues unsolved, isn&#39;t something the world needs (or can be made to want, nor should it).  So I&#39;ve dug my own hole: too many nifty concepts, but not a complete enough picture to deploy as a system.

**Could I do small bite-size YouTube shorts (or similar) that demonstrate interesting ideas, without actually trying to sell people on an artifact that implements those ideas?**  I&#39;m not sure... but there are people who will watch [entire documentaries on things like TempleOS](https://www.youtube.com/watch?v=UCgoxQCf5Jg) without feeling they&#39;ve wasted their time, even though they don&#39;t intend to ever run it.



---

# Step One Is Write Update Post.  Step Two Is...

I&#39;ve actually had some topics I&#39;ve wanted to write on in the last few weeks.

But I felt that since I hadn&#39;t said anything for a while, I needed to write a status post and speak some about what&#39;s been on my mind.

Ok...

**I&#39;m going to do some low-pressure tinkering just to get back to making commits and posts and see what grabs me.**

I&#39;ll update here with any more thoughts.  Certainly I think that making the canon &quot;Rebol: The Movie&quot; documentary is something I&#39;m uniquely qualified to do.  Maybe if I combined history, stories of the cast of characters and personalities, along with summarized design arguments and critiques it would be enough that the software-writing-AI of the future ([or...Thursday?](https://www.youtube.com/shorts/MSuw5AoN7I8)) could sort it out.  If not, at least entertain.</description>
    
    <lastBuildDate>Sun, 18 Aug 2024 17:10:34 +0000</lastBuildDate>
    <category>Announcements</category>
    <atom:link href="https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Back to Bedlam: August 2024 Status and...Plan? :confused:</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <blockquote>
<p>So Ren-C had a pretty exciting first 3 months of 2024, and then started to drop off, until I wasn't working on it at all.</p>
<p>I'll try and sum up what's gone on, and where things might realistically go from here.</p>
</blockquote>
<hr>
<h1>
<a name="rapid-development-january-march-1" class="anchor" href="https://forum.rebol.info#rapid-development-january-march-1"></a>Rapid Development: January <img src="https://forum.rebol.info/images/emoji/twitter/arrow_right.png?v=12" title=":arrow_right:" class="emoji" alt=":arrow_right:" loading="lazy" width="20" height="20"> March</h1>
<h3>
<a name="binding-paradigm-shift-2" class="anchor" href="https://forum.rebol.info#binding-paradigm-shift-2"></a>Binding Paradigm Shift</h3>
<p>The <a href="https://forum.rebol.info/t/bradrn-brad/2088">arrival of @bradrn</a> who had been investigating "R" directed attention back to the central language issue of how binding works at all (if it can be made to work).  This prioritized revisiting "Pure Virtual Binding" with fresh eyes: <strong><a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751/9">Pure Virtual Binding II</a></strong></p>
<p>I feel the premises are sound.  But if you buy into the methodology, then there are many consequences that will seem more alien than usual to historical Rebol programmers.  BLOCK!s are not inert in the evaluator, but rather evaluate to a version of the BLOCK! with binding applied... so <strong><code>(blk: [a b c])</code></strong> is distinct from <strong><code>(blk: '[a b c])</code></strong> where the latter uses quoting to suppress the evaluation.  And since quoting suppresses any binding, <strong><code>(x: 10, y: get 'x)</code></strong> won't work because the <strong><code>'x</code></strong> term drops the quote and stays unbound, meaning you have to use the new VAR-WORD! type and write <strong><code>(x: 10, y: get $x)</code></strong>.</p>
<p><em>The epicycles of this new world touch every aspect of the design</em>--forcing "binding awareness" to the forefront of dialect authors and casual users.  I wish there were an easier answer, but "implicitly paste unique binding pointers on words in waves" is being proven to be non-composable sufficiently well by other Redbol implementations.  It doesn't work meaningfully, so they simply write anything non-trivial as C or Red/System.</p>
<p>I managed to get the system to run well enough to research the design.  It is very half-baked, and every few minutes I work with it triggers the need for a new meditation in the <a href="https://forum.rebol.info/c/development/binding/49">Binding category</a>.  But as a positive sign, the new model made it possible to add a LET combinator to UPARSE, and there are other longstanding problems that get solved.</p>
<h3>
<a name="isotopes-shape-up-more-clearly-3" class="anchor" href="https://forum.rebol.info#isotopes-shape-up-more-clearly-3"></a>Isotopes Shape Up More Clearly</h3>
<p>We now use a more consistent terminology where things like null are called <a href="https://forum.rebol.info/t/quasiforms-stable-unstable-isotopes-simpler-terminology/2005/9">"antiforms" instead of "isotopes"</a> (e.g. the null antiform is one of the three isotopes of the WORD! <strong>null</strong>).</p>
<p>Some other shuffles were made, like saying that <a href="https://forum.rebol.info/t/why-shouldnt-void-be-done-with-a-void-word-antiform/2160">void is the antiform word of <strong>~void~</strong></a>, and flipping <a href="https://forum.rebol.info/t/why-trash-is-the-name-for-unset-state/2078">"trash" to the antiform of BLANK!</a>.  This was based on the realization that there wasn't really all that much value in trying to make voids some special magic type that wasn't an antiform and couldn't be put in blocks, just so its quoted form could be a lone apostrophe.</p>
<h3>
<a name="breaking-through-the-64-fundamental-types-barrier-4" class="anchor" href="https://forum.rebol.info#breaking-through-the-64-fundamental-types-barrier-4"></a>Breaking Through the 64 Fundamental Types Barrier</h3>
<p>Since the dawn of Rebol, the use of a 64-bit bitflag for type checking has meant there can be only 64 types.  We need more, and fully generalized typechecking wants to be able to test not just for fundamental types but also for predicates (like if something is EVEN? vs. just if it's an INTEGER!).</p>
<p>To keep the system from slowing down to a glacial pace by type checking through function calls, <a href="https://forum.rebol.info/t/intrinsics-functions-without-frames/2050">I hacked together an implementation of what I called "intrinsics"</a>.  These functions are faster to call than ordinary natives, helping make type checking faster, but also other simple function calls.</p>
<h3>
<a name="the-new-sigil-type-5" class="anchor" href="https://forum.rebol.info#the-new-sigil-type-5"></a>The New SIGIL! Type</h3>
<p>For a while there was a concept of tolerating "Weird Words" (e.g. with spaces in them) by putting them in vertical bars, <strong><code>|like this|</code></strong>.  That allowed a few new interesting "plain WORD!s" like <strong><code>::</code></strong> to exist because you could accomplish their "weird" forms with vertical bars like a SET-WORD! form as <strong><code>|::|:</code></strong>.</p>
<p>This turned out to be a bad idea.  So I simplified with <a href="https://github.com/metaeducation/ren-c/blob/master/tests/datatypes/sigil.test.reb">a new type called the SIGIL!</a>... with one for each decoration you could put on WORD!s and arrays.  These SIGIL!s only have a plain form, and have baked in evaluator behavior.  This also solves a problem elegantly, where you can write code like <strong><code>(x: '$abc, if '$ = sigil of x [...])</code></strong></p>
<h3>
<a name="api-antiform-splicing-solved-6" class="anchor" href="https://forum.rebol.info#api-antiform-splicing-solved-6"></a>API Antiform Splicing Solved</h3>
<p>Having the <code>@</code> symbol be a SIGIL! with built-in evaluator behavior finessed another longstanding problem that having it be a WORD! bound to a reassignable function couldn't do, which was to reconstruct antiforms in API splices, e.g.:</p>
<pre><code>Value* val = rebValue("~true~");  // quasiform evaluates to antiform (logic)

// rebElide("if", val, "[print {Error: no antiforms in source code blocks}]");

rebElide("if @", val, "[print {Special loophole for @ makes this work}]");
</code></pre>
<p>The @ sigil can be given a special baked-in behavior--specific to the API--allowing it to preserve and reconstitute the antiform state.  This helps bridge the fact that <code>val</code> above isn't a Rebol WORD!, but a C variable, but still give the indirection that a word would have.  <em>(Note that splicing antiforms as quasiforms would be too permissive, because you can't be certain that your splices are in code that is evaluative... it would be like saying <strong><code>compose [1 (null) 2]</code></strong> gives you <strong><code>[1 ~null~ 2]</code></strong> instead of raising the intended error.)</em></p>
<p>Resolving this major sticking point in the API was a big relief.</p>
<h3>
<a name="string-interpolation-solved-7" class="anchor" href="https://forum.rebol.info#string-interpolation-solved-7"></a>String Interpolation Solved?</h3>
<p>Whenever you are passing around a BLOCK! you may be passing along its environment, to which it holds a permanent reference (preventing that environment from GC'ing).  But even more costly would be if every string had to carry around an environment...which also meant anyone you passed a string to gets access to environments that may have incidentally been put on that string.</p>
<p>The solution seems a bit obvious in retrospect: if you want to do interpolation on a string, <a href="https://forum.rebol.info/t/could-strings-have-context/587/27">put it in something like a BLOCK!</a>.  Like I say, <em>"a lot better than starting to worry about having to quote your strings to suppress binding!"</em></p>
<hr>
<h1>
<a name="april-things-start-to-stall-8" class="anchor" href="https://forum.rebol.info#april-things-start-to-stall-8"></a>April : Things Start to Stall</h1>
<h3>
<a name="coming-to-terms-with-fence-and-brace-incompatibility-9" class="anchor" href="https://forum.rebol.info#coming-to-terms-with-fence-and-brace-incompatibility-9"></a>Coming to Terms with FENCE! and Brace Incompatibility</h3>
<p>For the past few years I'd been second-guessing the idea that plain braces should be used for strings, and that they should instead be another array type called FENCE!.  Comparing Rebol to the JSON it inspired made it seem like a thing that <a href="https://forum.rebol.info/t/json-envy-serialization-dialect-in-rebol/2140/2">once seen could not be unseen</a>.</p>
<p>Thinking through the natural alternatives for string representation made me think there could be an asymmetric pair of delimiters made by <strong><code>-{</code></strong> and <strong><code>}-</code></strong>.  Not only that, the pattern could be extended with more dashes.</p>
<pre><code> obj: {x: 10, y: "obj would be an object now"}

 print -{Hello new string "World"}-

 print -{Hello single } brace-containing string}-
 
 print --{Hello compound }- brace-containing double dash string}--
</code></pre>
<p>It might seem this would be a relatively simple-to-implement change compared to something like binding.  But it threw a wrench into things for many reasons:</p>
<ul>
<li>
<p>Historical binding was always complete garbage, whereas single-braced strings were actually touted as a pleasing aspect of the language (including by me).</p>
</li>
<li>
<p>This would be the first truly non-backwards-compatible LOAD change to Ren-C, meaning that either some special way to signal which interpretation would be needed, or the work in the Rebol2 compatibility module would go to waste.</p>
<ul>
<li>
<p>The idea of a single simple-switch covering this narrow issue always raises the question of whether you want a more generalized hook that you can give before loading.  Red offers such a thing as <code>system/lexer/pre-load</code> which is just a function that transform source UTF-8 before you load it, <a href="https://www.red-lang.org/2019/11/editorial-brief-essay-on-lexical.html">though claims it should not be abused</a></p>
</li>
<li>
<p>While I thought I could hack through a prototype with a kind of pre-load functionality using the existing bootstrap executable, trying to pre-empt the LOAD process exposed so many bugs in the R3-Alpha module implementation that it was basically impossible.</p>
</li>
</ul>
</li>
<li>
<p>Adding to the heaviness of the change, the concept that single-brace FENCE! creates an OBJECT! under evaluation just brings to attention the question of how binding works in such cases... e.g. does it make sense that <strong><code>{x: 10, y: y + 20}</code></strong> would try to make an object in which Y is adding 20 to the as-yet-to-be-defined Y field of the object being produced, necessitating you to write <strong><code>eval compose ${x: 10, y: (y) + 20}</code></strong> to capture an external Y?  Does that EVAL treat fences different than other array types, and if so should it treat groups different from blocks?</p>
</li>
</ul>
<h3>
<a name="i-went-down-the-rabbit-hole-of-updating-the-bootstrap-executable-10" class="anchor" href="https://forum.rebol.info#i-went-down-the-rabbit-hole-of-updating-the-bootstrap-executable-10"></a>I Went Down The Rabbit Hole Of Updating The Bootstrap Executable</h3>
<p>The makefile generation and other "prep" code has been building using a version of Ren-C from December 2018.  It's been somewhat impressive that techniques in a <code>bootstrap-shim</code> file have been able to largely twist the language to modern conventions from within the language itself.  (This continues the tradition from <code>r2-forward</code> which made Rebol2 act more like R3-Alpha without having to change the EXE itself, though the adaptations were much less radical and done without Ren-C's high-leverage function composition tools.)</p>
<p>But hitting the bugs in pre-empting the LOAD process made me realize that it was time to make new bootstrap executables that fixed those bugs, and supported a mechanism for the new string format (and perhaps even add the FENCE! type).</p>
<p>So long as I was doing that, I could fold <em>most</em> of the bootstrap-shim features into the executable itself, for better and cleaner performance.  While doing so I could take that time to assess whether all the improvements had actually turned out to be improvements or not...reverting anything that had turned out to be bad.  I could also make the bootstrap EXE's PARSE compatible with modern UPARSE, meaning the only Rebol2-style parsing we'd have would be in the Redbol emulation.</p>
<p>I also undertook modernizing the C code itself, where old names like <code>RELVAL</code> or <code>REBSER</code> could be replaced with newer stylization like <code>Cell</code> and <code>Series</code>.  This made it easier to read and compare older and newer code, and paste between them.</p>
<h3>
<a name="new-sigil-but-no-silver-bullet-for-types-11" class="anchor" href="https://forum.rebol.info#new-sigil-but-no-silver-bullet-for-types-11"></a>New <code>&amp;</code> Sigil, but No Silver Bullet For Types</h3>
<p>Opening up the number of fundamental types allowed bringing in a new sigil (<strong><code>&amp;[bl o ck]</code></strong>, <strong><code>&amp;word</code></strong>, <strong><code>&amp;(gr o up)</code></strong> etc.) which could be used for types.  While <a href="https://forum.rebol.info/t/ugly-types-less-ugly-than-history-can-we-do-better/2151">some ideas were thrown around</a>, no truly great coherent ideas for what Rebol's type system should be came up.</p>
<hr>
<h1>
<a name="may-july-not-really-thinking-about-rebol-12" class="anchor" href="https://forum.rebol.info#may-july-not-really-thinking-about-rebol-12"></a>May <img src="https://forum.rebol.info/images/emoji/twitter/arrow_right.png?v=12" title=":arrow_right:" class="emoji" alt=":arrow_right:" loading="lazy" width="20" height="20"> July : Not Really Thinking About Rebol</h1>
<p>I had a lot going on personally, and confronting Rebol's hard problems head-on was very wearying and not something I felt like doing (or even <em>able</em> to do).</p>
<p>Also wearying is that the world doesn't stand still.  The tools you use become deprecated and new versions have new flags and frustrations to deal with.  Every month (week?) you step away means you'll be coming back to something that broke, especially when you try to keep things running on as many platforms as Ren-C does.</p>
<p>So I found it easier to mess around with NixOS and discover more about what state it's in these days, watch YouTube math videos and <a href="https://github.com/ManimCommunity/manim">learn about Manim</a>, ask AI to turn my old <a href="http://metaeducation.com/media/music/harpsy.mp3">unfinished clips</a> into <a href="http://metaeducation.com/media/music/paper-planes.mp3">complete songs</a>, go to improv... basically anything but worry about the design of an esoteric language.</p>
<p><em>(I also have a "part-time job" as a product reviewer, that I was picked for on the basis of having written good reviews on Amazon for some years.  It doesn't pay directly, but I get free stuff to write reviews for: listening on <a href="https://www.pcmag.com/reviews/jabra-elite-10-gen-2">these $279-list-price earbuds right now</a>.)</em></p>
<hr>
<h1>
<a name="august-now-what-13" class="anchor" href="https://forum.rebol.info#august-now-what-13"></a>August : Now What?</h1>
<p>I'm back in Florida now, and settling into hermit mode...possibly for a couple of months, or maybe all winter.  More in the mood for doing some development.</p>
<p>I've synchronized Ren-C with all the updates of the compilers and tools, and made a new Linux development VM based on Ubuntu 24.04 LTS (since the last Long-Term-Support release I'd been using expired, long-term doesn't actually feel all that long).</p>
<p>And I'm now taking the important step of sitting down to write a status update.  It's good to remember the nifty stuff that happened earlier in the year, and consciously reflect on what has been blocking the desire to work on it since then.</p>
<p><strong>I sure wish I could make some conservative choices and create a mimimum viable product, without needing to single-handedly try and solve everything up front with the Ren-C artifact.</strong></p>
<p>Yet the sad fact is that when it comes to just "getting the idea out there", that ship sailed long ago with Rebol2.  From a design level, it found just enough that would stick to the wall.  But it was enough to inspire JSON, and then spawn a bunch of bus-factor-one derivative projects.</p>
<p>While Ren-C took R3-Alpha's <a href="https://en.wikipedia.org/wiki/Second-system_effect">Second-System Effect</a> to new heights of pathology, it has the merit of being full of ideas I find interesting.  Meanwhile in over a decade, Red's "getting the idea out there, part 2" mission hasn't even accomplished an artifact that achieves Rebol2 parity for our modern faster-evolving ecology... <em>despite being relatively unambitious about changing the language</em>.  And I don't personally find much interesting about it <sub>(except for some of the stuff Boris does)</sub></p>
<p>Grafting one or two of the cool ideas onto R3-Alpha or Red, while leaving binding and the other big picture issues unsolved, isn't something the world needs (or can be made to want, nor should it).  So I've dug my own hole: too many nifty concepts, but not a complete enough picture to deploy as a system.</p>
<p><strong>Could I do small bite-size YouTube shorts (or similar) that demonstrate interesting ideas, without actually trying to sell people on an artifact that implements those ideas?</strong>  I'm not sure... but there are people who will watch <a href="https://www.youtube.com/watch?v=UCgoxQCf5Jg">entire documentaries on things like TempleOS</a> without feeling they've wasted their time, even though they don't intend to ever run it.</p>
<hr>
<h1>
<a name="step-one-is-write-update-post-step-two-is-14" class="anchor" href="https://forum.rebol.info#step-one-is-write-update-post-step-two-is-14"></a>Step One Is Write Update Post.  Step Two Is...</h1>
<p>I've actually had some topics I've wanted to write on in the last few weeks.</p>
<p>But I felt that since I hadn't said anything for a while, I needed to write a status post and speak some about what's been on my mind.</p>
<p>Ok...</p>
<p><strong>I'm going to do some low-pressure tinkering just to get back to making commits and posts and see what grabs me.</strong></p>
<p>I'll update here with any more thoughts.  Certainly I think that making the canon "Rebol: The Movie" documentary is something I'm uniquely qualified to do.  Maybe if I combined history, stories of the cast of characters and personalities, along with summarized design arguments and critiques it would be enough that the software-writing-AI of the future (<a href="https://www.youtube.com/shorts/MSuw5AoN7I8">or...Thursday?</a>) could sort it out.  If not, at least entertain.</p>
          <p><a href="https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188/1</link>
        <pubDate>Sun, 18 Aug 2024 00:43:55 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2188-1</guid>
        <source url="https://forum.rebol.info/t/back-to-bedlam-august-2024-status-and-plan/2188.rss">Back to Bedlam: August 2024 Status and...Plan? :confused:</source>
      </item>
  </channel>
</rss>

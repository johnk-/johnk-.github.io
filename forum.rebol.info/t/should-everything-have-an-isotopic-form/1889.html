<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Should Everything Have an Isotopic Form? - Datatypes - AltRebol</title>
    <meta name="description" content="A little too soon to declare victory, but... we may have a solution in our hands for the historical problem of splicing arrays, by allowing BLOCK! isotopes to convey the splicing intent. 
Isotopes are essentially &amp;quot;quote &amp;hellip;">
    <meta name="generator" content="Discourse 2.7.0.beta4 - https://github.com/discourse/discourse version 3fc72543de22c329cf2156f28b781821adc496ae">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" content="#ffffff">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="1889.html" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://forum.rebol.info","potentialAction":{"@type":"SearchAction","target":"https://forum.rebol.info/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

      <link href="https://forum.rebol.info/stylesheets/desktop_cdfbc200d3f5311dbee0f69ae668cfc42cfc8cb7.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop" data-theme-id="2"/>
      <link href="https://forum.rebol.info/stylesheets/desktop_theme_2_7b2b5b1bc734c2cc3b6ad5e0f49f467e8601ef2c.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2"/>
    
    
        <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;Should Everything Have an Isotopic Form?&#39;" href="1889.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889" />
<meta name="twitter:url" content="https://forum.rebol.info/t/should-everything-have-an-isotopic-form/1889" />
<meta property="og:title" content="Should Everything Have an Isotopic Form?" />
<meta name="twitter:title" content="Should Everything Have an Isotopic Form?" />
<meta property="og:description" content="A little too soon to declare victory, but... we may have a solution in our hands for the historical problem of splicing arrays, by allowing BLOCK! isotopes to convey the splicing intent.  Isotopes are essentially &quot;quote level -1&quot; ... if you take something at quote level 0 and UNMETA it, you&#39;re allowed precisely one level of  below-rock-bottom.  The isotopes are unfriendly: normal function parameters won&#39;t accept them, you cannot put them in arrays, and some of them have strange behaviors when as..." />
<meta name="twitter:description" content="A little too soon to declare victory, but... we may have a solution in our hands for the historical problem of splicing arrays, by allowing BLOCK! isotopes to convey the splicing intent.  Isotopes are essentially &quot;quote level -1&quot; ... if you take something at quote level 0 and UNMETA it, you&#39;re allowed precisely one level of  below-rock-bottom.  The isotopes are unfriendly: normal function parameters won&#39;t accept them, you cannot put them in arrays, and some of them have strange behaviors when as..." />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="13 mins 🕑" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="6 ❤" />
<meta property="article:published_time" content="2022-07-16T22:41:35+00:00" />
<meta property="og:ignore_canonical" content="true" />



    
  </head>
  <body class="crawler">
    
    <header>
      <a href="https://forum.rebol.info/">
          <img src="../../uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" alt="AltRebol" id="site-logo" style="max-width: 150px;">
      </a>
    </header>
    <div id="main-outlet" class="wrap">
        <div id="topic-title">
    <h1>
      <a href="1889.html">Should Everything Have an Isotopic Form?</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/development/8" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="../../c/development/datatypes.html" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Datatypes</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  


      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="1889.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2022-07-16T22:41:35Z'>
              <time itemprop='dateModified' datetime='2022-07-17T23:13:48Z' class='post-time'>
                July 17, 2022, 11:13pm
              </time>
          <span itemprop='position'>#1</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <p>A little too soon to declare victory, but... we may have a solution in our hands for the historical problem of splicing arrays, <strong><a href="../cutting-out-only-could-we-make-append-find-etc-only-accept-blocks/1182/18.html">by allowing BLOCK! isotopes</a></strong> to convey the splicing intent.</p>
<p>Isotopes are essentially <em>"quote level -1"</em> ... if you take something at quote level 0 and UNMETA it, you're allowed precisely one level of  below-rock-bottom.</p>
<p>The isotopes are unfriendly: normal function parameters won't accept them, you cannot put them in arrays, and some of them have strange behaviors when assigned to variables.</p>
<p>So what would an isotopic block look like?</p>
<p>A thought I had inspired by BAD-WORD!s was that they might use tildes on the outsides:</p>
<pre><code>&gt;&gt; unmeta [a b c]
== ~[a b c]~
</code></pre>
<p>But that's used for normal BAD-WORD! today, that you unmeta to make isotopes.</p>
<p>Which made me wonder, what if what we call BAD-WORD! today was actually a BAD-WORD! isotope, and you got them from unmeta'ing WORD! ?</p>
<pre><code>&gt;&gt; unmeta 'something
== ~something~
    ; ^-- ornery, how what we call `~something~ isotope` is today
</code></pre>
<p>And then, what if you could make anything isotopic:</p>
<pre><code>&gt;&gt; unmeta 1020
== ~1020~
</code></pre>
<p>This would break a number of things--and we've come to depend on reified BAD-WORD!s for some reasonably important purposes.  But it crossed my mind and I tend to jot notes here for every single whim that comes to my mind, so there it is.  <img src="../../images/emoji/twitter/slight_smile.png%3Fv=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<h2>Storing Isotopic Blocks In Variables?</h2>
<p>If you go back and review <a href="../generic-quoting-makes-headway-on-make-object/997.html">"Generic Quoting Makes Headway on MAKE OBJECT!"</a> you'll see that we've been getting by not needing quotes on items that are inert.</p>
<p>You have to have a quote on (1 + 2) if the intent is to store a GROUP! in a variable, because it will evaluate otherwise:</p>
<pre><code>make object! [group: '(1 + 2)]
</code></pre>
<p>But things like BLOCK! haven't needed them (and shouldn't):</p>
<pre><code>make object! [block: [1 + 2]]
</code></pre>
<p>However, I think that BLOCK! isotopes are likely going to need to be stored in variables.  You'll have to use ^META operations to get the value out of the variable.</p>
<p>Why couldn't it be an error to try and store an isotopic block in a variable?  Well, there is some attempts to be friendly by higher-level operations like SPECIALIZE.  So when you say</p>
<pre><code>append-a-b-c: specialize :append [value: spread [a b c]]  ; or whatever...
</code></pre>
<p>What happened was that everything in the frame was marked as holding a special identity for unspecialized-ness.  When the code block finishes running, it looks and notices value is a ^META parameter, and does the isotopic quoting for you.</p>
<p>If you don't have that feature, you have to know the convention of the parameter in order to assign it.  That's not the end of the world, but it feels like a hassle.  Being able to store an isotopic block in a variable enables that feature--as well as others.</p>
<h2>So I Think Isotopes Are In For Some Kind of Reckoning</h2>
<p>There's a lot of pieces to the puzzle, and they're all tied in together.  But the good news is that the corpus of code is so big that the impacts of any change are seen, and so I can try to make sure nothing of value gets lost.</p>
        </div>

        <meta itemprop='headline' content='Should Everything Have an Isotopic Form?'>
          <meta itemprop='keywords' content=''>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

            <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../find-treats-typeset-s-specially-why-not-functions/1881/2.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/find-treats-typeset-s-specially-why-not-functions/1881/2'>
                      <span itemprop='name'>FIND treats TYPESET!s specially...why not functions?</span>
                    </a>
                    <meta itemprop='position' content='3'>
                  </div>
            </div>
      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="1889.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2022-07-18T13:58:19Z'>
              <time itemprop='dateModified' datetime='2022-07-18T14:13:40Z' class='post-time'>
                July 18, 2022,  2:13pm
              </time>
          <span itemprop='position'>#2</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <blockquote>
<p>But it crossed my mind and I tend to jot notes here for every single whim that comes to my mind, so there it is.</p>
</blockquote>
<p>Corollary to this thought:</p>
<p><em>What if it's only isotopic ACTION!s that execute implicitly?  And what if you can make an isotopic FRAME! that does the same?</em></p>
<p>This would mean that if you passed an action as a normal parameter to a function, it would have to be explicitly executed.  And you wouldn't use GET-WORD! to defuse functions, you would use ^META.</p>
<h2>ACTION! in BLOCK! couldn't be isotopic, so would not run</h2>
<p>It would reduce the danger in this case:</p>
<pre><code>for-each item block [
    if integer? item [...]  ; don't have to worry that ITEM consumes the block
]
</code></pre>
<p>You'd still have potential problems with enumerating objects and such, but the way it would guard you would be that the enumeration would force you to use ^META if you actually hit any isotopes.</p>
<pre><code>obj: make object! [a: 10 b: func [x [text!]] [print ["Foiled!" x]]]

for-each [key value] object [
    print [value "is the value of" key]
]
</code></pre>
<p>That would catch you before the function could consume "is the value of".  The FOR-EACH could complain and say it hit an isotope, so you'd need to use ^META.</p>
<p>This gives us the long-awaited get-what-you-pay-for safety in enumeration!</p>
<h2>One Step Closer to GET-WORD! as Unmeta</h2>
<p>A proposal in the air is that GET-WORD! act as UNMETA.</p>
<pre><code>&gt;&gt; var: the '10

&gt;&gt; ^var
== ''10

&gt;&gt; :var
== 10
</code></pre>
<p>We could say that you could interchangeably use UTF-8 arrows for this:</p>
<pre><code>&gt;&gt; ↑var
== ''10

&gt;&gt; ↓var
== 10
</code></pre>
<p>We might call them UP-WORD! and DOWN-WORD!, as there's not really what we'd say is a "GET" happening in the <strong>:var</strong> case.</p>
<p>A standalone colon could act as a free UNMETA, biasing it to having the meaning of the DOWN of <strong>:x</strong> (as opposed to the SET of <strong>x:</strong>)</p>
<pre><code>&gt;&gt; append [a b c] : reduce [1 + 2 3 + 4]
== [a b c 3 7]
</code></pre>
<p>And in light of the current thinking on blocks, we'd get a shorthand for appending splices via isotopic blocks:</p>
<pre><code>&gt;&gt; append [a b c] :[d e] 
== [a b c d e]

&gt;&gt; append [a b c] ↓[d e]
== [a b c d e]
</code></pre>
<p>This would mean we'd lose the GET-BLOCK!-as-REDUCE.  Which is unfortunate.  But REDUCE probably happens less often these days than splicing and UNMETA-ing.</p>
<p><em>Would this mean that things like REDUCE and COPY and such would need to take ^META parameters to handle isotopic blocks?</em></p>
<p>Urg.  Not sure I think that's such a great idea, it undermines the point of the types being rare and not propagating that widely.</p>
<p>So you wouldn't write this:</p>
<pre><code>append [a b c] reduce :[1 + 2 3 + 4]
</code></pre>
<p>You'd write:</p>
<pre><code>&gt;&gt; append [a b c] : reduce [1 + 2 3 + 4]
== [a b c 3 7]
</code></pre>
<p>It would be technically possible to make things like REDUCE operate in the ^META domain, but I (think) it's probably better if only the functions that directly ascribe meaning to the isotopic state are actually meta.</p>
        </div>

        <meta itemprop='headline' content='Should Everything Have an Isotopic Form?'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="1" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="1889.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2022-07-23T16:25:33Z'>
              <time itemprop='dateModified' datetime='2022-07-23T18:40:28Z' class='post-time'>
                July 23, 2022,  6:40pm
              </time>
          <span itemprop='position'>#3</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="1889">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>What if it's only isotopic ACTION!s that execute implicitly? And what if you can make an isotopic FRAME! that does the same?</p>
</blockquote>
</aside>
<p>The gist of the above idea is to make the following code safe:</p>
<pre><code>for-each item some-block [  ; isotopes won't be found in a BLOCK!
    switch type of item [  ; no need for `:item`
        action! [print "It's an ACTION! at quote level 0"]
        integer! [print "It's an INTEGER! at quote level 0"]
    ] else [
        print "It's not an action or integer (or is quoted)"
    ]
]
</code></pre>
<p>Historical Redbol makes you have to be very cautious and do tests like <strong><code>action? :item</code></strong>, where the colon is required to suppress the implicit evaluation.  It also has to worry about UNSET! (and in Rebol2, "armed" errors as well.)  This is a pleasing solution to the problem.</p>
<p>(Of course, if you are enumerating an OBJECT! or MODULE! you will encounter the isotopic form of the action in the values.  So you'd have to say <strong><code>for-each [key ^value] [...]</code></strong> for full coverage.  But that again has pleasing safety properties, because once you ^META something it won't be isotopic anymore...so had it been an isotopic ACTION! that would run implicitly on word fetch, it will now be a quote level 0 action that won't!)</p>
<h2>But There's a Glitch If ACTION! at Quote Level 0 Is Inert</h2>
<p>The system relies on plain ACTION!s translating to invocation in several places... in particular the API.</p>
<p>Let's imagine we live in the world where <code>print_isotope</code> is allowed to be a function isotope:</p>
<pre><code> REBVAL* print_isotope = rebValue("get/any 'print");
 rebElide(print_isotope, "[{Print} {me}]");
</code></pre>
<p>That causes a runtime error.  Because rebElide() internally makes something equivalent to a BLOCK!.  And isotopes can't be put in BLOCK!s.  :-/</p>
<p>The same problem would affect people trying to make code with a COMPOSE:</p>
<pre><code> &gt;&gt; do compose [(get/any 'print) [{Print} {me}]]
 ** Error: COMPOSE can't put ACTION! isotope in BLOCK!
</code></pre>
<p>So you have to ^META that isotope and get an ACTION!.  But if you do <em>that</em>, then the pitch above was that the action would not run:</p>
<pre><code> &gt;&gt; do compose [(^print) [{Print} {me}]]
 == ["Print" "me"]
</code></pre>
<p>You'd need to throw in some additional operation, like REEVAL:</p>
<pre><code> &gt;&gt; do compose [reeval (^print) [{Print} {me}]]
 Print me
</code></pre>
<p>That's not great.  We're saying you are forced to pay for a WORD!-lookup to lean on the WORD!-dispatches-action-isotopes behavior, because we don't have any other way of running a plain ACTION! when nothing is allowed to go lower than quote level 0.</p>
<h2>But Can't ACTION! vs. WORD!-Fetched-ACTION! Be Different?</h2>
<p>Our safe FOR-EACH has an ACTION! referenced by <strong><code>item</code></strong>, a WORD!</p>
<p>The block wants to run a raw ACTION!.</p>
<p>Couldn't we just say that actions fetched by words must be isotopes to run, and then say that a non-isotopic ACTION! that's <em>not</em> referenced through a WORD! will execute?</p>
<p>Sounds good, but then what about this:</p>
<pre><code>&gt;&gt; obj: make object! [foo: func [] [print "FUNC makes Isotopic ACTION!"]]
== make object! [
    foo: ???  ; solve for ???
]
</code></pre>
<p>Which is to ask: what value sits in that slot and <em>doesn't</em> run an ACTION!, but produces an action isotope that foo can receive?</p>
<p><strong>We need a single atomic value at a quoting level no lower than 0 which produces ACTION! isotopes when evaluated.</strong></p>
<p>That can't be ACTION! itself... <em>if</em> we've said that plain ACTION!s need to run when they are found literally during execution of a block.</p>
<h2>What About Terminal Slash?</h2>
<p>I came up with an idea some time ago that terminal slash could be used on paths to say that they would execute.  For words that pointed at ACTION!s already, this was just commentary:</p>
<pre><code>&gt;&gt; append/ [a b c] 'd
== [a b c d]
</code></pre>
<p>But it could be used to retrigger things, like a REEVAL would--but not keyword-dependent:</p>
<pre><code> &gt;&gt; (specialize :append [value: 'd])/ [a b c]
 == [a b c d]
</code></pre>
<p>Due to <a href="../heart-bytes-explained/1008.html">some clever mechanisms of path and tuple compression</a>, this form of PATH! is accomplished in a single cell.</p>
<p><strong>Maybe this explicit execution is the answer for those who wish to compose actions and run them?</strong></p>
<pre><code> &gt;&gt; do compose [(^print)/ [{Print} {me}]]
 Print me
</code></pre>
<p>The API could offer some operator like rebA() for (rebACTIVATE()) that would slashify your actions:</p>
<pre><code> REBVAL* print_action = rebValue("^print");
 rebElide(rebA(print_action), "[{Print} {me}]");
</code></pre>
<p>This would mean a plain ACTION! could evaluate to its isotope.</p>
<p>Well, it's an idea.  Just kind of trying to inventory the possibilities here...</p>
<p>My gut feeling on this is that plain ACTION! should not need this rebA() to run.  We have the nice generic quoting aspect to escape it.  But unfortunately we don't have a nice generic <em>unquoting</em> mechanism to annotate things as needing to be isotopes.</p>
<p>I think I'd rather make a separate GET-ACTION! datatype that becomes isotopic, than screw things up too badly in common use.</p>
        </div>

        <meta itemprop='headline' content='Should Everything Have an Isotopic Form?'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="2" />
           <span class='post-likes'>2 Likes</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="1" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="1889.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2022-07-24T20:33:20Z'>
              <time itemprop='dateModified' datetime='2022-07-24T21:30:09Z' class='post-time'>
                July 24, 2022,  9:30pm
              </time>
          <span itemprop='position'>#4</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1889">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think I'd rather make a separate GET-ACTION! datatype that becomes isotopic, than screw things up too badly in common use.</p>
</blockquote>
</aside>
<p>So this hypothetical "GET-ACTION!" type would have to be the ^META of an isotopic action.  Because let's say you're trying to POKE an action isotope through the API, or via the analogous situation with a COMPOSE:</p>
<pre><code> ; we assume here that FUNC returns isotopes, so x: func [] [] executes on X
 ;
 ; Remember, BLOCK!s can't hold isotopes, so we have to ^META it
 ; (unless an exception was made for ACTION! isotopes to be auto-^META'd)
 ;
 do compose [poke obj name (^ func [] [print "I'm a method in an object"]])]
</code></pre>
<p>If the ^META of an ACTION! isotope is ACTION!, and actions run when encountered in blocks by default, then what you'd wind up with there is actually running the method...instead of assigning the isotope.  Which is why it would have to be GET-ACTION!, so this could properly evaluate to the desired isotope to poke.</p>
<h2>But That Is <em>Ugly</em>
</h2>
<p>...it means instead of one ACTION! type you have three states to worry about.</p>
<ul>
<li>
<p>Plain ACTION! that does not run when fetched via WORD! or TUPLE! (but runs when encountered as-is in DO of a BLOCK!)</p>
</li>
<li>
<p>Isotopic GET-ACTION! that runs when fetched via WORD! or TUPLE!</p>
</li>
<li>
<p>Plain GET-ACTION! that becomes an isotopic GET-ACTION! when encountered as-is in DO of a BLOCK!</p>
</li>
</ul>
<p><em>But in such a world...when would you ever <em>encounter</em> a plain ACTION!?</em>  Everywhere you looked there would be GET-ACTION!s.</p>
<pre><code> &gt;&gt; action: ^append

 &gt;&gt; type of action
 == #[datatype! get-action!]
</code></pre>
<p><strong>This sucks, and makes it pretty clear that GET-ACTION! should just be ACTION!</strong>...which has exactly two forms, normal and isotope.  (and we can then call the isotopic form of ACTION! an "activation")</p>
<p>Which is to say, that in the API (or a COMPOSE), if you haven't assigned an action isotope to some WORD! you can use, you need to mark the slot for execution one way or another:</p>
<pre><code>&gt;&gt; do compose [(^print)/ [{Print} {me}]]
Print me

&gt;&gt; do compose [reeval (^print) [{Print} {me}]]
Print me

&gt;&gt; do compose [apply (^print) [ [{Print} {me}] ]]
Print me
</code></pre>
<p>A nice aspect of this is that the terminal slash is efficient, and will work whether you are splicing an ACTION! or a TUPLE! or a WORD! in that slot.</p>
<h2>It's Necessary To Preserve Invariants</h2>
<p>The following code neds to guarantee leaving VAR in the same state it was found:</p>
<pre><code>temp: ^var
var: unmeta temp  ; Plan is that :TEMP will be synonym for UNMETA TEMP
</code></pre>
<p>This should also leave VAR in the same state as it was found:</p>
<pre><code>temp: ^var
do [var: (temp)]
</code></pre>
<p>You really lose your bearings if those things don't hold true.</p>
<h2>What About the Parallel Complexity for Splices?</h2>
<p>Laying down those rules definitely does suggest that a "splice" cannot be a <strong><code>[...]</code></strong> isotope, but rather a <strong><code>:[...]</code></strong> isotope (GET-BLOCK! might be a bad name, it would be an UNMETA-BLOCK! or UN-BLOCK! or DOWN-BLOCK! or similar).</p>
<p>I don't think splices being a different type is the same kind of problem as having a secondary superfluous action type.  The scenarios are pretty different.</p>
<p>But quickly to the topic question... which is now understood a bit better.</p>
<blockquote>
<p><em>"Should Everything Have an Isotopic Form?"</em></p>
</blockquote>
<h1><em>No!</em></h1>
<p>I believe the rule I came up with is the correct way to put it: <em>the only types that have isotopic forms are those whose evaluation is to their isotope.</em>  That gives us the invariants I outline above.</p>
<p>That gives us:</p>
<ul>
<li>
<p><strong>~bad-words~</strong></p>
</li>
<li>
<p><strong>action!</strong></p>
</li>
<li>
<p><strong>:[...]</strong> (whatever we call these blocks)</p>
</li>
<li>
<p><strong>error!</strong> (which we now know, literal errors will evaluate to their isotopes)</p>
</li>
</ul>
<p>That's all for now, anyway.</p>
        </div>

        <meta itemprop='headline' content='Should Everything Have an Isotopic Form?'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="1" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="1889.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2022-08-04T22:07:53Z'>
              <time itemprop='dateModified' datetime='2022-08-05T10:22:57Z' class='post-time'>
                August 5, 2022, 10:22am
              </time>
          <span itemprop='position'>#5</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group" data-username="hostilefork" data-post="4" data-topic="1889">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This should also leave VAR in the same state as it was found:</p>
<pre><code>temp: ^var
do [var: (temp)]
</code></pre>
</blockquote>
</aside>
<p>So I think this idea has turned out to be too limiting.</p>
<p>I've backed out the code that stopped ACTION! from executing in a block, so it's back at the point where if you compose an action literal value into a block, it just runs.  <em>(Some interesting related developments were kept, so it was not all for naught.)</em></p>
<p>I've observed that under the new concept of <code>:xxx</code> behavior, a <strong><code>:(...)</code></strong> styled group could be used to make anything an isotopic form, even if it doesn't have a "GET-XXX" form.</p>
<pre><code>&gt;&gt; make object! [demo: unmeta block!]
== make object! [
     demo: :(#[datatype! block!])
]
</code></pre>
<p>So even if ACTION! would typically run, you could put a quoted action inside of a <code>:(...)</code> to get an isotopic form of the action.</p>
<h2>Or...could There Be A Notation for "anti-quoting"?</h2>
<p>An old half-baked thought was toying with the notation of surrounding things with tildes to denote isotopes.  But I remarked that really, <em>we should not be thinking about isotopes as having any notation</em>.  Their existence is only measured by parameter conventions that "quote them up into the visible spectrum".</p>
<p>But...there could be something <em>similar</em> to QUOTED!...a "container" that was a generic ANTI-QUOTED! (or what I've been calling "BAD!"), which when evaluated gave an isotope.</p>
<pre><code>&gt;&gt; 'word
== word

&gt;&gt; ~word~
== word  ; isotope

&gt;&gt; ~[a b c]~
== [a b c]  ; isotope
</code></pre>
<p>In this world, we could say that lone <code>~</code> is the representation of a BAD! blank, and blank isotopes could be the contents of unset variables, what I've been calling NONE.  <img src="../../images/emoji/twitter/thinking.png%3Fv=9" title=":thinking:" class="emoji" alt=":thinking:"></p>
<p><em>This is notably not just another level of quoting, because these would be entities which could themselves be quoted.</em></p>
<pre><code>&gt;&gt; quote first [~baddie~]
== '~baddie~
</code></pre>
<p>So this datatype would be something that would replace BAD-WORD!, and would give better visual indications of isotopes:</p>
<pre><code> &gt;&gt; make object! [x: ~xxx~, y: '~yyy~, z: spread [a b], f: does [print "HI"]]
 == make object! [
     x: ~xxx~
     y: '~yyy~
     z: ~[a b]~
     f: ~#[action! []]~
 ]
</code></pre>
<p>There you can see that X actually denotes that it holds a WORD! isotope, while Y has a way of conveying that it actually holds the BAD!-word-container <strong><code>~yyy~</code></strong>.  Z holds an isotopic block (a "splice"), and F holds an action that will run through word reference (an "activation").</p>
<p>It seems more harmonious than if we stick with the current BAD-WORD! only design, and go the <strong><code>:(...)</code></strong> route, should <strong><code>:</code></strong> be deemed useful for UNMETA-GET.</p>
<pre><code> &gt;&gt; make object! [x: ~xxx~, y: '~yyy~, z: spread [a b], f: does [print "HI"]]
 == make object! [
     x: ~xxx~
     y: '~yyy~
     z: :[a b]
     f: :(#[action! []])
 ]
</code></pre>
<p>Harder to make sense of, and less performant (the BAD! state would be encoded as part of the quote byte, e.g. we have 127 levels of quoting instead of 255, to chew out an extra bit for "are you bad, or what?").</p>
<h2>Would This New Menagerie Pay Off?</h2>
<p>This started with trying to find ways to generalize the basic mechanics of unsets, as well as how to have a taken branch return NULL...yet not trigger an ELSE.  And it's taken off from there.</p>
<p>Has the expansion in scope been good?  Well...</p>
<ul>
<li>
<p><strong><a href="../fail-vs-return-fail-the-new-age-of-definitional-failures/1852.html">There should be no question that isotopic errors are paying off...bigly.</a></strong></p>
</li>
<li>
<p><strong><a href="../the-long-awaited-death-of-only/1607.html">There's also no question that isotopic blocks are now paying off.</a></strong></p>
</li>
</ul>
<p>These are the early moments of isotopic actions, and they introduce some complexities, but they're being figured out.</p>
<p>I put forth the question of isotopic typesets, where if you could pass something like FIND a DATATYPE! isotope, it might interpret that as looking for instances of the type instead of looking for the datatype itself.</p>
<p>Rebol has always used datatype sensitivity as a cue for behavior, and isotopes offer generalized routines a new dimension of "I don't mean it <em>literally</em>..." and that non-literalness is given a boost by preventing the isotopic values from appearing in blocks.  I don't think this should seep too much into user consciousness...but it helps the core functions a lot.</p>
<p>Really it looks like things have reached the point where generalized isotopes are the best answer.</p>
<hr>
<p><strong>UPDATE:</strong> Trying some experimentation shows some promise, but definitely issues to consider with making it possible to have isotopes of <em>everything</em>.</p>
<ul>
<li>
<p>We already know that ERROR! isotopes can't be stored in variables, because the act of trying to store one without ^META-ing them will raise a "non-definitional" failure.</p>
<ul>
<li>This may extend to prohibiting storing other kinds of isotopes in variables--even perhaps most kinds (?)  I don't know if there are particularly great arguments for or against letting people store things like block isotopes (splices) in a variable vs. raising an error.</li>
</ul>
</li>
<li>
<p>Previously it was the case that whenever you took the ^META of something, only NULL could be falsey...because the ^META of NULL is NULL.  That is what makes the FOR-BOTH example work:</p>
<pre><code>  for-both: lambda ['var blk1 blk2 body] [
      unmeta all [
          meta for-each (var) blk1 body
          meta for-each (var) blk2 body
      ]
  ]
</code></pre>
<p>But if a body evaluation of the FOR-EACH can return something like a BLANK! isotope or a LOGIC! false isotope, then META'ing those will be false and act like BREAKs.  This would be particularly chronic if <code>~</code> was taken to be the way of generating an isotopic BLANK!, and isotopic blank was thus used for unset (leading to the <strong><code>~</code></strong> for unset variables in object renderings seen today).</p>
<p>You could fix that with double meta and double unmeta, which would take something like a blank isotope to a blank (falsey) and then a quoted blank (truthy) so truly only the NULL would remain as NULL and be falsey, but... <img src="../../images/emoji/twitter/nauseated_face.png%3Fv=9" title=":nauseated_face:" class="emoji" alt=":nauseated_face:"></p>
<pre><code>  for-both: lambda ['var blk1 blk2 body] [
      unmeta unmeta all [
          meta meta for-each (var) blk1 body
          meta meta for-each (var) blk2 body
      ]
  ]
</code></pre>
<p>Well... this isn't actually <em>that</em> bad a solution to the problem.  Saying it's unthinkable is kind of like a mathematician rejecting an equation because it has something squared in it.  There could be meta2 and unmeta2 operators, or meta+ and unmeta+...and if you know why you're taking the extra step that's fine.  <em>(Unfortunately the idea of operators <strong><code>^^</code></strong> and <strong><code>::</code></strong> capturing this succinctly doesn't currently fit, because ^ does not pass through void... however, perhaps <code>^</code> and <code>^()</code> could be distinct in this manner)</em></p>
<pre><code>  for-both: lambda ['var blk1 blk2 body] [
      :: all [
          ^^ for-each (var) blk1 body
          ^^ for-each (var) blk2 body
      ]
  ]
</code></pre>
<p>Or maybe instead of META which doesn't contain the deisotoped non-nulls enough to keep them from "reacting", you could put things in blocks.  So NULL =&gt; NULL and VOID =&gt; VOID, but <code>_</code> =&gt; <code>[_]</code>, and by virtue of being in the box it's not falsey.  So box and unbox?</p>
<p>Or... maybe we just call the 2-meta form metaquote and unmetaquote, to emphasize that you are pushing things up through the level so it's quoted in order to truly stop the datatype from "reacting".  That could be a more semantic and less mechanical way of saying the same thing--without needing to allocate a series.</p>
<pre><code>  for-both: lambda ['var blk1 blk2 body] [
      unmetaquote all [
          metaquote for-each (var) blk1 body
          metaquote for-each (var) blk2 body
      ]
  ]
</code></pre>
<p>Another option would be using a version of ALL that only considered NULLs to be falsey.</p>
<pre><code>  for-both: lambda ['var blk1 blk2 body] [
      unmeta all/predicate [
          meta for-each (var) blk1 body
          meta for-each (var) blk2 body
      ] ^x -&gt; [not null? x]
  ]
</code></pre>
<p>Anyway...it's just sort of the price you pay for completeness, and having more than one signal for falseyness <em>(which is its own question... I can't say for sure that (1 = 2) shouldn't return NULL and BLANK!s shouldn't be truthy...sigh)</em></p>
<p><strong>It's just what happens when we can no longer guarantee that the only isotope that generates a falsey meta product is NULL.</strong></p>
</li>
<li>
<p>The handling of BAD-WORD! previously was geared toward system specific purposes, like ~null~ generating a <code>~null~ isotope</code> with special behaviors.  But under the generic scheme, ~null~ produces the null WORD! isotope...and people might have ideas for how to use that in some non-literal-sense of WORD! in a way different from the system ideas for ~null~ and ~void~ behaviors--where these applications could compete.</p>
<ul>
<li>
<p>It's not that different from saying "no, you don't have full control of ERROR! isotopes"... but WORD! is more foundational and it may have more obvious out-of-band signaling applications.</p>
</li>
<li>
<p>The system could take something less "in demand" like <strong><code>~@void~</code></strong> vs. <strong><code>~void~</code></strong>, but it feels a bit lame to be demoting the original purpose of "BAD-WORD!s"...they were supposed to be clean-looking precisely because they are of frequent concern when doing things ^META.</p>
</li>
<li>
<p>One strange idea would be to say that the system purposes actually make the BAD! states the ^META states, e.g. <strong>^(comment "hi")</strong> would give back <strong>~void~</strong>.  This would be an outlier, because there's no such thing as <strong><code>~~void~~</code></strong> to produce an isotopic bad-thing; it's merely a way of describing a state that has no other description.  So if you wanted to "unevaluate" it, you'd have to do that with <strong>(unmeta '~void~)</strong> or a reference to the <strong>void</strong> function itself to produce the outlier state.</p>
</li>
</ul>
</li>
</ul>
<p>So definitely no shortage of thinking points, here... <img src="../../images/emoji/twitter/exploding_head.png%3Fv=9" title=":exploding_head:" class="emoji" alt=":exploding_head:"></p>
<p>This worldview really requires you to get your head around the difference between "unevaluation" and "meta"...</p>
<ul>
<li>
<p>If you want to <em>unevaluate</em> a word! isotope of the word <strong><code>foo</code></strong>, then you need something that when evaluated will give you the isotope of the word foo.  So the unevaluation in this world would be <strong>~foo~</strong>.</p>
</li>
<li>
<p>If you want to <em>meta</em> a word! isotope of the word <strong><code>foo</code></strong>, then you get the plain (non-isotopic) word <strong>foo</strong> at quoting level 0.  If you choose to put that through normal evaluation, it will run the word as you would expect...looking up the value or function assigned to foo.</p>
</li>
</ul>
<p>Before, I was trying to make unevaluate=meta ... which gave that rule that "only things which evaluate to their own isotopes can be have isotopic forms".  That rule turned out to screw up things like ACTION!...which turn out to be more useful if they are invoked when evaluated.  And of course it can't work for things like WORD!, which need to do lookups in evaluation.</p>
<p>With unevaluation and meta becoming distinct, I don't know if we want to just say that QUOTE goes ahead and acts as unevaluation...e.g. quoting an isotope makes it BAD!, and the next steps above that make it quoted bad:</p>
<pre><code>&gt;&gt; ~foo~
== foo  ; isotope

&gt;&gt; meta ~foo~
== foo

&gt;&gt; meta meta ~foo~
== 'foo

&gt;&gt; quote ~foo~
== ~foo~

&gt;&gt; quote quote ~foo~
== '~foo~
</code></pre>
<p>The problem with this is that if you say QUOTE of something, and the result is not QUOTED!, that might feel wrong.  I don't know if that justifies introducing this separate term of UNEVALUATE/UNEVAL...but...arrgh, it probably does.</p>
        </div>

        <meta itemprop='headline' content='Should Everything Have an Isotopic Form?'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="0" />
           <span class='post-likes'></span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="1" />
          </div>

            <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../im-not-bad-im-just-mold-ed-that-way/1911.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/im-not-bad-im-just-mold-ed-that-way/1911'>
                      <span itemprop='name'>&quot;I&#39;m not BAD!...I&#39;m just MOLD-ed that way...&quot;</span>
                    </a>
                    <meta itemprop='position' content='3'>
                  </div>
            </div>
      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="1889.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2022-08-07T22:41:51Z'>
              <time itemprop='dateModified' datetime='2022-08-08T00:13:54Z' class='post-time'>
                August 8, 2022, 12:13am
              </time>
          <span itemprop='position'>#6</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="1889">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This worldview really requires you to get your head around the difference between "unevaluation" and "meta"...</p>
</blockquote>
</aside>
<p>So we could unify "unevaluation" and "meta"... if when you receive an isotopic value as a ^META argument it will be BAD!.</p>
<p>This actually resembles the status quo where there were "bad-word! isotopes", e.g.:</p>
<pre><code>&gt;&gt; ~foo~
== ~foo~  ; isotope (vs. plain WORD! of `foo` isotope)
</code></pre>
<p>In this model, there would be no WORD! isotopes, or ACTION! isotopes...just BAD! WORD! isotopes, and BAD! ACTION! isotopes (etc.)  Example for INTEGER!:</p>
<pre><code>&gt;&gt; ~1~
== ~1~  ; isotope (vs. plain INTEGER! of `1` isotope)

&gt;&gt; meta ~1~
== ~1~
</code></pre>
<h2>A ^META Parameter Could Thus Only be One of 3 Things</h2>
<ul>
<li>
<p>A NULL if the input was NULL</p>
</li>
<li>
<p>A QUOTED! if the input was normal (this would cover if the input was "normal bad", e.g. just some random <strong><code>~foo~</code></strong> value picked out of a block, this would be received as <strong>'~foo~</strong>).</p>
</li>
<li>
<p>A BAD! if the input was isotopic (e.g. the input was both isotopic and bad, as this is proposing that's the only kind of isotope)</p>
<ul>
<li><em>Reminder: This naming concept of "BAD!" is very much <a href="../im-not-bad-im-just-mold-ed-that-way/1911.html">open for suggested alternatives</a>.</em></li>
</ul>
</li>
</ul>
<h2>This Would Mean META Would Be the Same As UNEVAL</h2>
<p>Dropping UNEVAL as a separate concern sounds good on the surface. This lets us have generic isotopes -and- gets us back to the following being a no-op, regardless of VAR's initial state:</p>
<pre><code>temp: ^var
do [var: (temp)]
</code></pre>
<p>Plus, if BAD! values acted like quoteds and were always considered truthy (even a BAD! LOGIC! of false or a BAD! BLANK!) this would put NULL back as being the only falsey state for a ^META value.  So things like FOR-BOTH would still work as expected with the following implementation, where NULL would be the only loop result to lead to breaking:</p>
<pre><code>    for-both: lambda ['var blk1 blk2 body] [
        unmeta all [
            meta for-each (var) blk1 body
            meta for-each (var) blk2 body
        ]
    ]
</code></pre>
<p>That's one of the pinnacles of the Ren-C design...and I certainly place importance on not making that any uglier.</p>
<h2>Sounds Pretty Good... Anything Wrong With It?</h2>
<p>(...Insert usual reminder of <em>"essential complexity can't be erased, only redistributed"</em> here...)</p>
<p>Once you've ^META'd something, you get something you always have to unwrap (if it's not null).  And you can't directly UNMETA things without wrapping them up in BAD! first.</p>
<p>Getting more unwrappings and wrappings involved may be the right number to have--but it gets a little more awkward.</p>
<p><em><strong>Think of the perspective of the author of something like SPREAD</strong></em>...</p>
<p>SPREAD wants to take in a BLOCK! and make an isotope out of it.  This used to be as simple as <strong>unmeta block</strong> on its argument.  But now BLOCK! represents the bottom of the META pile (as it is the bottom-most QUOTE level).  You'd have to do something morally equivalent to <strong>unmeta make bad! block</strong>, because only BAD! can be unmeta'd below quoting level 0.</p>
<p>(unless you're willing to make UNMETA return something that wouldn't META back to what you gave it initially, e.g. UNMETA of plain BLOCK! gives you an isotopic bad block, where META'ing that gives a bad-block.  That doesn't sound good.)</p>
<p>This side-step SPREAD takes onto "the bad path" won't ever come back to BLOCK! through meta and unmeta operations alone.  Because that bad block isotope will be meta'd to a plain bad block, and then up to a quoted bad block and so forth.</p>
<p><em><strong>Then think of the perspective of the author of something like APPEND</strong></em>...</p>
<p>APPEND has decided to take a ^META argument for the appended value instead of a normal one.  The reason is because it wants to differentiate spliced BLOCK! from plain BLOCK!.</p>
<p>Now you get either a QUOTED! block or a BAD! block... it's in a container in both cases, and you have to get it out.  Either UNQUOTE or UNMETA will get you back your plain block from the QUOTED!, but neither will extract the block from the BAD!, so what will?</p>
<p><em>(So it's pretty clear that we can't be calling these things "bad"... fully legitimate code with branches testing for this wouldn't make any sense.)</em></p>
<h2>It's A Somewhat Tough Call</h2>
<p>It seemed a nice property of ^META that since there were no quoted isotopes, we really could look directly at the result of a ^META and know any non-quoted thing implied the original input was isotopic.</p>
<pre><code>[^x]: something then [
    if quoted? x [x: unquote x, handle x]
    else [handle x]
] else [
   ; null handling
]
</code></pre>
<p>Arguably it's just one more step:</p>
<pre><code>[^x]: something then [
    if quoted? x [x: unquote x, handle x]
    else [x: unbad x, handle x]
] else [
   ; null handling
]
</code></pre>
<h2>I Feel Like I'm Just Going to Have To Try It</h2>
<p>It's sort of too hard to pre-reason about this.  There are enough advantages to certainly make it worth a shot.</p>
<p>So I'm going to try the version where all isotopes are also "bad" and see how awkward it is, and what sorts of patterns emerge.  I'll keep it as fluid as possible, so the C code will say things like Is_Meta_Of_Splice() instead of Is_Bad_Block(), so it will be easier to change if it turns out to be wrong.</p>
        </div>

        <meta itemprop='headline' content='Should Everything Have an Isotopic Form?'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="1" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="1889.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2022-08-09T09:47:47Z'>
              <time itemprop='dateModified' datetime='2022-08-09T09:49:04Z' class='post-time'>
                August 9, 2022,  9:49am
              </time>
          <span itemprop='position'>#7</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <hr>
<p><em>Arrgh.</em></p>
<p><em>The goal here is to make pleasing parts that compose well, letting novices build clever language constructs out of solid-feeling bricks.  By this point I shouldn't have to stress that this is <em>really</em>, <em>really</em> hard to make simple.</em></p>
<p><img src="../../images/emoji/twitter/face_with_head_bandage.png%3Fv=9" title=":face_with_head_bandage:" class="emoji only-emoji" alt=":face_with_head_bandage:"></p>
<p><em>But...slogging through it some more...</em></p>
<hr>
<aside class="quote no-group" data-username="hostilefork" data-post="6" data-topic="1889">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>So we could unify "unevaluation" and "meta"... if when you receive an isotopic value as a ^META argument it will be BAD!.</p>
</blockquote>
</aside>
<p>As I've mentioned, this doesn't make <em>everything</em> easier...it introduces a level of unwrapping whether you are dealing with something that was isotopic or if it was plain.</p>
<p>But the fact is that fully generic quoting--including of isotopic things--isn't just useful, it's foundational.  And things like the META-WORD! fuse together accessing a potentially isotopic value with a quoting operation.  If QUOTE and META were <em>not</em> mostly the same thing conceptually, we'd be hard pressed to make a quoted isotope... <em>even if we allowed QUOTE to take isotopes as parameters</em>, because getting those isotopes would be a challenge.</p>
<p>To demonstrate: let's say META decided to go its own way and <em>not</em> give back something that would evaluate back to the isotope.  But QUOTE decided it would take isotopes, and give you back something that evaluated to an isotope (effectively becoming "UNEVAL"):</p>
<pre><code>&gt;&gt; ~something~
== something  ; isotope

&gt;&gt; meta ~something~
== something

&gt;&gt; quote ~something~
== ~something~
</code></pre>
<p>So META's result can be used without unboxing it, while QUOTE's result is ready to be poked into a COMPOSE or something of that sort.  Different purposes, so maybe okay, right?</p>
<p>But there's a META-WORD! but no corresponding operator that means "make quoted" (a quoted word just means "<em>be</em> quoted").  So you've got a pretty big feature gap</p>
<pre><code> &gt;&gt; x: ~something~
 == something  ; isotope

 &gt;&gt; ^x
 == something

 &gt;&gt; quote x
 ** Error: x is a WORD! isotope, use ^x to access it
</code></pre>
<p>You'd have to get awkward:</p>
<pre><code> &gt;&gt; quote unmeta ^x
 == ~something~

 &gt;&gt; quote get/any 'x
 == ~something~
</code></pre>
<p><strong>This shows a pretty big pain point for having the ^META meanings and QUOTE meanings divergent... <em>not just the mechanical pain</em>, but the <em>conceptual pain</em> of understanding what the heck is going on here.</strong></p>
<p><strong>So I'm getting fairly certain we'll have to accept the situation of saying that ^META of isotopes are wrapped up in the thing I am currently calling "BAD!" <sub>(but clearly it shouldn't be called that)</sub></strong></p>
<pre><code>&gt;&gt; x: ~something~
== ~something~  ; isotope

&gt;&gt; ^x
== ~something~
</code></pre>
<h2>...But What About The NULL Situation?</h2>
<p>When I suggested making ^META of something like a word isotope be a ~word~ instead of plain word, I claimed it had an advantage...such as by making it easier to use in something like COMPOSE to reconstitute the original variable back:</p>
<pre><code>temp: ^var
do compose [var: (temp)]
</code></pre>
<p>But there's the twist that META of NULL is NULL.  So that COMPOSE will complain about it (which is good, it forces you to decide what you really meant, and if that was a special case missing handling).</p>
<p>You can't solve this by putting a quote mark on the group in the compose, because that will mess up non-NULL values:</p>
<pre><code>temp: ^var
do compose [var: '(temp)]  ; if var starts as foo, it will wind up as 'foo
</code></pre>
<p>Quoting produces a standalone tick mark instead of a NULL for a NULL input, which provides the necessary properties of being both reified (so it can be in a block) and reproducing null in evaluation:</p>
<pre><code>&gt;&gt; quote null
== '

&gt;&gt; '
== null
</code></pre>
<p>But a quoted null (single tick mark) does not trigger ELSE and isn't falsey.</p>
<h2>For Completeness: What About A (NULL =&gt; ') Construct?</h2>
<p>If QUOTE and META were similar in all other aspects, we could add a missing construct to fill in this gap.  Something that turned NULL into a single quote and passed through all BAD! and QUOTED! as-is.</p>
<p>Blunt name for starters...<strong>nullquote</strong>.  For the moment, we will imagine it's tailored to fit this situation, and will warn you if the thing it's spitting out as a result can't be UNMETA'd:</p>
<pre><code>&gt;&gt; nullquote null
== '

&gt;&gt; nullquote first ['3]
== '3

&gt;&gt; nullquote &lt;something&gt;
** Error: NULLQUOTE only accepts BAD!, QUOTED!, and NULL
</code></pre>
<p>The concept would be you could combine this with <strong><code>^var</code></strong> to turn it into a generalized "unevaluate" operation that could also work in COMPOSE scenarios:</p>
<pre><code>temp: nullquote ^var
do compose [var: (temp)]
</code></pre>
<p>-or-</p>
<pre><code>temp: ^var
do compose [var: (nullquote temp)]
</code></pre>
<p>You could also try being explicit:</p>
<pre><code>do compose [var: (temp else [the '])]

do compose [var: (temp else [''])]

do compose [var: (temp else [quote null])]
</code></pre>
<p>The current idea behind REIFY is that it would produce <strong>~null~</strong> out of a NULL.  It doesn't produce a quoted null because it's trying to put in a placeholder that represents the idea of a non-quoted null (which isn't possible, so that's why it makes a visibly jarring choice).  But in the case of these assignments under evaluation, it would produce an isotopic null and do the correct thing.</p>
<h2>What About The Reverse... (' =&gt; NULL) ... nulldequote?</h2>
<p>If we made the ^META operations never return NULL, then that produces a different situation:</p>
<pre><code>&gt;&gt; x: null

&gt;&gt; ^x
== '

&gt;&gt; nulldequote ^x
; null
</code></pre>
<p><strong>It should be obvious that the other way around is preferable.</strong></p>
<p>META'ing defaulting NULL =&gt; NULL has systemic benefits.  I'll play the broken record about FOR-BOTH:</p>
<pre><code>for-both: lambda ['var blk1 blk2 body] [
    unmeta all [
        meta for-each (var) blk1 body
        meta for-each (var) blk2 body
    ]
]
</code></pre>
<p>Just in general, being able to find out if an operation--even a ^META one--is NULL is a good test.</p>
<h2>Conclusions</h2>
<p><img src="../../images/emoji/twitter/question.png%3Fv=9" title=":question:" class="emoji only-emoji" alt=":question:"> <img src="../../images/emoji/twitter/question.png%3Fv=9" title=":question:" class="emoji only-emoji" alt=":question:"> <img src="../../images/emoji/twitter/question.png%3Fv=9" title=":question:" class="emoji only-emoji" alt=":question:"></p>
<p><strong>It's clear that diligence is needed to reduce the total number of concepts in play--to the extent possible--without sacrificing functionality.</strong></p>
<ul>
<li>
<p>I was a bit spooked by the possibility of having <em>three</em> distinct concepts: QUOTING, META, and UNEVAL... all doing similar but slightly different things.</p>
<ul>
<li>Unifying QUOTE and UNEVAL has the somewhat uncomfortable consequence of saying that the result of QUOTE isn't always a QUOTED! thing.</li>
</ul>
</li>
<li>
<p>So I suggested making META on isotopes give back something that when evaluated would produce the isotope back.</p>
<ul>
<li>
<p>This meant the META of something like an isotopic WORD! could not be a WORD!, because that would not evaluate back to an isotope...it would have to be in a wrapper (the BAD! wrapper, indicated by <code>~&lt;leading and trailing tildes&gt;~</code></p>
</li>
<li>
<p>This allowed NULL to be the only falsey output from META, so long as this wrapper type would be truthy even if it was a wrapped BLANK! or wrapped LOGIC! false.</p>
</li>
</ul>
</li>
<li>
<p>That mostly nixes the need for UNEVAL, but with a loophole surrounding NULL behavior when the unevaluated thing was to be used in something like a COMPOSE</p>
<ul>
<li>
<p>As an edge case, it doesn't seem too horrific...especially since NULLs now tend to raise errors to draw attention to improper uses.</p>
</li>
<li>
<p>If you can turn a NULL into a quoted null (<code>'</code>) one way or another, the loophole is filled in the cases where it matters.</p>
</li>
</ul>
</li>
</ul>
<h2>Now Needed: More Techniques, and Better Names</h2>
<p>So if ^META is going to be coming back BAD! or QUOTED! or NULL... then there's going to have to be some ways of dealing with this.</p>
<p>I feel like there needs to be some sort of mechanic to make this pattern easier:</p>
<pre><code> x: ^(some operation)
 switch type of x [
     null [...process null case...]
     bad! [x: unbad x, ...process isotope case...]
     quoted! [x: unquote x, ...process normal case...]
 ]
</code></pre>
<p><em>(And of course UNBAD is terrible.  I wondered if maybe ~asdf~ could be called a "semiquoted" or "quasiquoted" WORD!, so that UNQUOTE could be used to remove the ~'s from it.  But that probably just makes things more confusing instead of less (and introduces '''~asdf~ as a "quoted quasiquoted word")</em></p>
<p>We've got a few options:</p>
<pre><code> (some operation) then ^x -&gt; [
     if quoted? x [
         x: unquote x, ...process normal case...
     ] else [
         x: unbad x, ...process isotope case...
     ]
 ] else [
     ...process null case...
 ]
</code></pre>
<p><strong>Anyway, this looks like where things are at right now, and is what has to be improved upon.</strong>  The rationale feels pretty sound.  Guess it just needs to develop from here.</p>
        </div>

        <meta itemprop='headline' content='Should Everything Have an Isotopic Form?'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="0" />
           <span class='post-likes'></span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

            <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../questions-about-wrapped-things-quoted-quasi/1916.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/questions-about-wrapped-things-quoted-quasi/1916'>
                      <span itemprop='name'>Questions About &quot;Wrapped&quot; Things (QUOTED!, QUASI!)</span>
                    </a>
                    <meta itemprop='position' content='1'>
                  </div>
            </div>
      </div>






    </div>
    <footer class="container wrap">
      <nav class='crawler-nav'>
        <ul>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/' itemprop="url">Home </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/categories' itemprop="url">Categories </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/guidelines' itemprop="url">FAQ/Guidelines </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
        </ul>
      </nav>
      <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
    
  </body>
  
</html>

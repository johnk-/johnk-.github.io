<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>True, False, On, Off, Yes, No...? - Datatypes - AltRebol</title>
    <meta name="description" content="UPDATE: This thread led to the conclusion to not treat ON, OFF, YES, NO as synonyms for TRUE and FALSE, but instead rethink the paradigm as what we are calling &amp;quot;Flexible Logic&amp;quot;.  In this system, plain WORD!s are used to &amp;hellip;">
    <meta name="generator" content="Discourse 3.4.0.beta3-dev - https://github.com/discourse/discourse version 93983286b54a0e96b8073abce23f4566e9f296f7">
<link rel="icon" type="image/png" href="../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" media="all" content="#ffffff">

<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="2250.html" />

<link rel="search" type="application/opensearchdescription+xml" href="../../opensearch.xml" title="AltRebol Search">

    <link href="https://forum.rebol.info/stylesheets/color_definitions_base__2_b36da8919caf93960d3b4470a90d0e79c6a110e2.css?__ws=forum.rebol.info" media="all" rel="stylesheet" class="light-scheme"/>

  <link href="https://forum.rebol.info/stylesheets/desktop_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop"  />



  <link href="https://forum.rebol.info/stylesheets/chat_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="chat"  />
  <link href="https://forum.rebol.info/stylesheets/checklist_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="checklist"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-details_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-details"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-lazy-videos_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-lazy-videos"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-local-dates_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-local-dates"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-narrative-bot_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-narrative-bot"  />
  <link href="https://forum.rebol.info/stylesheets/discourse-presence_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="discourse-presence"  />
  <link href="https://forum.rebol.info/stylesheets/docker_manager_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="docker_manager"  />
  <link href="https://forum.rebol.info/stylesheets/footnote_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="footnote"  />
  <link href="https://forum.rebol.info/stylesheets/poll_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="poll"  />
  <link href="https://forum.rebol.info/stylesheets/spoiler-alert_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="spoiler-alert"  />
  <link href="https://forum.rebol.info/stylesheets/chat_desktop_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="chat_desktop"  />
  <link href="https://forum.rebol.info/stylesheets/poll_desktop_eb475c67ca07665cb858ddf2ea6c953c2e3e2b85.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="poll_desktop"  />

  <link href="https://forum.rebol.info/stylesheets/desktop_theme_2_bac9ab3eace9fe3f17026a3c4dbf25e3e9e1e9a0.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2" data-theme-name="default"/>

    
    
        <link rel="alternate nofollow" type="application/rss+xml" title="RSS feed of &#39;True, False, On, Off, Yes, No...?&#39;" href="2250.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://forum.rebol.info/t/true-false-on-off-yes-no/2250" />
<meta name="twitter:url" content="https://forum.rebol.info/t/true-false-on-off-yes-no/2250" />
<meta property="og:title" content="True, False, On, Off, Yes, No...?" />
<meta name="twitter:title" content="True, False, On, Off, Yes, No...?" />
<meta property="og:description" content="UPDATE: This thread led to the conclusion to not treat ON, OFF, YES, NO as synonyms for TRUE and FALSE, but instead rethink the paradigm as what we are calling &quot;Flexible Logic&quot;.  In this system, plain WORD!s are used to represent boolean states that indiscriminately take branches in things like IF...and NULL is the only state that inhibits branching.   Historical Rebol does this definition:  on:  true off: false yes: true no:  false  And Red carried it forward.  Whether it&#39;s good or bad, I don&#39;t..." />
<meta name="twitter:description" content="UPDATE: This thread led to the conclusion to not treat ON, OFF, YES, NO as synonyms for TRUE and FALSE, but instead rethink the paradigm as what we are calling &quot;Flexible Logic&quot;.  In this system, plain WORD!s are used to represent boolean states that indiscriminately take branches in things like IF...and NULL is the only state that inhibits branching.   Historical Rebol does this definition:  on:  true off: false yes: true no:  false  And Red carried it forward.  Whether it&#39;s good or bad, I don&#39;t..." />
<meta property="og:article:section" content="Development" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="og:article:section" content="Datatypes" />
<meta property="og:article:section:color" content="25AAE2" />
<meta property="og:article:tag" content="isotopes" />
<meta name="twitter:label1" value="Reading time" />
<meta name="twitter:data1" value="11 mins ðŸ•‘" />
<meta name="twitter:label2" value="Likes" />
<meta name="twitter:data2" value="2 â¤" />
<meta property="article:published_time" content="2024-09-04T10:38:37+00:00" />
<meta property="og:ignore_canonical" content="true" />


    
  </head>
  <body class="crawler ">
    
    <header>
  <a href="https://forum.rebol.info/">
    AltRebol
  </a>
</header>

    <div id="main-outlet" class="wrap" role="main">
        <div id="topic-title">
    <h1>
      <a href="2250.html">True, False, On, Off, Yes, No...?</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/development/datatypes/45" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/development/datatypes/45" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Datatypes</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

      <div class="topic-category">
        <div class='discourse-tags list-tags'>
            <a href='../../tag/isotopes.html' class='discourse-tag' rel="tag">isotopes</a>
        </div>
      </div>
  </div>

  

    <div itemscope itemtype='http://schema.org/DiscussionForumPosting'>
      <meta itemprop='headline' content='True, False, On, Off, Yes, No...?'>
      <link itemprop='url' href='2250.html'>
      <meta itemprop='datePublished' content='2024-09-04T10:38:37Z'>
        <meta itemprop='articleSection' content='Datatypes'>
      <meta itemprop='keywords' content='isotopes'>
      <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
        <meta itemprop='name' content='AltRebol'>
          <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
            <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
          </div>
      </div>


          <div id='post_1'  class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>

                <link itemprop="mainEntityOfPage" href="2250.html">


              <span class="crawler-post-infos">
                  <time  datetime='2024-09-04T10:38:37Z' class='post-time'>
                    September 4, 2024, 10:38am
                  </time>
                  <meta itemprop='dateModified' content='2024-09-06T02:08:15Z'>
              <span itemprop='position'>1</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p><em><strong>UPDATE:</strong> This thread led to the conclusion to not treat ON, OFF, YES, NO as synonyms for TRUE and FALSE, but instead rethink the paradigm as what we are calling <strong><a href="../flexible-logic-system-terminology/2252.html">"Flexible Logic"</a></strong>.  In this system, plain WORD!s are used to represent boolean states that indiscriminately take branches in things like IF...and NULL is the only state that inhibits branching.</em></p>
<hr>
<p>Historical Rebol does this definition:</p>
<pre><code>on:  true
off: false
yes: true
no:  false
</code></pre>
<p>And Red carried it forward.  Whether it's good or bad, I don't know (my instinct is to say bad).  I do know that it's lossy.</p>
<pre><code>red&gt;&gt; on
== true  ; not a word, but a misleading display of #[true]
</code></pre>
<p>Ren-C has the opportunity to do something different.</p>
<pre><code>&gt;&gt; on: ~on~
== ~on~  ; anti

&gt;&gt; off: ~off~
== ~off~  ; anti

&gt;&gt; yes: ~yes~
== ~yes~  ; anti

&gt;&gt; no: ~no~
== ~no~  ; anti
</code></pre>
<p>And then these WORD! antiforms could be treated as truthy and falsey as appropriate.  Negation could preserve the form:</p>
<pre><code>&gt;&gt; not yes
== ~no~ ; anti
</code></pre>
<p>Does it have value?  <img src="../../images/emoji/twitter/thinking.png%3Fv=12" title=":thinking:" class="emoji" alt=":thinking:" loading="lazy" width="20" height="20">  Well, my instincts are that if there is any value to have in defining these, that value arises from having them be differently-typed logic-like things.  e.g. a function that took ON and OFF would <em>not</em> take YES and NO.</p>
<pre><code>&gt;&gt; security-system on
The security system is now activated.

&gt;&gt; security-system false
** Error: What are you talking about?
</code></pre>
<h2><a name="p-7560-does-this-buy-you-anything-1" class="anchor" href="2250.html#p-7560-does-this-buy-you-anything-1"></a>Does This Buy You Anything?</h2>
<p>What you get here is a little bit of friction on the callsite if your decision comes direct from math:</p>
<pre><code>&gt;&gt; security-system (user = 'Ron)
** Error: security-system requires TOGGLE! as enable argument, not ~true~
</code></pre>
<p>So you have to write something more laborious:</p>
<pre><code>&gt;&gt; security-system (either user = 'Ron [on] [off])
The security system is now activated.
</code></pre>
<p>At which point you might ask what the advantage is here over just using the words ON and OFF.</p>
<p>The advantages I see are:</p>
<ul>
<li>
<p>Callsite doesn't have to quote ON and OFF like <code>(either user = 'Ron ['on] ['off])</code></p>
</li>
<li>
<p>Once arguments are received, callee can use conditionals like IF and CASE and such directly:</p>
<pre><code>if enable [...]
</code></pre>
<p>...instead of...</p>
<pre><code>if enable = 'on [...]
</code></pre>
</li>
<li>
<p>You preserve the semantically correct word in the antiform, so you can see it in that form in debug output, and generalized print routines can extract them, e.g. TO WORD! gets you the word you want instead of just TRUE and FALSE</p>
</li>
<li>
<p>You're letting people guide the callsites to use clearer terms with some amount of enforcement, instead of permitting yes and true where ON is intended</p>
</li>
<li>
<p>FWIW the words are shorter.  <strong>false</strong> is 5 letters while <strong>no</strong> is just 2</p>
</li>
</ul>
<h2><a name="p-7560-how-valuable-is-it-2" class="anchor" href="2250.html#p-7560-how-valuable-is-it-2"></a>How Valuable Is It?</h2>
<p>Infinitely moreso than just defining them to true and false.  (Mostly because any amount is more useful than zero.)</p>
<p>I started this out as devil's advocacy, but I think I've actually talked myself into it.  It's pretty cool.</p>
<h2><a name="p-7560-naming-the-types-3" class="anchor" href="2250.html#p-7560-naming-the-types-3"></a>Naming The Types</h2>
<p>Uh, YES-NO? and ON-OFF? kind of suck, like calling logic TRUE-FALSE? would suck.  But they're clear.</p>
<p>I asked Claude for thoughts:</p>
<blockquote>
<p>These are some interesting ideas for expanding the concept of boolean types. Let's break down the potential names and rationales:</p>
<ol>
<li>
<p>BOOLEAN! or LOGIC! for TRUE/FALSE</p>
<ul>
<li>This is the standard name, representing traditional boolean logic.</li>
</ul>
</li>
<li>
<p>SWITCH! or TOGGLE! for ON/OFF</p>
<ul>
<li>
<p>These names capture the idea of a binary state that can be flipped.</p>
</li>
<li>
<p>SWITCH! might be slightly more intuitive as it's commonly used in programming and everyday language.</p>
</li>
</ul>
</li>
<li>
<p>CONFIRM! or RESPONSE! for YES/NO</p>
<ul>
<li>
<p>CONFIRM! does indeed capture the essence of affirmation or negation.</p>
</li>
<li>
<p>RESPONSE! could work too, as it implies an answer to a question.</p>
</li>
</ul>
</li>
</ol>
<p>Your suggestion of YES-NO! and ON-OFF! as type names is also valid, though they might be less conventional in programming language design.</p>
<p>The key aspect of your proposal is that these types, while similar in their binary nature, are distinct and not interchangeable. This could lead to more precise and context-specific code, but it might also increase complexity.</p>
</blockquote>
<p>I like <strong>[TOGGLE?]</strong> and <strong>[CONFIRM?]</strong></p>
<p>But your type check can use quasiforms as a proxy for antiforms, e.g. <strong>[~yes~ ~no~]</strong>, and that may be about as clear.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_2' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-09-04T20:34:51Z' class='post-time'>
                    September 4, 2024,  8:34pm
                  </time>
                  <meta itemprop='dateModified' content='2024-09-04T20:34:51Z'>
              <span itemprop='position'>2</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2250">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="../../user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Whether it's good or bad, I don't know (my instinct is to say bad).</p>
</blockquote>
</aside>
<p>Part of my negative impression of it comes from Rebmake, where Shixin felt like he wanted to support the natural words, but could not require it.  He wound up with things like this:</p>
<pre><code>append flags spread switch rigorous [
    true 'yes 'on 'true [
       ...
    ]
    false 'no 'off 'false [
        ...
    ]
]
</code></pre>
<p>The situation here is that the configuration data is sometimes coming from evaluative contexts (a config file that is running code assigning objects to members, <strong><code>(rigorous: yes)</code></strong> and sometimes non-evaluative contexts (e.g. a string on the command line like <strong><code>"rigorous: true"</code></strong>)  If the context was evaluative then the nuance between yes/no/on/off/true/false is lost.  If it's non-evaluative you still have the word.</p>
<p>My feeling would be that the config file should be written to the same convention to bring it in sync with what you get from the command line, so <strong><code>(rigorous: 'yes)</code></strong>.  Getting all the code on the same page is worth using the apostrophe for a "dialected" word.  It's the better tradeoff.</p>
<p>But that aside... I didn't like the fact that <em>all</em> the words had to be tolerated.  It just makes a mess.</p>
<p>So this is where part of my bias that they shouldn't be synonyms comes from.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2250">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="../../user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>How Valuable Is It?</p>
</blockquote>
</aside>
<p>I am liking the distinction of ON and OFF.  It communicates more about what the toggle is doing.</p>
<pre><code>symbols: on
</code></pre>
<p>...as opposed to...</p>
<pre><code>symbols: true
</code></pre>
<p>That has a nuance to it that I think is valuable.  And it feels easy and natural to me to tell which things are ON/OFF vs. TRUE/FALSE.   <strong><code>recycle false</code></strong> vs. <strong><code>recycle off</code></strong> has a clear winner.</p>
<p>I don't have the same confidence about YES/NO vs. TRUE/FALSE.  Having lived in a world of just true and false for so long I honestly can't tell if they're actually a good default.</p>
<pre><code>&gt;&gt; 1 &gt; 2
== ~no~  ; anti

&gt;&gt; 1 &lt; 2
== ~yes~  ; anti
</code></pre>
<p>That seems pretty natural.  But true and false are rather ingrained.</p>
<p>Anyway, it is hazy to me where YES and NO have enough benefit to justify not just being able to use boolean logic expressions to pass the value.  But I definitely see the value of ON and OFF.</p>
<p>I'll continue to experiment and see how my feelings evolve.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_3' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-09-04T20:49:31Z' class='post-time'>
                    September 4, 2024,  8:49pm
                  </time>
                  <meta itemprop='dateModified' content='2024-09-05T10:02:20Z'>
              <span itemprop='position'>3</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="hostilefork" data-post="2" data-topic="2250">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="../../user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p><strong><code>recycle false</code></strong> vs. <strong><code>recycle off</code></strong> has a clear winner.</p>
</blockquote>
</aside>
<p>The one point here though, is that switches tend to expand.  Like new modes get added, to where you might expect there to be not just ON and OFF but some distinctions like HIBERNATING or whatever.</p>
<p>And when the instructions expand, the new instructions have to be quoted as words, for <strong><code>recycle 'infrequent</code></strong>.  Then you have the issue of just ON and OFF standing out as being able to be not quoted, and it's inconsistent.</p>
<p>This is something I wrote about a long time ago (2017):</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="303">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="../../user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"><a href="../a-lingering-feeling-rebol-may-not-want-a-logic-type-at-all/303/1.html">A lingering feeling: Rebol may not want a LOGIC! type at all</a></div>
<blockquote>
<p>In trying to square this circle, I've had a nagging feeling in my mind that LOGIC! as a primitive type in Rebol may be just a bad idea in general. Rebol is a messaging language, so what if in my message for calendar appointments I have a ternary set of words like "yes / no / maybe"...if I want to capture that then why is my problem so different if it's just "yes / no" or "true / false"?</p>
</blockquote>
</aside>
<p>So my fear is that once you go into something semantic like ON and OFF, that jump into the semantic realm may be just the beginning.  And letting you not quote the words may in the long run lead to having an inconsistent interface when your semantics expand.</p>
<h2><a name="p-7564-back-to-where-this-line-of-thinking-has-always-led-1" class="anchor" href="2250.html#p-7564-back-to-where-this-line-of-thinking-has-always-led-1"></a>Back To Where This Line Of Thinking Has Always Led...</h2>
<p>...ever since 2017 (and before), which is that there is no LOGIC! type, and you instead say:</p>
<pre><code>some-flag: 'true

if true? some-flag [...]
</code></pre>
<p>And then what gets returned by TRUE? is either NULL or some canon "you should take the branch" value (I'll avoid calling that "truthy").  It could be rigged so that TRUE? and FALSE? accept only TRUE and FALSE words.</p>
<pre><code>&gt;&gt; true? 'true
== #  ; or whatever...as long as it's not ~null~ antiform (or ~NaN~ antiform...)

&gt;&gt; true? 'false
== ~null~  ; anti

&gt;&gt; true? 10
** Error: TRUE? and FALSE? tests only work on TRUE and FALSE words

&gt;&gt; logic? 'false
== #

&gt;&gt; logic? 10
== ~null~  ; anti
</code></pre>
<p>Actually...<a href="../the-truthiness-of-nothing/2180.html">now that NOTHING is truthy</a>, I can see definite advantages to making it the canon "run the branch" value.  This means it's good enough for comparisons that aren't being stored in a value:</p>
<pre><code>&gt;&gt; 10 &lt; 20

&gt;&gt; if 10 &lt; 20 [print "Good enough for this."]
Good enough for this.
</code></pre>
<p>But if you store it in a variable, it unsets it.  That's a good way of saying you didn't triage it into some sort of reified state, which would be friendly to rendering and putting in blocks etc.</p>
<pre><code>&gt;&gt; flag: 10 &lt; 20

&gt;&gt; if flag [print "You triaged it into a meaningful reified state"]
** Error: Flag is ~ antiform (unset variable)
</code></pre>
<p>So instead you'd have to write:</p>
<pre><code>&gt;&gt; flag: either 10 &lt; 20 ['true] ['false]
== true

&gt;&gt; flag: to-logic 10 &lt; 20
== true

&gt;&gt; flag: boolean 10 &lt; 20  ; fewer characters, no hyphen
== true 

&gt;&gt; flag: bool 10 &lt; 20  ; abbreviation for those who want it
== true
</code></pre>
<p>Bummer here is still that if you leave off the TRUE? test in <strong>if true?</strong> then your FALSE state will run the branch, because all reified values are non-null.  But with the interplay of LOGIC!s sometimes being words (or sometimes being quasiforms) you were always at risk of that.  This just bites the bullet and tells you to learn the new and consistent way.</p>
<p>If you're starting from scratch learning the language you can be taught that IF just tests for non-nullness.  That's all it does.  If you <em>know</em> that's all it does--and it's ingrained to you from the beginning--then you will know that you have to say <strong>if blank?</strong> or <strong>if trash?</strong> or <strong>if true?</strong> or <strong>if false?</strong> etc. etc.    You won't expect it to test flags.</p>
<p>Furthermore: <strong><code>if flag</code></strong> now has a distinct meaning.  It means "if the flag has been assigned a value--including either true or false".  That is useful in its own right if one has learned it this way, and if you read it simply as "if flag is not null" it is actually quite obvious.  When you're trained to read it that way, that's what you'll see it as.</p>
<h2><a name="p-7564-a-new-idea-but-a-learnable-one-2" class="anchor" href="2250.html#p-7564-a-new-idea-but-a-learnable-one-2"></a>A New Idea.  But a <em>Learnable</em> One.</h2>
<p><strong>It appears to be the better long-tail path for a Rebol in which we've seen the tension between words and non-reifyable states (or undesirably ugly reifyable states) causing catastrophic consequences in the code.</strong></p>
<ul>
<li>
<p>It applies absolutely everywhere else (including BLANK? now, as it too causes branches to run).</p>
</li>
<li>
<p>There'd never be a confusion between the "fetched state" of a LOGIC! and the WORD! of the LOGIC <em>because the WORD! is the logic</em>.</p>
</li>
<li>
<p>The new "run the branch" signaling of NOTHING turns the arbitrary choice of what logic expressions return for true into something non-arbitrary.  It serves a purpose in calling attention to non-triaged results being used as variables.</p>
</li>
<li>
<p><strong><code>if flag</code></strong> becomes a new and interesting test, to help discern an unassigned flag (one that is null) from one that has been assigned a value (either TRUE or FALSE, or whatever else).</p>
<ul>
<li>Someone learning Ren-C from scratch would learn that meaning and read it for that meaning, not expecting it to test for true or false.</li>
</ul>
</li>
<li>
<p>Rendering the TRUE and FALSE "enum states" becomes as natural as any other word, and the states can expand without requiring a difference in handling.</p>
</li>
<li>
<p>You can put the currency we use for representing logic into a BLOCK!</p>
<ul>
<li><a href="../why-theres-no-boolean-type-storable-in-a-block/2095.html">@bradrn would be happy that what we use to represent logic would not be an antiform.</a></li>
</ul>
</li>
<li>
<p>With TRUE and FALSE being themselves "take the branch" signals, they can both drop out of things like ANY or ALL verbatim.</p>
<pre><code>flag: update all [
     threshold &gt; maximum
     even? number-of-variants
     'false
]  ; result could never be false before, always null
</code></pre>
</li>
<li>
<p>We can dismiss with this question of ON OFF YES NO antiforms.  All of them (as well as TRUE and FALSE) would be undefined.</p>
</li>
</ul>
<p>And if people get exposed to things like <strong><code>either 10 &lt; 20 ['true] ['false]</code></strong> early on, it might train their brain to start thinking about all the possibilities Rebol has to offer them for expression.  It's a pattern with a smooth slope toward getting more out of the representation and out of the language.</p>
<h2><a name="p-7564-my-2017-self-may-have-known-more-than-my-2022-self-3" class="anchor" href="2250.html#p-7564-my-2017-self-may-have-known-more-than-my-2022-self-3"></a>My 2017-Self May Have Known More Than My 2022-Self</h2>
<p>The lingering feeling now seems spot on.</p>
<p>I think this is the answer.</p>
<p>I'll point out that we now type check quoted literal things.</p>
<pre><code>machine-control: func [mode ['on 'off]] [
    switch mode [
         'on [print "Turning machine on"]
         'off [print "Turning machine off"]
    ]
]

&gt;&gt; machine-control 'explode
** Error: machine control requires mode as ['on 'off]
</code></pre>
<p>We still might want a TOGGLE? type constraint, and functions ON? and OFF? which check to make sure you're only testing something that is the WORD! of ON or OFF... same for YES? and NO?</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_4' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-09-05T00:24:05Z' class='post-time'>
                    September 5, 2024, 12:24am
                  </time>
                  <meta itemprop='dateModified' content='2024-09-05T04:58:16Z'>
              <span itemprop='position'>4</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <h2><a name="p-7565-benefit-of-the-new-idea-in-practice-1" class="anchor" href="2250.html#p-7565-benefit-of-the-new-idea-in-practice-1"></a>Benefit Of The New Idea In Practice</h2>
<p>Poking at Rebmake still more, I ran into this:</p>
<pre><code>assert [logic? user-config.odbc-requires-ltdl]
compose [
    %odbc (if user-config.odbc-requires-ltdl [%ltdl])
]
</code></pre>
<p>Here we are trying to do a sanity check, because if there's some stray value in the field we don't want to assume it is true or false.</p>
<p>But guess what...</p>
<pre><code>compose [
    %odbc (if yes? user-config.odbc-requires-ltdl [%ltdl])
]
</code></pre>
<p><strong>You get the check for free.</strong>  YES? and NO? only respond for the words YES and NO, and error on all other values.</p>
<p>So here's a layer of validation in the code.  And I think it's neat that you can use YES and NO if it's appropriate instead of TRUE and FALSE.  Here I think it's better--and we're just sort of brainwashed into using TRUE and FALSE in places they aren't actually the right words.</p>
<p><strong>This also means that you can see when things are logical, saving you from needing to name the variable with a ? in it.</strong>  (I always hated it when people did that.)</p>
<pre><code>if project.generated? [print "Sometimes people named variables like this"]

if yes? project.generated [print "You keep the clarity, plus a bonus typecheck!"]
</code></pre>
<h2><a name="p-7565-bootstrap-implementation-2" class="anchor" href="2250.html#p-7565-bootstrap-implementation-2"></a>Bootstrap Implementation</h2>
<pre><code>; Note: bootstrap EXE doesn't have closure, can't refer to WANT/NAME/DONT directly.
; Must compose values into the generated function body.
;
wordtester: enfix func3 ['name [set-word!] want [word!] dont [word!]] [
    set name func3 [x] compose3/deep [
        case [
            :x = the (want) [true]  ; bootstrap can't do :x = '(want)
            :x = the (dont) [false]
        ]
        fail [to word! the (name) "expects only" mold compose3 [(want) (dont)]]
    ]
]

true?: wordtester 'true 'false
false?: wordtester 'false 'true
on?: wordtester 'on 'off
off?: wordtester 'off 'on
yes?: wordtester 'yes 'no
no?: wordtester 'no 'yes
</code></pre>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="2250">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="../../user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Negation could preserve the form:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">&gt;&gt; not yes
== ~no~ ; anti
</code></pre>
</blockquote>
</aside>
<p>So NOT will only flip the null and undefined status.</p>
<p>That raises the question of what you'd use to flip a TRUE to a FALSE or a FALSE to a TRUE (or a YES to a NO, etc.)</p>
<p>You could write something like:</p>
<pre><code>flag: bool not true? flag    ; a bit convoluted
flag: bool false? flag       ; a little shorter, but less obviously a NOT
</code></pre>
<p>Haven't seen a need for it yet, though I only just started tinkering.  Most of the places that use NOT are just inside a test, and not saving the result into a variable.</p>
<h2><a name="p-7565-further-observations-3" class="anchor" href="2250.html#p-7565-further-observations-3"></a>Further Observations</h2>
<p>NOT needs to reverse the NULL-ness of what it is given.  So anything that isn't NULL you pass it needs to give back NULL.  And NULL needs to give back something that will cause branches to be taken (e.g. NOTHING, in my current formulation).</p>
<p>So you don't use NOT with TRUE/FALSE/ON/OFF/YES/NO.  You use FALSE?, OFF?, or NO?</p>
<p>With NO? it's even the same number of characters as NOT:</p>
<pre><code> if not var [...]
 if no? var [...]
</code></pre>
<p>I am finding that when given the freedom to choose, YES and NO are a preferred choice to TRUE and FALSE for many things.  Kind of not seeing a lot of places that I <em>actually want</em> to use TRUE and FALSE.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
          <div id='post_5' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-09-05T13:10:13Z' class='post-time'>
                    September 5, 2024,  1:10pm
                  </time>
                  <meta itemprop='dateModified' content='2024-09-06T19:08:25Z'>
              <span itemprop='position'>5</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>In about exactly 24 hours (including about 8 hours of sleep), I managed to go from having the fleeting thought of ~on~ and ~off~ and ~yes~ and ~no~ isotopes, to implementing the long-wished-for WORD!s-for-logical-states...and having a non-trivially booting system (can run TLS and HTTP, etc.)</p>
<p>The fact that I could do it that fast tells you something--Rebol doesn't really use a whole lot of variables that are <code>true</code> and <code>false</code>.  It's rare to pass them as arguments to functions, because parameter-less refinements are more the way to do that.</p>
<p>It works better than what we had before.  And the ways in which it is "weak" are really just bringing true and false into the realm of how you deal with every other thing in the language.  <strong>Trying to give an exceptional experience of using LOGIC! has really just wound up as an experience in creating a lot of exceptions.</strong>  This is a better path, that gets people in the rhythm of thinking with words--not the ideas they are used to from other languages.</p>
<h2>
<a name="some-spots-showcase-the-benefit-1" class="anchor" href="2250.html#some-spots-showcase-the-benefit-1"></a>Some Spots Showcase The Benefit</h2>
<p>Consider a case where you are trying to discern a refinement that has been supplied, and would hold a logic if so:</p>
<pre><code>===: func [
    return: [nihil?]
    'remarks [element? &lt;variadic&gt;]
    /visibility [logic?]
    &lt;static&gt; showing (false)
][
    if not null? visibility [showing: visibility, return nihil]

    if showing [...]
]
</code></pre>
<p>You have to specifically say <strong>if not null? visibility</strong> because you can't just use <strong>if visibility</strong> to ask if the refinement had been supplied.  When you consider NULL to be the only branch inhibiting state, the question is natural... <strong>if visibility</strong> means exactly that: <em>are you non-null</em>.</p>
<pre><code>===: func [
    return: [nihil?]
    'remarks [element? &lt;variadic&gt;]
    /visibility ['yes 'no]
    &lt;static&gt; showing ('no)
][
    if visibility [showing: visibility, return nihil]

    if yes? showing [...]
]
</code></pre>
<p>To me that paints a sort of picture of why we are better off without the likes of #[true] and #[false].  When you get away from the mental chains of thinking you have to be limited to those words, you are getting into the mindset of how to do more with the language.</p>
<h2>
<a name="some-while-true-type-places-need-a-different-answer-2" class="anchor" href="2250.html#some-while-true-type-places-need-a-different-answer-2"></a>Some <code>while [true]</code> Type Places Need A Different Answer</h2>
<p><strong><code>true</code></strong> is no longer defined, so you can't do that (unless you define true yourself for some reason).</p>
<p>Although <em>technically</em> you could just change that to <strong><code>while ['true]</code></strong> and it would <em>work</em>, that's rather misleading, because <strong><code>while ['false]</code></strong> would do the same thing.  Not a good way to teach people how to think about this.</p>
<p>You could say <strong><code>while [true? 'true]</code></strong> and be <em>accurate</em>, but that hardly seems like the best choice here.</p>
<p><strong><code>while [#]</code></strong> isn't the worst choice... the zero ASCII character literal is compact--looks solid.  It's what no-argument refinements currently use to be branch-triggering.  Certainly there's nothing overtly wrong with it, besides being "symboly"... to where someone might look at that and go "what does that <em>mean?</em>"</p>
<p>More talkative choices like <strong><code>while [#forever]</code></strong> communicate more without costing any more.  That's a short enough character sequence to fit in a cell.  You could say <strong><code>while [&lt;forever&gt;]</code></strong> with a TAG! that always does a string allocation (because it's mutable), but it's still a trivial cost when only one copy of the code exists.  And it doesn't have to dereference the string node to know it's not a null, so same runtime property as anything else.  If you think it looks better I wouldn't worry about the extra 8 platform pointers it costs.</p>
<p>Similar arguments apply to how some people (who don't like generalized ELSE) are accustomed to writing:</p>
<pre><code>case [
    condition1 [...]
    condition2 [...]
    true [...]
]
</code></pre>
<p>You wouldn't want to change that to <strong><code>'true</code></strong> for the reasons I've already mentioned (e.g. that <strong><code>'false</code></strong> would do exactly the same thing).</p>
<p>A literate choice would probably be mentioning how this is some kind of default.</p>
<pre><code>case [
    condition1 [...]
    condition2 [...]
    #default [...]
]
</code></pre>
<p>Again, the "default" fits entirely into an immutable character sequence cell such as that, so it's very cheap.</p>
<p>Anyway: my point is that <em><strong><code>'true</code></strong> now represents a particularly poor and counter-educational choice for arbitrary truthy things.</em>  There's an infinite number to choose from.  Just don't choose that.</p>
<h2>
<a name="turns-out-im-a-yes-man-3" class="anchor" href="2250.html#turns-out-im-a-yes-man-3"></a>Turns Out I'm a <code>'yes</code> Man</h2>
<p>For practically everywhere that was using <code>true</code> and <code>false</code>, I think <code>yes</code> and <code>no</code> read better.</p>
<pre><code>is-dynamic: false
=&gt;
is-dynamic: 'no
</code></pre>
<p>And they're shorter.  Plus if you said <strong>if not is-dynamic</strong> before, you can say <strong>if no? is-dynamic</strong> now.</p>
<p>I just wish there was a better name for <strong>to-yes-no</strong>, if you want convert values that are NULL to <strong>no</strong> and every other non-void thing to <strong>yes</strong>.</p>
<p>I am very tempted to reclaim DID and DIDN'T for this.  "Did you find it?" -&gt; yes, no</p>
<pre><code>&gt;&gt; did find [a b c] 'b
== yes

&gt;&gt; did find [a b c] 'e
== no

&gt;&gt; didn't find [a b c] 'e
== yes
</code></pre>
<h2>
<a name="predictably-most-questionable-nothing-for-branch-trigger-4" class="anchor" href="2250.html#predictably-most-questionable-nothing-for-branch-trigger-4"></a>Predictably Most Questionable: NOTHING for "Branch Trigger"</h2>
<p>The likely best other choice would be the zero ASCII character representation, <strong>#</strong>.  It's already used for no-argument refinements when they are supplied.</p>
<pre><code> &gt;&gt; 10 &lt; 20
 == #

 &gt;&gt; 10 &gt; 20
 == ~null~  ; anti
</code></pre>
<p>If we went with this, it has the seeming appealing property of letting you store the results of a logical expression in a variable, and then use it without having to invoke YES? or TRUE? or OFF? or anything like that:</p>
<pre><code> &gt;&gt; var1: 10 &lt; 20
 &gt;&gt; var2: 10 &gt; 20

 &gt;&gt; if var1 [print "This works."]
 This works.

 &gt;&gt; if not var2 [print "So does this.  What's wrong with it?"]
 So does this.  What's wrong with it?
</code></pre>
<p><em><strong>What's wrong is that I think this would encourage people to be representationally lazy, and it would slip the meaning of NULL into a haze.</strong></em></p>
<p>You'd stop really knowing what NULL means.  It ceases to be "unassigned thing that you don't really want to be passing around as a parameter".  People would start passing it around as if it was some kind of measurement.  It would become a currency for booleans, and I don't think it should be doing that.</p>
<p>That's why I speak of this "forced triage": I <em>want</em> people to be turning it into the right words for the problem, not leave it as null.  And it seems to me the best way to do that is to pick an ornery truthy state.</p>
<p><strong>"Okay, let's say we buy into that: having people assigning "logic" expressions to variables getting them unset half the time is actually a call to action to make better code, and keep NULL living to its full potential.  What are the downsides?"</strong></p>
<h2>
<a name="returning-logic-nothing-or-null-is-a-bit-weird-5" class="anchor" href="2250.html#returning-logic-nothing-or-null-is-a-bit-weird-5"></a>Returning "Logic" (NOTHING or NULL) is a Bit Weird</h2>
<pre><code> foo?: func [return: [logic?] ...] [
     if whatever blah whatever [
         return ~
     ]
     return null
 ]
</code></pre>
<p>That doesn't look a whole lot like a function that's dealing in LOGIC?.</p>
<p>We're in a bit of a pickle in a sense, because we have to find some way of saying "return branch trigger" or "return branch inhibitor" without using the words true or false.  <img src="../../images/emoji/twitter/grimacing.png%3Fv=12" title=":grimacing:" class="emoji" alt=":grimacing:" loading="lazy" width="20" height="20"></p>
<p>The first idea I had was to make something that we might consider useful for other reasons: LOGICAL, a routine which converts 0 to NULL and all other integers to NOTHING.</p>
<pre><code> foo?: func [return: [logic?] ...] [
     if whatever blah whatever [
         return logical 1  ; e.g. NOTHING
     ]
     return logical 0  ; e.g. NULL
 ]
</code></pre>
<p>It's not a useless function, and it dodges words we don't want to use.  Doesn't seem like  a terrible idea.</p>
<p>Of course, a lot of the time you're not generating the states.  You're just passing on the result of another function (e.g. writing a routine like <strong><code>even?</code></strong> in terms of <strong><code>odd?</code></strong>, and you can just say <strong><code>return not odd? number</code></strong> without having to generate anything.)</p>
<h2>
<a name="forces-functions-like-remove-each-to-pick-a-keyword-6" class="anchor" href="2250.html#forces-functions-like-remove-each-to-pick-a-keyword-6"></a>Forces Functions Like REMOVE-EACH To Pick A Keyword</h2>
<p>The function REMOVE-EACH will remove the items you say to remove.</p>
<pre><code> red&gt;&gt; remove-each num [1 2 3 4] [even? num]
 == [1 3]
</code></pre>
<p>Red considers UNSET! (nothing) to be truthy, and REMOVE-EACH only cares if your branch comes out truthy (not specifically true or false).  So if your block of code ends with something like PRINT, that winds up being a removal instruction:</p>
<pre><code>red&gt;&gt; remove-each num [1 2 3 4] [print num]
1
2
3
4
== []
</code></pre>
<p>I find that a bit too liberal and easy to make mistakes.  I required your loop body to evaluate to a LOGIC! (remove if true, keep if false), NULL (keep), or VOID (keep).</p>
<p>If I were to carry that forward...it would mean taking NOTHING, NULL, or VOID.  But there are a -lot- of ways to make NOTHING (e.g. PRINT).</p>
<p>Does this mean REMOVE-EACH needs to force you to pick a word form of logic?</p>
<pre><code>&gt;&gt; remove-each num [1 2 3 4] [even? num]
** Error: REMOVE-EACH expects TRUE or FALSE (or VOID to skip)

&gt;&gt; remove-each num [1 2 3 4] [bool even? num]
1
2
3
4
== []
</code></pre>
<p>I'd almost rather it expect the body to evaluate to KEEP or REMOVE, but you lose some elegance.  Though being able to skip voids might work out:</p>
<pre><code>&gt;&gt; remove-each num [1 2 3 4] [if even? num ['remove]]
1
2
3
4
== []
</code></pre>
<p>So we're in a situation where I'm not uncomfortable with the canon branch-triggering state being the same state that unsets variables.  That's a feature.  The thing I'm less pleased about is if it's being generated by other things (like <strong>eval []</strong> or <strong>case [1 &lt; 2 []]</strong> or <strong>print [...]</strong>)</p>
<h2>
<a name="may-be-better-than-too-much-prescriptiveness-7" class="anchor" href="2250.html#may-be-better-than-too-much-prescriptiveness-7"></a><strong><code>#</code></strong> May Be Better Than Too Much Prescriptiveness</h2>
<p>It would be consistent with unused refinement arguments.  You would be able to use them directly:</p>
<pre><code>&gt;&gt; f: make frame! :append

&gt;&gt; f.line: 1 &gt; 2
== ~null~  ; anti  (valid state for the /LINE no-arg refinement)

&gt;&gt; f.line: 1 &lt; 2
== #  ; valid state for the /LINE no-arg refinement
</code></pre>
<p>(It used to be that we had to worry about whether to convert TRUE and FALSE automatically, but now we would not do that--because those are WORD!s.)</p>
<p>It would allow you to save conditional expression tests in variables, even though you probably shouldn't do that very often.</p>
<p>It would mean that REMOVE-EACH could require #, NULL, or VOID.</p>
<p><strong>But one thing I don't like about it is that you can put it in blocks.</strong>  I'd rather whatever this truthy state is be an antiform.  That's probably a good property for the used refinement state as well.</p>
<p>What's a good short word that's the opposite of NULL that could be branch triggering that isn't TRUE?  <strong><code>~used~</code></strong> makes sense in the context of refinements, but does it make sense for comparisons in general?</p>
<pre><code>&gt;&gt; 1 &gt; 2
== ~null~  ; anti

&gt;&gt; 1 &lt; 2
== ~used~  ; anti
</code></pre>
<p>There's ~okay~</p>
<pre><code>&gt;&gt; 1 &gt; 2
== ~null~  ; anti

&gt;&gt; 1 &lt; 2
== ~okay~  ; anti
</code></pre>
<p>Using that for refinements doesn't necessarily seem like an improvement.</p>
<pre><code>&gt;&gt; f.line: if some-condition [okay]

&gt;&gt; f.line: if some-condition [~used~]

&gt;&gt; f.line: if some-condition [apex]  ; apex: ~apex~
</code></pre>
<p>Apex is actually pretty cool.  But certain to look strange.</p>
<pre><code>&gt;&gt; 1 &gt; 2
== ~null~  ; anti

&gt;&gt; 1 &lt; 2
== ~apex~  ; anti
</code></pre>
<p>The somewhat pejorative nature of TRASH makes me a bit reluctant to use it.</p>
<pre><code>&gt;&gt; 1 &gt; 2
== ~null~  ; anti

&gt;&gt; 1 &lt; 2
== ~
</code></pre>
<p>But also, you need to quote it.  I think this all just points to <strong><code>#</code></strong> being the most sensible choice, even though it's not an antiform.  You can't have everything.</p>
<h1>
<a name="null-complement-aside-the-rest-is-a-winner-8" class="anchor" href="2250.html#null-complement-aside-the-rest-is-a-winner-8"></a>NULL Complement Aside, The Rest Is A Winner</h1>
<p>I am happy with using the words and the TRUE? YES? tests...and having the new understanding of NULL being the only branch-inhibitor (besides, probably, NaN).</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

                <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                      <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                        <a itemprop='url' href="../resurrecting-the-if-combinator-as-when/2253.html">Resurrecting the &quot;IF&quot; Combinator... as WHEN</a>
                        <meta itemprop='position' content='1'>
                      </div>
                </div>
          </div>
          <div id='post_6' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" href='https://forum.rebol.info/u/bradrn'><span itemprop='name'>bradrn</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-09-06T01:08:57Z' class='post-time'>
                    September 6, 2024,  1:08am
                  </time>
                  <meta itemprop='dateModified' content='2024-09-06T01:08:57Z'>
              <span itemprop='position'>6</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <p>I find it very interesting to see that Ren-C has converged on the same solution as Lisp: a special value (<code>~</code> or <code>'()</code>) for falsy, anything else for truthy. Strong evidence that this is on the right track!</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="1" />
              <span class='post-likes'>1 Like</span>
            </div>

          </div>
          <div id='post_7' itemprop='comment' itemscope itemtype='http://schema.org/Comment' class='topic-body crawler-post'>
            <div class='crawler-post-meta'>
              <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
                <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
                
              </span>



              <span class="crawler-post-infos">
                  <time itemprop='datePublished' datetime='2024-09-06T15:45:38Z' class='post-time'>
                    September 6, 2024,  3:45pm
                  </time>
                  <meta itemprop='dateModified' content='2024-09-06T19:38:41Z'>
              <span itemprop='position'>7</span>
              </span>
            </div>
            <div class='post' itemprop='text'>
              <aside class="quote no-group" data-username="bradrn" data-post="6" data-topic="2250">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="../../user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I find it very interesting to see that Ren-C has converged on the same solution as Lisp</p>
</blockquote>
</aside>
<p><strong><a href="../a-justification-of-generalized-isotopes/1918/5.html">Isotopes do make it measurably distinct...</a></strong></p>
<p>And to competently play the hand I've dealt myself, NULL's complement in conditional logic (e.g. returned by comparisons or functions like EVEN?)--<em><strong>must be an antiform</strong></em>.</p>
<p>Having struggled with names, I think the best choice is probably OKAY.</p>
<pre><code>&gt;&gt; 10 &gt; 20
== ~null~  ; anti

&gt;&gt; 10 &lt; 20
== ~okay~  ; anti
</code></pre>
<p>There are tradeoffs to anything you'd put here.  It's an antiform whose sole reason for existing is to not be null, and not be legal as a List element.</p>
<p>You could call it ~not-null~.  <img src="../../images/emoji/twitter/face_with_diagonal_mouth.png%3Fv=12" title=":face_with_diagonal_mouth:" class="emoji" alt=":face_with_diagonal_mouth:" loading="lazy" width="20" height="20"> Claude.ai was suggesting ~value~ <em>(or ~valu~ if I wanted 4 letters--which I prefer--but not enough to be illiterate to get it)</em>.  It goes with that vein of "I am just a generic value that a variable can hold, and there's nothing else interesting about me except that I'm not null".  It's not meritless, but among its problems are that putting it into a word (like <strong>value</strong>) competes with a very important variable name...as well as that in the vernacular, an ANY-VALUE? is anything you can put into a variable, and ~null~ antiforms are in that set.</p>
<p>Trying to use a non-word for it has a host of problems.  <code>~()~</code> and <code>~[]~</code> etc. are taken for actual purposes (splicing, parameter packs).  I don't want SIGIL! antiforms, and if <code>~#~</code> were permitted that would probably require permitting <code>~#a~</code> and everything else.  And if you use a non-word, you'd still have to name it to talk about it in discussion...or to put it in a WORD! so you didn't have to put the tildes on at the callsites where you used it.  So you don't really buy yourself anything using a symbol.</p>
<p>On balance, OKAY is just... okay.  It's like "yeah, all right, here's your non-null thing".  There are places where it makes sense, like in the tests.  There it is expected that the canon branch trigger to drop out, or the test fails.</p>
<pre><code>; Note that BLOCK!s in the test dialect isolate the code into a module, so
; local definitions (or redefinitions of library words) are isolated into
; that block of tests! ðŸ˜Ž
[
    (var: 2, okay)  ; just saying `var: 2` the 2 drops out, test fails
    (even? var + 2)
    (odd? var + 1)
    (for-each x [2 4 6] [assert [even? x]], okay)
    ~expect-arg~ !! (even? &lt;banana&gt;)
]
; Also: I like having the QUASI-WORD! choice there for dialecting error IDs.
; But I believe it should be illegal to EVAL/UNMETA those to get antiforms
; unless they're in the system-vetted list of word antiforms.
</code></pre>
<p>OKAY works pretty well there.</p>
<p>It's a little strange that "used" refinements would be just "okay"</p>
<pre><code>&gt;&gt; foo: func [:refine] [probe refine]  ; in the soon-to-be notation

&gt;&gt; foo
== ~null~  ; anti

&gt;&gt; foo:refine
== ~okay~  ; anti
</code></pre>
<p>But I don't know if that's any stranger than anything else.  So far we've been getting <strong>#</strong> as the "arbitrary truthy thing".  I can't say how that's better--but I can articulate how it is worse (e.g. having various dialected meanings, appending zero bytes to binaries, matching # in block parses, COMPOSE-ing into slots without complaint, etc. etc.)</p>
<p>Anyway, I think I'm comfortable with it.  An added advantage is that there's an abbreviated form (<strong><code>ok</code></strong>, <strong><code>ok?</code></strong>)... so you can say <strong><code>frame.refinement: ok</code></strong> or a test like <strong><code>(var: 2, ok)</code></strong>, which is close to as brief as <strong><code>#</code></strong> while being more meaningful and getting all those sweet, sweet antiform benefits.  <img src="../../images/emoji/twitter/+1.png%3Fv=12" title=":+1:" class="emoji" alt=":+1:" loading="lazy" width="20" height="20"></p>
<p>I'm a little less comfortable with the idea of people casually embracing <code>~okay~</code> and <code>~null~</code> for their boolean-like variables just to get the benefit of being able to test with IF directly.  But if the system can make that choice for argument-less refinements, its pretty hypocritical to say you should <em>never</em> do it.  Prescriptivism has limits.</p>
            </div>

            <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
              <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
              <meta itemprop="userInteractionCount" content="0" />
              <span class='post-likes'></span>
            </div>

          </div>
    </div>


    




    </div>
    <footer class="container wrap">
  <nav class='crawler-nav'>
    <ul>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://forum.rebol.info/' itemprop="url">Home </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://forum.rebol.info/categories' itemprop="url">Categories </a>
        </span>
      </li>
      <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
        <span itemprop='name'>
          <a href='https://forum.rebol.info/guidelines' itemprop="url">Guidelines </a>
        </span>
      </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
    </ul>
  </nav>
  <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
</footer>

    
    
  </body>
  
</html>

<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>What Should BLANK! in UPARSE Do?</title>
    <link>https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821</link>
    <description>It&#39;s always good to look at history first.  So let&#39;s compare and contrast #[none] vs. empty block in old Redbols.

**In Rebol2 and R3-Alpha, both are no-ops.**  The input type doesn&#39;t matter.

    r2/r3&gt;&gt; parse {ab} [[] &quot;a&quot; [] &quot;b&quot; []]
    == true

    r2/r3&gt;&gt; parse {ab} [#[none] &quot;a&quot; #[none] &quot;b&quot; #[none]]
    == true

    r2/r3&gt;&gt; parse [a b] [[] &#39;a [] &#39;b []]
    == true

    r2/r3&gt;&gt; parse [a b] [#[none] &#39;a #[none] &#39;b #[none]]
    == true

**In Red, #[none]s are expected to be literal.**  However, you don&#39;t get an error on string inputs...just a failure.

    red&gt;&gt; parse {ab} [[] &quot;a&quot; [] &quot;b&quot; []]
    == true

    red&gt;&gt; parse {ab} [#[none] &quot;a&quot; #[none] &quot;b&quot; #[none]]
    == false

    red&gt;&gt; parse [a b] [[] &#39;a [] &#39;b []]
    == true

    red&gt;&gt; parse [a b] [#[none] &#39;a #[none] &#39;b #[none]]
    == false

    red&gt;&gt; parse [#[none] a #[none] b #[none]] [#[none] &#39;a #[none] &#39;b #[none]]
    == true

## I Think No-Op Is the Superior Choice for BLANK! (NONE!)

Ren-C&#39;s philosophy surrounding blank as &quot;reified nothing&quot; is that it is there to signal opting-out.

It&#39;s raison d&#39;etre is being falsey, and easy to test for its nothing-ish state...easily convertible to and from NULL.  (NULL rules are errors, as they should be).

The idea of being able to look for literal values is being explored other ways, the @ was one proposal (though this is going back and forth).

      &gt;&gt; var: _

      &gt;&gt; uparse [_ _ _] [some @var]
      == #[true]

But a blank rule is more effectively a no-op, IMO.

(For a time it had been considered that it could be a way of matching ANY-VALUE!, but that is now done more clearly with the **`&lt;any&gt;`** tag combinator, which is working out splendidly.)

## What Should a BLANK! Rule&#39;s Synthesized Product Be?

When it comes to empty blocks, I&#39;m pretty solidly sold that the answer is a ~none~ isotope:

    &gt;&gt; rule: []

    &gt;&gt; did uparse {ab} [&quot;a&quot; x: rule &quot;b&quot;]
    == #[true]

    &gt;&gt; x
    ** Script Error: x is ~none~ isotope

There&#39;s a deeply interlocked set of justifications for that, which (I hope) aren&#39;t going to need rethinking.

But with BLANK! rules it&#39;s not so obvious:

    &gt;&gt; rule: _

    &gt;&gt; did uparse {ab} [&quot;a&quot; x: rule &quot;b&quot;]
    == #[true]

    &gt;&gt; x
    == ???

I&#39;m skeptical of vaporization, e.g. **`(x = &quot;b&quot;)`**  It seems that would be useful only in the most rare of situations, and 99% of the time it would surprise the caller.

The philosophy of &quot;blank in, null out&quot; suggests NULL.  That seems useful.  (Implementation of this would actually return a *null isotope*, such that the rule could still look successful while handing back that result!)

I think that gives a pretty interesting shape to things.  Because this is new, I&#39;ll have to look for applications of it...but I&#39;m pretty sure they will show up.  If I see any, I&#39;ll make a note of them here.</description>
    
    <lastBuildDate>Sun, 15 May 2022 22:35:24 +0000</lastBuildDate>
    <category>Parsing</category>
    <atom:link href="https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>What Should BLANK! in UPARSE Do?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>It's always good to look at history first.  So let's compare and contrast #[none] vs. empty block in old Redbols.</p>
<p><strong>In Rebol2 and R3-Alpha, both are no-ops.</strong>  The input type doesn't matter.</p>
<pre><code>r2/r3&gt;&gt; parse {ab} [[] "a" [] "b" []]
== true

r2/r3&gt;&gt; parse {ab} [#[none] "a" #[none] "b" #[none]]
== true

r2/r3&gt;&gt; parse [a b] [[] 'a [] 'b []]
== true

r2/r3&gt;&gt; parse [a b] [#[none] 'a #[none] 'b #[none]]
== true
</code></pre>
<p><strong>In Red, #[none]s are expected to be literal.</strong>  However, you don't get an error on string inputs...just a failure.</p>
<pre><code>red&gt;&gt; parse {ab} [[] "a" [] "b" []]
== true

red&gt;&gt; parse {ab} [#[none] "a" #[none] "b" #[none]]
== false

red&gt;&gt; parse [a b] [[] 'a [] 'b []]
== true

red&gt;&gt; parse [a b] [#[none] 'a #[none] 'b #[none]]
== false

red&gt;&gt; parse [#[none] a #[none] b #[none]] [#[none] 'a #[none] 'b #[none]]
== true
</code></pre>
<h2>I Think No-Op Is the Superior Choice for BLANK! (NONE!)</h2>
<p>Ren-C's philosophy surrounding blank as "reified nothing" is that it is there to signal opting-out.</p>
<p>It's raison d'etre is being falsey, and easy to test for its nothing-ish state...easily convertible to and from NULL.  (NULL rules are errors, as they should be).</p>
<p>The idea of being able to look for literal values is being explored other ways, the @ was one proposal (though this is going back and forth).</p>
<pre><code>  &gt;&gt; var: _

  &gt;&gt; uparse [_ _ _] [some @var]
  == #[true]
</code></pre>
<p>But a blank rule is more effectively a no-op, IMO.</p>
<p>(For a time it had been considered that it could be a way of matching ANY-VALUE!, but that is now done more clearly with the <strong><code>&lt;any&gt;</code></strong> tag combinator, which is working out splendidly.)</p>
<h2>What Should a BLANK! Rule's Synthesized Product Be?</h2>
<p>When it comes to empty blocks, I'm pretty solidly sold that the answer is a ~none~ isotope:</p>
<pre><code>&gt;&gt; rule: []

&gt;&gt; did uparse {ab} ["a" x: rule "b"]
== #[true]

&gt;&gt; x
** Script Error: x is ~none~ isotope
</code></pre>
<p>There's a deeply interlocked set of justifications for that, which (I hope) aren't going to need rethinking.</p>
<p>But with BLANK! rules it's not so obvious:</p>
<pre><code>&gt;&gt; rule: _

&gt;&gt; did uparse {ab} ["a" x: rule "b"]
== #[true]

&gt;&gt; x
== ???
</code></pre>
<p>I'm skeptical of vaporization, e.g. <strong><code>(x = "b")</code></strong>  It seems that would be useful only in the most rare of situations, and 99% of the time it would surprise the caller.</p>
<p>The philosophy of "blank in, null out" suggests NULL.  That seems useful.  (Implementation of this would actually return a <em>null isotope</em>, such that the rule could still look successful while handing back that result!)</p>
<p>I think that gives a pretty interesting shape to things.  Because this is new, I'll have to look for applications of it...but I'm pretty sure they will show up.  If I see any, I'll make a note of them here.</p>
          <p><a href="https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821/1</link>
        <pubDate>Sun, 15 May 2022 22:35:24 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1821-1</guid>
        <source url="https://forum.rebol.info/t/what-should-blank-in-uparse-do/1821.rss">What Should BLANK! in UPARSE Do?</source>
      </item>
  </channel>
</rss>

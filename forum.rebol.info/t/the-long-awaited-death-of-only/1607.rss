<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>The Long-Awaited Death of /ONLY</title>
    <link>https://forum.rebol.info/t/the-long-awaited-death-of-only/1607</link>
    <description>**As of July 2022, /ONLY is no longer a refinement available on APPEND, INSERT, CHANGE, FIND, SELECT, COMPOSE, or similar functions.**  It only appears in the Redbol module [through emulation](https://forum.rebol.info/t/agree-to-disagree-points-places-i-see-both-sides/1862/3?u=hostilefork).

## &quot;AS-IS&quot; Semantics Are Default

It&#39;s easy to sympathize with the historical Rebol idea of &quot;splice blocks by default&quot;, if you only look at examples where the code is fully literal:

    append files [%foo.r %bar.r]
    code: compose [... keep [sum: sum + x] ...]

But problems immediately strike when you start using variables that may-or-may-not-be blocks.  You can&#39;t rely on any invariants, and this leads to broken code:

    &gt;&gt; block: [#a {b} [c d e] %f]

    &gt;&gt; pick block 3
    == [c d e]

    &gt;&gt; find block pick block 3
    ; null

Time and experience has proven that &quot;as-is&quot; semantics are the safest and clearest default:

    &gt;&gt; append [a b c] [d e]
    == [a b c [d e]]

Ren-C offers a new tool for &quot;spliced&quot; semantics...which is to pass a BLOCK! isotope (&quot;quoting level -1&quot;).  SPREAD is the first function offered which produces them:

    &gt;&gt; append [a b c] spread [d e]
    == [a b c d e]

But there&#39;s nothing particularly special about SPREAD, and there will be many other options for defining functions that may-or-may-not return block isotopes...which have more parameterization and nuance.

## Making The Value Carry Splicing Intent Brings Systemic Good

The benefits are everywhere, with safer defaults and clear choices...for instance in REPLACE:

    &gt;&gt; replace/all [[a b] a b a b] [a b] [c d e]
    == [[c d e] a b a b] 

    &gt;&gt; replace/all [[a b] a b a b] spread [a b] [c d e]
    == [[a b] [c d e] [c d e]]

    &gt;&gt; replace/all [[a b] a b a b] [a b] spread [c d e]
    == [c d e a b a b]

    &gt;&gt; replace/all [[a b] a b a b] spread [a b] spread [c d e]
    == [[a b] c d e c d e]

Branching code can make decisions to splice-or-not-splice on a case by case basis:

    &gt;&gt; code: [&lt;splice&gt; [a b] &lt;no-splice&gt; [c d] &lt;no-splice&gt; &#39;x]

    &gt;&gt; map-each [instruction item] code [
           switch instruction [
                &lt;splice&gt; [spread item]
                &lt;no-splice&gt; [item]
                fail [&quot;Bad instruction:&quot; instruction]
           ]
       ]
    == [a b [c d] &#39;x]

And COMPOSE can have some slots that splice and others that do not, within the same operation:

    &gt;&gt; data: [a b]

    &gt;&gt; compose [spliced (spread data) non-spliced (data)]
    == [spliced a b non-spliced [a b]]

(COMPOSE is a case where not splicing by default is glaringly obvious as the right choice for a generic operation.)

## BLOCK! Isotopes Are Special (&quot;unfriendly&quot; :japanese_goblin: )

Normal parameters cannot accept them.

    &gt;&gt; normal-function: func [value] [print [&quot;Normal got:&quot; mold value]]

    &gt;&gt; normal-function spread [d e]
    ** Error: NORMAL-FUNCTION can&#39;t take a BLOCK! isotope as its VALUE argument

The way that you indicate you can take an isotope is using a ^META parameter.

But the convention with meta parameters is they will always be &quot;one quote level higher&quot; than the thing that they represent.

    &gt;&gt; meta-function: func [^value] [print [&quot;Meta got:&quot; mold value]]

    &gt;&gt; meta-function [d e]
    Meta got: &#39;[d e]  ; one quote level above 0 for unquoted input

    &gt;&gt; meta-function first [&#39;&#39;[d e]]
    Meta got: &#39;&#39;&#39;[d e]  ; three quote levels above 0 for double-quoted input

    &gt;&gt; meta-function spread [d e]
    Meta got: [d e]  ; no quotes for isotopic input

Using this detection mechanism, you can write your own routines that react specially to isotopes.

## Isotope Parameter Conventions Should Be Used *Sparingly*!

Routines that do not intend to react to an isotope should not take them as parameters.

As a good example, REDUCE might seem like the kind of thing that could act on block isotopes:

    &gt;&gt; append [a b c] reduce spread [1 + 2 3 + 4]
    == [a b c 3 7]

But we want to avoid this temptation, to stop the &quot;spread&quot; of isotopes to touching parts of the system that should not be concerned with them.  So exercise restraint here...and shift the burden on the calling code to reshape itself so that isotopes only exist at the points that are very close to the calls they affect:

    &gt;&gt; append [a b c] spread reduce [1 + 2 3 + 4]
    == [a b c 3 7]

## Good Riddance /ONLY

The elimination of /ONLY from the semantic model, and to have it not contaminate the user&#39;s heads, means that people can learn more generic tools that work in more contexts.

Its appearance in Ren-C will be limited to the Redbol compatibility module.</description>
    
    <lastBuildDate>Sat, 23 Jul 2022 04:17:43 +0000</lastBuildDate>
    <category>Internals</category>
    <atom:link href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>The Long-Awaited Death of /ONLY</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group quote-modified" data-username="rgchris" data-post="2" data-topic="1607">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>Will use <code>#"</code>"` to denote a -1 quoted block:</p>
</blockquote>
</aside>
<p>All this is new, so the thinking is going to naturally get shuffled around.  It's a complex puzzle with a lot of pieces.</p>
<p>But...it may be that the existing rules are right, and isotopes <em>don't really have any representation at all</em>.</p>
<p>You only know they exist by virtue of ^META'ing them and seeing something unquoted...or the errors you get when you try to access them (which tell you you have an isotope, and show you the value un-isotopified).</p>
<p>This is how things work today (which is why you get the little <strong><code>; isotope</code></strong> comment stuck after the BAD-WORD!s that are in isotope forms).  But I thought that maybe it would be possible to generalize this in formatting.  But trying to reason about it in any way that isotopes are willing to "mold" doesn't cohere.</p>
<p>I'm definitely leaning toward a new meaning for GET-XXX! things, which builds in an UNMETA.  This is unfortunate for those who liked <strong><code>:[...]</code></strong> meaning "reduce block".  But on the plus side, it would give us a new shorthand:</p>
<pre><code>&gt;&gt; :[d e]
== [d e]  ; isotope

&gt;&gt; append [a b c] :[d e]
== [a b c d e]
</code></pre>
<p>More importantly than shorthand, it provides a single value notation for isotopic forms:</p>
<pre><code> &gt;&gt; make object! [x: unmeta [d e], y: the :[d e]]
 == make object! [
     x: :[d e]
     y: ':[d e]
 ]
</code></pre>
<p>The whole "molded representations of objects" issue is up in the air, of course.  But I think there is broader importance to the idea that you can use single literal values that produce any state of a variable after evaluation.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="3" data-topic="1607">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre><code>&gt;&gt; thing: spread [a b c]
== [a b c]  ; isotope
</code></pre>
</blockquote>
</aside>
<p>The <code>; isotope</code> is a little hard to see.  The web console might stylize it more.</p>
<p><strong>We may actually want to keep the colon on it, and say it's a GET-BLOCK! (or whatever) isotope.</strong></p>
<pre><code>&gt;&gt; thing: spread [a b c]
== :[a b c]  ; isotope
</code></pre>
<p>Adopting this systemically may make things a bit uglier, such as by ^META operations yielding a decorated block:</p>
<pre><code>&gt;&gt; ^ spread [a b c]
== :[a b c]
</code></pre>
<p>But it could give reason to a new theory of what sorts of things have isotopes: <strong>the only things that have isotopic forms are things whose evaluator behavior is to produce isotopes of themselves.</strong></p>
<p>So that would explain why there are no plain BLOCK! isotopes, or SET-BLOCK! isotopes, or INTEGER! isotopes... because there's no single value that can be ^META'd to get the non-isotopic form.</p>
<p>And it would explain why ACTION! values evaluate to isotopes of ACTION! (which then, accessed via WORD!, will run the action vs. erroring...in a peculiarity of how action isotopes behave).</p>
<p>Though it twists a little the plan for <strong><code>:</code></strong> becoming UNMETA:</p>
<pre><code>&gt;&gt; append [a b c] : reduce [1 + 2 3 + 4]
== [a b c 3 7]
</code></pre>
<p>Because it would be saying that UNMETA of a BLOCK! is a GET-BLOCK! isotope.</p>
<p>Anyway, like I say... some bendy stuff.  It's being invented.  Have to look at what works across the various inventory of complex scenarios that have accrued.</p>
          <p><a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/the-long-awaited-death-of-only/1607/4</link>
        <pubDate>Fri, 22 Jul 2022 04:47:05 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1607-4</guid>
        <source url="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607.rss">The Long-Awaited Death of /ONLY</source>
      </item>
      <item>
        <title>The Long-Awaited Death of /ONLY</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="rgchris" data-post="2" data-topic="1607">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/rgchris/40/14_2.png" class="avatar"> rgchris:</div>
<blockquote>
<p>Can this be addressed in how SPREAD blocks are evaluated? A variation on lit-bit decay</p>
</blockquote>
</aside>
<p>I do not believe in decaying them, so this is what you would get</p>
<pre><code>&gt;&gt; spread [a b c]
== [a b c]  ; isotope

&gt;&gt; thing: spread [a b c]
== [a b c]  ; isotope

&gt;&gt; thing
** Error: THING is an isotope, you must use ^META operations

&gt;&gt; ^thing  ; ^META access adds one level of quote, removing isotope status
== [a b c]

&gt;&gt; get/any 'thing  ; should likely be called get/isotope now
== [a b c]  ; isotope</code></pre>
          <p><a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/the-long-awaited-death-of-only/1607/3</link>
        <pubDate>Thu, 21 Jul 2022 22:07:03 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1607-3</guid>
        <source url="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607.rss">The Long-Awaited Death of /ONLY</source>
      </item>
      <item>
        <title>The Long-Awaited Death of /ONLY</title>
        <dc:creator><![CDATA[rgchris]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1607">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But we want to avoid this temptation, to stop the "spread" of isotopes to touching parts of the system that should not be concerned with them. So exercise restraint here...and shift the burden on the calling code to reshape itself so that isotopes only exist at the points that are very close to the calls they affect:</p>
</blockquote>
</aside>
<p>Can this be addressed in how SPREAD blocks are evaluated? A variation on lit-bit decay <img src="https://forum.rebol.info/images/emoji/twitter/grimacing.png?v=9" title=":grimacing:" class="emoji" alt=":grimacing:">. Will use <code>#"`"</code> to denote a -1 quoted block (for presentation purposes, not a proposition):</p>
<pre><code class="lang-nohighlight">&gt;&gt; spread [a b c]
== `[a b c]

&gt;&gt; thing: spread [a b c]
== `[a b c]

&gt;&gt; thing
== [a b c]  ; on second evaluation, decay

&gt;&gt; append [] thing: spread [a b c]
== [[a b c]]  ; ^^ is second evaluation, =&gt; decay
</code></pre>
<p>Probably not, but would be nice to ditch the assignation as soon as possible as it's something of a hidden attribute</p>
          <p><a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/the-long-awaited-death-of-only/1607/2</link>
        <pubDate>Thu, 21 Jul 2022 22:01:43 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1607-2</guid>
        <source url="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607.rss">The Long-Awaited Death of /ONLY</source>
      </item>
      <item>
        <title>The Long-Awaited Death of /ONLY</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p><strong>As of July 2022, /ONLY is no longer a refinement available on APPEND, INSERT, CHANGE, FIND, SELECT, COMPOSE, or similar functions.</strong>  It only appears in the Redbol module <a href="https://forum.rebol.info/t/agree-to-disagree-points-places-i-see-both-sides/1862/3">through emulation</a>.</p>
<h2>"AS-IS" Semantics Are Default</h2>
<p>It's easy to sympathize with the historical Rebol idea of "splice blocks by default", if you only look at examples where the code is fully literal:</p>
<pre><code>append files [%foo.r %bar.r]
code: compose [... keep [sum: sum + x] ...]
</code></pre>
<p>But problems immediately strike when you start using variables that may-or-may-not-be blocks.  You can't rely on any invariants, and this leads to broken code:</p>
<pre><code>&gt;&gt; block: [#a {b} [c d e] %f]

&gt;&gt; pick block 3
== [c d e]

&gt;&gt; find block pick block 3
; null
</code></pre>
<p>Time and experience has proven that "as-is" semantics are the safest and clearest default:</p>
<pre><code>&gt;&gt; append [a b c] [d e]
== [a b c [d e]]
</code></pre>
<p>Ren-C offers a new tool for "spliced" semantics...which is to pass a BLOCK! isotope ("quoting level -1").  SPREAD is the first function offered which produces them:</p>
<pre><code>&gt;&gt; append [a b c] spread [d e]
== [a b c d e]
</code></pre>
<p>But there's nothing particularly special about SPREAD, and there will be many other options for defining functions that may-or-may-not return block isotopes...which have more parameterization and nuance.</p>
<h2>Making The Value Carry Splicing Intent Brings Systemic Good</h2>
<p>The benefits are everywhere, with safer defaults and clear choices...for instance in REPLACE:</p>
<pre><code>&gt;&gt; replace/all [[a b] a b a b] [a b] [c d e]
== [[c d e] a b a b] 

&gt;&gt; replace/all [[a b] a b a b] spread [a b] [c d e]
== [[a b] [c d e] [c d e]]

&gt;&gt; replace/all [[a b] a b a b] [a b] spread [c d e]
== [c d e a b a b]

&gt;&gt; replace/all [[a b] a b a b] spread [a b] spread [c d e]
== [[a b] c d e c d e]
</code></pre>
<p>Branching code can make decisions to splice-or-not-splice on a case by case basis:</p>
<pre><code>&gt;&gt; code: [&lt;splice&gt; [a b] &lt;no-splice&gt; [c d] &lt;no-splice&gt; 'x]

&gt;&gt; map-each [instruction item] code [
       switch instruction [
            &lt;splice&gt; [spread item]
            &lt;no-splice&gt; [item]
            fail ["Bad instruction:" instruction]
       ]
   ]
== [a b [c d] 'x]
</code></pre>
<p>And COMPOSE can have some slots that splice and others that do not, within the same operation:</p>
<pre><code>&gt;&gt; data: [a b]

&gt;&gt; compose [spliced (spread data) non-spliced (data)]
== [spliced a b non-spliced [a b]]
</code></pre>
<p>(COMPOSE is a case where not splicing by default is glaringly obvious as the right choice for a generic operation.)</p>
<h2>BLOCK! Isotopes Are Special ("unfriendly" <img src="https://forum.rebol.info/images/emoji/twitter/japanese_goblin.png?v=9" title=":japanese_goblin:" class="emoji" alt=":japanese_goblin:"> )</h2>
<p>Normal parameters cannot accept them.</p>
<pre><code>&gt;&gt; normal-function: func [value] [print ["Normal got:" mold value]]

&gt;&gt; normal-function spread [d e]
** Error: NORMAL-FUNCTION can't take a BLOCK! isotope as its VALUE argument
</code></pre>
<p>The way that you indicate you can take an isotope is using a ^META parameter.</p>
<p>But the convention with meta parameters is they will always be "one quote level higher" than the thing that they represent.</p>
<pre><code>&gt;&gt; meta-function: func [^value] [print ["Meta got:" mold value]]

&gt;&gt; meta-function [d e]
Meta got: '[d e]  ; one quote level above 0 for unquoted input

&gt;&gt; meta-function first [''[d e]]
Meta got: '''[d e]  ; three quote levels above 0 for double-quoted input

&gt;&gt; meta-function spread [d e]
Meta got: [d e]  ; no quotes for isotopic input
</code></pre>
<p>Using this detection mechanism, you can write your own routines that react specially to isotopes.</p>
<h2>Isotope Parameter Conventions Should Be Used <em>Sparingly</em>!</h2>
<p>Routines that do not intend to react to an isotope should not take them as parameters.</p>
<p>As a good example, REDUCE might seem like the kind of thing that could act on block isotopes:</p>
<pre><code>&gt;&gt; append [a b c] reduce spread [1 + 2 3 + 4]
== [a b c 3 7]
</code></pre>
<p>But we want to avoid this temptation, to stop the "spread" of isotopes to touching parts of the system that should not be concerned with them.  So exercise restraint here...and shift the burden on the calling code to reshape itself so that isotopes only exist at the points that are very close to the calls they affect:</p>
<pre><code>&gt;&gt; append [a b c] spread reduce [1 + 2 3 + 4]
== [a b c 3 7]
</code></pre>
<h2>Good Riddance /ONLY</h2>
<p>The elimination of /ONLY from the semantic model, and to have it not contaminate the user's heads, means that people can learn more generic tools that work in more contexts.</p>
<p>Its appearance in Ren-C will be limited to the Redbol compatibility module.</p>
          <p><a href="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/the-long-awaited-death-of-only/1607/1</link>
        <pubDate>Sat, 15 May 2021 09:48:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1607-1</guid>
        <source url="https://forum.rebol.info/t/the-long-awaited-death-of-only/1607.rss">The Long-Awaited Death of /ONLY</source>
      </item>
  </channel>
</rss>

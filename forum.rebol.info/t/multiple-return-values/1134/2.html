<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>The History of Multi-Return in Ren-C - #2 - Functions - AltRebol</title>
    <meta name="description" content="This thread merges discussions of history across several threads to cover the key points, starting with material from the post announcing the addition of the SET-BLOCK! and GET-BLOCK!...and then folding in important poin&amp;hellip;">
    <meta name="generator" content="Discourse 2.7.0.beta4 - https://github.com/discourse/discourse version 3fc72543de22c329cf2156f28b781821adc496ae">
<link rel="icon" type="image/png" href="../../../uploads/default/optimized/1X/cbd70027b53fa165575e5b665f00eb3b8ae7ea31_2_32x32.ico">
<link rel="apple-touch-icon" type="image/png" href="../../../uploads/default/optimized/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d_2_180x180.png">
<meta name="theme-color" content="#ffffff">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=yes, viewport-fit=cover">
<link rel="canonical" href="../1134.html" />
<script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://forum.rebol.info","potentialAction":{"@type":"SearchAction","target":"https://forum.rebol.info/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script>
<link rel="search" type="application/opensearchdescription+xml" href="../../../opensearch.xml" title="AltRebol Search">

      <link href="https://forum.rebol.info/stylesheets/desktop_cdfbc200d3f5311dbee0f69ae668cfc42cfc8cb7.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop" data-theme-id="2"/>
      <link href="https://forum.rebol.info/stylesheets/desktop_theme_2_7b2b5b1bc734c2cc3b6ad5e0f49f467e8601ef2c.css?__ws=forum.rebol.info" media="all" rel="stylesheet" data-target="desktop_theme" data-theme-id="2"/>
    
    
        <link rel="alternate" type="application/rss+xml" title="RSS feed of &#39;The History of Multi-Return in Ren-C&#39;" href="../../the-history-of-multi-return-in-ren-c/1134.rss" />
    <meta property="og:site_name" content="AltRebol" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:image" content="https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" />
<meta property="og:url" content="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/2" />
<meta name="twitter:url" content="https://forum.rebol.info/t/the-history-of-multi-return-in-ren-c/1134/2" />
<meta property="og:title" content="The History of Multi-Return in Ren-C" />
<meta name="twitter:title" content="The History of Multi-Return in Ren-C" />
<meta property="og:description" content="This thread merges discussions of history across several threads to cover the key points, starting with material from the post announcing the addition of the SET-BLOCK! and GET-BLOCK!...and then folding in important points from later posts in the relative chronology of when they happened.  So it&#39;s broken up into sections by approximate date.   March 2019: SET-BLOCK! and GET-BLOCK! Added These were generic parts which you could use in dialects however you wanted...just like other types.  But a ke..." />
<meta name="twitter:description" content="This thread merges discussions of history across several threads to cover the key points, starting with material from the post announcing the addition of the SET-BLOCK! and GET-BLOCK!...and then folding in important points from later posts in the relative chronology of when they happened.  So it&#39;s broken up into sections by approximate date.   March 2019: SET-BLOCK! and GET-BLOCK! Added These were generic parts which you could use in dialects however you wanted...just like other types.  But a ke..." />
<meta property="article:published_time" content="2019-03-28T01:56:31+00:00" />
<meta property="og:ignore_canonical" content="true" />



    
  </head>
  <body class="crawler">
    
    <header>
      <a href="https://forum.rebol.info/">
          <img src="../../../uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png" alt="AltRebol" id="site-logo" style="max-width: 150px;">
      </a>
    </header>
    <div id="main-outlet" class="wrap">
        <div id="topic-title">
    <h1>
      <a href="../1134.html">The History of Multi-Return in Ren-C</a>
    </h1>

      <div class="topic-category" itemscope itemtype="http://schema.org/BreadcrumbList">
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/development/8" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Development</span>
              </span>
            </a>
            <meta itemprop="position" content="1" />
          </span>
          <span itemprop="itemListElement" itemscope itemtype="http://schema.org/ListItem">
            <a href="https://forum.rebol.info/c/development/functions/59" class="badge-wrapper bullet" itemprop="item">
              <span class='badge-category-bg' style='background-color: #25AAE2'></span>
              <span class='badge-category clear-badge'>
                <span class='category-name' itemprop='name'>Functions</span>
              </span>
            </a>
            <meta itemprop="position" content="2" />
          </span>
      </div>

  </div>

  


      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="../1134.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2019-03-28T01:56:31Z'>
              <time itemprop='dateModified' datetime='2022-08-20T07:42:30Z' class='post-time'>
                August 20, 2022,  7:42am
              </time>
          <span itemprop='position'>#1</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <p><em>This thread merges discussions of history across several threads to cover the key points, starting with material from the post announcing the addition of the SET-BLOCK! and GET-BLOCK!...and then folding in important points from later posts in the relative chronology of when they happened.  So it's broken up into sections by approximate date.</em></p>
<hr>
<h1>March 2019: SET-BLOCK! and GET-BLOCK! Added</h1>
<p>These were generic parts which you could use in dialects however you wanted...just like other types.</p>
<p><strong>But a key motivation was the concept that the evaluator would use them for some kind of multiple-return-value strategy.</strong>  Users of languages with the feature seemed to rave about it. And if you don't have it, they will complain and constantly try to find ways to work around it.</p>
<p>I had inklings that Rebol could do them in a way that is mindbending and original. But a dirt simple implementation of the idea in 2019 looked roughly like what people were used to with SET of BLOCK! from Rebol2, without needing to write the word SET:</p>
<pre><code>early-multi-concept: function [a b] [
    return :[(a * 3) (b - 16)]  ; e.g. :[...] would act like REDUCE [...]
]

&gt;&gt; [x y]: early-multi-concept 10 20
== [30 4]

&gt;&gt; x
== 30

&gt;&gt; y
== 4
</code></pre>
<p>So <strong><code>([x y]: foo)</code></strong> would act like <strong><code>(set [x y] foo)</code></strong>, including allowances to let you take fewer than one value:</p>
<pre><code>&gt;&gt; [x]: [10 20]
== [10 20]

&gt;&gt; x
== 10
</code></pre>
<h2>But the simplicity had obvious drawbacks</h2>
<p>First of all, Ren-C had NULL states that by design could not be put into blocks.  This approach wouldn't be able to return those without distorting them into some different reified value  than the intended NULL.</p>
<pre><code>&gt;&gt; [x y]: function-returning-null-and-30
== [&lt;null&gt; 30]  ; can't put null, so... "something else" in first slot?

&gt;&gt; x
== null  ; not the same thing as what the block said...seems bad, yes?

&gt;&gt; y
== 30
</code></pre>
<p>Also, you would have to know that what you were calling returned multiple values.  If you missed that and used a plain SET-WORD!, you'd just wind up with the block:</p>
<pre><code>&gt;&gt; x: some-function-i-didnt-know-was-multi-return ...
== [ret1 ret2 ret3]  ; the block! could easily be mistaken for single return
</code></pre>
<h2>I had one of those ideas that just wouldn't go away...</h2>
<p>It seemed clearly preferable that rather than choose between <strong>[x]:</strong> and <strong>[x y]:</strong> and knowing in advance how many values you're taking or throwing away... someone who only asked for one value should be able to be blissfully ignorant.  So the choice would be between:</p>
<pre><code>&gt;&gt; x: multi-return ...
&gt;&gt; [x y]: multi-return ...
</code></pre>
<p>Even though the first case is a multiple return, you wouldn't set x to a block of values, <em>but just get the first value</em>.  An interface like this would also solve the issue of returning NULL.</p>
<p>Not being forced to return a BLOCK! also made great sense... <em>because since BLOCK! is always truthy, you'd not really be able to make useful conditional behavior be based on a BLOCK! return anyway!</em></p>
<pre><code>&gt;&gt; [x y]: function-returning-null-and-30
== null  ; so you could meaningfully say `if [x y]: whatever [...]`

&gt;&gt; x
== null

&gt;&gt; y
== 30
</code></pre>
<p>Going even further, I suggested <em>"it would be important that if a function wanted to do multiple returns that it could know how many results it was assigning.  This could save calculation on things that aren't needed."</em></p>
<h3>
<em><strong>...but all this would require some kind of magic...</strong></em> <img src="../../../images/emoji/twitter/mage.png%3Fv=9" title=":mage:" class="emoji" alt=":mage:">
</h3>
        </div>

        <meta itemprop='headline' content='The History of Multi-Return in Ren-C'>
          <meta itemprop='keywords' content=''>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="1" />
           <span class='post-likes'>1 Like</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

            <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../../wrapping-and-forwarding-multi-returns/1926.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/wrapping-and-forwarding-multi-returns/1926'>
                      <span itemprop='name'>Wrapping And Forwarding Multi-Returns</span>
                    </a>
                    <meta itemprop='position' content='1'>
                  </div>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../../lua-multi-return-as-parameters-to-function/1928.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/lua-multi-return-as-parameters-to-function/1928'>
                      <span itemprop='name'>Lua Multi-Return As Parameters to Function</span>
                    </a>
                    <meta itemprop='position' content='2'>
                  </div>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../../get-block-get-and-reduce/1183/2.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/get-block-get-and-reduce/1183/2'>
                      <span itemprop='name'>GET-BLOCK!, GET, and REDUCE</span>
                    </a>
                    <meta itemprop='position' content='3'>
                  </div>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../../where-the-series-ends-simplifying-out-of-bounds-rules/1141.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/where-the-series-ends-simplifying-out-of-bounds-rules/1141'>
                      <span itemprop='name'>Where the Series Ends: Simplifying Out of Bounds Rules</span>
                    </a>
                    <meta itemprop='position' content='4'>
                  </div>
            </div>
      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="../1134.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2020-04-08T15:39:01Z'>
              <time itemprop='dateModified' datetime='2022-11-27T04:58:42Z' class='post-time'>
                November 27, 2022,  4:58am
              </time>
          <span itemprop='position'>#6</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <h1>February 2020: Fake It (with Enfix) Until We Make It</h1>
<p>It occurred to me to work up a prototype completely in usermode using a skippable enfix parameter:</p>
<p><a href="../../multiple-return-values-via-enfix/1257.html" class="inline-onebox">Multiple Return Values Via Enfix</a></p>
<p>So a function could act as having multi-returns by peeking to its left... and seeing if there was a SET-BLOCK! there.  If there was, then it would do the SET-ing of the variables  that were needed (and could choose to only do calculations if variables were requested).  If no SET-BLOCK! was on the left, it could just return a value as usual.</p>
<p>But this was not generalized in a way that functions could share.</p>
<h1>April 2020: Unify With The Historical Refinement Model</h1>
<p>The old school "multiple return" method was to pass in WORD!s to set as variables.  Such as DO/NEXT:</p>
<pre><code> r3-alpha&gt;&gt; value: do/next [1 + 2 10 + 20] 'pos
 == 3

 r3-alpha&gt;&gt; pos
 == [10 + 20]
</code></pre>
<p>You see that DO could check for the presence of the /NEXT refinement and behave differently.  <em>It knows whether it has one return value or two.</em>  Based on that knowledge, many routines might have more optimized implementations when not all the possible return results they could give are wanted.</p>
<p>But since this mechanism existed, why couldn't the evaluator build a bridge so that the variables in the SET-BLOCK! would be passed in to specially marked refinement slots?</p>
<p>In April 2020, I implemented that.  It made variables passed from a SET-BLOCK! on the left compatible with the historical method of passing WORD!s via refinements...to be SET by the function as additional outputs....</p>
<p>This comment <a href="https://github.com/metaeducation/ren-c/commit/3a6fe97a419cdbd61304ee63f7129164af95e5b4">from the C code commit</a> explains how that prototype was approached.</p>
<pre><code>//==//// SET-BLOCK! //////////////////////////////////////////////////////==//
//
// The evaluator treats SET-BLOCK! specially as a means for implementing
// multiple return values.  The trick is that it does so by pre-loading
// arguments in the frame with variables to update, in a way that could have
// historically been achieved with passing a WORD! or PATH! to a refinement.
// So if there was a function that updates a variable you pass in by name:
//
//     result: updating-function/update arg1 arg2 'var
//
// The /UPDATE parameter is marked as being effectively a "return value", so
// that equivalent behavior can be achieved with:
//
//     [result var]: updating-function arg1 arg2
</code></pre>
<p>So all you needed to do to get the feature was mark a refinement as an output parameter.  Then check to see if it's null or not, and assign it if it's a WORD! or PATH!...the same way you ever would have.</p>
<p>You can use it in the old style (like a TRANSCODE/NEXT being passed a position to update) or you can use the SET-BLOCK! syntax and let the evaluator do the magic.</p>
<p>That meant these two calls would appear equivalent to the insides of TRANSCODE:</p>
<pre><code>&gt;&gt; value: transcode/next/relax "1 [2] &lt;3&gt;" 'next-pos 'error

&gt;&gt; [value next-pos error]: transcode "1 [2] &lt;3&gt;"
</code></pre>
<p>We're also given the feature of being able to check for if a return is requested, and vary the behavior based on it:</p>
<pre><code> &gt;&gt; transcode "abc def ghi"
 == [abc def ghi]

 &gt;&gt; [value rest]: transcode "abc def ghi"
 == abc

 &gt;&gt; rest
 == [def ghi]
</code></pre>
<p><strong><a href="../../transcode-and-load-multi-return-improvements/1925.html">TRANSCODE and LOAD seemed to show great results immediately</a></strong> <em>(though later problems of composability from this feature ultimately lead to it being panned to use in core functions <img src="../../../images/emoji/twitter/frowning.png%3Fv=9" title=":frowning:" class="emoji" alt=":frowning:"> )</em></p>
<p>And this was tried going along for the next year...</p>
        </div>

        <meta itemprop='headline' content='The History of Multi-Return in Ren-C'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="2" />
           <span class='post-likes'>2 Likes</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

            <div class='crawler-linkback-list' itemscope itemtype='http://schema.org/ItemList'>
                  <div itemprop='itemListElement' itemscope itemtype='http://schema.org/ListItem'>
                    <a href="../../transcode-and-load-multi-return-improvements/1925.html" itemscope itemtype='http://schema.org/DiscussionForumPosting' itemprop='item'>
                      <meta itemprop='url' content='https://forum.rebol.info/t/transcode-and-load-multi-return-improvements/1925'>
                      <span itemprop='name'>TRANSCODE and LOAD Multi-Return Improvements</span>
                    </a>
                    <meta itemprop='position' content='3'>
                  </div>
            </div>
      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="../1134.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2022-07-04T19:10:11Z'>
              <time itemprop='dateModified' datetime='2022-08-20T10:06:31Z' class='post-time'>
                August 20, 2022, 10:06am
              </time>
          <span itemprop='position'>#9</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <p>The multi-returns were WORD!s of the variables...while usually being named as the variables they represent.  <strong>This made them misleading if you tried to assign them.</strong></p>
<p>Here's an example of a very common mistake:</p>
<pre><code>remove-tags: func [  ; version that looks like it *should* be right but wasn't
    {Return block with all tags removed}

    return: [block!]
    num-removed: [integer!]

    block [block!]
][
    num-removed: 0
    while [not tail? block] [
        if tag? block.1 [
             take block
             removals: me + 1
        ]
    ]
    return block
]
</code></pre>
<p>That doesn't work because it's overwriting the WORD! that NUM-REMOVES may-or-may-not hold.</p>
<p>Here's how you had to do it instead:</p>
<pre><code>remove-tags: func [  ; ugly working version, but that's easy to get wrong
    {Return block with all tags removed}

    return: [block!]
    num-removed: [integer!]

    block [block!]
][
    let removals: 0
    while [not tail? block] [
        if tag? block.1 [
             take block
             removals: me + 1
        ]
    ]
    if num-removed [set num-removed removals]
    return block
]
</code></pre>
<h1>July 2022: Proxying Multi-Return Was Invented</h1>
<p>Each output variable was given its own local variable as the output.  Then when the function finishes, the multi-return mechanics proxied the contents of that local variable to whatever you passed in as the variable to assign.</p>
<p>This was desirable for other reasons:</p>
<ul>
<li>
<p>It meant that if a function errored, then no changes to the variables you used on the left hand side of a multi-return would be made.</p>
</li>
<li>
<p>It prevents unwanted dependencies: you don't want a multi-return to intentionally--or accidentally--have variant behavior based on the name of the variable it is returning.  (<em>that</em> is a feature that should be restricted to refinements that pass WORD!, because you're getting the word...)</p>
</li>
<li>
<p>Having a local variable to store a result in whether there was a multi-return request for it or not means that if you do a calculation that has a by-product you use during the body of your function, you don't need a separate name for that.</p>
</li>
</ul>
<p>But there would have to be some other means to know if a variable was requested by the callsite.  With some amount of hand-waving, I called that <strong>WANTED?</strong>... where you'd pass in the WORD! of the multi-return argument and be told whether it was being assigned to an output variable or not.</p>
<h2>How Proxying Worked</h2>
<p>Functions would have two cells in the frame for each output parameter: one refinement with the output name, and one hidden local slot to store the writeback variable (if any)</p>
<ul>
<li>
<p>A prelude would run before the function body, where whatever is in the refinement slots for the outputs would be shifted into their associated local slot.</p>
<ul>
<li>
<p>If no variable is given, then the refinement slot would be overwritten with a ~ isotope, indicating an unset variable state.  The hidden writeback slot would be set to null.</p>
</li>
<li>
<p>If a variable was given, the the refinement slot would again be written to indicate unset.  But the variable would be moved into the writeback slot</p>
</li>
<li>
<p>The WANTED? function is implemented by having the implementation peek into the hidden writeback slot and report if anything is there</p>
</li>
</ul>
</li>
<li>
<p>During the body of the function they use the named interface slot normally...assigning and reading with ordinary SET-WORD! and variable access (instead of needing SET and GET)</p>
</li>
<li>
<p>When the body is finished, an epilogue writes the value of the output cells for any that had saved variables</p>
<ul>
<li>
<p>This is also a good time to do typechecking</p>
</li>
<li>
<p>Internally, the parameter slot for the output variable can keep the types to check, as it can never be specialized</p>
</li>
</ul>
</li>
</ul>
<p>The epilogue runs at the moment of RETURN if a function has a return...because that's when the stack still has information of which return path has the problem (if there's more than one such path).  This is consistent with the historical concept that it's RETURN that does the typechecking.</p>
<h2>In November 2020, I Had Actually Mused About Proxying</h2>
<blockquote>
<p>"We could imagine a different setup which tried to let you just do <strong>multi: 10</strong> directly, and then when the operation was over would proxy that value into the target variable.  And it could use some similar rules about how when the frame started, it could be either NULL if it wasn't wanted or <code>#</code> if it was wanted.  But that seems a lot more error-prone.  And the variable exists anyway to make the request...so why not go ahead and set it where it is, instead of going through a middleman anyway?"*</p>
</blockquote>
<p>So I seem to have talked myself out of it because it would cost an extra slot for each variable, and people might not remember to check the state and lose it.</p>
<p><strong>But that was wrong thinking...it's much, much better and worth it.</strong>  Things quickly got more comprehensible in UPARSE (it was a large diff, so linking directly to it doesn't seem to work):</p>
<p><a href="https://github.com/metaeducation/ren-c/commit/3b0d9ba37bc03f7a8033b93180fb5f4d59913185#diff-dd8fb57db4500bffad0a67b376380db3c4b259ab95683d09e577850bf19f2299" class="inline-onebox">Inefficient first-cut at multi-return proxying · metaeducation/ren-c@3b0d9ba · GitHub</a></p>
<p>But lingering issues regarding wrapping and composing multi-returns remained...</p>
        </div>

        <meta itemprop='headline' content='The History of Multi-Return in Ren-C'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="2" />
           <span class='post-likes'>2 Likes</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="1" />
          </div>

      </div>
      <div itemscope itemtype='http://schema.org/DiscussionForumPosting' class='topic-body crawler-post'>
        <div class='crawler-post-meta'>
          <div itemprop='publisher' itemscope itemtype="http://schema.org/Organization">
            <meta itemprop='name' content='AltRebol'>
              <div itemprop='logo' itemscope itemtype="http://schema.org/ImageObject">
                <meta itemprop='url' content='https://forum.rebol.info/uploads/default/original/1X/ae4ccad1a2789bb1e85cf5a0f52f2f1de10da26d.png'>
              </div>
          </div>
          <span class="creator" itemprop="author" itemscope itemtype="http://schema.org/Person">
            <a itemprop="url" href='https://forum.rebol.info/u/hostilefork'><span itemprop='name'>hostilefork</span></a>
            
          </span>

          <link itemprop="mainEntityOfPage" href="../1134.html">


          <span class="crawler-post-infos">
              <meta itemprop='datePublished' content='2022-11-27T04:54:58Z'>
              <time itemprop='dateModified' datetime='2022-11-27T10:36:44Z' class='post-time'>
                November 27, 2022, 10:36am
              </time>
          <span itemprop='position'>#12</span>
          </span>
        </div>
        <div class='post' itemprop='articleBody'>
          <aside class="quote no-group" data-username="hostilefork" data-post="9" data-topic="1134">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But lingering issues regarding wrapping and composing multi-returns remained...</p>
</blockquote>
</aside>
<p>The proxying technique had shown clear advantages for the authors of functions, to be able to do direct assignments vs. need to remember to always <strong><code>SET</code></strong> the named variable passed in.</p>
<p>But underneath the hood, the names of the variables were still like inputs to the lower-level function.  This went as far as trying to act compatibly with the variable-passed-by-refinement trick that historical Redbol used for multiple returns.</p>
<p>Among the many problems were trying to write something like ENCLOSE.  An enclosing function could only influence the primary output, unless it went through some particularly convoluted work:</p>
<ul>
<li>
<p>It would have to capture the variable name passed in before delegating, because the name would be repurposed as the proxied value slot</p>
</li>
<li>
<p>The delegated function would be called and would update the variable as part of its RETURN</p>
</li>
<li>
<p>The encloser would then have to read back this written variable with GET to see it, and use SET to update it...again.</p>
</li>
</ul>
<p>Here's an example of what you could think you might have to do:</p>
<pre><code>multi-returner: func [
    return: [integer!]
    extra: [integer!]
][
    extra: 20  ; by this point, variable passed as /EXTRA hidden
    return 10  ; stowed /EXTRA variable written back using EXTRA's 20 value
]

wrapper: enclose :multi-returner func [f [frame!]] [
    let extra-var: f.extra  ; capture var before call via DO moves it aside
    result: do f  ; callee proxies input variable during RETURN
    set extra-var (get extra-var) + 1  ; get new written value and update it 
    return result + 1
]

&gt;&gt; [a b]: wrapper
== 11

&gt;&gt; a
== 11

&gt;&gt; b
== 21
</code></pre>
<p><em>The situation was actually even worse than that.</em>  All the complex logic for filling proxy slots with variable WORD!s was done during the frame building.  e.g. <strong><code>extra-var</code></strong> wasn't the hypothetical "parameter passed to extra before it got shifted into a hidden variable slot by FUNC", it was already the unset slot to be filled by the callee.  And the actual variable name was private, known only to the enclosed function.</p>
<p><em>And it's worse than that</em> if you want to preserve the ability to have behavior depending on how many inputs are requested, because there may be no variable at all... or an "opt in for the feature without a variable" placeholder.  Correct code would be much more convoluted, if meaningful code could be written at all.</p>
<p>The headaches go deeper.  Copying a frame and running it multiple times introduced semantic and ordering problems about the writing of these additional outputs!</p>
<h2>Simply Put: Variable Names As Inputs Make Poor Outputs</h2>
<p>All of this pointed to the inconvenient truth:</p>
<p><strong>Implementing a function's conceptual outputs by passing named variables as input that are imperatively written during the function's body--anywhere, even at the end--is something that will break composition.</strong></p>
<p><strong>It's also horrible for atomicity, because a SET of an output variable may happen but then there's an error which occurs before the final return result can be produced... so any multi-return function working in this way is either broken or bearing an undue burden to do its own "transaction management", which is to say probably also broken.</strong></p>
<p>Of course we knew this.  But to get the desired effects (single return unless you use a SET-BLOCK!), there's no other choice, right?</p>
<p>The idea of making an ANY-VALUE! which tried to bundle values was nixed in the beginning.  Because if we declared some new datatype to represent a multi-return pack that decays to its first value when assigned to a variable, you enter a catch-22, like this early puzzle when <strong><code>@[...]</code></strong> was being considered to denote multi-returns:</p>
<pre><code>multi-return: func [] [
    return @[10 20]  ; assume RETURN is "magic" and returns @[10 20] vs. 10
]

&gt;&gt; x: multi-return
== 10

&gt;&gt; [x y]: multi-return
== 10

&gt;&gt; x
== 10

&gt;&gt; y
== 20
</code></pre>
<p>The problems are apparent on even a trivial analysis.  These "highly reactive" <strong><code>@[...]</code></strong> values wreak havoc in a general system.  If you walked across a block and encountered one, trying to work with it to store them in a variable would introduce distortions on assignment when they "decayed" to their first element.</p>
<pre><code>for-each x [foo @[10 20] bar] [
    if integer? x [...]  ; INTEGER? sees @[10 20] as just 10
] 
</code></pre>
<p><img src="../../../images/emoji/twitter/man_facepalming.png%3Fv=9" title=":man_facepalming:" class="emoji" alt=":man_facepalming:"> ...but gee... if only there were some variation of BLOCK! which you could be guaranteed not to encounter when enumerating other blocks, and that couldn't be stored in variables... and a method for dealing with transforming them into and out of reified states so you could work with them...</p>
<p><em>Hey, waitaminute...</em> <img src="../../../images/emoji/twitter/atom_symbol.png%3Fv=9" title=":atom_symbol:" class="emoji" alt=":atom_symbol:"></p>
<h2>September 2022: Core Multi-Return via Isotopic BLOCK!</h2>
<p><a href="https://forum.rebol.info/t/a-justification-of-generalized-isotopes/1918">Generalized Isotopes</a> made longstanding problems seem to fall like dominos; like block splicing and error handling.  And they could be applied here, too... solving several profound problems:</p>
<ul>
<li>
<p>As with all isotopes, you wouldn't be able to put BLOCK! isotopes in blocks...alleviating many conceptual problems.</p>
</li>
<li>
<p>Yet even more severely, you wouldn't be able to put BLOCK! isotopes in <em>variables</em>.  Isotopic BLOCK!s would decay to their first value when assigned to <em>any</em> variable</p>
<ul>
<li>
<p>This turned out to be the <em>only</em> isotopic "decay" mechanism required, subsuming prior concepts like decaying "heavy null" to "light null".  Heavy null would simply be a null representation in an isotopic block.</p>
</li>
<li>
<p>Representing things like null would be possible since ^META values would be used in the multi-return convention, to afford the multi-return of isotopes themselves</p>
</li>
</ul>
</li>
<li>
<p>Fitting in with the general rules of isotopes, a QUASI-BLOCK! would evaluate to an isotopic block:</p>
<pre><code>&gt;&gt; ~['10 '20]~
== ~['10 '20]~  ; isotope

&gt;&gt; x: ~['10 '20]~
== 10
</code></pre>
</li>
<li>
<p>Functions that might be interested in the isotopic state would need to take a parameter via a ^META parameter, in which case they would receive a QUASI-BLOCK! vs the decayed parameter</p>
<ul>
<li>
<p>A good example of a function that would want this would be RETURN, in order to be able to have a forwarding mode that would return an isotopic result vs. its decayed first value</p>
</li>
<li>
<p><strong>This doesn't rule out the proxying-named-output-variable concept</strong>; in fact it fixes its problems, by limiting the relevance of the fact that proxying is being used to the interior of the function, and making its external speak the isotopic block protocol.  If you want a proxying-FUNC you can have it.</p>
</li>
<li>
<p>It also opens the doors to many other conceptions of how to abstract the multi-return process</p>
</li>
</ul>
</li>
<li>
<p>SET-BLOCK! assignments would have special understandings of how to decompose isotopic blocks and assign the component variables</p>
<ul>
<li>
<p>This would break the uneasy "backchannel" between caller and callee of variable names</p>
</li>
<li>
<p>The most obvious sign this had been a problem was that mere parenthesization would break historical multi-assignment:</p>
<pre><code>&gt;&gt; [a b]: multi-return   ; would work

&gt;&gt; [a b]: (multi-return)  ; would act like `(a: multi-return)`
</code></pre>
</li>
<li>
<p>Now any expression that doesn't store a variable as intermediate can act pass-thru (such as a conditional), and if a variable wanted to capture the multi-return character temporarily it could META it...potentially manipulate the QUASI-BLOCK!, and UNMETA it back</p>
</li>
</ul>
</li>
</ul>
<h2>Casualties of Composability</h2>
<p>One casualty of this was be the feature of being able to make a function's behavior depend on how many outputs were requested.  But the feature can still be achieved with enfix quoting left-hand-side and managing the assignment, it's just no longer be something the core attempts to generalize.</p>
<p>Another casualty is legacy compatibility with passing in variable names via refinement.  But again: this feature could be achieved by AUGMENT-ing the function with the refinement, then ENCLOSE-ing that with something that wrote the multi-return's output to the variable passed in via that augmented refinement.</p>
<p>But there's really no competition here.  As I've hopefully made clear, passing in a named variable via refinement is simply not in the same league as a mechanism which legitimately makes additional outputs.</p>
<p><strong>As usual with these things, I'll admit it may not be simple or obvious at first glance, but the results are speaking for themselves!</strong></p>
        </div>

        <meta itemprop='headline' content='The History of Multi-Return in Ren-C'>

        <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
           <meta itemprop="interactionType" content="http://schema.org/LikeAction"/>
           <meta itemprop="userInteractionCount" content="2" />
           <span class='post-likes'>2 Likes</span>
         </div>

         <div itemprop="interactionStatistic" itemscope itemtype="http://schema.org/InteractionCounter">
            <meta itemprop="interactionType" content="http://schema.org/CommentAction"/>
            <meta itemprop="userInteractionCount" content="0" />
          </div>

      </div>






    </div>
    <footer class="container wrap">
      <nav class='crawler-nav'>
        <ul>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/' itemprop="url">Home </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/categories' itemprop="url">Categories </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/guidelines' itemprop="url">FAQ/Guidelines </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/tos' itemprop="url">Terms of Service </a>
          </span>
        </li>
        <li itemscope itemtype='http://schema.org/SiteNavigationElement'>
          <span itemprop='name'>
            <a href='https://forum.rebol.info/privacy' itemprop="url">Privacy Policy </a>
          </span>
        </li>
        </ul>
      </nav>
      <p class='powered-by-link'>Powered by <a href="https://www.discourse.org">Discourse</a>, best viewed with JavaScript enabled</p>
    </footer>
    
    
  </body>
  
</html>

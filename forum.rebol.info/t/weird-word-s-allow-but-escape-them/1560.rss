<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Weird WORD!s - Allow, But Escape Them?</title>
    <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560</link>
    <description>My feeling is you should be able to build paths and tuples out of anything that&#39;s a valid WORD!.  But is it time we had an escaping mode for &quot;weird words&quot;?

Let&#39;s say you didn&#39;t want **`&lt;.&gt;`** to be a  TAG!, but rather a TUPLE! where the first element was **`&lt;`** and the second was **`&gt;`**.

We could do something like backquotes:

    `&lt;`.`&gt;`

Having an escaping mode for words would open up more lexical space.  For instance,  I like the idea of allowing $FOO, $(FOO), $FOO/BAR, $[FOO BAR] etc. as another type...

But this would seem to kill off the idea of being able to have `$` and `$$` etc. as WORD!s, because you get into ambiguous situations... is $/foo a PATH! with the $ word in the first slot, or an ENV-PATH! with an empty first slot?

These ambiguities create problems for other things that might stand alone all right, because we don&#39;t want to have &quot;second-class-citizen&quot; WORD!s that can&#39;t appear in paths.

But what if we used backticks if they wind up in paths?

    `$`/foo   ; PATH! with $ in the first slot
    $/foo  ; ENV-PATH! with blank in the first slot

This could give us the likes of `:` and `::` as operators...

    &gt;&gt; `:`: does [print &quot;I am colon!&quot;]

    &gt;&gt; :
    I am colon!

    &gt;&gt; type of :`:`
    == #[datatype! action!]

It could work for other standalone characters, like **`@`** and perhaps **`&amp;`**.  **%** could be the same (with %&quot;&quot; or %{} used for empty file)

I feel like # and / may not be good candidates for this treatment, it would need more thought.

**The point wouldn&#39;t be that you&#39;d likely be going crazy with paths involving these characters, but rather that you might want to do interesting things with them standalone.**  It&#39;s just to put them on the map as legitimate words.</description>
    
    <lastBuildDate>Mon, 01 Aug 2022 20:00:48 +0000</lastBuildDate>
    <category>Philosophy</category>
    <atom:link href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="IngoHohmann" data-post="4" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>This way there's no need to invent new escaping rules, because it's already there in strings.</p>
</blockquote>
</aside>
<p>I do agree the same escaping rules should be used, but I think the caret-escaping is an increasingly poor idea.</p>
<p>Carl <a href="https://forum.rebol.info/t/carls-new-projects-altscript-altos/1571">wanted to move away from it</a> and use C's escaping:</p>
<blockquote>
<p>String character escapes use C notation. They use backslash notation, for example "\n" for newline and "\t" for tab.</p>
</blockquote>
<p>I definitely feel that with caret taking on more of a purpose in the language now for ^META, that sticking with the status quo for escaping in strings may be wise.</p>
<p>Needs thought...</p>
          <p><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/5</link>
        <pubDate>Mon, 01 Aug 2022 20:00:48 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1560-5</guid>
        <source url="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560.rss">Weird WORD!s - Allow, But Escape Them?</source>
      </item>
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
        <description><![CDATA[
            <p>Another idea might be to have backticked (or something else) braced strings be the notation for weird words.</p>
<pre><code class="lang-auto">`{word.with.dots}
`{|||}
`{ and with {} inside and spaces aroun }
</code></pre>
<p>This way there's no need to invent new escaping rules, because it's already there in strings.</p>
          <p><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/4</link>
        <pubDate>Sun, 31 Jul 2022 21:54:29 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1560-4</guid>
        <source url="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560.rss">Weird WORD!s - Allow, But Escape Them?</source>
      </item>
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>With a new rule pending that <a href="https://forum.rebol.info/t/big-alien-proposal-refinements-run-functions/1905">"word-active functions" have to be assigned with SET-PATH!s</a> e.g. <strong>/foo:</strong> then that means "weird words" like <strong><code>&lt;</code></strong> and <strong><code>||</code></strong> and <strong><code>|&gt;</code></strong> have to be able to be in paths.</p>
<p>So unfortunately, this is now a blocking item.  Time to revisit it.</p>
<hr>
<aside class="quote no-group" data-username="IngoHohmann" data-post="2" data-topic="1560">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/ingohohmann/40/195_2.png" class="avatar"> IngoHohmann:</div>
<blockquote>
<p>I'm not yet a big fan of this specific proposal, but can't think of anything better.</p>
</blockquote>
</aside>
<p>Long ago, <a class="mention" href="/u/mark-hi">@Mark-hi</a> suggested following Lisp's example and <a href="https://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node27.html">using vertical bars</a> for escaping symbols:</p>
<pre><code>&gt;&gt; |word with spaces|: 10

&gt;&gt; print ["The value is" |word with spaces|]
The value is 10
</code></pre>
<p>Maybe this seems more palatable.  But Lisp uses backslash to escape their vertical bars.  And we don't want to have to mangle things like: <strong><code>some ["a" | "b"]</code></strong> into:</p>
<pre><code>parse "ab" [some ["a" |\|| "b"]]
</code></pre>
<p>So we'd have to make some different tradeoffs in the design than Lisp.</p>
<h2>All-Vertical-Bar Tokens Could Be Escaping-Exempt</h2>
<p>For starters: if a token consists of <em>only</em> vertical bars, we might say we don't think of that as being escaped:</p>
<pre><code>&gt;&gt; as text! '|
== "|"

&gt;&gt; as text! '|||
== "|||"
</code></pre>
<p>You might say <em>"Hey, if it's that easy, why wouldn't Lisp have thought of that?"</em></p>
<p>It's because this sacrifices symbols that start and end with spaces.  So if you think this way, you <em>can't</em> have things like:</p>
<pre><code>&gt;&gt; as text! '| this wouldn't be possible |
== " this wouldn't be possible "
</code></pre>
<p>You'd have to escape the spaces one way or another:</p>
<pre><code>&gt;&gt; as text! '|\ maybe this would work\ |
== " maybe this would work "
</code></pre>
<p>Similar issues arise with commas and other delimiters.  We have to be able to decide if the sequence <strong><code>|,</code></strong>  is starting some arbitrary WORD! with a comma as the first character, or if that's a vertical bar WORD! followed by a COMMA!.   Same for <strong><code>|)</code></strong> to decide if you should consider that parenthesis to be a vertical bar WORD! followed by a parentheses that might close an existing group... or a arbitrary word with left parenthesis as the first character.</p>
<p>It seems pretty fair to me to say that delimiter characters can't be in your "arbitrary word" at the beginning or end, at least without escaping.  Though having dots in the words is a requested feature:</p>
<pre><code>&gt;&gt; as text! |graham.likes.these|
== "graham.likes.these"
</code></pre>
<p>I don't know the exact boundaries here:</p>
<pre><code>&gt;&gt; as text! |should this (work?)|
== "should this (work?)"
</code></pre>
<p>But seeing as we've gotten by for a pretty good while without such weirdness in WORD! at all, I don't think these edge cases need to be the focus of the present moment.</p>
<p>Note that even though <strong><code>foo</code></strong> and <strong><code>|foo|</code></strong> could be interchangeable, we can't say <strong><code>|</code></strong> and <strong><code>|||</code></strong> are interchangeable.  Instead, <strong><code>|</code></strong> would be interchangeable with <strong><code>|\||</code></strong>.</p>
<h2>What About Things Like "Flags" <code>&lt;|</code>
</h2>
<p>As with the "all bars" cases, we want to be able to use these unescaped as operators.  For instance, "left flag" has been used to point to the left evaluation while eliding everything to the right:</p>
<pre><code>&gt;&gt; 1 + 2 &lt;| print "Hello" print "World"
Hello
World
== 3
</code></pre>
<p>But just because they would be unescaped when standing alone, doesn't mean we can get away with that everywhere.  Let's imagine we want to make the PATH! whose first element is <strong><code>&lt;|</code></strong> and whose second element is <strong><code> |&gt;</code></strong></p>
<p>Under <a href="https://forum.rebol.info/t/raw-strings/1750/14">new design proposals</a>, if we just were to write <strong><code>&lt;|/|&gt;</code></strong>, that's actually a TAG!...the kind of tag that would permit internal &lt; and &gt;</p>
<pre><code>&gt;&gt; as text! &lt;|&lt;|&gt;
== "&lt;"
</code></pre>
<p>So we'd get:</p>
<pre><code>&gt;&gt; type of &lt;|/|&gt;
== #[datatype! tag!]

&gt;&gt; as text! &lt;|/|&gt;
== "/"
</code></pre>
<p>To try for the PATH! we want, let's think about hypothetically just wrapping the flags in vertical bars:</p>
<pre><code>&gt;&gt; as block! '|&lt;||/||&gt;|
== [&lt;| |&gt;]
</code></pre>
<p>It's not the <em>worst</em> looking thing. <img src="https://forum.rebol.info/images/emoji/twitter/worried.png?v=9" title=":worried:" class="emoji" alt=":worried:"></p>
<p>But if we're not escaping the vertical bar that's part of the flag, then how it would know that the first element should be <strong><code>&lt;|</code></strong> instead of seeing the <code>|&lt;|</code> pattern and assuming that meant it was <strong><code>&lt;</code></strong> ?</p>
<p>One reasoning <em>could</em> be that as long as it hasn't hit a delimiter (<strong>]</strong> or <strong>)</strong> or <strong>,</strong> or <strong>/</strong> or <strong>.</strong> or space or newline) then all vertical bars are considered content.</p>
<p>This policy would allow:</p>
<pre><code>&gt;&gt; /|&lt;||: does [print "Hello"]

&gt;&gt; &lt;|
Hello
</code></pre>
<p><em>But again</em> we have to ask what such assumptions rule out.  And what it rules out are any internal delimiters--so no spaces, parentheses, brackets, dots, slashes.</p>
<p>That seems a bit much to throw out, for the sake of a few weird operators...if-and-when they happen to wind up in paths.  So we'd probably have to escape this:</p>
<pre><code>&gt;&gt; /|&lt;\||: does [print "Hello"]

&gt;&gt; &lt;|
Hello
</code></pre>
<h2>Otherwise, Start-And-End Vertical Bar Must Be Escaped</h2>
<p>So there's an idea that <strong><code>&lt;|</code></strong> won't require escaping when standalone as WORD!, but then when they are put in PATH! they will be as <strong><code>|&lt;\||</code></strong>.</p>
<p>But what about <strong><code>|&lt;|</code></strong> ?  That notation pretty clearly needs to be reserved for how <strong><code>&lt;</code></strong> appears when put in a PATH!, otherwise we'd have things like <strong><code>&lt;/&gt;</code></strong> would be a PATH! and not a TAG!.  (It needs to be a TAG!)</p>
<h2>Quick Look At Those Backticks Again</h2>
<p>Backticks have the advantage that we seem to be 99% uninterested in them as symbols otherwise.  So it's a bit less messy:</p>
<pre><code>/`&lt;|`: does [print "Hello"]
</code></pre>
<p>But they still might have other applications that are less esoteric.  It seems wasteful to apply them here.</p>
<p><em>Especially</em> because in practice, we have an evaluator to draw from, which could make things look better:</p>
<pre><code>/('&lt;|): does [print "Hello"]
</code></pre>
<p>Actually...that is probably what I would suggest doing.  But if such paths can be formed, then we have to have a representation for them... like if they get COMPOSE'd</p>
<pre><code>&gt;&gt; compose the /('&lt;|):
== /|&lt;\||:  ; or whatever
</code></pre>
<p>It's not great...but when working in the limited medium of text, you wind up with these kinds of things.  Hopefully it would be pretty rare.</p>
<h2>Tentative Strategy</h2>
<p><strong>I think that it's rare enough that people will be putting vertical-bar-words in paths and tuples we can just go ahead and say you always escape them.</strong></p>
<p>Sure, we <em>could</em> say that <strong><code>|.|</code></strong> is a TUPLE! instead of a representation of a single-character period WORD!  But I think that it will be much more often desirable to have <strong><code>|.word|</code></strong> without having to write <strong><code>|\.word|</code></strong></p>
<p>So if you want two vertical bars in a TUPLE! you'd say <strong><code>|\||.|\||</code></strong> - and that should be reasonable discouragement against saying it too often.  <img src="https://forum.rebol.info/images/emoji/twitter/slight_smile.png?v=9" title=":slight_smile:" class="emoji" alt=":slight_smile:"></p>
<p><strong>But spaces and commas and parentheses and such will need to be delimited inside your "weird escaped words", at least at the start and end.</strong></p>
<pre><code>&gt;&gt; block: transcode "(|) (|)"
== [(|) (|)]

&gt;&gt; type of first block
== #[datatype! group!]

&gt;&gt; length of first block
== 2

&gt;&gt; first first block
== |
</code></pre>
<p>e.g. this is not a GROUP! holding a word with a spelling of ") ("</p>
<p><strong>If it starts AND ends with a vertical bar, it's an escape notation <em>unless it's all vertical bars</em>.</strong></p>
<p>Hopefully this is enough of a sketch to enable pushing through to the next dilemma...</p>
          <p><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/3</link>
        <pubDate>Sat, 30 Jul 2022 21:40:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1560-3</guid>
        <source url="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560.rss">Weird WORD!s - Allow, But Escape Them?</source>
      </item>
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[IngoHohmann]]></dc:creator>
        <description><![CDATA[
            <p>I definitely think there should be a way to escape weird words.<br>
I'm not yet a big fan of this specific proposal, but can't think of anything better.</p>
          <p><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/2</link>
        <pubDate>Mon, 15 Mar 2021 14:18:47 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1560-2</guid>
        <source url="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560.rss">Weird WORD!s - Allow, But Escape Them?</source>
      </item>
      <item>
        <title>Weird WORD!s - Allow, But Escape Them?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>My feeling is you should be able to build paths and tuples out of anything that's a valid WORD!.  But is it time we had an escaping mode for "weird words"?</p>
<p>Let's say you didn't want <strong><code>&lt;.&gt;</code></strong> to be a  TAG!, but rather a TUPLE! where the first element was <strong><code>&lt;</code></strong> and the second was <strong><code>&gt;</code></strong>.</p>
<p>We could do something like backquotes:</p>
<pre><code>`&lt;`.`&gt;`
</code></pre>
<p>Having an escaping mode for words would open up more lexical space.  For instance,  I like the idea of allowing $FOO, $(FOO), $FOO/BAR, $[FOO BAR] etc. as another type...</p>
<p>But this would seem to kill off the idea of being able to have <code>$</code> and <code>$$</code> etc. as WORD!s, because you get into ambiguous situations... is $/foo a PATH! with the $ word in the first slot, or an ENV-PATH! with an empty first slot?</p>
<p>These ambiguities create problems for other things that might stand alone all right, because we don't want to have "second-class-citizen" WORD!s that can't appear in paths.</p>
<p>But what if we used backticks if they wind up in paths?</p>
<pre><code>`$`/foo   ; PATH! with $ in the first slot
$/foo  ; ENV-PATH! with blank in the first slot
</code></pre>
<p>This could give us the likes of <code>:</code> and <code>::</code> as operators...</p>
<pre><code>&gt;&gt; `:`: does [print "I am colon!"]

&gt;&gt; :
I am colon!

&gt;&gt; type of :`:`
== #[datatype! action!]
</code></pre>
<p>It could work for other standalone characters, like <strong><code>@</code></strong> and perhaps <strong><code>&amp;</code></strong>.  <strong>%</strong> could be the same (with %"" or %{} used for empty file)</p>
<p>I feel like # and / may not be good candidates for this treatment, it would need more thought.</p>
<p><strong>The point wouldn't be that you'd likely be going crazy with paths involving these characters, but rather that you might want to do interesting things with them standalone.</strong>  It's just to put them on the map as legitimate words.</p>
          <p><a href="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560/1</link>
        <pubDate>Mon, 15 Mar 2021 03:30:50 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1560-1</guid>
        <source url="https://forum.rebol.info/t/weird-word-s-allow-but-escape-them/1560.rss">Weird WORD!s - Allow, But Escape Them?</source>
      </item>
  </channel>
</rss>

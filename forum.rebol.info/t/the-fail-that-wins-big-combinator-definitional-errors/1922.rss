<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>The FAIL That Wins Big: Combinator Definitional Errors</title>
    <link>https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922</link>
    <description>## Announcing Another Major Step Forward...

As the wheels of thought began to churn around TRY, it came to seem clear that it had a higher purpose in defusing definitional errors.

This led to a thought about how if UPARSE were to allow calling arbitrary decoders (like DEBIN) that would deliver informative errors when the input wasn&#39;t a fit...that those errors would need to be interpreted as &quot;soft&quot; parse match failures...moving on to the next alternate.

That called back to another musing about why we don&#39;t use the readable word TRY instead of OPT in PARSE when we want to say a component of a parse is optional.

But so long as the combinator-skinned-decoders are communicating in errors, **why not make combinators always indicate failure with definitional errors?**

* This would free up NULL as a synthesized product to just be an ordinary result, which had been a sticking point trying to wrangle the dual needs of isotopic nulls in a fully generic dialect.

* The parsers would be able to generate diverse and informative errors, that in debug modes could be tagged with where they came from.  Parsers could distinguish between tunneling an error generated by another parser and emitting their own...providing more information for tracing tools.

**It only took a couple of days to do...** most of which was just sorting out a lot of edge cases from being a very thorough client of the relatively untested definitional error infrastructure.

But expect good things from this!

## A Bit Of History: How The Previous Model Came To Be

When UPARSE was first conceived *(a mere year and a half ago)*, the combinators were responsible for returning three things:

* Whether the parser succeeded or not

* A synthesized value

* How much of the input was consumed (represented by a series position of the new &quot;current&quot; parse position, which could potentially be at the tail)

*(COLLECT and friends necessitated some more nuances, but you only have to worry about it manually if you need fine-grained control.  So most combinators look like these are the only results in play, with the other outputs being &quot;autopiped&quot; around by the machinery.)*

The second two results would only be applicable if the parser succeeded.  So rather than return three results, it aimed to return just two... and fold together the success with some invalid state for the other result.

At first this seemed like it would be best to fold with the series position.  This would mean that the position could be either a series value or NULL.  That way, NULL could be a valid synthesized product.  This came in handy for things like OPT:

    &gt;&gt; x: y: &lt;before&gt;

    &gt;&gt; did parse [1020] [x: integer! y: opt integer!]
    == #[true]  ; parse succeeded

    &gt;&gt; x
    == 1020

    &gt;&gt; y
    ; null

The first draft used the fledgling multi-return facility to do this, and it had the nice property of working with ELSE.  So when a combinator called a parser that failed, it was easy to handle that failure, e.g. to propagate that failure along:

    [pos synthesized]: parser input else [return null]

## But This Was Reversed... For... Reasons

A mechanical issue came up that VOID could only be represented by the primary return result of a function.  If a multi-return argument was going to be returned and convey voids, it would have to use the ^META protocol... and the caller would have to be explicitly aware that the result they got would be pre-quoted by convention.

But I also noticed that some combinators didn&#39;t want to advance the input at all, only operate to transform one synthesized product into another.  Or that they didn&#39;t really need to plug into the overall parse architecture.  It seemed like making combinators match as closely to a &quot;normal&quot; function--by putting their synthesized result as the primary result--just made sense.

NULL isotopes were just coming on the scene, which gave a potential way to get out of this: a successful parser which wanted to return NULL would return the isotope form.  Pure NULL would be reserved as the signal for isotopic failure.  This meant the reversed parameters would be able to work:

    [synthesized pos]: parser input else [return null]

Internally, to OPT something like **`y: opt integer!`** would not return NULL, but a ~null~ isotope.

## But Now, It&#39;s Done With Definitional Errors!

    [synthesized pos]: parser input except e -&gt; [return raise e]

Here you see the error being intercepted, and then passed on.  NULL is free to be dealt with as a normal product without interference.  And there&#39;s a difference between generating a new error (tagging it with the location in the parse rules and the context) vs. just passing on one that was generated by a subparser--you are actually keeping a record of what happened, to show in logs or otherwise.</description>
    
    <lastBuildDate>Mon, 22 Aug 2022 13:05:25 +0000</lastBuildDate>
    <category>Errors</category>
    <atom:link href="https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>The FAIL That Wins Big: Combinator Definitional Errors</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <h2>Announcing Another Major Step Forward...</h2>
<p>As the wheels of thought began to churn around TRY, it came to seem clear that it had a higher purpose in defusing definitional errors.</p>
<p>This led to a thought about how if UPARSE were to allow calling arbitrary decoders (like DEBIN) that would deliver informative errors when the input wasn't a fit...that those errors would need to be interpreted as "soft" parse match failures...moving on to the next alternate.</p>
<p>That called back to another musing about why we don't use the readable word TRY instead of OPT in PARSE when we want to say a component of a parse is optional.</p>
<p>But so long as the combinator-skinned-decoders are communicating in errors, <strong>why not make combinators always indicate failure with definitional errors?</strong></p>
<ul>
<li>
<p>This would free up NULL as a synthesized product to just be an ordinary result, which had been a sticking point trying to wrangle the dual needs of isotopic nulls in a fully generic dialect.</p>
</li>
<li>
<p>The parsers would be able to generate diverse and informative errors, that in debug modes could be tagged with where they came from.  Parsers could distinguish between tunneling an error generated by another parser and emitting their own...providing more information for tracing tools.</p>
</li>
</ul>
<p><strong>It only took a couple of days to do...</strong> most of which was just sorting out a lot of edge cases from being a very thorough client of the relatively untested definitional error infrastructure.</p>
<p>But expect good things from this!</p>
<h2>A Bit Of History: How The Previous Model Came To Be</h2>
<p>When UPARSE was first conceived <em>(a mere year and a half ago)</em>, the combinators were responsible for returning three things:</p>
<ul>
<li>
<p>Whether the parser succeeded or not</p>
</li>
<li>
<p>A synthesized value</p>
</li>
<li>
<p>How much of the input was consumed (represented by a series position of the new "current" parse position, which could potentially be at the tail)</p>
</li>
</ul>
<p><em>(COLLECT and friends necessitated some more nuances, but you only have to worry about it manually if you need fine-grained control.  So most combinators look like these are the only results in play, with the other outputs being "autopiped" around by the machinery.)</em></p>
<p>The second two results would only be applicable if the parser succeeded.  So rather than return three results, it aimed to return just two... and fold together the success with some invalid state for the other result.</p>
<p>At first this seemed like it would be best to fold with the series position.  This would mean that the position could be either a series value or NULL.  That way, NULL could be a valid synthesized product.  This came in handy for things like OPT:</p>
<pre><code>&gt;&gt; x: y: &lt;before&gt;

&gt;&gt; did parse [1020] [x: integer! y: opt integer!]
== #[true]  ; parse succeeded

&gt;&gt; x
== 1020

&gt;&gt; y
; null
</code></pre>
<p>The first draft used the fledgling multi-return facility to do this, and it had the nice property of working with ELSE.  So when a combinator called a parser that failed, it was easy to handle that failure, e.g. to propagate that failure along:</p>
<pre><code>[pos synthesized]: parser input else [return null]
</code></pre>
<h2>But This Was Reversed... For... Reasons</h2>
<p>A mechanical issue came up that VOID could only be represented by the primary return result of a function.  If a multi-return argument was going to be returned and convey voids, it would have to use the ^META protocol... and the caller would have to be explicitly aware that the result they got would be pre-quoted by convention.</p>
<p>But I also noticed that some combinators didn't want to advance the input at all, only operate to transform one synthesized product into another.  Or that they didn't really need to plug into the overall parse architecture.  It seemed like making combinators match as closely to a "normal" function--by putting their synthesized result as the primary result--just made sense.</p>
<p>NULL isotopes were just coming on the scene, which gave a potential way to get out of this: a successful parser which wanted to return NULL would return the isotope form.  Pure NULL would be reserved as the signal for isotopic failure.  This meant the reversed parameters would be able to work:</p>
<pre><code>[synthesized pos]: parser input else [return null]
</code></pre>
<p>Internally, to OPT something like <strong><code>y: opt integer!</code></strong> would not return NULL, but a ~null~ isotope.</p>
<h2>But Now, It's Done With Definitional Errors!</h2>
<pre><code>[synthesized pos]: parser input except e -&gt; [return raise e]
</code></pre>
<p>Here you see the error being intercepted, and then passed on.  NULL is free to be dealt with as a normal product without interference.  And there's a difference between generating a new error (tagging it with the location in the parse rules and the context) vs. just passing on one that was generated by a subparser--you are actually keeping a record of what happened, to show in logs or otherwise.</p>
          <p><a href="https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922/1</link>
        <pubDate>Fri, 19 Aug 2022 02:27:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1922-1</guid>
        <source url="https://forum.rebol.info/t/the-fail-that-wins-big-combinator-definitional-errors/1922.rss">The FAIL That Wins Big: Combinator Definitional Errors</source>
      </item>
  </channel>
</rss>

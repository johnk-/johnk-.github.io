<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Custom Function Generator Pitfalls</title>
    <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093</link>
    <description>I commonly write function generators that put in some boilerplate to make some variables and service routines available to the generated function.  But these frequently have weaknesses, and I thought I&#39;d write up an example to illustrate...and explain some ways to mitigate the problems.

## Example: PROMISE Generator With RESOLVE and REJECT

Imagine I want to make a function variation that&#39;s like a JavaScript promise, with a RESOLVE and REJECT...which are defined per-promise.

Let&#39;s say the first cut of the new generator looks something like this:

    promise: func [spec body] [
        body: compose [
            let resolve: lambda [result] [  ; lambdas lack their own return
                some code here
                return whatever  ; intending return of generated FUNC
            ]
            let reject: lambda [error] [
                more code here
                return whatever
            ]
            (spread body)  ; code here should see RESOLVE and REJECT 
        ]
        return func spec body
    ]

When the frame is created for the new function, it will run this body that&#39;s been extended with some boilerplate.  But that frame&#39;s arguments could have the name of any of the functions you&#39;re using in the bodies of RESOLVE or REJECT.  e.g. what if I said **`foo: promise [code /more] [...]`** ... the implementations of RESOLVE and REJECT would be disrupted from what they thought the words they had used meant.

Once you notice this, you might think the solution is to pre-compute more things:

    promise: func [spec body] [
        body: compose [
            let resolve: ^(lambda [result] [
                some code here
                return whatever
            ])
            let reject: ^(lambda [error] [
                more code here
                return whatever
            ])
            (spread body)  ; code here should see RESOLVE and REJECT 
        ]
        return func spec body
    ]

*(Note use of ^META group in order to turn the isotopic frame produced by FUNC into a quasi frame, so that under evaluation in the function body it becomes isotopic again.  The compose would fail if you tried to compose the isotopic frame in directly.)*

That&#39;s a bit better in terms of insulating the boilerplate code from stray bindings coming from the user-supplied spec (though there&#39;s still the weakness of LET if the user wrote something like **promise [let [integer!]] [...]**, which if you cared you could address by composing :LET in as its literal function value).

But it does too good a job: the COMPOSE runs during the PROMISE fabrication time, and so the notion of RETURN used by RESOLVE and REJECT are is the return for the PROMISE generator itself... not the produced FUNC as intended.  This is true of anything else you need to have picked up from the instance (let&#39;s say REJECT was implemented in terms of RESOLVE, or needed some other local).

One way of addressing this would be to slip the instance RETURN in as a parameter, e.g. via specialization of the precomputed code:

    promise: func [spec body] [
        body: compose [
            let resolve: specialize ^(lambda [result ret] [
                some code here
                ret whatever
            ]) [ret: :return]
            let reject: specialize ^(lambda [error ret] [
                more code here
                ret whatever
            ]) [ret: :return]
            (spread body)  ; code here should see RESOLVE and REJECT 
        ]
        return func spec body
    ]

There you&#39;ve got an added assumed term which can break things, e.g. **`promise [let [integer!] specialize [block!]] [...]`** or similar.  But at least **some code here** and **more code here** are running under the understandings that the PROMISE generator author had of what those implementations meant.

Once you&#39;ve separated out that which can be precomputed vs. that which can&#39;t, there&#39;s no need to make the precomputed part every time:

    promise-resolve*: lambda [result ret] [
        some code here
        ret whatever
    ]

    promise-reject*: lambda [error ret] [
        more code here
        ret whatever
    ]

    promise: func [spec body] [
        body: compose [
            let resolve: specialize :promise-resolve* [ret: :return]
            let reject: specialize :promise-reject* [ret: :return]
            (spread body) 
        ]
        return func spec body
    ]

## Could Some Kind of COMPILE Operation Help?

Weaknesses due to redefinitions of things like LET and SPECIALIZE makes me wonder if situations like this could be helped by an operation that would replace words that look up to functions with references to the functions.  [The cell can retain the symbol for the word](https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357), which can make debugging and errors more tolerable.

    promise: func [spec body] [
        body: compose (compile [let specialize] [
            let resolve: specialize :promise-resolve* [ret: :return]
            let reject: specialize :promise-reject* [ret: :return]
            (spread body) 
        ])
        return func spec body
    ]

Merging with COMPOSE would be more efficient, and could help cue that you want to avoid compiling the things in GROUP!s.  Maybe it could assume you wanted to compile references to actions unless you threw in some kind of escaping:

    promise: func [spec body] [
        body: compile [
            let resolve: specialize :promise-resolve* [ret: $ :return]
            let reject: specialize :promise-reject* [ret: $ :return]
            (spread body) 
        ]
        return func spec body
    ]

I&#39;ve thought about this kind of thing for a while, but never got around to writing it.

## Paranoia Plus Efficiency: Body As GROUP! vs. Spliced

One improvement to this code is to splice the body as a group instead of spreading it itemwise in a block.

To see why this matters, consider something like:

    func-with-a-as-one: func [spec body] [
        return func spec compose [
            let a: 1
            (spread body)
        ]
    ]

Now let&#39;s say someone wrote:

    &gt;&gt; test: func-with-a-as-one [x] [+ 9, return a + x]

    &gt;&gt; test 1000
    == 1010  ; not 1001

Accidentally or intentionally, the function was defined as:

    func [x] [
       let a: 1
       + 9, return a + x
    ]

You can avoid this by quarantining the body, using **(as group! body)** instead of **(spread body)** in the COMPOSE.

    func [x] [
       let a: 1
       (+ 9, return a + x)
    ]

As an added benefit, the AS alias is cheaper memory-wise than copying the elements in item-wise (though it adds one extra GROUP! evaluation step to the function).

## Another Loophole: What If RESOLVE/REJECT Are Args?

If you use LET, currently that will override whatever definition is in play.  So if someone were to write **promise [x y reject] [...]** they&#39;d not be able to see the REJECT argument, and wouldn&#39;t get an error.

You can force an error by dropping the LETs, and expanding the specification to include **&lt;local&gt;** definitions.

    promise: func [spec body] [
        body: compile [
            resolve: specialize :promise-resolve* [ret: $ :return]
            reject: specialize :promise-reject* [ret: $ :return]
            (as group! body) 
        ]
        return func compose [(spread spec) &lt;local&gt; resolve reject] body
    ]

So that&#39;s just sort of a peek into the effort it would take to make a relatively hygienic function generator.  Some things like worrying about taking SPECIALIZE as an argument might be beyond the concerns of the average one-off task.  But if you write a bunch of indiscriminate boilerplate using arbitrary words to refer to functions, it&#39;s very easy to get bitten when an argument reuses those words.</description>
    
    <lastBuildDate>Wed, 24 Jan 2024 02:52:37 +0000</lastBuildDate>
    <category>Functions</category>
    <atom:link href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="15" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>But an odd aspect of this is that it brings back something that was previously being done <em>everywhere</em>... e.g. structural operations were concretizing binding as they went. Most all of those structural operations have been changed to ignore specifiers, so this is an anomaly. It sort of straddles a line of being "binding preservation", I guess...</p>
</blockquote>
</aside>
<p>So this presents a bit of a conundrum, because if you let it apply to <em>all</em> elements then it applies to QUOTED!s too, and you may have explicitly put that quote on to avoid getting a binding.</p>
<p>If you follow the evaluator's rules for binding then it's kind of removing the agnosticism you would expect SPREAD to have about what you plan to do with the code.</p>
<p>Hence I think... probably it's a bad idea for SPREAD to do this.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="15" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">spaced collect [
    ...
    keep spread ["HTTP/1.1" response.status status-codes.(response.status)]
    ...
 ]
</code></pre>
</blockquote>
</aside>
<p>One way this particular case could not break is for COLLECT to give back a block which has the same specifier as its input block by default, instead of unbound?  :-/</p>
<p>I don't think I like that (though I'm not sure exactly what makes it different from COMPOSE in this respect).  I'd probably prefer:</p>
<pre><code>spaced in [] collect [
    ...
    keep spread ["HTTP/1.1" response.status status-codes.(response.status)]
    ...
]
</code></pre>
<p>That might be more palatable than having COLLECT producing blocks with attached environments.</p>
<p><strong>It really is looking like those who build code programmatically need to be actively involved in binding...</strong></p>
<p>...it feels a little sad to see examples like this becoming "more complicated".  But as I've said before, the reason that Rebol examples seemed to "just work" at times is because nothing tricky was being tried.  Once you do try something beyond the most basic of cases, you'll get bit by the assumptions.</p>
<p>At least if you find yourself repeating any pattern enough times you can generate an abstraction for that pattern.  Automatic behaviors probably hurt more than they help.</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/16">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/16</link>
        <pubDate>Wed, 24 Jan 2024 01:19:37 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-16</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I have hit the first case in practice of SPREAD not applying the binding being a problem.  It's essentially like this:</p>
<pre><code>spaced collect [
    ...
    keep spread ["HTTP/1.1" response.status status-codes.(response.status)]
    ...
 ]
</code></pre>
<p>The SPACED operation does evaluation (strings are inert).</p>
<p>Reducing in advance could yield problems with double-reduction (e.g. if something evaluated to a WORD!, SPACED would then see the word and try to evaluate it again vs. consider it for its spelling).</p>
<pre><code>&gt;&gt; term: 'something

&gt;&gt; spaced collect [keep spread reduce ["The term is:" term]]
** Error: something word is not bound to a context
</code></pre>
<aside class="quote no-group" data-username="bradrn" data-post="14" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>What I was thinking here was that SPREAD could take the binding of the block and reapply it to each individual element of the block.</p>
</blockquote>
</aside>
<p>Seems unavoidable.  If you don't want it to happen, you'll have to unbind before you spread (or pass it quoted material so it doesn't get bound).</p>
<p>But an odd aspect of this is that it brings back something that was previously being done <em>everywhere</em>... e.g. structural operations were concretizing binding as they went.  Most all of those structural operations have been changed to ignore specifiers, so this is an anomaly.  It sort of straddles a line of being "binding preservation", I guess...</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/15">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/15</link>
        <pubDate>Tue, 23 Jan 2024 18:34:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-15</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="13" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>You probably don't need <strong>spread bindable</strong> because it probably ignores the outer binding on splices.<br>
The implications of losing the binding on things you SPREAD are not entirely clear.</p>
</blockquote>
</aside>
<p>What I was thinking here was that SPREAD could take the binding of the block and reapply it to each individual element of the block. But the interaction of splices with binding is something I haven’t fully figured out yet.</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/14">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/14</link>
        <pubDate>Thu, 18 Jan 2024 01:37:36 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-14</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Overall this was very useful to see worked through!</p>
<p>The original point I started the thread to make is now made more convincingly in <a href="https://forum.rebol.info/t/what-dialects-need-from-binding/2111">"What Dialects Need From Binding"</a>.</p>
<aside class="quote no-group" data-username="bradrn" data-post="11" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Clearly, each function invocation must create a new environment to run itself in. Equally clearly, the parent of that environment needs to be set correctly to ensure that the body can access global variables. But… the function could be called from anywhere, so how does <code>func</code> find the environment to set as parent?</p>
<p>The answer is quite obvious: <strong><code>func</code> should use the environment bound to the BLOCK! which is its body!</strong> When the function is defined at the top level, that BLOCK! gets created in the top-level scope, and bound to the same</p>
</blockquote>
</aside>
<p>I don't know about "obvious", but...</p>
<p>...do take note that's how I described it, walking through the steps in <a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">"Rebol and Scopes: Why Not"</a>.</p>
<p><em>"The virtual bind chain starts out with a module context that has <code>global</code>, <code>x</code>, and <code>foo</code> in it. This is all there is to stick on the BLOCK!s that gets passed to FUNC. So the spec and body are blocks with a module as the specifier."</em></p>
<p><em>"FUNC stows the body block away in an ACTION! that it generates. Later when it gets invoked, it creates a FRAME! with <code>return</code> and <code>x</code> in it...and puts that in a chain <em>with</em> the module context. So upon entry to the function body, that body is being executed with a specifier that looks in the frame first (would find that x) and then in the module second (would find <code>global</code> and <code>foo</code>). This compound specifier is what the evaluator state initially has for that body block."</em></p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="11" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<ul>
<li><code>(unbind name):</code> looks at <code>name</code>, UNBINDs it and SETIFYs it, making a SET-WORD! which is not bound to any environment in particular (and thus will be looked up wherever the splice ends up going).<br>
...</li>
<li><code>(unbind ':return)</code> is the same story as <code>unbind name</code>: it creates a GET-WORD! which is not bound to any environment.</li>
</ul>
</blockquote>
</aside>
<p>So the concept of quotes shielding material from binding under evaluation does seem to be a winner!  Good instincts, there.</p>
<p><em>(Though as I mentioned, that too has come up before.  See <a href="https://forum.rebol.info/t/breaking-make-object-into-component-operations/1442/3">"Breaking MAKE OBJECT! Into Component Operations"</a>.  I wasn't "all in" on it yet, due to the impacts it would have on existing programming style.  But as this has unfolded, breaking the existing expectations seems inevitable if binding is going to become more hygeinic.)</em></p>
<p>But I think when all is taken into consideration here, you have to write it like:</p>
<pre><code>return spread compose [
     (in [] 'let) (name): (in [] 'passthru) :return
 ]
</code></pre>
<p>Presumed rule is that the block COMPOSE produces at the end will have the same environment its argument came in with.</p>
<p>GROUP!s are evaluated using the environment of the outer block, while other material is left as-is.</p>
<p>Using LET means you don't have to UNBIND the name you get in, because we assume LET ignores the binding.  But generally speaking, you probably can't trust that callers don't pass you bound words, even if that binding is not meaningful for the usage.</p>
<p>You want PASSTHRU with its definition in the function.  Or you can compose in PASSTHRU as a FRAME! (I'd like to make that as friendly as possible for debugging... it does cache the word of the name it was fetched from, but still, it will never be quite as friendly as a word).</p>
<p>I've added that for LET as well, which is presumably needed here... and to be safe about the calling environment you could protect it this way, or trust it's not redefined and just say LET and let it be unbound, to pick up the binding in the splicd environment.</p>
<p>You probably don't need <strong>spread bindable</strong> because it probably ignores the outer binding on splices.<br>
The implications of losing the binding on things you SPREAD are not entirely clear.</p>
<p>As these patterns become more understood, dialect tools should be able to help make the more common cases briefer.  A complement to COMPOSE which assumes you want hardened references to the existing environment with relatively few "escaped" slots--what I was calling "COMPILE"--is probably useful.</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/13">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/13</link>
        <pubDate>Wed, 17 Jan 2024 17:03:30 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-13</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="11" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>does this mean that <code>with-return</code> would suddenly stop working if the body of <code>promise-ish</code> were to define a variable <code>passthru</code>?</p>
</blockquote>
</aside>
<p>Yes.</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="11" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>Indeed, there would have to be a notion of the ‘currently active environment’ from which unbound words lookup their names. (...)  Surely <a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">specifiers</a> require the same kind of concept already?</p>
</blockquote>
</aside>
<p>Discussion moved to new topic:</p>
<p><a href="https://forum.rebol.info/t/functions-that-capture-the-current-evaluation-environment/2122" class="inline-onebox">Functions That Capture the Current "Evaluation Environment"</a></p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/12">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/12</link>
        <pubDate>Tue, 09 Jan 2024 09:22:02 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-12</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>As I mention, the <em>current</em> rule for binding of arguments and locals in FUNC (including RETURN) is to override any existing bindings in the body at the time the function is created.</p>
</blockquote>
</aside>
<p>Hmm, I think I see… does this mean that <code>with-return</code> would suddenly stop working if the body of <code>promise-ish</code> were to define a variable <code>passthru</code>?</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>COMPOSE is receiving just one block argument, and here we're saying that block is unbound. Inside the implementation of COMPOSE, where is it getting environment information from? Are you suggesting that when a function like COMPOSE is called, it receives an additional environment parameter of whatever its containing block had in effect at the callsite? Or is UNBIND doing something strange to tunnel the binding anyway, somehow?</p>
<p>This notion of "currently active environment" is an even newer beast than letting blocks carry along some kind of scope with them.</p>
</blockquote>
</aside>
<p>Indeed, there would have to be a notion of the ‘currently active environment’ from which unbound words lookup their names. Apologies for not making that clear.</p>
<p>That being said, I hesitate to call it ‘new’ when it’s already been used in nearly every other programming language in existence. Besides, surely <a href="https://forum.rebol.info/t/rebol-and-scopes-well-why-not/1751">specifiers</a> require the same kind of concept already?</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>For this to do any good, COMPOSE has to apply that environment to any evaluated groups. Otherwise it doesn't know what SETIFY is, or NAME is, or anything else.</p>
</blockquote>
</aside>
<p>Indeed… but it’s quite sufficient for COMPOSE to <em>evaluate the groups within that environment</em>. It doesn’t have to rebind anything in the process. So this:</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>In which case, BIND-TO-CURRENT is superfluous, right? It could just be <strong>('passthru)</strong>.</p>
</blockquote>
</aside>
<p>…isn’t correct, the way I’m thinking about it: <code>('passthru)</code> would still construct an unbound word, since <strong>all words would start out unbound</strong>, and continue that way until explicitly bound to something. If you want the word to be bound individually to an environment (rather than inheriting the same environment it’s evaluated in), you have to bind it yourself.</p>
<p>(There’s an interesting duality here, now that I think about it: all words start out unbound but can be bound to environments, whereas all blocks start out bound but can have their bindings removed.)</p>
<aside class="quote no-group" data-username="hostilefork" data-post="10" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>When thinking along these lines, I've generally felt that something like SETIFY NAME should preserve the binding as it's easy enough to SETIFY UNBIND NAME (or UNBIND SETIFY NAME) if you want it unbound. It's harder to get the original binding back if you want it.</p>
</blockquote>
</aside>
<p>Yeah, you’re right. I think I had a mental blind spot there, where I thought that a quoted name can’t take any bindings at all. (Yet more Lispiness creeping into my thoughts, I suspect…!) So indeed it would need to be <code>setify unbind name</code>.</p>
<aside class="quote no-group quote-modified" data-username="hostilefork" data-post="10" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<blockquote>
<ul>
<li><code>unbind</code> removes that default binding of the block. The words within it must now be understood in the environment of the next highest enclosing block. (Which in this case happens to be the same environment.)</li>
</ul>
</blockquote>
<p>If your goal is just to flip off a block's outermost "my bind is complete" bit, it seems it might be better to have an operation that does only that... maybe call it BINDABLE.</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">with-return: func [name spec body] [
     let passthru: lambda [return] reduce ['lambda spec body]
     return spread bindable compose [
         (unbind name): passthru (unbind ':return)]
     ]
]
</code></pre>
</blockquote>
</aside>
<p>I don’t see how this is any different to my UNBIND. In the text you quoted, my meaning was that removing the binding of a block <em>requires</em> its elements to be interpreted in some other context. (Because their containing block no longer has a bound environment in which they can be looked up in!)</p>
<p>To be clear, let me describe how I see this being evaluated:</p>
<ul>
<li>The block is bound to the current environment when created.</li>
<li>COMPOSE evaluates the groups in that environment:
<ul>
<li><code>(unbind name):</code> looks at <code>name</code>, UNBINDs it and SETIFYs it, making a SET-WORD! which is not bound to any environment in particular (and thus will be looked up wherever the splice ends up going).</li>
<li><code>passthru</code> is a word, which like all newly created words is unbound, and it’s not in a GROUP! so it stays the same.</li>
<li><code>(unbind ':return)</code> is the same story as <code>unbind name</code>: it creates a GET-WORD! which is not bound to any environment.</li>
</ul>
</li>
<li>The result is a block in which <em>all three words are unbound</em>. You might as well have written <code>[name: passthru :return]</code> — that would have done the same thing.</li>
<li>Then BINDABLE removes the binding from that block.</li>
<li>Eventually that block gets spliced into the promise, and it all blows up when evaluated because <code>passthru</code> isn’t bound to anything and the current environment doesn’t have any definition for it either.</li>
</ul>
<hr>
<p>Now that I think of it, there’s an interesting wrinkle with COMPOSE (and REDUCE, etc.) which I hadn’t fully considered:</p>
<pre><code class="lang-plaintext">inner: func [] [
    local: 5
    return [(local)]
]

outer: func [] [
    local: 10
    return compose inner
]
</code></pre>
<p>In my model, how would <code>outer</code> evaluate? Firstly, <code>local</code> would be created in <code>outer</code>’s environment. Then, <code>inner</code> is called. It would create <code>local</code> in its own environment, then create the BLOCK! <code>[(local)]</code>. This BLOCK! would be bound to the current environment, whereas the WORD! <code>local</code> within it starts out unbound. (I suspect that GROUP!s would have to start out unbound, too.) This returned BLOCK! is then <code>compose</code>d… but which environment is the GROUP! evaluated in? To get the semantics we want, <code>compose</code> would have to <strong>enter the environment bound to the BLOCK!</strong>, so that <code>local</code> is looked up in <code>inner</code>’s environment, not <code>outer</code>’s. To evaluate it in <code>outer</code>’s environment, we would have to get rid of the binding to <code>inner</code>’s environment by running <code>compose unbind inner</code>.</p>
<p>Incidentally, <code>func</code> itself needs to do something similar, though more subtle. Clearly, each function invocation must create a new environment to run itself in. Equally clearly, the parent of that environment needs to be set correctly to ensure that the body can access global variables. But… the function could be called from anywhere, so how does <code>func</code> find the environment to set as parent?</p>
<p>The answer is quite obvious: <strong><code>func</code> should use the environment bound to the BLOCK! which is its body!</strong> When the function is defined at the top level, that BLOCK! gets created in the top-level scope, and bound to the same. If it’s a nested function, same idea — the BLOCK! ends up bound to the current environment, and the function will create a new scope descending from that environment.</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/11">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/11</link>
        <pubDate>Sun, 07 Jan 2024 04:33:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-11</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="bradrn" data-post="9" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>How does <code>:return</code> get bound to <code>promise-ish</code>’s RETURN, even though it should by rights be bound to <code>with-return</code>’s?</p>
</blockquote>
</aside>
<p>As I mention, the <em>current</em> rule for binding of arguments and locals in FUNC (including RETURN) is to override any existing bindings in the body at the time the function is created.</p>
<p>So when I've suggested thinking about adding an UNBIND, that's just playing along with the proposed idea that bindings would stick by default--a concept I did mention in <em>"Rebol and Scopes..."</em></p>
<p>There I also put forth the idea that code would start unbound, with the binding flowing along from the top.  We are talking about similar premises--but the devil's in the details.  Glad to be talking through them.</p>
<aside class="quote no-group quote-modified" data-username="bradrn" data-post="9" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<pre><code>spread compose unbind [(setify name) (bind-to-current 'passthru) :return]
</code></pre>
<p>(Where <code>bind-to-current</code> is a hypothetical function which binds the given word to the currently active environment.)</p>
</blockquote>
</aside>
<p>COMPOSE is receiving just one block argument, and here we're saying that block is unbound.  Inside the implementation of COMPOSE, where is it getting environment information from?  Are you suggesting that when a function like COMPOSE is called, it receives an additional environment parameter of whatever its containing block had in effect at the callsite?  Or is UNBIND doing something strange to tunnel the binding anyway, somehow?</p>
<p>This notion of "currently active environment" is an even newer beast than letting blocks carry along some kind of scope with them.</p>
<p>For this to do any good, COMPOSE has to apply that environment to any evaluated groups.  Otherwise it doesn't know what SETIFY is, or NAME is, or anything else.  In which case, BIND-TO-CURRENT is superfluous, right?  It could just be <strong>('passthru)</strong>.</p>
<p>Then if you didn't put <code>('passthru)</code> in a group, would it have been assumed that it should be left unbound?  Is it only GROUP!s that have these applications of the secret slipstreamed environment?  If not, why not just write PASSTHRU?</p>
<blockquote>
<ul>
<li><code>setify name</code>: produces an unbound SET-WORD! from the given <code>name</code></li>
</ul>
</blockquote>
<p>When thinking along these lines, I've generally felt that something like SETIFY NAME should preserve the binding as it's easy enough to SETIFY UNBIND NAME (or UNBIND SETIFY NAME) if you want it unbound.  It's harder to get the original binding back if you want it.</p>
<blockquote>
<ul>
<li><code>unbind</code> removes that default binding of the block. The words within it must now be understood in the environment of the next highest enclosing block. (Which in this case happens to be the same environment.)</li>
</ul>
</blockquote>
<p>If your goal is just to flip off a block's outermost "my bind is complete" bit, it seems it might be better to have an operation that does only that... maybe call it BINDABLE.</p>
<pre><code>with-return: func [name spec body] [
     let passthru: lambda [return] reduce ['lambda spec body]
     return spread bindable compose [
         (unbind name): passthru (unbind ':return)
     ]
]
</code></pre>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/10">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/10</link>
        <pubDate>Sun, 07 Jan 2024 03:18:14 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-10</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>This FUNC has a RETURN. And so, that <strong>:RETURN</strong> used inside the COMPOSE is by default bound to it, e.g. the WITH-RETURN's RETURN.</p>
</blockquote>
</aside>
<p>Well, yes, that’s what I thought would happen… but when I test it in the REPL, it does somehow seem to work:</p>
<pre><code class="lang-plaintext">&gt;&gt; with-return: func [name spec body] [let passthru: lambda [return] reduce ['lambda spec body] return spread compose [(setify name) passthru :return]]
== ~#[frame! {with-return} [name spec body]]~  ; isotope

&gt;&gt; add-addone*: with-return 'addone [result] [return result + 1]
== ~(addone: passthru :return)~  ; isotope

&gt;&gt; promise-ish: func [spec body] [body: compose [(add-addone*) (as group! body)] return func spec body]
== ~#[frame! {promise-ish} [spec body]]~  ; isotope

&gt;&gt; instantiated: promise-ish [x] [print "got to 1" addone x print "got to 2"]
== ~#[frame! {instantiated} [x]]~  ; isotope

&gt;&gt; instantiated 10
got to 1
== 11
</code></pre>
<p>So what’s going on here? How does <code>:return</code> get bound to <code>promise-ish</code>’s RETURN, even though it should by rights be bound to <code>with-return</code>’s?</p>
<aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>If you try to institute a rule that bindings "stick" unless overridden, it might suggest you'd need:</p>
<pre><code class="lang-plaintext"> with-return: func [name spec body] [
     let passthru: lambda [return] reduce ['lambda spec body]
     return spread compose [(setify name) passthru (unbind ':return)]
 ]
</code></pre>
</blockquote>
</aside>
<p>Well, not quite: my idea was that <em>all</em> words are unbound by default, and inherit their bindings from the environment of the containing block. So really you’d want to do almost the opposite:</p>
<pre><code class="lang-plaintext"> with-return: func [name spec body] [
     let passthru: lambda [return] reduce ['lambda spec body]
     return spread compose unbind [(setify name) (bind-to-current 'passthru) :return]
 ]
</code></pre>
<p>(Where <code>bind-to-current</code> is a hypothetical function which binds the given word to the currently active environment. You could probably implement it using <code>bind</code> plus a new native function <code>get-current-environment</code>.)</p>
<p>Conceptually, the <code>unbind</code> here expresses the intent: ‘these words should not be interpreted in the currently active environment, they should be interpreted wherever they land up’. This code makes an exception for <code>passthru</code>, which individually gets bound to its current environment.</p>
<p>It’s probably also helpful to step through the mechanics of that last line in more detail:</p>
<ul>
<li>The block <code>[(setify name) (bind-to-current 'passthru) :return]</code> is created with a binding to the currently active environment. (It’s important to do this by default, since otherwise returned blocks wouldn’t retain the bindings they were created with.)</li>
<li><code>unbind</code> removes that default binding of the block. The words within it must now be understood in the environment of the next highest enclosing block. (Which in this case happens to be the same environment.)</li>
<li><code>compose</code> runs the groups:
<ul>
<li><code>setify name</code>: produces an unbound SET-WORD! from the given <code>name</code></li>
<li><code>bind-to-current 'passthru</code>: produces a WORD! <code>passthru</code>, bound to the currently active environment (i.e. the environment of <code>with-return</code>’s body).</li>
<li><code>:return</code> is not a group, so it remains unchanged (i.e. an unbound GET-WORD!)</li>
</ul>
</li>
<li><code>spread</code> turns it into an isotopic GROUP!, i.e. a splice. I haven’t yet worked out the interaction between splices and this kind of binding, but my hunch is that it should rebind the splice’s environment to each element of the splice when inserted into another block. In this case, it’s passed an unbound block, so that would be a no-op.</li>
<li>The unbound splice gets returned.</li>
</ul>
<aside class="quote no-group" data-username="hostilefork" data-post="8" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Basically you have to think about all the various intents. Like what if I <em>did</em> want that :RETURN to refer to WITH-RETURN's RETURN?</p>
</blockquote>
</aside>
<p>Then you would rebind that one too:</p>
<pre><code class="lang-plaintext"> with-return: func [name spec body] [
     let passthru: lambda [return] reduce ['lambda spec body]
     return spread compose unbind [(setify name) (bind-to-current 'passthru) (bind-to-current :return)]
 ]
</code></pre>
<p>Of course, this would get unwieldy if you wanted to bind <em>nearly all</em> words, except for one or two. But that situation is better handled by the caller anyway, since the caller knows which words it needs to rebind.</p>
<p>Essentially, there are four situations:</p>
<ul>
<li>If the callee wants to maintain control over all the words in a block: this is the default, since the block is already bound to the current environment. (The caller might still override things.)</li>
<li>If the callee wants the caller to control the words in the block: <code>unbind</code>, so the words are interpreted in whichever context they might be passed too. (The caller might still rebind certain words it wants to stay the same.)</li>
<li>If the caller wants the callee to control the words in the block: do nothing, this is the default. (The caller might already have relinquished control over the block already using <code>unbind</code>.)</li>
<li>If the caller wants to override certain words: rebind the block to a new environment, which contains the new meanings of the desired words. (The callee might alrady have bound individual words so this doesn’t rebind them.)</li>
</ul>
<p>Plus, of course, you can still do a deep traverse of the code and bind every word individually, if that’s really what you want to do. There’s just not much need for it in this model.</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/9">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/9</link>
        <pubDate>Sun, 07 Jan 2024 01:52:13 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-9</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <blockquote>
<pre><code>with-return: func [name spec body] [
    let passthru: lambda [return] reduce ['lambda spec body]
    return spread compose [(setify name) passthru :return]
]
</code></pre>
</blockquote>
<p>This example illustrates a case of the binding contention I'm trying to stress that exists.</p>
<p>This FUNC has a RETURN.  And so, that <strong>:RETURN</strong> used inside the COMPOSE is by default bound to it, e.g. the WITH-RETURN's RETURN.</p>
<p>You are then splicing this code into a body where it's supposed to intend the RETURN of the function generated by the promise.  And there's clearly a mixture of intent here.  You want PASSTHRU to stick regardless of definitions in the place where it's spliced, but you want :RETURN to pick up the new definition.</p>
<p>If you try to institute a rule that bindings "stick" unless overridden, it might suggest you'd need:</p>
<pre><code> with-return: func [name spec body] [
     let passthru: lambda [return] reduce ['lambda spec body]
     return spread compose [(setify name) passthru (unbind ':return)]
 ]
</code></pre>
<p>Perhaps you'd think you could avoid this here via using a lambda (and throw in the SET-GROUP! in COMPOSE trick, and even briefer GET-BLOCK! for REDUCE).</p>
<pre><code>with-return: lambda [name spec body] [
    let passthru: lambda [return] :['lambda spec body]
    spread compose [(name): passthru :return]
]
</code></pre>
<p>But that :RETURN is still bound (to a dummy library RETURN that says "hey you called RETURN but there's not one in effect").</p>
<p>Today's rule, that FUNC will override the binding for all args and locals (including RETURN) in the body is how things work.  So if you're considering a mechanic based on <em>"things that have bindings have those bindings stick, and unbound things get bound"</em> it's going to need at least one exception of function args and locals "overbinding" things that already have binding... but then you have to ask when (if ever) the "sticky" concept of binding that doesn't override existing bindings would be applicable.</p>
<p>Basically you have to think about all the various intents.  Like what if I <em>did</em> want that :RETURN to refer to WITH-RETURN's RETURN?</p>
<p>Good work going after these non-trivial explorations, in any case!  You're the kind of user I've hoped would come along at some point...</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/8">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/8</link>
        <pubDate>Sun, 07 Jan 2024 00:57:17 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-8</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>I think a "strict mode" (parallel to JavaScript's) should be the default in modules, where you can't create new module-level declarations from non-module-level "scopes", at least without some special operator. I've called that operator EMERGE in the past.</p>
</blockquote>
</aside>
<p>Yes, I think something like this is very important.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="5" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/48/421_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>In the micro-optimization culture of historical Rebol, people would avoid COMPOSE when they could and write something less obvious with REDUCE:</p>
<pre data-code-wrap="plaintext"><code class="lang-plaintext">lambda [return] reduce ['lambda spec body]
</code></pre>
<p>I myself find that harder to grok</p>
</blockquote>
</aside>
<p>I don’t know so much… I actually find it slightly easier to read. And it’s a lot more concise, which I like in and of itself.</p>
<p>So that becomes:</p>
<pre><code class="lang-plaintext">with-return: func [name spec body] [
    let passthru: lambda [return] reduce ['lambda spec body]
    return spread compose [(setify name) passthru :return]
]
</code></pre>
<p>I like it!</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/7">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/7</link>
        <pubDate>Sat, 06 Jan 2024 23:59:10 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-7</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>Seems good.  As you've perhaps absorbed by now, RETURN in Rebol and Red is not smart enough to do this, as it just climbs the stack and returns from the first non-native it finds...meaning a whole lot of things aren't possible.</p>
<p>Historical discussion of "definitional return": <a href="https://web.archive.org/web/20130720084333/http://www.rebol.net/wiki/Exceptions#Proposed_RETURN_alternatives">Proposed RETURN alternatives (archive.org)</a></p>
<aside class="quote no-group" data-username="bradrn" data-post="4" data-topic="2093">
<div class="title">
<div class="quote-controls"></div>
<img loading="lazy" alt="" width="24" height="24" src="https://forum.rebol.info/user_avatar/forum.rebol.info/bradrn/48/365_2.png" class="avatar"> bradrn:</div>
<blockquote>
<p>I forgot the LET and accidentally made PASSTHRU global…</p>
</blockquote>
</aside>
<p>I think a "strict mode" (parallel to JavaScript's) should be the default in modules, where you can't create new module-level declarations from non-module-level "scopes", at least without some special operator.  I've called that operator EMERGE in the past.</p>
<p>Today only the special modules of LIB and SYSTEM use a kind of "strict mode", and it catches a lot of errors there.</p>
<p>Not sure what the implications would be for the console... there's a cost when it doesn't act the same as code in a script, but also people have come to expect certain things to work.</p>
<blockquote>
<pre><code>do compose/deep [
   lambda [return] [
       lambda (spec) (body)
    ]
]
</code></pre>
</blockquote>
<p>You can do this more succinctly by moving the COMPOSE:</p>
<pre><code>lambda [return] compose [
    lambda (spec) (body)
]
</code></pre>
<p>In the micro-optimization culture of historical Rebol, people would avoid COMPOSE when they could and write something less obvious with REDUCE:</p>
<pre><code>lambda [return] reduce ['lambda spec body]
</code></pre>
<p>I myself find that harder to grok, but it's not insignificant when dealing with interpreted languages to apply these changes sometimes.</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/5">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/5</link>
        <pubDate>Sat, 06 Jan 2024 23:28:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-5</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>I’ve managed to get something even better working (I think):</p>
<pre><code class="lang-plaintext">with-return: func [name spec body] [
    let passthru: do compose/deep [
        lambda [return] [
            lambda (spec) (body)
        ]
    ]
    return spread compose [(setify name) passthru :return]
]
</code></pre>
<p>So with this one can do:</p>
<pre><code class="lang-plaintext">promise-add-resolve*: with-return 'resolve [result] [
    some code here
    return whatever
]

promise-add-reject*: with-return 'reject [error] [
    more code here
    return whatever
]

promise: func [spec body] [
    body: compose [
        (promise-add-resolve*)
        (promise-add-reject*)
        (as group! body) 
    ]
    return func spec body
]
</code></pre>
<p>To be quite honest, I’m not entirely sure <em>how</em> this works… somehow, that <code>:return</code> seems to correctly refer to the RETURN of the promise, while <code>passthru</code> is bound to the function defined in WITH-RETURN. I still have this horrible feeling that I’m doing something completely wrong, and the small example I tested only worked by accident. (That’s what happened while I was writing this thing, when I forgot the LET and accidentally made PASSTHRU global…!)</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/4">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/4</link>
        <pubDate>Sat, 06 Jan 2024 12:40:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-4</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>For that part in this case, yes that does work. and is an improvement...</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/3</link>
        <pubDate>Sat, 06 Jan 2024 12:07:18 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-3</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[bradrn]]></dc:creator>
        <description><![CDATA[
            <p>As a Haskeller, my immediate thought here is: <a href="https://wiki.haskell.org/Currying" rel="noopener nofollow ugc">currying</a>!</p>
<pre><code class="lang-plaintext">promise-resolve*: lambda [ret] [
    lambda [result] [
        some code here
        ret whatever
    ]
]

promise-reject*: lambda [ret] [
    lambda [error] [
        more code here
        ret whatever
    ]
]

promise: func [spec body] [
    body: compose [
        resolve: promise-resolve* :return
        reject: promise-reject* :return
        (as group! body) 
    ]
    return func spec body
]
</code></pre>
<p>Is there any reason why this wouldn’t work?</p>
<p>EDIT: yes, I’ve tested this and it does seem to work:</p>
<pre><code class="lang-plaintext">&gt;&gt; test*: lambda [ret] [lambda [result] [ret result + 1]]
== ~#[frame! {test*} [ret]]~  ; isotope

&gt;&gt; test: func [spec body] [body: compose [xxx: test* :return (as group! body)] return func spec body]
== ~#[frame! {test} [spec body]]~  ; isotope

&gt;&gt; apply (test [x] [xxx x]) [10]
== 11
</code></pre>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/2">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/2</link>
        <pubDate>Sat, 06 Jan 2024 11:41:38 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-2</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
      <item>
        <title>Custom Function Generator Pitfalls</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>I commonly write function generators that put in some boilerplate to make some variables and service routines available to the generated function.  But these frequently have weaknesses, and I thought I'd write up an example to illustrate...and explain some ways to mitigate the problems.</p>
<h2>
<a name="example-promise-generator-with-resolve-and-reject-1" class="anchor" href="https://forum.rebol.info#example-promise-generator-with-resolve-and-reject-1"></a>Example: PROMISE Generator With RESOLVE and REJECT</h2>
<p>Imagine I want to make a function variation that's like a JavaScript promise, with a RESOLVE and REJECT...which are defined per-promise.</p>
<p>Let's say the first cut of the new generator looks something like this:</p>
<pre><code>promise: func [spec body] [
    body: compose [
        let resolve: lambda [result] [  ; lambdas lack their own return
            some code here
            return whatever  ; intending return of generated FUNC
        ]
        let reject: lambda [error] [
            more code here
            return whatever
        ]
        (spread body)  ; code here should see RESOLVE and REJECT 
    ]
    return func spec body
]
</code></pre>
<p>When the frame is created for the new function, it will run this body that's been extended with some boilerplate.  But that frame's arguments could have the name of any of the functions you're using in the bodies of RESOLVE or REJECT.  e.g. what if I said <strong><code>foo: promise [code /more] [...]</code></strong> ... the implementations of RESOLVE and REJECT would be disrupted from what they thought the words they had used meant.</p>
<p>Once you notice this, you might think the solution is to pre-compute more things:</p>
<pre><code>promise: func [spec body] [
    body: compose [
        let resolve: ^(lambda [result] [
            some code here
            return whatever
        ])
        let reject: ^(lambda [error] [
            more code here
            return whatever
        ])
        (spread body)  ; code here should see RESOLVE and REJECT 
    ]
    return func spec body
]
</code></pre>
<p><em>(Note use of ^META group in order to turn the isotopic frame produced by FUNC into a quasi frame, so that under evaluation in the function body it becomes isotopic again.  The compose would fail if you tried to compose the isotopic frame in directly.)</em></p>
<p>That's a bit better in terms of insulating the boilerplate code from stray bindings coming from the user-supplied spec (though there's still the weakness of LET if the user wrote something like <strong>promise [let [integer!]] [...]</strong>, which if you cared you could address by composing :LET in as its literal function value).</p>
<p>But it does too good a job: the COMPOSE runs during the PROMISE fabrication time, and so the notion of RETURN used by RESOLVE and REJECT are is the return for the PROMISE generator itself... not the produced FUNC as intended.  This is true of anything else you need to have picked up from the instance (let's say REJECT was implemented in terms of RESOLVE, or needed some other local).</p>
<p>One way of addressing this would be to slip the instance RETURN in as a parameter, e.g. via specialization of the precomputed code:</p>
<pre><code>promise: func [spec body] [
    body: compose [
        let resolve: specialize ^(lambda [result ret] [
            some code here
            ret whatever
        ]) [ret: :return]
        let reject: specialize ^(lambda [error ret] [
            more code here
            ret whatever
        ]) [ret: :return]
        (spread body)  ; code here should see RESOLVE and REJECT 
    ]
    return func spec body
]
</code></pre>
<p>There you've got an added assumed term which can break things, e.g. <strong><code>promise [let [integer!] specialize [block!]] [...]</code></strong> or similar.  But at least <strong>some code here</strong> and <strong>more code here</strong> are running under the understandings that the PROMISE generator author had of what those implementations meant.</p>
<p>Once you've separated out that which can be precomputed vs. that which can't, there's no need to make the precomputed part every time:</p>
<pre><code>promise-resolve*: lambda [result ret] [
    some code here
    ret whatever
]

promise-reject*: lambda [error ret] [
    more code here
    ret whatever
]

promise: func [spec body] [
    body: compose [
        let resolve: specialize :promise-resolve* [ret: :return]
        let reject: specialize :promise-reject* [ret: :return]
        (spread body) 
    ]
    return func spec body
]
</code></pre>
<h2>
<a name="could-some-kind-of-compile-operation-help-2" class="anchor" href="https://forum.rebol.info#could-some-kind-of-compile-operation-help-2"></a>Could Some Kind of COMPILE Operation Help?</h2>
<p>Weaknesses due to redefinitions of things like LET and SPECIALIZE makes me wonder if situations like this could be helped by an operation that would replace words that look up to functions with references to the functions.  <a href="https://forum.rebol.info/t/more-comprehensible-errors-with-per-cell-labeling/1357">The cell can retain the symbol for the word</a>, which can make debugging and errors more tolerable.</p>
<pre><code>promise: func [spec body] [
    body: compose (compile [let specialize] [
        let resolve: specialize :promise-resolve* [ret: :return]
        let reject: specialize :promise-reject* [ret: :return]
        (spread body) 
    ])
    return func spec body
]
</code></pre>
<p>Merging with COMPOSE would be more efficient, and could help cue that you want to avoid compiling the things in GROUP!s.  Maybe it could assume you wanted to compile references to actions unless you threw in some kind of escaping:</p>
<pre><code>promise: func [spec body] [
    body: compile [
        let resolve: specialize :promise-resolve* [ret: $ :return]
        let reject: specialize :promise-reject* [ret: $ :return]
        (spread body) 
    ]
    return func spec body
]
</code></pre>
<p>I've thought about this kind of thing for a while, but never got around to writing it.</p>
<h2>
<a name="paranoia-plus-efficiency-body-as-group-vs-spliced-3" class="anchor" href="https://forum.rebol.info#paranoia-plus-efficiency-body-as-group-vs-spliced-3"></a>Paranoia Plus Efficiency: Body As GROUP! vs. Spliced</h2>
<p>One improvement to this code is to splice the body as a group instead of spreading it itemwise in a block.</p>
<p>To see why this matters, consider something like:</p>
<pre><code>func-with-a-as-one: func [spec body] [
    return func spec compose [
        let a: 1
        (spread body)
    ]
]
</code></pre>
<p>Now let's say someone wrote:</p>
<pre><code>&gt;&gt; test: func-with-a-as-one [x] [+ 9, return a + x]

&gt;&gt; test 1000
== 1010  ; not 1001
</code></pre>
<p>Accidentally or intentionally, the function was defined as:</p>
<pre><code>func [x] [
   let a: 1
   + 9, return a + x
]
</code></pre>
<p>You can avoid this by quarantining the body, using <strong>(as group! body)</strong> instead of <strong>(spread body)</strong> in the COMPOSE.</p>
<pre><code>func [x] [
   let a: 1
   (+ 9, return a + x)
]
</code></pre>
<p>As an added benefit, the AS alias is cheaper memory-wise than copying the elements in item-wise (though it adds one extra GROUP! evaluation step to the function).</p>
<h2>
<a name="another-loophole-what-if-resolvereject-are-args-4" class="anchor" href="https://forum.rebol.info#another-loophole-what-if-resolvereject-are-args-4"></a>Another Loophole: What If RESOLVE/REJECT Are Args?</h2>
<p>If you use LET, currently that will override whatever definition is in play.  So if someone were to write <strong>promise [x y reject] [...]</strong> they'd not be able to see the REJECT argument, and wouldn't get an error.</p>
<p>You can force an error by dropping the LETs, and expanding the specification to include <strong></strong> definitions.</p>
<pre><code>promise: func [spec body] [
    body: compile [
        resolve: specialize :promise-resolve* [ret: $ :return]
        reject: specialize :promise-reject* [ret: $ :return]
        (as group! body) 
    ]
    return func compose [(spread spec) &lt;local&gt; resolve reject] body
]
</code></pre>
<p>So that's just sort of a peek into the effort it would take to make a relatively hygienic function generator.  Some things like worrying about taking SPECIALIZE as an argument might be beyond the concerns of the average one-off task.  But if you write a bunch of indiscriminate boilerplate using arbitrary words to refer to functions, it's very easy to get bitten when an argument reuses those words.</p>
          <p><a href="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/custom-function-generator-pitfalls/2093/1</link>
        <pubDate>Sat, 06 Jan 2024 11:29:08 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-2093-1</guid>
        <source url="https://forum.rebol.info/t/custom-function-generator-pitfalls/2093.rss">Custom Function Generator Pitfalls</source>
      </item>
  </channel>
</rss>

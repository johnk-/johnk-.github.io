<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>Does SET/ANY, GET/ANY-thing matter anymore?</title>
    <link>https://forum.rebol.info/t/does-set-any-get-any-thing-matter-anymore/1053</link>
    <description>One of the reasons [I said I did not like /ANY on GET and SET](https://forum.rebol.info/t/set-any-and-get-any-vs-set-opt-and-get-opt/187) is because it didn&#39;t seem a good match for OPT-ness.  And ANY is a very common construct.  So if people get in the habit of naming their refinements /ANY it would be kind of irritating.  One doesn&#39;t want to set a bad precedent.

But for reasons [that have been reasoned to death](https://forum.rebol.info/t/null-first-class-values-and-safety/895), SET-WORD! doesn&#39;t error on null assignments, it just clears the variable.  *That&#39;s firm now.  Re-read the post if you need to.*

It thus seems to make sense that SET of a WORD! would do what a SET-WORD! would do, and not error.  And GET returning a null seems okay, since most routines don&#39;t take NULLs as input.  If you really want to check something is not null you can do that on the result...e.g. **non null get word**. 
 [*(Still shopping for a single term for &quot;non null&quot;.)*](https://forum.rebol.info/t/we-really-need-a-better-name-for-really/1250)

So there&#39;d seem to be no need for a refinement... except...

## ...something has to be done about VOID!

VOID! assignments still cause errors on SET-WORD!:

    &gt;&gt; x: print &quot;still an error&quot;
    ** Script Error: x: is VOID!

If you want to write truly generic code (like, say, a READ-EVAL-PRINT-LOOP), you want to really accept not just nulls, but also &quot;ANY&quot;-VALUE!...and that counts void.

So we have a situation where:

1. This comes up nearly almost never.
1. &quot;ANY&quot; actually sort of feels like it is sensible for the behavior you&#39;re expanding, since it&#39;s no longer talking about non-ANY-VALUE!d NULLs.

Hence **I may be willing to bring GET/ANY and SET/ANY back, but under the new meaning applying to #[void]**.

But still, `get/any &#39;some-unset-var` will answer UNSET? back.  Regular GET would have done so too...but what&#39;s the harm?

## Afterthought...should plain GET-WORD! not get voids?

If SET-WORD! won&#39;t set voids, it seems that maybe GET-WORD! shouldn&#39;t get them.  You really aren&#39;t supposed to be using them as values or signals or anything.

I think I&#39;d be comfortable saying you had to use a special function to get a void out of a variable.</description>
    
    <lastBuildDate>Wed, 17 Aug 2022 12:25:41 +0000</lastBuildDate>
    <category>Naming</category>
    <atom:link href="https://forum.rebol.info/t/does-set-any-get-any-thing-matter-anymore/1053.rss" rel="self" type="application/rss+xml" />
      <item>
        <title>Does SET/ANY, GET/ANY-thing matter anymore?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1053">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>Hence <strong>I may be willing to bring GET/ANY and SET/ANY back, but under the new meaning applying to #[void]</strong>.</p>
</blockquote>
</aside>
<p>This post asks about naming for refinements on GET and SET... <em>but it predates isotopes and ^META operations by a long while</em>.</p>
<p>It came out of the era of splitting NULL out into a "non-ornery nothing". At the time of the split, the "ornery nothing" state was called <strong>#[void]</strong>... an idea which has forked off into a whole family of QUASI! and isotopic states... where the quasi states are allowed in blocks, while the isotopic states are not.</p>
<p><a href="https://forum.rebol.info/t/should-set-word-disallow-isotopic-assignments/1919">And now isotopic states aren't allowed to be assigned through normal SET-WORD!</a>, with the usual expectation being that you would be required to use ^META operations.</p>
<p><strong>It doesn't come up all that often that you need to set a variable to an isotope.</strong>  It's generally preferable for variables to hold the ^META state, to make them easier to work with.  Isotopes usually are only RETURN'd by functions at the last step of a transformation</p>
<p><strong>But it does come up!</strong>  For example, with multi-returns.  The caller of the multi-return has to use a ^META variable in the calling block to receive an additional return value:</p>
<pre><code>&gt;&gt; [x y]: some-multi arg1 arg2
** Error: Result for Y is a BLOCK! isotope, use ^Y to receive it

&gt;&gt; [x ^y']: some-multi arg1 arg2
== 10

&gt;&gt; y'
== ~[a b c]~
</code></pre>
<p>But in the implementation of SOME-MULTI you need a way to assign such outputs, and a plain SET-WORD! won't let you do it.</p>
<aside class="quote no-group" data-username="hostilefork" data-post="1" data-topic="1053">
<div class="title">
<div class="quote-controls"></div>
<img alt="" width="20" height="20" src="https://forum.rebol.info/user_avatar/forum.rebol.info/hostilefork/40/26_2.png" class="avatar"> hostilefork:</div>
<blockquote>
<p>"ANY" actually sort of feels like it is sensible for the behavior you're expanding, since it's no longer talking about non-ANY-VALUE!d NULLs.</p>
</blockquote>
</aside>
<p>This connection to ANY-VALUE! is no longer relevant.</p>
<p>You're just talking about setting something to a state that is potentially isotopic.  But not necessarily.</p>
<p><strong><code>set/isotope</code></strong> sounds like you're saying that you're guaranteeing it's an isotope, or that you want the value being passed in to be made isotopic if it wasn't already.</p>
<p>It's not the most important renaming in the world, but uses of ANY are now consolidating into meaning more like "pick any one of". When you see SET/ANY the rhythm kind of makes it read like SET ANY [...] where it feels like a choice is being made.</p>
<p>So it's more like <strong><code>set/lax</code></strong> or <strong><code>set/permissive</code></strong>.  Maybe <strong><code>set/core</code></strong>.</p>
<p>Just wanted to kind of resurrect the thread as the refinement needs to make a comeback on SET.  I've had a specialization as <strong><code>SET*</code></strong> to avoid using a name at all, and this fits a pattern of sort of naming the lower level or unchecked versions of things with asterisks.</p>
          <p><a href="https://forum.rebol.info/t/does-set-any-get-any-thing-matter-anymore/1053/3">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/does-set-any-get-any-thing-matter-anymore/1053/3</link>
        <pubDate>Wed, 17 Aug 2022 12:25:41 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1053-3</guid>
        <source url="https://forum.rebol.info/t/does-set-any-get-any-thing-matter-anymore/1053.rss">Does SET/ANY, GET/ANY-thing matter anymore?</source>
      </item>
      <item>
        <title>Does SET/ANY, GET/ANY-thing matter anymore?</title>
        <dc:creator><![CDATA[hostilefork]]></dc:creator>
        <description><![CDATA[
            <p>One of the reasons <a href="https://forum.rebol.info/t/set-any-and-get-any-vs-set-opt-and-get-opt/187">I said I did not like /ANY on GET and SET</a> is because it didn't seem a good match for OPT-ness.  And ANY is a very common construct.  So if people get in the habit of naming their refinements /ANY it would be kind of irritating.  One doesn't want to set a bad precedent.</p>
<p>But for reasons <a href="https://forum.rebol.info/t/null-first-class-values-and-safety/895">that have been reasoned to death</a>, SET-WORD! doesn't error on null assignments, it just clears the variable.  <em>That's firm now.  Re-read the post if you need to.</em></p>
<p>It thus seems to make sense that SET of a WORD! would do what a SET-WORD! would do, and not error.  And GET returning a null seems okay, since most routines don't take NULLs as input.  If you really want to check something is not null you can do that on the result...e.g. <strong>non null get word</strong>.<br>
<a href="https://forum.rebol.info/t/we-really-need-a-better-name-for-really/1250"><em>(Still shopping for a single term for "non null".)</em></a></p>
<p>So there'd seem to be no need for a refinement... except...</p>
<h2>...something has to be done about VOID!</h2>
<p>VOID! assignments still cause errors on SET-WORD!:</p>
<pre><code>&gt;&gt; x: print "still an error"
** Script Error: x: is VOID!
</code></pre>
<p>If you want to write truly generic code (like, say, a READ-EVAL-PRINT-LOOP), you want to really accept not just nulls, but also "ANY"-VALUE!...and that counts void.</p>
<p>So we have a situation where:</p>
<ol>
<li>This comes up nearly almost never.</li>
<li>"ANY" actually sort of feels like it is sensible for the behavior you're expanding, since it's no longer talking about non-ANY-VALUE!d NULLs.</li>
</ol>
<p>Hence <strong>I may be willing to bring GET/ANY and SET/ANY back, but under the new meaning applying to #[void]</strong>.</p>
<p>But still, <code>get/any 'some-unset-var</code> will answer UNSET? back.  Regular GET would have done so too...but what's the harm?</p>
<h2>Afterthought...should plain GET-WORD! not get voids?</h2>
<p>If SET-WORD! won't set voids, it seems that maybe GET-WORD! shouldn't get them.  You really aren't supposed to be using them as values or signals or anything.</p>
<p>I think I'd be comfortable saying you had to use a special function to get a void out of a variable.</p>
          <p><a href="https://forum.rebol.info/t/does-set-any-get-any-thing-matter-anymore/1053/1">Read full topic</a></p>
        ]]></description>
        <link>https://forum.rebol.info/t/does-set-any-get-any-thing-matter-anymore/1053/1</link>
        <pubDate>Mon, 04 Feb 2019 11:20:31 +0000</pubDate>
        <guid isPermaLink="false">forum.rebol.info-post-1053-1</guid>
        <source url="https://forum.rebol.info/t/does-set-any-get-any-thing-matter-anymore/1053.rss">Does SET/ANY, GET/ANY-thing matter anymore?</source>
      </item>
  </channel>
</rss>
